const p$1 = function () {
    const e = document.createElement("link").relList
    if (e && e.supports && e.supports("modulepreload")) return
    for (const o of document.querySelectorAll('link[rel="modulepreload"]')) i(o)
    new MutationObserver((o) => {
        for (const a of o) if (a.type === "childList") for (const l of a.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && i(l)
    }).observe(document, { childList: !0, subtree: !0 })
    function n(o) {
        const a = {}
        return (
            o.integrity && (a.integrity = o.integrity),
            o.referrerpolicy && (a.referrerPolicy = o.referrerpolicy),
            o.crossorigin === "use-credentials"
                ? (a.credentials = "include")
                : o.crossorigin === "anonymous"
                ? (a.credentials = "omit")
                : (a.credentials = "same-origin"),
            a
        )
    }
    function i(o) {
        if (o.ep) return
        o.ep = !0
        const a = n(o)
        fetch(o.href, a)
    }
}
p$1()
function makeMap(t, e) {
    const n = Object.create(null),
        i = t.split(",")
    for (let o = 0; o < i.length; o++) n[i[o]] = !0
    return e ? (o) => !!n[o.toLowerCase()] : (o) => !!n[o]
}
const GLOBALS_WHITE_LISTED =
        "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",
    isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED),
    specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    isSpecialBooleanAttr = makeMap(specialBooleanAttrs)
function includeBooleanAttr(t) {
    return !!t || t === ""
}
function normalizeStyle(t) {
    if (isArray$1(t)) {
        const e = {}
        for (let n = 0; n < t.length; n++) {
            const i = t[n],
                o = isString(i) ? parseStringStyle(i) : normalizeStyle(i)
            if (o) for (const a in o) e[a] = o[a]
        }
        return e
    } else {
        if (isString(t)) return t
        if (isObject(t)) return t
    }
}
const listDelimiterRE = /;(?![^(]*\))/g,
    propertyDelimiterRE = /:(.+)/
function parseStringStyle(t) {
    const e = {}
    return (
        t.split(listDelimiterRE).forEach((n) => {
            if (n) {
                const i = n.split(propertyDelimiterRE)
                i.length > 1 && (e[i[0].trim()] = i[1].trim())
            }
        }),
        e
    )
}
function normalizeClass(t) {
    let e = ""
    if (isString(t)) e = t
    else if (isArray$1(t))
        for (let n = 0; n < t.length; n++) {
            const i = normalizeClass(t[n])
            i && (e += i + " ")
        }
    else if (isObject(t)) for (const n in t) t[n] && (e += n + " ")
    return e.trim()
}
function normalizeProps(t) {
    if (!t) return null
    let { class: e, style: n } = t
    return e && !isString(e) && (t.class = normalizeClass(e)), n && (t.style = normalizeStyle(n)), t
}
function looseCompareArrays(t, e) {
    if (t.length !== e.length) return !1
    let n = !0
    for (let i = 0; n && i < t.length; i++) n = looseEqual(t[i], e[i])
    return n
}
function looseEqual(t, e) {
    if (t === e) return !0
    let n = isDate(t),
        i = isDate(e)
    if (n || i) return n && i ? t.getTime() === e.getTime() : !1
    if (((n = isSymbol(t)), (i = isSymbol(e)), n || i)) return t === e
    if (((n = isArray$1(t)), (i = isArray$1(e)), n || i)) return n && i ? looseCompareArrays(t, e) : !1
    if (((n = isObject(t)), (i = isObject(e)), n || i)) {
        if (!n || !i) return !1
        const o = Object.keys(t).length,
            a = Object.keys(e).length
        if (o !== a) return !1
        for (const l in t) {
            const c = t.hasOwnProperty(l),
                g = e.hasOwnProperty(l)
            if ((c && !g) || (!c && g) || !looseEqual(t[l], e[l])) return !1
        }
    }
    return String(t) === String(e)
}
function looseIndexOf(t, e) {
    return t.findIndex((n) => looseEqual(n, e))
}
const toDisplayString = (t) =>
        isString(t)
            ? t
            : t == null
            ? ""
            : isArray$1(t) || (isObject(t) && (t.toString === objectToString || !isFunction(t.toString)))
            ? JSON.stringify(t, replacer, 2)
            : String(t),
    replacer = (t, e) =>
        e && e.__v_isRef
            ? replacer(t, e.value)
            : isMap(e)
            ? { [`Map(${e.size})`]: [...e.entries()].reduce((n, [i, o]) => ((n[`${i} =>`] = o), n), {}) }
            : isSet(e)
            ? { [`Set(${e.size})`]: [...e.values()] }
            : isObject(e) && !isArray$1(e) && !isPlainObject(e)
            ? String(e)
            : e,
    EMPTY_OBJ = {},
    EMPTY_ARR = [],
    NOOP = () => {},
    NO = () => !1,
    onRE = /^on[^a-z]/,
    isOn = (t) => onRE.test(t),
    isModelListener = (t) => t.startsWith("onUpdate:"),
    extend = Object.assign,
    remove = (t, e) => {
        const n = t.indexOf(e)
        n > -1 && t.splice(n, 1)
    },
    hasOwnProperty$1 = Object.prototype.hasOwnProperty,
    hasOwn = (t, e) => hasOwnProperty$1.call(t, e),
    isArray$1 = Array.isArray,
    isMap = (t) => toTypeString(t) === "[object Map]",
    isSet = (t) => toTypeString(t) === "[object Set]",
    isDate = (t) => toTypeString(t) === "[object Date]",
    isFunction = (t) => typeof t == "function",
    isString = (t) => typeof t == "string",
    isSymbol = (t) => typeof t == "symbol",
    isObject = (t) => t !== null && typeof t == "object",
    isPromise = (t) => isObject(t) && isFunction(t.then) && isFunction(t.catch),
    objectToString = Object.prototype.toString,
    toTypeString = (t) => objectToString.call(t),
    toRawType = (t) => toTypeString(t).slice(8, -1),
    isPlainObject = (t) => toTypeString(t) === "[object Object]",
    isIntegerKey = (t) => isString(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    isReservedProp = makeMap(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    cacheStringFunction = (t) => {
        const e = Object.create(null)
        return (n) => e[n] || (e[n] = t(n))
    },
    camelizeRE = /-(\w)/g,
    camelize = cacheStringFunction((t) => t.replace(camelizeRE, (e, n) => (n ? n.toUpperCase() : ""))),
    hyphenateRE = /\B([A-Z])/g,
    hyphenate = cacheStringFunction((t) => t.replace(hyphenateRE, "-$1").toLowerCase()),
    capitalize = cacheStringFunction((t) => t.charAt(0).toUpperCase() + t.slice(1)),
    toHandlerKey = cacheStringFunction((t) => (t ? `on${capitalize(t)}` : "")),
    hasChanged = (t, e) => !Object.is(t, e),
    invokeArrayFns = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    def = (t, e, n) => {
        Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: n })
    },
    toNumber = (t) => {
        const e = parseFloat(t)
        return isNaN(e) ? t : e
    }
let _globalThis
const getGlobalThis = () =>
    _globalThis ||
    (_globalThis =
        typeof globalThis != "undefined"
            ? globalThis
            : typeof self != "undefined"
            ? self
            : typeof window != "undefined"
            ? window
            : typeof global != "undefined"
            ? global
            : {})
let activeEffectScope
class EffectScope {
    constructor(e = !1) {
        ;(this.active = !0),
            (this.effects = []),
            (this.cleanups = []),
            !e &&
                activeEffectScope &&
                ((this.parent = activeEffectScope), (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1))
    }
    run(e) {
        if (this.active) {
            const n = activeEffectScope
            try {
                return (activeEffectScope = this), e()
            } finally {
                activeEffectScope = n
            }
        }
    }
    on() {
        activeEffectScope = this
    }
    off() {
        activeEffectScope = this.parent
    }
    stop(e) {
        if (this.active) {
            let n, i
            for (n = 0, i = this.effects.length; n < i; n++) this.effects[n].stop()
            for (n = 0, i = this.cleanups.length; n < i; n++) this.cleanups[n]()
            if (this.scopes) for (n = 0, i = this.scopes.length; n < i; n++) this.scopes[n].stop(!0)
            if (this.parent && !e) {
                const o = this.parent.scopes.pop()
                o && o !== this && ((this.parent.scopes[this.index] = o), (o.index = this.index))
            }
            this.active = !1
        }
    }
}
function effectScope(t) {
    return new EffectScope(t)
}
function recordEffectScope(t, e = activeEffectScope) {
    e && e.active && e.effects.push(t)
}
function getCurrentScope() {
    return activeEffectScope
}
function onScopeDispose(t) {
    activeEffectScope && activeEffectScope.cleanups.push(t)
}
const createDep = (t) => {
        const e = new Set(t)
        return (e.w = 0), (e.n = 0), e
    },
    wasTracked = (t) => (t.w & trackOpBit) > 0,
    newTracked = (t) => (t.n & trackOpBit) > 0,
    initDepMarkers = ({ deps: t }) => {
        if (t.length) for (let e = 0; e < t.length; e++) t[e].w |= trackOpBit
    },
    finalizeDepMarkers = (t) => {
        const { deps: e } = t
        if (e.length) {
            let n = 0
            for (let i = 0; i < e.length; i++) {
                const o = e[i]
                wasTracked(o) && !newTracked(o) ? o.delete(t) : (e[n++] = o), (o.w &= ~trackOpBit), (o.n &= ~trackOpBit)
            }
            e.length = n
        }
    },
    targetMap = new WeakMap()
let effectTrackDepth = 0,
    trackOpBit = 1
const maxMarkerBits = 30
let activeEffect
const ITERATE_KEY = Symbol(""),
    MAP_KEY_ITERATE_KEY = Symbol("")
class ReactiveEffect {
    constructor(e, n = null, i) {
        ;(this.fn = e), (this.scheduler = n), (this.active = !0), (this.deps = []), (this.parent = void 0), recordEffectScope(this, i)
    }
    run() {
        if (!this.active) return this.fn()
        let e = activeEffect,
            n = shouldTrack
        for (; e; ) {
            if (e === this) return
            e = e.parent
        }
        try {
            return (
                (this.parent = activeEffect),
                (activeEffect = this),
                (shouldTrack = !0),
                (trackOpBit = 1 << ++effectTrackDepth),
                effectTrackDepth <= maxMarkerBits ? initDepMarkers(this) : cleanupEffect(this),
                this.fn()
            )
        } finally {
            effectTrackDepth <= maxMarkerBits && finalizeDepMarkers(this),
                (trackOpBit = 1 << --effectTrackDepth),
                (activeEffect = this.parent),
                (shouldTrack = n),
                (this.parent = void 0),
                this.deferStop && this.stop()
        }
    }
    stop() {
        activeEffect === this ? (this.deferStop = !0) : this.active && (cleanupEffect(this), this.onStop && this.onStop(), (this.active = !1))
    }
}
function cleanupEffect(t) {
    const { deps: e } = t
    if (e.length) {
        for (let n = 0; n < e.length; n++) e[n].delete(t)
        e.length = 0
    }
}
function effect$3(t, e) {
    t.effect && (t = t.effect.fn)
    const n = new ReactiveEffect(t)
    e && (extend(n, e), e.scope && recordEffectScope(n, e.scope)), (!e || !e.lazy) && n.run()
    const i = n.run.bind(n)
    return (i.effect = n), i
}
function stop(t) {
    t.effect.stop()
}
let shouldTrack = !0
const trackStack = []
function pauseTracking() {
    trackStack.push(shouldTrack), (shouldTrack = !1)
}
function resetTracking() {
    const t = trackStack.pop()
    shouldTrack = t === void 0 ? !0 : t
}
function track(t, e, n) {
    if (shouldTrack && activeEffect) {
        let i = targetMap.get(t)
        i || targetMap.set(t, (i = new Map()))
        let o = i.get(n)
        o || i.set(n, (o = createDep())), trackEffects(o)
    }
}
function trackEffects(t, e) {
    let n = !1
    effectTrackDepth <= maxMarkerBits ? newTracked(t) || ((t.n |= trackOpBit), (n = !wasTracked(t))) : (n = !t.has(activeEffect)),
        n && (t.add(activeEffect), activeEffect.deps.push(t))
}
function trigger(t, e, n, i, o, a) {
    const l = targetMap.get(t)
    if (!l) return
    let c = []
    if (e === "clear") c = [...l.values()]
    else if (n === "length" && isArray$1(t))
        l.forEach((g, v) => {
            ;(v === "length" || v >= i) && c.push(g)
        })
    else
        switch ((n !== void 0 && c.push(l.get(n)), e)) {
            case "add":
                isArray$1(t)
                    ? isIntegerKey(n) && c.push(l.get("length"))
                    : (c.push(l.get(ITERATE_KEY)), isMap(t) && c.push(l.get(MAP_KEY_ITERATE_KEY)))
                break
            case "delete":
                isArray$1(t) || (c.push(l.get(ITERATE_KEY)), isMap(t) && c.push(l.get(MAP_KEY_ITERATE_KEY)))
                break
            case "set":
                isMap(t) && c.push(l.get(ITERATE_KEY))
                break
        }
    if (c.length === 1) c[0] && triggerEffects(c[0])
    else {
        const g = []
        for (const v of c) v && g.push(...v)
        triggerEffects(createDep(g))
    }
}
function triggerEffects(t, e) {
    const n = isArray$1(t) ? t : [...t]
    for (const i of n) i.computed && triggerEffect(i)
    for (const i of n) i.computed || triggerEffect(i)
}
function triggerEffect(t, e) {
    ;(t !== activeEffect || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run())
}
const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue"),
    builtInSymbols = new Set(
        Object.getOwnPropertyNames(Symbol)
            .filter((t) => t !== "arguments" && t !== "caller")
            .map((t) => Symbol[t])
            .filter(isSymbol)
    ),
    get = createGetter(),
    shallowGet = createGetter(!1, !0),
    readonlyGet = createGetter(!0),
    shallowReadonlyGet = createGetter(!0, !0),
    arrayInstrumentations = createArrayInstrumentations()
function createArrayInstrumentations() {
    const t = {}
    return (
        ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
            t[e] = function (...n) {
                const i = toRaw(this)
                for (let a = 0, l = this.length; a < l; a++) track(i, "get", a + "")
                const o = i[e](...n)
                return o === -1 || o === !1 ? i[e](...n.map(toRaw)) : o
            }
        }),
        ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
            t[e] = function (...n) {
                pauseTracking()
                const i = toRaw(this)[e].apply(this, n)
                return resetTracking(), i
            }
        }),
        t
    )
}
function createGetter(t = !1, e = !1) {
    return function (i, o, a) {
        if (o === "__v_isReactive") return !t
        if (o === "__v_isReadonly") return t
        if (o === "__v_isShallow") return e
        if (o === "__v_raw" && a === (t ? (e ? shallowReadonlyMap : readonlyMap) : e ? shallowReactiveMap : reactiveMap).get(i)) return i
        const l = isArray$1(i)
        if (!t && l && hasOwn(arrayInstrumentations, o)) return Reflect.get(arrayInstrumentations, o, a)
        const c = Reflect.get(i, o, a)
        return (isSymbol(o) ? builtInSymbols.has(o) : isNonTrackableKeys(o)) || (t || track(i, "get", o), e)
            ? c
            : isRef(c)
            ? l && isIntegerKey(o)
                ? c
                : c.value
            : isObject(c)
            ? t
                ? readonly$1(c)
                : reactive(c)
            : c
    }
}
const set = createSetter(),
    shallowSet = createSetter(!0)
function createSetter(t = !1) {
    return function (n, i, o, a) {
        let l = n[i]
        if (isReadonly(l) && isRef(l) && !isRef(o)) return !1
        if (!t && (!isShallow(o) && !isReadonly(o) && ((l = toRaw(l)), (o = toRaw(o))), !isArray$1(n) && isRef(l) && !isRef(o)))
            return (l.value = o), !0
        const c = isArray$1(n) && isIntegerKey(i) ? Number(i) < n.length : hasOwn(n, i),
            g = Reflect.set(n, i, o, a)
        return n === toRaw(a) && (c ? hasChanged(o, l) && trigger(n, "set", i, o) : trigger(n, "add", i, o)), g
    }
}
function deleteProperty(t, e) {
    const n = hasOwn(t, e)
    t[e]
    const i = Reflect.deleteProperty(t, e)
    return i && n && trigger(t, "delete", e, void 0), i
}
function has(t, e) {
    const n = Reflect.has(t, e)
    return (!isSymbol(e) || !builtInSymbols.has(e)) && track(t, "has", e), n
}
function ownKeys(t) {
    return track(t, "iterate", isArray$1(t) ? "length" : ITERATE_KEY), Reflect.ownKeys(t)
}
const mutableHandlers = { get, set, deleteProperty, has, ownKeys },
    readonlyHandlers = {
        get: readonlyGet,
        set(t, e) {
            return !0
        },
        deleteProperty(t, e) {
            return !0
        },
    },
    shallowReactiveHandlers = extend({}, mutableHandlers, { get: shallowGet, set: shallowSet }),
    shallowReadonlyHandlers = extend({}, readonlyHandlers, { get: shallowReadonlyGet }),
    toShallow = (t) => t,
    getProto = (t) => Reflect.getPrototypeOf(t)
function get$1(t, e, n = !1, i = !1) {
    t = t.__v_raw
    const o = toRaw(t),
        a = toRaw(e)
    n || (e !== a && track(o, "get", e), track(o, "get", a))
    const { has: l } = getProto(o),
        c = i ? toShallow : n ? toReadonly : toReactive
    if (l.call(o, e)) return c(t.get(e))
    if (l.call(o, a)) return c(t.get(a))
    t !== o && t.get(e)
}
function has$1(t, e = !1) {
    const n = this.__v_raw,
        i = toRaw(n),
        o = toRaw(t)
    return e || (t !== o && track(i, "has", t), track(i, "has", o)), t === o ? n.has(t) : n.has(t) || n.has(o)
}
function size(t, e = !1) {
    return (t = t.__v_raw), !e && track(toRaw(t), "iterate", ITERATE_KEY), Reflect.get(t, "size", t)
}
function add$1(t) {
    t = toRaw(t)
    const e = toRaw(this)
    return getProto(e).has.call(e, t) || (e.add(t), trigger(e, "add", t, t)), this
}
function set$1(t, e) {
    e = toRaw(e)
    const n = toRaw(this),
        { has: i, get: o } = getProto(n)
    let a = i.call(n, t)
    a || ((t = toRaw(t)), (a = i.call(n, t)))
    const l = o.call(n, t)
    return n.set(t, e), a ? hasChanged(e, l) && trigger(n, "set", t, e) : trigger(n, "add", t, e), this
}
function deleteEntry(t) {
    const e = toRaw(this),
        { has: n, get: i } = getProto(e)
    let o = n.call(e, t)
    o || ((t = toRaw(t)), (o = n.call(e, t))), i && i.call(e, t)
    const a = e.delete(t)
    return o && trigger(e, "delete", t, void 0), a
}
function clear() {
    const t = toRaw(this),
        e = t.size !== 0,
        n = t.clear()
    return e && trigger(t, "clear", void 0, void 0), n
}
function createForEach(t, e) {
    return function (i, o) {
        const a = this,
            l = a.__v_raw,
            c = toRaw(l),
            g = e ? toShallow : t ? toReadonly : toReactive
        return !t && track(c, "iterate", ITERATE_KEY), l.forEach((v, _) => i.call(o, g(v), g(_), a))
    }
}
function createIterableMethod(t, e, n) {
    return function (...i) {
        const o = this.__v_raw,
            a = toRaw(o),
            l = isMap(a),
            c = t === "entries" || (t === Symbol.iterator && l),
            g = t === "keys" && l,
            v = o[t](...i),
            _ = n ? toShallow : e ? toReadonly : toReactive
        return (
            !e && track(a, "iterate", g ? MAP_KEY_ITERATE_KEY : ITERATE_KEY),
            {
                next() {
                    const { value: A, done: B } = v.next()
                    return B ? { value: A, done: B } : { value: c ? [_(A[0]), _(A[1])] : _(A), done: B }
                },
                [Symbol.iterator]() {
                    return this
                },
            }
        )
    }
}
function createReadonlyMethod(t) {
    return function (...e) {
        return t === "delete" ? !1 : this
    }
}
function createInstrumentations() {
    const t = {
            get(a) {
                return get$1(this, a)
            },
            get size() {
                return size(this)
            },
            has: has$1,
            add: add$1,
            set: set$1,
            delete: deleteEntry,
            clear,
            forEach: createForEach(!1, !1),
        },
        e = {
            get(a) {
                return get$1(this, a, !1, !0)
            },
            get size() {
                return size(this)
            },
            has: has$1,
            add: add$1,
            set: set$1,
            delete: deleteEntry,
            clear,
            forEach: createForEach(!1, !0),
        },
        n = {
            get(a) {
                return get$1(this, a, !0)
            },
            get size() {
                return size(this, !0)
            },
            has(a) {
                return has$1.call(this, a, !0)
            },
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear"),
            forEach: createForEach(!0, !1),
        },
        i = {
            get(a) {
                return get$1(this, a, !0, !0)
            },
            get size() {
                return size(this, !0)
            },
            has(a) {
                return has$1.call(this, a, !0)
            },
            add: createReadonlyMethod("add"),
            set: createReadonlyMethod("set"),
            delete: createReadonlyMethod("delete"),
            clear: createReadonlyMethod("clear"),
            forEach: createForEach(!0, !0),
        }
    return (
        ["keys", "values", "entries", Symbol.iterator].forEach((a) => {
            ;(t[a] = createIterableMethod(a, !1, !1)),
                (n[a] = createIterableMethod(a, !0, !1)),
                (e[a] = createIterableMethod(a, !1, !0)),
                (i[a] = createIterableMethod(a, !0, !0))
        }),
        [t, n, e, i]
    )
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = createInstrumentations()
function createInstrumentationGetter(t, e) {
    const n = e ? (t ? shallowReadonlyInstrumentations : shallowInstrumentations) : t ? readonlyInstrumentations : mutableInstrumentations
    return (i, o, a) =>
        o === "__v_isReactive" ? !t : o === "__v_isReadonly" ? t : o === "__v_raw" ? i : Reflect.get(hasOwn(n, o) && o in i ? n : i, o, a)
}
const mutableCollectionHandlers = { get: createInstrumentationGetter(!1, !1) },
    shallowCollectionHandlers = { get: createInstrumentationGetter(!1, !0) },
    readonlyCollectionHandlers = { get: createInstrumentationGetter(!0, !1) },
    shallowReadonlyCollectionHandlers = { get: createInstrumentationGetter(!0, !0) },
    reactiveMap = new WeakMap(),
    shallowReactiveMap = new WeakMap(),
    readonlyMap = new WeakMap(),
    shallowReadonlyMap = new WeakMap()
function targetTypeMap(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2
        default:
            return 0
    }
}
function getTargetType(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : targetTypeMap(toRawType(t))
}
function reactive(t) {
    return isReadonly(t) ? t : createReactiveObject(t, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap)
}
function shallowReactive(t) {
    return createReactiveObject(t, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap)
}
function readonly$1(t) {
    return createReactiveObject(t, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap)
}
function shallowReadonly(t) {
    return createReactiveObject(t, !0, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap)
}
function createReactiveObject(t, e, n, i, o) {
    if (!isObject(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t
    const a = o.get(t)
    if (a) return a
    const l = getTargetType(t)
    if (l === 0) return t
    const c = new Proxy(t, l === 2 ? i : n)
    return o.set(t, c), c
}
function isReactive(t) {
    return isReadonly(t) ? isReactive(t.__v_raw) : !!(t && t.__v_isReactive)
}
function isReadonly(t) {
    return !!(t && t.__v_isReadonly)
}
function isShallow(t) {
    return !!(t && t.__v_isShallow)
}
function isProxy(t) {
    return isReactive(t) || isReadonly(t)
}
function toRaw(t) {
    const e = t && t.__v_raw
    return e ? toRaw(e) : t
}
function markRaw(t) {
    return def(t, "__v_skip", !0), t
}
const toReactive = (t) => (isObject(t) ? reactive(t) : t),
    toReadonly = (t) => (isObject(t) ? readonly$1(t) : t)
function trackRefValue(t) {
    shouldTrack && activeEffect && ((t = toRaw(t)), trackEffects(t.dep || (t.dep = createDep())))
}
function triggerRefValue(t, e) {
    ;(t = toRaw(t)), t.dep && triggerEffects(t.dep)
}
function isRef(t) {
    return !!(t && t.__v_isRef === !0)
}
function ref(t) {
    return createRef(t, !1)
}
function shallowRef(t) {
    return createRef(t, !0)
}
function createRef(t, e) {
    return isRef(t) ? t : new RefImpl(t, e)
}
class RefImpl {
    constructor(e, n) {
        ;(this.__v_isShallow = n),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this._rawValue = n ? e : toRaw(e)),
            (this._value = n ? e : toReactive(e))
    }
    get value() {
        return trackRefValue(this), this._value
    }
    set value(e) {
        const n = this.__v_isShallow || isShallow(e) || isReadonly(e)
        ;(e = n ? e : toRaw(e)),
            hasChanged(e, this._rawValue) && ((this._rawValue = e), (this._value = n ? e : toReactive(e)), triggerRefValue(this))
    }
}
function triggerRef(t) {
    triggerRefValue(t)
}
function unref(t) {
    return isRef(t) ? t.value : t
}
const shallowUnwrapHandlers = {
    get: (t, e, n) => unref(Reflect.get(t, e, n)),
    set: (t, e, n, i) => {
        const o = t[e]
        return isRef(o) && !isRef(n) ? ((o.value = n), !0) : Reflect.set(t, e, n, i)
    },
}
function proxyRefs(t) {
    return isReactive(t) ? t : new Proxy(t, shallowUnwrapHandlers)
}
class CustomRefImpl {
    constructor(e) {
        ;(this.dep = void 0), (this.__v_isRef = !0)
        const { get: n, set: i } = e(
            () => trackRefValue(this),
            () => triggerRefValue(this)
        )
        ;(this._get = n), (this._set = i)
    }
    get value() {
        return this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function customRef(t) {
    return new CustomRefImpl(t)
}
function toRefs(t) {
    const e = isArray$1(t) ? new Array(t.length) : {}
    for (const n in t) e[n] = toRef(t, n)
    return e
}
class ObjectRefImpl {
    constructor(e, n, i) {
        ;(this._object = e), (this._key = n), (this._defaultValue = i), (this.__v_isRef = !0)
    }
    get value() {
        const e = this._object[this._key]
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
}
function toRef(t, e, n) {
    const i = t[e]
    return isRef(i) ? i : new ObjectRefImpl(t, e, n)
}
var _a$1
class ComputedRefImpl {
    constructor(e, n, i, o) {
        ;(this._setter = n),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this[_a$1] = !1),
            (this._dirty = !0),
            (this.effect = new ReactiveEffect(e, () => {
                this._dirty || ((this._dirty = !0), triggerRefValue(this))
            })),
            (this.effect.computed = this),
            (this.effect.active = this._cacheable = !o),
            (this.__v_isReadonly = i)
    }
    get value() {
        const e = toRaw(this)
        return trackRefValue(e), (e._dirty || !e._cacheable) && ((e._dirty = !1), (e._value = e.effect.run())), e._value
    }
    set value(e) {
        this._setter(e)
    }
}
_a$1 = "__v_isReadonly"
function computed$1(t, e, n = !1) {
    let i, o
    const a = isFunction(t)
    return a ? ((i = t), (o = NOOP)) : ((i = t.get), (o = t.set)), new ComputedRefImpl(i, o, a || !o, n)
}
const stack = []
function warn(t, ...e) {
    pauseTracking()
    const n = stack.length ? stack[stack.length - 1].component : null,
        i = n && n.appContext.config.warnHandler,
        o = getComponentTrace()
    if (i)
        callWithErrorHandling(i, n, 11, [
            t + e.join(""),
            n && n.proxy,
            o.map(({ vnode: a }) => `at <${formatComponentName(n, a.type)}>`).join(`
`),
            o,
        ])
    else {
        const a = [`[Vue warn]: ${t}`, ...e]
        o.length &&
            a.push(
                `
`,
                ...formatTrace(o)
            ),
            console.warn(...a)
    }
    resetTracking()
}
function getComponentTrace() {
    let t = stack[stack.length - 1]
    if (!t) return []
    const e = []
    for (; t; ) {
        const n = e[0]
        n && n.vnode === t ? n.recurseCount++ : e.push({ vnode: t, recurseCount: 0 })
        const i = t.component && t.component.parent
        t = i && i.vnode
    }
    return e
}
function formatTrace(t) {
    const e = []
    return (
        t.forEach((n, i) => {
            e.push(
                ...(i === 0
                    ? []
                    : [
                          `
`,
                      ]),
                ...formatTraceEntry(n)
            )
        }),
        e
    )
}
function formatTraceEntry({ vnode: t, recurseCount: e }) {
    const n = e > 0 ? `... (${e} recursive calls)` : "",
        i = t.component ? t.component.parent == null : !1,
        o = ` at <${formatComponentName(t.component, t.type, i)}`,
        a = ">" + n
    return t.props ? [o, ...formatProps(t.props), a] : [o + a]
}
function formatProps(t) {
    const e = [],
        n = Object.keys(t)
    return (
        n.slice(0, 3).forEach((i) => {
            e.push(...formatProp(i, t[i]))
        }),
        n.length > 3 && e.push(" ..."),
        e
    )
}
function formatProp(t, e, n) {
    return isString(e)
        ? ((e = JSON.stringify(e)), n ? e : [`${t}=${e}`])
        : typeof e == "number" || typeof e == "boolean" || e == null
        ? n
            ? e
            : [`${t}=${e}`]
        : isRef(e)
        ? ((e = formatProp(t, toRaw(e.value), !0)), n ? e : [`${t}=Ref<`, e, ">"])
        : isFunction(e)
        ? [`${t}=fn${e.name ? `<${e.name}>` : ""}`]
        : ((e = toRaw(e)), n ? e : [`${t}=`, e])
}
function callWithErrorHandling(t, e, n, i) {
    let o
    try {
        o = i ? t(...i) : t()
    } catch (a) {
        handleError(a, e, n)
    }
    return o
}
function callWithAsyncErrorHandling(t, e, n, i) {
    if (isFunction(t)) {
        const a = callWithErrorHandling(t, e, n, i)
        return (
            a &&
                isPromise(a) &&
                a.catch((l) => {
                    handleError(l, e, n)
                }),
            a
        )
    }
    const o = []
    for (let a = 0; a < t.length; a++) o.push(callWithAsyncErrorHandling(t[a], e, n, i))
    return o
}
function handleError(t, e, n, i = !0) {
    const o = e ? e.vnode : null
    if (e) {
        let a = e.parent
        const l = e.proxy,
            c = n
        for (; a; ) {
            const v = a.ec
            if (v) {
                for (let _ = 0; _ < v.length; _++) if (v[_](t, l, c) === !1) return
            }
            a = a.parent
        }
        const g = e.appContext.config.errorHandler
        if (g) {
            callWithErrorHandling(g, null, 10, [t, l, c])
            return
        }
    }
    logError(t, n, o, i)
}
function logError(t, e, n, i = !0) {
    console.error(t)
}
let isFlushing = !1,
    isFlushPending = !1
const queue = []
let flushIndex = 0
const pendingPostFlushCbs = []
let activePostFlushCbs = null,
    postFlushIndex = 0
const resolvedPromise = Promise.resolve()
let currentFlushPromise = null
function nextTick(t) {
    const e = currentFlushPromise || resolvedPromise
    return t ? e.then(this ? t.bind(this) : t) : e
}
function findInsertionIndex(t) {
    let e = flushIndex + 1,
        n = queue.length
    for (; e < n; ) {
        const i = (e + n) >>> 1
        getId(queue[i]) < t ? (e = i + 1) : (n = i)
    }
    return e
}
function queueJob(t) {
    ;(!queue.length || !queue.includes(t, isFlushing && t.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        (t.id == null ? queue.push(t) : queue.splice(findInsertionIndex(t.id), 0, t), queueFlush())
}
function queueFlush() {
    !isFlushing && !isFlushPending && ((isFlushPending = !0), (currentFlushPromise = resolvedPromise.then(flushJobs)))
}
function invalidateJob(t) {
    const e = queue.indexOf(t)
    e > flushIndex && queue.splice(e, 1)
}
function queuePostFlushCb(t) {
    isArray$1(t)
        ? pendingPostFlushCbs.push(...t)
        : (!activePostFlushCbs || !activePostFlushCbs.includes(t, t.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) &&
          pendingPostFlushCbs.push(t),
        queueFlush()
}
function flushPreFlushCbs(t, e = flushIndex) {
    for (; e < queue.length; e++) {
        const n = queue[e]
        n && n.pre && (queue.splice(e, 1), e--, n())
    }
}
function flushPostFlushCbs(t) {
    if (pendingPostFlushCbs.length) {
        const e = [...new Set(pendingPostFlushCbs)]
        if (((pendingPostFlushCbs.length = 0), activePostFlushCbs)) {
            activePostFlushCbs.push(...e)
            return
        }
        for (
            activePostFlushCbs = e, activePostFlushCbs.sort((n, i) => getId(n) - getId(i)), postFlushIndex = 0;
            postFlushIndex < activePostFlushCbs.length;
            postFlushIndex++
        )
            activePostFlushCbs[postFlushIndex]()
        ;(activePostFlushCbs = null), (postFlushIndex = 0)
    }
}
const getId = (t) => (t.id == null ? 1 / 0 : t.id),
    comparator = (t, e) => {
        const n = getId(t) - getId(e)
        if (n === 0) {
            if (t.pre && !e.pre) return -1
            if (e.pre && !t.pre) return 1
        }
        return n
    }
function flushJobs(t) {
    ;(isFlushPending = !1), (isFlushing = !0), queue.sort(comparator)
    const e = NOOP
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const n = queue[flushIndex]
            n && n.active !== !1 && callWithErrorHandling(n, null, 14)
        }
    } finally {
        ;(flushIndex = 0),
            (queue.length = 0),
            flushPostFlushCbs(),
            (isFlushing = !1),
            (currentFlushPromise = null),
            (queue.length || pendingPostFlushCbs.length) && flushJobs()
    }
}
let devtools,
    buffer$1 = []
function setDevtoolsHook(t, e) {
    var n, i
    ;(devtools = t),
        devtools
            ? ((devtools.enabled = !0), buffer$1.forEach(({ event: o, args: a }) => devtools.emit(o, ...a)), (buffer$1 = []))
            : typeof window != "undefined" &&
              window.HTMLElement &&
              !(!((i = (n = window.navigator) === null || n === void 0 ? void 0 : n.userAgent) === null || i === void 0) && i.includes("jsdom"))
            ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((a) => {
                  setDevtoolsHook(a, e)
              }),
              setTimeout(() => {
                  devtools || ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (buffer$1 = []))
              }, 3e3))
            : (buffer$1 = [])
}
function emit$1(t, e, ...n) {
    if (t.isUnmounted) return
    const i = t.vnode.props || EMPTY_OBJ
    let o = n
    const a = e.startsWith("update:"),
        l = a && e.slice(7)
    if (l && l in i) {
        const _ = `${l === "modelValue" ? "model" : l}Modifiers`,
            { number: A, trim: B } = i[_] || EMPTY_OBJ
        B && (o = n.map((D) => D.trim())), A && (o = n.map(toNumber))
    }
    let c,
        g = i[(c = toHandlerKey(e))] || i[(c = toHandlerKey(camelize(e)))]
    !g && a && (g = i[(c = toHandlerKey(hyphenate(e)))]), g && callWithAsyncErrorHandling(g, t, 6, o)
    const v = i[c + "Once"]
    if (v) {
        if (!t.emitted) t.emitted = {}
        else if (t.emitted[c]) return
        ;(t.emitted[c] = !0), callWithAsyncErrorHandling(v, t, 6, o)
    }
}
function normalizeEmitsOptions(t, e, n = !1) {
    const i = e.emitsCache,
        o = i.get(t)
    if (o !== void 0) return o
    const a = t.emits
    let l = {},
        c = !1
    if (!isFunction(t)) {
        const g = (v) => {
            const _ = normalizeEmitsOptions(v, e, !0)
            _ && ((c = !0), extend(l, _))
        }
        !n && e.mixins.length && e.mixins.forEach(g), t.extends && g(t.extends), t.mixins && t.mixins.forEach(g)
    }
    return !a && !c
        ? (isObject(t) && i.set(t, null), null)
        : (isArray$1(a) ? a.forEach((g) => (l[g] = null)) : extend(l, a), isObject(t) && i.set(t, l), l)
}
function isEmitListener(t, e) {
    return !t || !isOn(e)
        ? !1
        : ((e = e.slice(2).replace(/Once$/, "")), hasOwn(t, e[0].toLowerCase() + e.slice(1)) || hasOwn(t, hyphenate(e)) || hasOwn(t, e))
}
let currentRenderingInstance = null,
    currentScopeId = null
function setCurrentRenderingInstance(t) {
    const e = currentRenderingInstance
    return (currentRenderingInstance = t), (currentScopeId = (t && t.type.__scopeId) || null), e
}
function pushScopeId(t) {
    currentScopeId = t
}
function popScopeId() {
    currentScopeId = null
}
const withScopeId = (t) => withCtx
function withCtx(t, e = currentRenderingInstance, n) {
    if (!e || t._n) return t
    const i = (...o) => {
        i._d && setBlockTracking(-1)
        const a = setCurrentRenderingInstance(e),
            l = t(...o)
        return setCurrentRenderingInstance(a), i._d && setBlockTracking(1), l
    }
    return (i._n = !0), (i._c = !0), (i._d = !0), i
}
function markAttrsAccessed() {}
function renderComponentRoot(t) {
    const {
        type: e,
        vnode: n,
        proxy: i,
        withProxy: o,
        props: a,
        propsOptions: [l],
        slots: c,
        attrs: g,
        emit: v,
        render: _,
        renderCache: A,
        data: B,
        setupState: D,
        ctx: I,
        inheritAttrs: L,
    } = t
    let G, U
    const F = setCurrentRenderingInstance(t)
    try {
        if (n.shapeFlag & 4) {
            const Y = o || i
            ;(G = normalizeVNode(_.call(Y, Y, A, a, D, B, I))), (U = g)
        } else {
            const Y = e
            ;(G = normalizeVNode(Y.length > 1 ? Y(a, { attrs: g, slots: c, emit: v }) : Y(a, null))),
                (U = e.props ? g : getFunctionalFallthrough(g))
        }
    } catch (Y) {
        ;(blockStack.length = 0), handleError(Y, t, 1), (G = createVNode(Comment))
    }
    let Z = G
    if (U && L !== !1) {
        const Y = Object.keys(U),
            { shapeFlag: X } = Z
        Y.length && X & 7 && (l && Y.some(isModelListener) && (U = filterModelListeners(U, l)), (Z = cloneVNode(Z, U)))
    }
    return (
        n.dirs && ((Z = cloneVNode(Z)), (Z.dirs = Z.dirs ? Z.dirs.concat(n.dirs) : n.dirs)),
        n.transition && (Z.transition = n.transition),
        (G = Z),
        setCurrentRenderingInstance(F),
        G
    )
}
function filterSingleRoot(t) {
    let e
    for (let n = 0; n < t.length; n++) {
        const i = t[n]
        if (isVNode(i)) {
            if (i.type !== Comment || i.children === "v-if") {
                if (e) return
                e = i
            }
        } else return
    }
    return e
}
const getFunctionalFallthrough = (t) => {
        let e
        for (const n in t) (n === "class" || n === "style" || isOn(n)) && ((e || (e = {}))[n] = t[n])
        return e
    },
    filterModelListeners = (t, e) => {
        const n = {}
        for (const i in t) (!isModelListener(i) || !(i.slice(9) in e)) && (n[i] = t[i])
        return n
    }
function shouldUpdateComponent(t, e, n) {
    const { props: i, children: o, component: a } = t,
        { props: l, children: c, patchFlag: g } = e,
        v = a.emitsOptions
    if (e.dirs || e.transition) return !0
    if (n && g >= 0) {
        if (g & 1024) return !0
        if (g & 16) return i ? hasPropsChanged(i, l, v) : !!l
        if (g & 8) {
            const _ = e.dynamicProps
            for (let A = 0; A < _.length; A++) {
                const B = _[A]
                if (l[B] !== i[B] && !isEmitListener(v, B)) return !0
            }
        }
    } else return (o || c) && (!c || !c.$stable) ? !0 : i === l ? !1 : i ? (l ? hasPropsChanged(i, l, v) : !0) : !!l
    return !1
}
function hasPropsChanged(t, e, n) {
    const i = Object.keys(e)
    if (i.length !== Object.keys(t).length) return !0
    for (let o = 0; o < i.length; o++) {
        const a = i[o]
        if (e[a] !== t[a] && !isEmitListener(n, a)) return !0
    }
    return !1
}
function updateHOCHostEl({ vnode: t, parent: e }, n) {
    for (; e && e.subTree === t; ) ((t = e.vnode).el = n), (e = e.parent)
}
const isSuspense = (t) => t.__isSuspense,
    SuspenseImpl = {
        name: "Suspense",
        __isSuspense: !0,
        process(t, e, n, i, o, a, l, c, g, v) {
            t == null ? mountSuspense(e, n, i, o, a, l, c, g, v) : patchSuspense(t, e, n, i, o, l, c, g, v)
        },
        hydrate: hydrateSuspense,
        create: createSuspenseBoundary,
        normalize: normalizeSuspenseChildren,
    },
    Suspense = SuspenseImpl
function triggerEvent(t, e) {
    const n = t.props && t.props[e]
    isFunction(n) && n()
}
function mountSuspense(t, e, n, i, o, a, l, c, g) {
    const {
            p: v,
            o: { createElement: _ },
        } = g,
        A = _("div"),
        B = (t.suspense = createSuspenseBoundary(t, o, i, e, A, n, a, l, c, g))
    v(null, (B.pendingBranch = t.ssContent), A, null, i, B, a, l),
        B.deps > 0
            ? (triggerEvent(t, "onPending"),
              triggerEvent(t, "onFallback"),
              v(null, t.ssFallback, e, n, i, null, a, l),
              setActiveBranch(B, t.ssFallback))
            : B.resolve()
}
function patchSuspense(t, e, n, i, o, a, l, c, { p: g, um: v, o: { createElement: _ } }) {
    const A = (e.suspense = t.suspense)
    ;(A.vnode = e), (e.el = t.el)
    const B = e.ssContent,
        D = e.ssFallback,
        { activeBranch: I, pendingBranch: L, isInFallback: G, isHydrating: U } = A
    if (L)
        (A.pendingBranch = B),
            isSameVNodeType(B, L)
                ? (g(L, B, A.hiddenContainer, null, o, A, a, l, c),
                  A.deps <= 0 ? A.resolve() : G && (g(I, D, n, i, o, null, a, l, c), setActiveBranch(A, D)))
                : (A.pendingId++,
                  U ? ((A.isHydrating = !1), (A.activeBranch = L)) : v(L, o, A),
                  (A.deps = 0),
                  (A.effects.length = 0),
                  (A.hiddenContainer = _("div")),
                  G
                      ? (g(null, B, A.hiddenContainer, null, o, A, a, l, c),
                        A.deps <= 0 ? A.resolve() : (g(I, D, n, i, o, null, a, l, c), setActiveBranch(A, D)))
                      : I && isSameVNodeType(B, I)
                      ? (g(I, B, n, i, o, A, a, l, c), A.resolve(!0))
                      : (g(null, B, A.hiddenContainer, null, o, A, a, l, c), A.deps <= 0 && A.resolve()))
    else if (I && isSameVNodeType(B, I)) g(I, B, n, i, o, A, a, l, c), setActiveBranch(A, B)
    else if (
        (triggerEvent(e, "onPending"), (A.pendingBranch = B), A.pendingId++, g(null, B, A.hiddenContainer, null, o, A, a, l, c), A.deps <= 0)
    )
        A.resolve()
    else {
        const { timeout: F, pendingId: Z } = A
        F > 0
            ? setTimeout(() => {
                  A.pendingId === Z && A.fallback(D)
              }, F)
            : F === 0 && A.fallback(D)
    }
}
function createSuspenseBoundary(t, e, n, i, o, a, l, c, g, v, _ = !1) {
    const {
            p: A,
            m: B,
            um: D,
            n: I,
            o: { parentNode: L, remove: G },
        } = v,
        U = toNumber(t.props && t.props.timeout),
        F = {
            vnode: t,
            parent: e,
            parentComponent: n,
            isSVG: l,
            container: i,
            hiddenContainer: o,
            anchor: a,
            deps: 0,
            pendingId: 0,
            timeout: typeof U == "number" ? U : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !0,
            isHydrating: _,
            isUnmounted: !1,
            effects: [],
            resolve(Z = !1) {
                const { vnode: Y, activeBranch: X, pendingBranch: ie, pendingId: he, effects: oe, parentComponent: le, container: Te } = F
                if (F.isHydrating) F.isHydrating = !1
                else if (!Z) {
                    const O = X && ie.transition && ie.transition.mode === "out-in"
                    O &&
                        (X.transition.afterLeave = () => {
                            he === F.pendingId && B(ie, Te, u, 0)
                        })
                    let { anchor: u } = F
                    X && ((u = I(X)), D(X, le, F, !0)), O || B(ie, Te, u, 0)
                }
                setActiveBranch(F, ie), (F.pendingBranch = null), (F.isInFallback = !1)
                let ye = F.parent,
                    Ae = !1
                for (; ye; ) {
                    if (ye.pendingBranch) {
                        ye.effects.push(...oe), (Ae = !0)
                        break
                    }
                    ye = ye.parent
                }
                Ae || queuePostFlushCb(oe), (F.effects = []), triggerEvent(Y, "onResolve")
            },
            fallback(Z) {
                if (!F.pendingBranch) return
                const { vnode: Y, activeBranch: X, parentComponent: ie, container: he, isSVG: oe } = F
                triggerEvent(Y, "onFallback")
                const le = I(X),
                    Te = () => {
                        !F.isInFallback || (A(null, Z, he, le, ie, null, oe, c, g), setActiveBranch(F, Z))
                    },
                    ye = Z.transition && Z.transition.mode === "out-in"
                ye && (X.transition.afterLeave = Te), (F.isInFallback = !0), D(X, ie, null, !0), ye || Te()
            },
            move(Z, Y, X) {
                F.activeBranch && B(F.activeBranch, Z, Y, X), (F.container = Z)
            },
            next() {
                return F.activeBranch && I(F.activeBranch)
            },
            registerDep(Z, Y) {
                const X = !!F.pendingBranch
                X && F.deps++
                const ie = Z.vnode.el
                Z.asyncDep
                    .catch((he) => {
                        handleError(he, Z, 0)
                    })
                    .then((he) => {
                        if (Z.isUnmounted || F.isUnmounted || F.pendingId !== Z.suspenseId) return
                        Z.asyncResolved = !0
                        const { vnode: oe } = Z
                        handleSetupResult(Z, he, !1), ie && (oe.el = ie)
                        const le = !ie && Z.subTree.el
                        Y(Z, oe, L(ie || Z.subTree.el), ie ? null : I(Z.subTree), F, l, g),
                            le && G(le),
                            updateHOCHostEl(Z, oe.el),
                            X && --F.deps === 0 && F.resolve()
                    })
            },
            unmount(Z, Y) {
                ;(F.isUnmounted = !0), F.activeBranch && D(F.activeBranch, n, Z, Y), F.pendingBranch && D(F.pendingBranch, n, Z, Y)
            },
        }
    return F
}
function hydrateSuspense(t, e, n, i, o, a, l, c, g) {
    const v = (e.suspense = createSuspenseBoundary(e, i, n, t.parentNode, document.createElement("div"), null, o, a, l, c, !0)),
        _ = g(t, (v.pendingBranch = e.ssContent), n, v, a, l)
    return v.deps === 0 && v.resolve(), _
}
function normalizeSuspenseChildren(t) {
    const { shapeFlag: e, children: n } = t,
        i = e & 32
    ;(t.ssContent = normalizeSuspenseSlot(i ? n.default : n)), (t.ssFallback = i ? normalizeSuspenseSlot(n.fallback) : createVNode(Comment))
}
function normalizeSuspenseSlot(t) {
    let e
    if (isFunction(t)) {
        const n = isBlockTreeEnabled && t._c
        n && ((t._d = !1), openBlock()), (t = t()), n && ((t._d = !0), (e = currentBlock), closeBlock())
    }
    return (
        isArray$1(t) && (t = filterSingleRoot(t)),
        (t = normalizeVNode(t)),
        e && !t.dynamicChildren && (t.dynamicChildren = e.filter((n) => n !== t)),
        t
    )
}
function queueEffectWithSuspense(t, e) {
    e && e.pendingBranch ? (isArray$1(t) ? e.effects.push(...t) : e.effects.push(t)) : queuePostFlushCb(t)
}
function setActiveBranch(t, e) {
    t.activeBranch = e
    const { vnode: n, parentComponent: i } = t,
        o = (n.el = e.el)
    i && i.subTree === n && ((i.vnode.el = o), updateHOCHostEl(i, o))
}
function provide(t, e) {
    if (currentInstance) {
        let n = currentInstance.provides
        const i = currentInstance.parent && currentInstance.parent.provides
        i === n && (n = currentInstance.provides = Object.create(i)), (n[t] = e)
    }
}
function inject(t, e, n = !1) {
    const i = currentInstance || currentRenderingInstance
    if (i) {
        const o = i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides
        if (o && t in o) return o[t]
        if (arguments.length > 1) return n && isFunction(e) ? e.call(i.proxy) : e
    }
}
function watchEffect(t, e) {
    return doWatch(t, null, e)
}
function watchPostEffect(t, e) {
    return doWatch(t, null, { flush: "post" })
}
function watchSyncEffect(t, e) {
    return doWatch(t, null, { flush: "sync" })
}
const INITIAL_WATCHER_VALUE = {}
function watch(t, e, n) {
    return doWatch(t, e, n)
}
function doWatch(t, e, { immediate: n, deep: i, flush: o, onTrack: a, onTrigger: l } = EMPTY_OBJ) {
    const c = currentInstance
    let g,
        v = !1,
        _ = !1
    if (
        (isRef(t)
            ? ((g = () => t.value), (v = isShallow(t)))
            : isReactive(t)
            ? ((g = () => t), (i = !0))
            : isArray$1(t)
            ? ((_ = !0),
              (v = t.some((U) => isReactive(U) || isShallow(U))),
              (g = () =>
                  t.map((U) => {
                      if (isRef(U)) return U.value
                      if (isReactive(U)) return traverse(U)
                      if (isFunction(U)) return callWithErrorHandling(U, c, 2)
                  })))
            : isFunction(t)
            ? e
                ? (g = () => callWithErrorHandling(t, c, 2))
                : (g = () => {
                      if (!(c && c.isUnmounted)) return A && A(), callWithAsyncErrorHandling(t, c, 3, [B])
                  })
            : (g = NOOP),
        e && i)
    ) {
        const U = g
        g = () => traverse(U())
    }
    let A,
        B = (U) => {
            A = G.onStop = () => {
                callWithErrorHandling(U, c, 4)
            }
        }
    if (isInSSRComponentSetup) return (B = NOOP), e ? n && callWithAsyncErrorHandling(e, c, 3, [g(), _ ? [] : void 0, B]) : g(), NOOP
    let D = _ ? [] : INITIAL_WATCHER_VALUE
    const I = () => {
        if (!!G.active)
            if (e) {
                const U = G.run()
                ;(i || v || (_ ? U.some((F, Z) => hasChanged(F, D[Z])) : hasChanged(U, D))) &&
                    (A && A(), callWithAsyncErrorHandling(e, c, 3, [U, D === INITIAL_WATCHER_VALUE ? void 0 : D, B]), (D = U))
            } else G.run()
    }
    I.allowRecurse = !!e
    let L
    o === "sync"
        ? (L = I)
        : o === "post"
        ? (L = () => queuePostRenderEffect(I, c && c.suspense))
        : ((I.pre = !0), c && (I.id = c.uid), (L = () => queueJob(I)))
    const G = new ReactiveEffect(g, L)
    return (
        e ? (n ? I() : (D = G.run())) : o === "post" ? queuePostRenderEffect(G.run.bind(G), c && c.suspense) : G.run(),
        () => {
            G.stop(), c && c.scope && remove(c.scope.effects, G)
        }
    )
}
function instanceWatch(t, e, n) {
    const i = this.proxy,
        o = isString(t) ? (t.includes(".") ? createPathGetter(i, t) : () => i[t]) : t.bind(i, i)
    let a
    isFunction(e) ? (a = e) : ((a = e.handler), (n = e))
    const l = currentInstance
    setCurrentInstance(this)
    const c = doWatch(o, a.bind(i), n)
    return l ? setCurrentInstance(l) : unsetCurrentInstance(), c
}
function createPathGetter(t, e) {
    const n = e.split(".")
    return () => {
        let i = t
        for (let o = 0; o < n.length && i; o++) i = i[n[o]]
        return i
    }
}
function traverse(t, e) {
    if (!isObject(t) || t.__v_skip || ((e = e || new Set()), e.has(t))) return t
    if ((e.add(t), isRef(t))) traverse(t.value, e)
    else if (isArray$1(t)) for (let n = 0; n < t.length; n++) traverse(t[n], e)
    else if (isSet(t) || isMap(t))
        t.forEach((n) => {
            traverse(n, e)
        })
    else if (isPlainObject(t)) for (const n in t) traverse(t[n], e)
    return t
}
function useTransitionState() {
    const t = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
    return (
        onMounted(() => {
            t.isMounted = !0
        }),
        onBeforeUnmount(() => {
            t.isUnmounting = !0
        }),
        t
    )
}
const TransitionHookValidator = [Function, Array],
    BaseTransitionImpl = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: TransitionHookValidator,
            onEnter: TransitionHookValidator,
            onAfterEnter: TransitionHookValidator,
            onEnterCancelled: TransitionHookValidator,
            onBeforeLeave: TransitionHookValidator,
            onLeave: TransitionHookValidator,
            onAfterLeave: TransitionHookValidator,
            onLeaveCancelled: TransitionHookValidator,
            onBeforeAppear: TransitionHookValidator,
            onAppear: TransitionHookValidator,
            onAfterAppear: TransitionHookValidator,
            onAppearCancelled: TransitionHookValidator,
        },
        setup(t, { slots: e }) {
            const n = getCurrentInstance(),
                i = useTransitionState()
            let o
            return () => {
                const a = e.default && getTransitionRawChildren(e.default(), !0)
                if (!a || !a.length) return
                let l = a[0]
                if (a.length > 1) {
                    for (const L of a)
                        if (L.type !== Comment) {
                            l = L
                            break
                        }
                }
                const c = toRaw(t),
                    { mode: g } = c
                if (i.isLeaving) return emptyPlaceholder(l)
                const v = getKeepAliveChild(l)
                if (!v) return emptyPlaceholder(l)
                const _ = resolveTransitionHooks(v, c, i, n)
                setTransitionHooks(v, _)
                const A = n.subTree,
                    B = A && getKeepAliveChild(A)
                let D = !1
                const { getTransitionKey: I } = v.type
                if (I) {
                    const L = I()
                    o === void 0 ? (o = L) : L !== o && ((o = L), (D = !0))
                }
                if (B && B.type !== Comment && (!isSameVNodeType(v, B) || D)) {
                    const L = resolveTransitionHooks(B, c, i, n)
                    if ((setTransitionHooks(B, L), g === "out-in"))
                        return (
                            (i.isLeaving = !0),
                            (L.afterLeave = () => {
                                ;(i.isLeaving = !1), n.update()
                            }),
                            emptyPlaceholder(l)
                        )
                    g === "in-out" &&
                        v.type !== Comment &&
                        (L.delayLeave = (G, U, F) => {
                            const Z = getLeavingNodesForType(i, B)
                            ;(Z[String(B.key)] = B),
                                (G._leaveCb = () => {
                                    U(), (G._leaveCb = void 0), delete _.delayedLeave
                                }),
                                (_.delayedLeave = F)
                        })
                }
                return l
            }
        },
    },
    BaseTransition = BaseTransitionImpl
function getLeavingNodesForType(t, e) {
    const { leavingVNodes: n } = t
    let i = n.get(e.type)
    return i || ((i = Object.create(null)), n.set(e.type, i)), i
}
function resolveTransitionHooks(t, e, n, i) {
    const {
            appear: o,
            mode: a,
            persisted: l = !1,
            onBeforeEnter: c,
            onEnter: g,
            onAfterEnter: v,
            onEnterCancelled: _,
            onBeforeLeave: A,
            onLeave: B,
            onAfterLeave: D,
            onLeaveCancelled: I,
            onBeforeAppear: L,
            onAppear: G,
            onAfterAppear: U,
            onAppearCancelled: F,
        } = e,
        Z = String(t.key),
        Y = getLeavingNodesForType(n, t),
        X = (oe, le) => {
            oe && callWithAsyncErrorHandling(oe, i, 9, le)
        },
        ie = (oe, le) => {
            const Te = le[1]
            X(oe, le), isArray$1(oe) ? oe.every((ye) => ye.length <= 1) && Te() : oe.length <= 1 && Te()
        },
        he = {
            mode: a,
            persisted: l,
            beforeEnter(oe) {
                let le = c
                if (!n.isMounted)
                    if (o) le = L || c
                    else return
                oe._leaveCb && oe._leaveCb(!0)
                const Te = Y[Z]
                Te && isSameVNodeType(t, Te) && Te.el._leaveCb && Te.el._leaveCb(), X(le, [oe])
            },
            enter(oe) {
                let le = g,
                    Te = v,
                    ye = _
                if (!n.isMounted)
                    if (o) (le = G || g), (Te = U || v), (ye = F || _)
                    else return
                let Ae = !1
                const O = (oe._enterCb = (u) => {
                    Ae || ((Ae = !0), u ? X(ye, [oe]) : X(Te, [oe]), he.delayedLeave && he.delayedLeave(), (oe._enterCb = void 0))
                })
                le ? ie(le, [oe, O]) : O()
            },
            leave(oe, le) {
                const Te = String(t.key)
                if ((oe._enterCb && oe._enterCb(!0), n.isUnmounting)) return le()
                X(A, [oe])
                let ye = !1
                const Ae = (oe._leaveCb = (O) => {
                    ye || ((ye = !0), le(), O ? X(I, [oe]) : X(D, [oe]), (oe._leaveCb = void 0), Y[Te] === t && delete Y[Te])
                })
                ;(Y[Te] = t), B ? ie(B, [oe, Ae]) : Ae()
            },
            clone(oe) {
                return resolveTransitionHooks(oe, e, n, i)
            },
        }
    return he
}
function emptyPlaceholder(t) {
    if (isKeepAlive(t)) return (t = cloneVNode(t)), (t.children = null), t
}
function getKeepAliveChild(t) {
    return isKeepAlive(t) ? (t.children ? t.children[0] : void 0) : t
}
function setTransitionHooks(t, e) {
    t.shapeFlag & 6 && t.component
        ? setTransitionHooks(t.component.subTree, e)
        : t.shapeFlag & 128
        ? ((t.ssContent.transition = e.clone(t.ssContent)), (t.ssFallback.transition = e.clone(t.ssFallback)))
        : (t.transition = e)
}
function getTransitionRawChildren(t, e = !1, n) {
    let i = [],
        o = 0
    for (let a = 0; a < t.length; a++) {
        let l = t[a]
        const c = n == null ? l.key : String(n) + String(l.key != null ? l.key : a)
        l.type === Fragment$1
            ? (l.patchFlag & 128 && o++, (i = i.concat(getTransitionRawChildren(l.children, e, c))))
            : (e || l.type !== Comment) && i.push(c != null ? cloneVNode(l, { key: c }) : l)
    }
    if (o > 1) for (let a = 0; a < i.length; a++) i[a].patchFlag = -2
    return i
}
function defineComponent(t) {
    return isFunction(t) ? { setup: t, name: t.name } : t
}
const isAsyncWrapper = (t) => !!t.type.__asyncLoader
function defineAsyncComponent(t) {
    isFunction(t) && (t = { loader: t })
    const { loader: e, loadingComponent: n, errorComponent: i, delay: o = 200, timeout: a, suspensible: l = !0, onError: c } = t
    let g = null,
        v,
        _ = 0
    const A = () => (_++, (g = null), B()),
        B = () => {
            let D
            return (
                g ||
                (D = g =
                    e()
                        .catch((I) => {
                            if (((I = I instanceof Error ? I : new Error(String(I))), c))
                                return new Promise((L, G) => {
                                    c(
                                        I,
                                        () => L(A()),
                                        () => G(I),
                                        _ + 1
                                    )
                                })
                            throw I
                        })
                        .then((I) =>
                            D !== g && g ? g : (I && (I.__esModule || I[Symbol.toStringTag] === "Module") && (I = I.default), (v = I), I)
                        ))
            )
        }
    return defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: B,
        get __asyncResolved() {
            return v
        },
        setup() {
            const D = currentInstance
            if (v) return () => createInnerComp(v, D)
            const I = (F) => {
                ;(g = null), handleError(F, D, 13, !i)
            }
            if ((l && D.suspense) || isInSSRComponentSetup)
                return B()
                    .then((F) => () => createInnerComp(F, D))
                    .catch((F) => (I(F), () => (i ? createVNode(i, { error: F }) : null)))
            const L = ref(!1),
                G = ref(),
                U = ref(!!o)
            return (
                o &&
                    setTimeout(() => {
                        U.value = !1
                    }, o),
                a != null &&
                    setTimeout(() => {
                        if (!L.value && !G.value) {
                            const F = new Error(`Async component timed out after ${a}ms.`)
                            I(F), (G.value = F)
                        }
                    }, a),
                B()
                    .then(() => {
                        ;(L.value = !0), D.parent && isKeepAlive(D.parent.vnode) && queueJob(D.parent.update)
                    })
                    .catch((F) => {
                        I(F), (G.value = F)
                    }),
                () => {
                    if (L.value && v) return createInnerComp(v, D)
                    if (G.value && i) return createVNode(i, { error: G.value })
                    if (n && !U.value) return createVNode(n)
                }
            )
        },
    })
}
function createInnerComp(t, { vnode: { ref: e, props: n, children: i, shapeFlag: o }, parent: a }) {
    const l = createVNode(t, n, i)
    return (l.ref = e), l
}
const isKeepAlive = (t) => t.type.__isKeepAlive,
    KeepAliveImpl = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] },
        setup(t, { slots: e }) {
            const n = getCurrentInstance(),
                i = n.ctx
            if (!i.renderer)
                return () => {
                    const F = e.default && e.default()
                    return F && F.length === 1 ? F[0] : F
                }
            const o = new Map(),
                a = new Set()
            let l = null
            const c = n.suspense,
                {
                    renderer: {
                        p: g,
                        m: v,
                        um: _,
                        o: { createElement: A },
                    },
                } = i,
                B = A("div")
            ;(i.activate = (F, Z, Y, X, ie) => {
                const he = F.component
                v(F, Z, Y, 0, c),
                    g(he.vnode, F, Z, Y, he, c, X, F.slotScopeIds, ie),
                    queuePostRenderEffect(() => {
                        ;(he.isDeactivated = !1), he.a && invokeArrayFns(he.a)
                        const oe = F.props && F.props.onVnodeMounted
                        oe && invokeVNodeHook(oe, he.parent, F)
                    }, c)
            }),
                (i.deactivate = (F) => {
                    const Z = F.component
                    v(F, B, null, 1, c),
                        queuePostRenderEffect(() => {
                            Z.da && invokeArrayFns(Z.da)
                            const Y = F.props && F.props.onVnodeUnmounted
                            Y && invokeVNodeHook(Y, Z.parent, F), (Z.isDeactivated = !0)
                        }, c)
                })
            function D(F) {
                resetShapeFlag(F), _(F, n, c, !0)
            }
            function I(F) {
                o.forEach((Z, Y) => {
                    const X = getComponentName(Z.type)
                    X && (!F || !F(X)) && L(Y)
                })
            }
            function L(F) {
                const Z = o.get(F)
                !l || Z.type !== l.type ? D(Z) : l && resetShapeFlag(l), o.delete(F), a.delete(F)
            }
            watch(
                () => [t.include, t.exclude],
                ([F, Z]) => {
                    F && I((Y) => matches(F, Y)), Z && I((Y) => !matches(Z, Y))
                },
                { flush: "post", deep: !0 }
            )
            let G = null
            const U = () => {
                G != null && o.set(G, getInnerChild(n.subTree))
            }
            return (
                onMounted(U),
                onUpdated(U),
                onBeforeUnmount(() => {
                    o.forEach((F) => {
                        const { subTree: Z, suspense: Y } = n,
                            X = getInnerChild(Z)
                        if (F.type === X.type) {
                            resetShapeFlag(X)
                            const ie = X.component.da
                            ie && queuePostRenderEffect(ie, Y)
                            return
                        }
                        D(F)
                    })
                }),
                () => {
                    if (((G = null), !e.default)) return null
                    const F = e.default(),
                        Z = F[0]
                    if (F.length > 1) return (l = null), F
                    if (!isVNode(Z) || (!(Z.shapeFlag & 4) && !(Z.shapeFlag & 128))) return (l = null), Z
                    let Y = getInnerChild(Z)
                    const X = Y.type,
                        ie = getComponentName(isAsyncWrapper(Y) ? Y.type.__asyncResolved || {} : X),
                        { include: he, exclude: oe, max: le } = t
                    if ((he && (!ie || !matches(he, ie))) || (oe && ie && matches(oe, ie))) return (l = Y), Z
                    const Te = Y.key == null ? X : Y.key,
                        ye = o.get(Te)
                    return (
                        Y.el && ((Y = cloneVNode(Y)), Z.shapeFlag & 128 && (Z.ssContent = Y)),
                        (G = Te),
                        ye
                            ? ((Y.el = ye.el),
                              (Y.component = ye.component),
                              Y.transition && setTransitionHooks(Y, Y.transition),
                              (Y.shapeFlag |= 512),
                              a.delete(Te),
                              a.add(Te))
                            : (a.add(Te), le && a.size > parseInt(le, 10) && L(a.values().next().value)),
                        (Y.shapeFlag |= 256),
                        (l = Y),
                        isSuspense(Z.type) ? Z : Y
                    )
                }
            )
        },
    },
    KeepAlive = KeepAliveImpl
function matches(t, e) {
    return isArray$1(t) ? t.some((n) => matches(n, e)) : isString(t) ? t.split(",").includes(e) : t.test ? t.test(e) : !1
}
function onActivated(t, e) {
    registerKeepAliveHook(t, "a", e)
}
function onDeactivated(t, e) {
    registerKeepAliveHook(t, "da", e)
}
function registerKeepAliveHook(t, e, n = currentInstance) {
    const i =
        t.__wdc ||
        (t.__wdc = () => {
            let o = n
            for (; o; ) {
                if (o.isDeactivated) return
                o = o.parent
            }
            return t()
        })
    if ((injectHook(e, i, n), n)) {
        let o = n.parent
        for (; o && o.parent; ) isKeepAlive(o.parent.vnode) && injectToKeepAliveRoot(i, e, n, o), (o = o.parent)
    }
}
function injectToKeepAliveRoot(t, e, n, i) {
    const o = injectHook(e, t, i, !0)
    onUnmounted(() => {
        remove(i[e], o)
    }, n)
}
function resetShapeFlag(t) {
    let e = t.shapeFlag
    e & 256 && (e -= 256), e & 512 && (e -= 512), (t.shapeFlag = e)
}
function getInnerChild(t) {
    return t.shapeFlag & 128 ? t.ssContent : t
}
function injectHook(t, e, n = currentInstance, i = !1) {
    if (n) {
        const o = n[t] || (n[t] = []),
            a =
                e.__weh ||
                (e.__weh = (...l) => {
                    if (n.isUnmounted) return
                    pauseTracking(), setCurrentInstance(n)
                    const c = callWithAsyncErrorHandling(e, n, t, l)
                    return unsetCurrentInstance(), resetTracking(), c
                })
        return i ? o.unshift(a) : o.push(a), a
    }
}
const createHook =
        (t) =>
        (e, n = currentInstance) =>
            (!isInSSRComponentSetup || t === "sp") && injectHook(t, e, n),
    onBeforeMount = createHook("bm"),
    onMounted = createHook("m"),
    onBeforeUpdate = createHook("bu"),
    onUpdated = createHook("u"),
    onBeforeUnmount = createHook("bum"),
    onUnmounted = createHook("um"),
    onServerPrefetch = createHook("sp"),
    onRenderTriggered = createHook("rtg"),
    onRenderTracked = createHook("rtc")
function onErrorCaptured(t, e = currentInstance) {
    injectHook("ec", t, e)
}
function withDirectives(t, e) {
    const n = currentRenderingInstance
    if (n === null) return t
    const i = getExposeProxy(n) || n.proxy,
        o = t.dirs || (t.dirs = [])
    for (let a = 0; a < e.length; a++) {
        let [l, c, g, v = EMPTY_OBJ] = e[a]
        isFunction(l) && (l = { mounted: l, updated: l }),
            l.deep && traverse(c),
            o.push({ dir: l, instance: i, value: c, oldValue: void 0, arg: g, modifiers: v })
    }
    return t
}
function invokeDirectiveHook(t, e, n, i) {
    const o = t.dirs,
        a = e && e.dirs
    for (let l = 0; l < o.length; l++) {
        const c = o[l]
        a && (c.oldValue = a[l].value)
        let g = c.dir[i]
        g && (pauseTracking(), callWithAsyncErrorHandling(g, n, 8, [t.el, c, t, e]), resetTracking())
    }
}
const COMPONENTS = "components",
    DIRECTIVES = "directives"
function resolveComponent(t, e) {
    return resolveAsset(COMPONENTS, t, !0, e) || t
}
const NULL_DYNAMIC_COMPONENT = Symbol()
function resolveDynamicComponent(t) {
    return isString(t) ? resolveAsset(COMPONENTS, t, !1) || t : t || NULL_DYNAMIC_COMPONENT
}
function resolveDirective(t) {
    return resolveAsset(DIRECTIVES, t)
}
function resolveAsset(t, e, n = !0, i = !1) {
    const o = currentRenderingInstance || currentInstance
    if (o) {
        const a = o.type
        if (t === COMPONENTS) {
            const c = getComponentName(a, !1)
            if (c && (c === e || c === camelize(e) || c === capitalize(camelize(e)))) return a
        }
        const l = resolve$1(o[t] || a[t], e) || resolve$1(o.appContext[t], e)
        return !l && i ? a : l
    }
}
function resolve$1(t, e) {
    return t && (t[e] || t[camelize(e)] || t[capitalize(camelize(e))])
}
function renderList(t, e, n, i) {
    let o
    const a = n && n[i]
    if (isArray$1(t) || isString(t)) {
        o = new Array(t.length)
        for (let l = 0, c = t.length; l < c; l++) o[l] = e(t[l], l, void 0, a && a[l])
    } else if (typeof t == "number") {
        o = new Array(t)
        for (let l = 0; l < t; l++) o[l] = e(l + 1, l, void 0, a && a[l])
    } else if (isObject(t))
        if (t[Symbol.iterator]) o = Array.from(t, (l, c) => e(l, c, void 0, a && a[c]))
        else {
            const l = Object.keys(t)
            o = new Array(l.length)
            for (let c = 0, g = l.length; c < g; c++) {
                const v = l[c]
                o[c] = e(t[v], v, c, a && a[c])
            }
        }
    else o = []
    return n && (n[i] = o), o
}
function createSlots(t, e) {
    for (let n = 0; n < e.length; n++) {
        const i = e[n]
        if (isArray$1(i)) for (let o = 0; o < i.length; o++) t[i[o].name] = i[o].fn
        else
            i &&
                (t[i.name] = i.key
                    ? (...o) => {
                          const a = i.fn(...o)
                          return (a.key = i.key), a
                      }
                    : i.fn)
    }
    return t
}
function renderSlot(t, e, n = {}, i, o) {
    if (
        currentRenderingInstance.isCE ||
        (currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE)
    )
        return createVNode("slot", e === "default" ? null : { name: e }, i && i())
    let a = t[e]
    a && a._c && (a._d = !1), openBlock()
    const l = a && ensureValidVNode(a(n)),
        c = createBlock$1(Fragment$1, { key: n.key || (l && l.key) || `_${e}` }, l || (i ? i() : []), l && t._ === 1 ? 64 : -2)
    return !o && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), a && a._c && (a._d = !0), c
}
function ensureValidVNode(t) {
    return t.some((e) => (isVNode(e) ? !(e.type === Comment || (e.type === Fragment$1 && !ensureValidVNode(e.children))) : !0)) ? t : null
}
function toHandlers(t, e) {
    const n = {}
    for (const i in t) n[e && /[A-Z]/.test(i) ? `on:${i}` : toHandlerKey(i)] = t[i]
    return n
}
const getPublicInstance = (t) => (t ? (isStatefulComponent(t) ? getExposeProxy(t) || t.proxy : getPublicInstance(t.parent)) : null),
    publicPropertiesMap = extend(Object.create(null), {
        $: (t) => t,
        $el: (t) => t.vnode.el,
        $data: (t) => t.data,
        $props: (t) => t.props,
        $attrs: (t) => t.attrs,
        $slots: (t) => t.slots,
        $refs: (t) => t.refs,
        $parent: (t) => getPublicInstance(t.parent),
        $root: (t) => getPublicInstance(t.root),
        $emit: (t) => t.emit,
        $options: (t) => resolveMergedOptions(t),
        $forceUpdate: (t) => t.f || (t.f = () => queueJob(t.update)),
        $nextTick: (t) => t.n || (t.n = nextTick.bind(t.proxy)),
        $watch: (t) => instanceWatch.bind(t),
    }),
    PublicInstanceProxyHandlers = {
        get({ _: t }, e) {
            const { ctx: n, setupState: i, data: o, props: a, accessCache: l, type: c, appContext: g } = t
            let v
            if (e[0] !== "$") {
                const D = l[e]
                if (D !== void 0)
                    switch (D) {
                        case 1:
                            return i[e]
                        case 2:
                            return o[e]
                        case 4:
                            return n[e]
                        case 3:
                            return a[e]
                    }
                else {
                    if (i !== EMPTY_OBJ && hasOwn(i, e)) return (l[e] = 1), i[e]
                    if (o !== EMPTY_OBJ && hasOwn(o, e)) return (l[e] = 2), o[e]
                    if ((v = t.propsOptions[0]) && hasOwn(v, e)) return (l[e] = 3), a[e]
                    if (n !== EMPTY_OBJ && hasOwn(n, e)) return (l[e] = 4), n[e]
                    shouldCacheAccess && (l[e] = 0)
                }
            }
            const _ = publicPropertiesMap[e]
            let A, B
            if (_) return e === "$attrs" && track(t, "get", e), _(t)
            if ((A = c.__cssModules) && (A = A[e])) return A
            if (n !== EMPTY_OBJ && hasOwn(n, e)) return (l[e] = 4), n[e]
            if (((B = g.config.globalProperties), hasOwn(B, e))) return B[e]
        },
        set({ _: t }, e, n) {
            const { data: i, setupState: o, ctx: a } = t
            return o !== EMPTY_OBJ && hasOwn(o, e)
                ? ((o[e] = n), !0)
                : i !== EMPTY_OBJ && hasOwn(i, e)
                ? ((i[e] = n), !0)
                : hasOwn(t.props, e) || (e[0] === "$" && e.slice(1) in t)
                ? !1
                : ((a[e] = n), !0)
        },
        has({ _: { data: t, setupState: e, accessCache: n, ctx: i, appContext: o, propsOptions: a } }, l) {
            let c
            return (
                !!n[l] ||
                (t !== EMPTY_OBJ && hasOwn(t, l)) ||
                (e !== EMPTY_OBJ && hasOwn(e, l)) ||
                ((c = a[0]) && hasOwn(c, l)) ||
                hasOwn(i, l) ||
                hasOwn(publicPropertiesMap, l) ||
                hasOwn(o.config.globalProperties, l)
            )
        },
        defineProperty(t, e, n) {
            return (
                n.get != null ? (t._.accessCache[e] = 0) : hasOwn(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
            )
        },
    },
    RuntimeCompiledPublicInstanceProxyHandlers = extend({}, PublicInstanceProxyHandlers, {
        get(t, e) {
            if (e !== Symbol.unscopables) return PublicInstanceProxyHandlers.get(t, e, t)
        },
        has(t, e) {
            return e[0] !== "_" && !isGloballyWhitelisted(e)
        },
    })
let shouldCacheAccess = !0
function applyOptions(t) {
    const e = resolveMergedOptions(t),
        n = t.proxy,
        i = t.ctx
    ;(shouldCacheAccess = !1), e.beforeCreate && callHook$1(e.beforeCreate, t, "bc")
    const {
        data: o,
        computed: a,
        methods: l,
        watch: c,
        provide: g,
        inject: v,
        created: _,
        beforeMount: A,
        mounted: B,
        beforeUpdate: D,
        updated: I,
        activated: L,
        deactivated: G,
        beforeDestroy: U,
        beforeUnmount: F,
        destroyed: Z,
        unmounted: Y,
        render: X,
        renderTracked: ie,
        renderTriggered: he,
        errorCaptured: oe,
        serverPrefetch: le,
        expose: Te,
        inheritAttrs: ye,
        components: Ae,
        directives: O,
        filters: u,
    } = e
    if ((v && resolveInjections(v, i, null, t.appContext.config.unwrapInjectedRef), l))
        for (const N in l) {
            const M = l[N]
            isFunction(M) && (i[N] = M.bind(n))
        }
    if (o) {
        const N = o.call(n, n)
        isObject(N) && (t.data = reactive(N))
    }
    if (((shouldCacheAccess = !0), a))
        for (const N in a) {
            const M = a[N],
                R = isFunction(M) ? M.bind(n, n) : isFunction(M.get) ? M.get.bind(n, n) : NOOP,
                C = !isFunction(M) && isFunction(M.set) ? M.set.bind(n) : NOOP,
                S = computed({ get: R, set: C })
            Object.defineProperty(i, N, { enumerable: !0, configurable: !0, get: () => S.value, set: (b) => (S.value = b) })
        }
    if (c) for (const N in c) createWatcher(c[N], i, n, N)
    if (g) {
        const N = isFunction(g) ? g.call(n) : g
        Reflect.ownKeys(N).forEach((M) => {
            provide(M, N[M])
        })
    }
    _ && callHook$1(_, t, "c")
    function $(N, M) {
        isArray$1(M) ? M.forEach((R) => N(R.bind(n))) : M && N(M.bind(n))
    }
    if (
        ($(onBeforeMount, A),
        $(onMounted, B),
        $(onBeforeUpdate, D),
        $(onUpdated, I),
        $(onActivated, L),
        $(onDeactivated, G),
        $(onErrorCaptured, oe),
        $(onRenderTracked, ie),
        $(onRenderTriggered, he),
        $(onBeforeUnmount, F),
        $(onUnmounted, Y),
        $(onServerPrefetch, le),
        isArray$1(Te))
    )
        if (Te.length) {
            const N = t.exposed || (t.exposed = {})
            Te.forEach((M) => {
                Object.defineProperty(N, M, { get: () => n[M], set: (R) => (n[M] = R) })
            })
        } else t.exposed || (t.exposed = {})
    X && t.render === NOOP && (t.render = X), ye != null && (t.inheritAttrs = ye), Ae && (t.components = Ae), O && (t.directives = O)
}
function resolveInjections(t, e, n = NOOP, i = !1) {
    isArray$1(t) && (t = normalizeInject(t))
    for (const o in t) {
        const a = t[o]
        let l
        isObject(a) ? ("default" in a ? (l = inject(a.from || o, a.default, !0)) : (l = inject(a.from || o))) : (l = inject(a)),
            isRef(l) && i
                ? Object.defineProperty(e, o, { enumerable: !0, configurable: !0, get: () => l.value, set: (c) => (l.value = c) })
                : (e[o] = l)
    }
}
function callHook$1(t, e, n) {
    callWithAsyncErrorHandling(isArray$1(t) ? t.map((i) => i.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function createWatcher(t, e, n, i) {
    const o = i.includes(".") ? createPathGetter(n, i) : () => n[i]
    if (isString(t)) {
        const a = e[t]
        isFunction(a) && watch(o, a)
    } else if (isFunction(t)) watch(o, t.bind(n))
    else if (isObject(t))
        if (isArray$1(t)) t.forEach((a) => createWatcher(a, e, n, i))
        else {
            const a = isFunction(t.handler) ? t.handler.bind(n) : e[t.handler]
            isFunction(a) && watch(o, a, t)
        }
}
function resolveMergedOptions(t) {
    const e = t.type,
        { mixins: n, extends: i } = e,
        {
            mixins: o,
            optionsCache: a,
            config: { optionMergeStrategies: l },
        } = t.appContext,
        c = a.get(e)
    let g
    return (
        c
            ? (g = c)
            : !o.length && !n && !i
            ? (g = e)
            : ((g = {}), o.length && o.forEach((v) => mergeOptions$2(g, v, l, !0)), mergeOptions$2(g, e, l)),
        isObject(e) && a.set(e, g),
        g
    )
}
function mergeOptions$2(t, e, n, i = !1) {
    const { mixins: o, extends: a } = e
    a && mergeOptions$2(t, a, n, !0), o && o.forEach((l) => mergeOptions$2(t, l, n, !0))
    for (const l in e)
        if (!(i && l === "expose")) {
            const c = internalOptionMergeStrats[l] || (n && n[l])
            t[l] = c ? c(t[l], e[l]) : e[l]
        }
    return t
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject,
}
function mergeDataFn(t, e) {
    return e
        ? t
            ? function () {
                  return extend(isFunction(t) ? t.call(this, this) : t, isFunction(e) ? e.call(this, this) : e)
              }
            : e
        : t
}
function mergeInject(t, e) {
    return mergeObjectOptions(normalizeInject(t), normalizeInject(e))
}
function normalizeInject(t) {
    if (isArray$1(t)) {
        const e = {}
        for (let n = 0; n < t.length; n++) e[t[n]] = t[n]
        return e
    }
    return t
}
function mergeAsArray(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}
function mergeObjectOptions(t, e) {
    return t ? extend(extend(Object.create(null), t), e) : e
}
function mergeWatchOptions(t, e) {
    if (!t) return e
    if (!e) return t
    const n = extend(Object.create(null), t)
    for (const i in e) n[i] = mergeAsArray(t[i], e[i])
    return n
}
function initProps(t, e, n, i = !1) {
    const o = {},
        a = {}
    def(a, InternalObjectKey, 1), (t.propsDefaults = Object.create(null)), setFullProps(t, e, o, a)
    for (const l in t.propsOptions[0]) l in o || (o[l] = void 0)
    n ? (t.props = i ? o : shallowReactive(o)) : t.type.props ? (t.props = o) : (t.props = a), (t.attrs = a)
}
function updateProps(t, e, n, i) {
    const {
            props: o,
            attrs: a,
            vnode: { patchFlag: l },
        } = t,
        c = toRaw(o),
        [g] = t.propsOptions
    let v = !1
    if ((i || l > 0) && !(l & 16)) {
        if (l & 8) {
            const _ = t.vnode.dynamicProps
            for (let A = 0; A < _.length; A++) {
                let B = _[A]
                if (isEmitListener(t.emitsOptions, B)) continue
                const D = e[B]
                if (g)
                    if (hasOwn(a, B)) D !== a[B] && ((a[B] = D), (v = !0))
                    else {
                        const I = camelize(B)
                        o[I] = resolvePropValue(g, c, I, D, t, !1)
                    }
                else D !== a[B] && ((a[B] = D), (v = !0))
            }
        }
    } else {
        setFullProps(t, e, o, a) && (v = !0)
        let _
        for (const A in c)
            (!e || (!hasOwn(e, A) && ((_ = hyphenate(A)) === A || !hasOwn(e, _)))) &&
                (g ? n && (n[A] !== void 0 || n[_] !== void 0) && (o[A] = resolvePropValue(g, c, A, void 0, t, !0)) : delete o[A])
        if (a !== c) for (const A in a) (!e || (!hasOwn(e, A) && !0)) && (delete a[A], (v = !0))
    }
    v && trigger(t, "set", "$attrs")
}
function setFullProps(t, e, n, i) {
    const [o, a] = t.propsOptions
    let l = !1,
        c
    if (e)
        for (let g in e) {
            if (isReservedProp(g)) continue
            const v = e[g]
            let _
            o && hasOwn(o, (_ = camelize(g)))
                ? !a || !a.includes(_)
                    ? (n[_] = v)
                    : ((c || (c = {}))[_] = v)
                : isEmitListener(t.emitsOptions, g) || ((!(g in i) || v !== i[g]) && ((i[g] = v), (l = !0)))
        }
    if (a) {
        const g = toRaw(n),
            v = c || EMPTY_OBJ
        for (let _ = 0; _ < a.length; _++) {
            const A = a[_]
            n[A] = resolvePropValue(o, g, A, v[A], t, !hasOwn(v, A))
        }
    }
    return l
}
function resolvePropValue(t, e, n, i, o, a) {
    const l = t[n]
    if (l != null) {
        const c = hasOwn(l, "default")
        if (c && i === void 0) {
            const g = l.default
            if (l.type !== Function && isFunction(g)) {
                const { propsDefaults: v } = o
                n in v ? (i = v[n]) : (setCurrentInstance(o), (i = v[n] = g.call(null, e)), unsetCurrentInstance())
            } else i = g
        }
        l[0] && (a && !c ? (i = !1) : l[1] && (i === "" || i === hyphenate(n)) && (i = !0))
    }
    return i
}
function normalizePropsOptions(t, e, n = !1) {
    const i = e.propsCache,
        o = i.get(t)
    if (o) return o
    const a = t.props,
        l = {},
        c = []
    let g = !1
    if (!isFunction(t)) {
        const _ = (A) => {
            g = !0
            const [B, D] = normalizePropsOptions(A, e, !0)
            extend(l, B), D && c.push(...D)
        }
        !n && e.mixins.length && e.mixins.forEach(_), t.extends && _(t.extends), t.mixins && t.mixins.forEach(_)
    }
    if (!a && !g) return isObject(t) && i.set(t, EMPTY_ARR), EMPTY_ARR
    if (isArray$1(a))
        for (let _ = 0; _ < a.length; _++) {
            const A = camelize(a[_])
            validatePropName(A) && (l[A] = EMPTY_OBJ)
        }
    else if (a)
        for (const _ in a) {
            const A = camelize(_)
            if (validatePropName(A)) {
                const B = a[_],
                    D = (l[A] = isArray$1(B) || isFunction(B) ? { type: B } : B)
                if (D) {
                    const I = getTypeIndex(Boolean, D.type),
                        L = getTypeIndex(String, D.type)
                    ;(D[0] = I > -1), (D[1] = L < 0 || I < L), (I > -1 || hasOwn(D, "default")) && c.push(A)
                }
            }
        }
    const v = [l, c]
    return isObject(t) && i.set(t, v), v
}
function validatePropName(t) {
    return t[0] !== "$"
}
function getType(t) {
    const e = t && t.toString().match(/^\s*function (\w+)/)
    return e ? e[1] : t === null ? "null" : ""
}
function isSameType(t, e) {
    return getType(t) === getType(e)
}
function getTypeIndex(t, e) {
    return isArray$1(e) ? e.findIndex((n) => isSameType(n, t)) : isFunction(e) && isSameType(e, t) ? 0 : -1
}
const isInternalKey = (t) => t[0] === "_" || t === "$stable",
    normalizeSlotValue = (t) => (isArray$1(t) ? t.map(normalizeVNode) : [normalizeVNode(t)]),
    normalizeSlot$1 = (t, e, n) => {
        if (e._n) return e
        const i = withCtx((...o) => normalizeSlotValue(e(...o)), n)
        return (i._c = !1), i
    },
    normalizeObjectSlots = (t, e, n) => {
        const i = t._ctx
        for (const o in t) {
            if (isInternalKey(o)) continue
            const a = t[o]
            if (isFunction(a)) e[o] = normalizeSlot$1(o, a, i)
            else if (a != null) {
                const l = normalizeSlotValue(a)
                e[o] = () => l
            }
        }
    },
    normalizeVNodeSlots = (t, e) => {
        const n = normalizeSlotValue(e)
        t.slots.default = () => n
    },
    initSlots = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const n = e._
            n ? ((t.slots = toRaw(e)), def(e, "_", n)) : normalizeObjectSlots(e, (t.slots = {}))
        } else (t.slots = {}), e && normalizeVNodeSlots(t, e)
        def(t.slots, InternalObjectKey, 1)
    },
    updateSlots = (t, e, n) => {
        const { vnode: i, slots: o } = t
        let a = !0,
            l = EMPTY_OBJ
        if (i.shapeFlag & 32) {
            const c = e._
            c ? (n && c === 1 ? (a = !1) : (extend(o, e), !n && c === 1 && delete o._)) : ((a = !e.$stable), normalizeObjectSlots(e, o)), (l = e)
        } else e && (normalizeVNodeSlots(t, e), (l = { default: 1 }))
        if (a) for (const c in o) !isInternalKey(c) && !(c in l) && delete o[c]
    }
function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: NO,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
    }
}
let uid = 0
function createAppAPI(t, e) {
    return function (i, o = null) {
        isFunction(i) || (i = Object.assign({}, i)), o != null && !isObject(o) && (o = null)
        const a = createAppContext(),
            l = new Set()
        let c = !1
        const g = (a.app = {
            _uid: uid++,
            _component: i,
            _props: o,
            _container: null,
            _context: a,
            _instance: null,
            version: version$k,
            get config() {
                return a.config
            },
            set config(v) {},
            use(v, ..._) {
                return l.has(v) || (v && isFunction(v.install) ? (l.add(v), v.install(g, ..._)) : isFunction(v) && (l.add(v), v(g, ..._))), g
            },
            mixin(v) {
                return a.mixins.includes(v) || a.mixins.push(v), g
            },
            component(v, _) {
                return _ ? ((a.components[v] = _), g) : a.components[v]
            },
            directive(v, _) {
                return _ ? ((a.directives[v] = _), g) : a.directives[v]
            },
            mount(v, _, A) {
                if (!c) {
                    const B = createVNode(i, o)
                    return (
                        (B.appContext = a),
                        _ && e ? e(B, v) : t(B, v, A),
                        (c = !0),
                        (g._container = v),
                        (v.__vue_app__ = g),
                        getExposeProxy(B.component) || B.component.proxy
                    )
                }
            },
            unmount() {
                c && (t(null, g._container), delete g._container.__vue_app__)
            },
            provide(v, _) {
                return (a.provides[v] = _), g
            },
        })
        return g
    }
}
function setRef(t, e, n, i, o = !1) {
    if (isArray$1(t)) {
        t.forEach((B, D) => setRef(B, e && (isArray$1(e) ? e[D] : e), n, i, o))
        return
    }
    if (isAsyncWrapper(i) && !o) return
    const a = i.shapeFlag & 4 ? getExposeProxy(i.component) || i.component.proxy : i.el,
        l = o ? null : a,
        { i: c, r: g } = t,
        v = e && e.r,
        _ = c.refs === EMPTY_OBJ ? (c.refs = {}) : c.refs,
        A = c.setupState
    if ((v != null && v !== g && (isString(v) ? ((_[v] = null), hasOwn(A, v) && (A[v] = null)) : isRef(v) && (v.value = null)), isFunction(g)))
        callWithErrorHandling(g, c, 12, [l, _])
    else {
        const B = isString(g),
            D = isRef(g)
        if (B || D) {
            const I = () => {
                if (t.f) {
                    const L = B ? _[g] : g.value
                    o
                        ? isArray$1(L) && remove(L, a)
                        : isArray$1(L)
                        ? L.includes(a) || L.push(a)
                        : B
                        ? ((_[g] = [a]), hasOwn(A, g) && (A[g] = _[g]))
                        : ((g.value = [a]), t.k && (_[t.k] = g.value))
                } else B ? ((_[g] = l), hasOwn(A, g) && (A[g] = l)) : D && ((g.value = l), t.k && (_[t.k] = l))
            }
            l ? ((I.id = -1), queuePostRenderEffect(I, n)) : I()
        }
    }
}
let hasMismatch = !1
const isSVGContainer = (t) => /svg/.test(t.namespaceURI) && t.tagName !== "foreignObject",
    isComment = (t) => t.nodeType === 8
function createHydrationFunctions(t) {
    const {
            mt: e,
            p: n,
            o: { patchProp: i, createText: o, nextSibling: a, parentNode: l, remove: c, insert: g, createComment: v },
        } = t,
        _ = (U, F) => {
            if (!F.hasChildNodes()) {
                n(null, U, F), flushPostFlushCbs(), (F._vnode = U)
                return
            }
            ;(hasMismatch = !1),
                A(F.firstChild, U, null, null, null),
                flushPostFlushCbs(),
                (F._vnode = U),
                hasMismatch && console.error("Hydration completed but contains mismatches.")
        },
        A = (U, F, Z, Y, X, ie = !1) => {
            const he = isComment(U) && U.data === "[",
                oe = () => L(U, F, Z, Y, X, he),
                { type: le, ref: Te, shapeFlag: ye, patchFlag: Ae } = F,
                O = U.nodeType
            ;(F.el = U), Ae === -2 && ((ie = !1), (F.dynamicChildren = null))
            let u = null
            switch (le) {
                case Text:
                    O !== 3
                        ? F.children === ""
                            ? (g((F.el = o("")), l(U), U), (u = U))
                            : (u = oe())
                        : (U.data !== F.children && ((hasMismatch = !0), (U.data = F.children)), (u = a(U)))
                    break
                case Comment:
                    O !== 8 || he ? (u = oe()) : (u = a(U))
                    break
                case Static:
                    if (O !== 1 && O !== 3) u = oe()
                    else {
                        u = U
                        const E = !F.children.length
                        for (let $ = 0; $ < F.staticCount; $++)
                            E && (F.children += u.nodeType === 1 ? u.outerHTML : u.data), $ === F.staticCount - 1 && (F.anchor = u), (u = a(u))
                        return u
                    }
                    break
                case Fragment$1:
                    he ? (u = I(U, F, Z, Y, X, ie)) : (u = oe())
                    break
                default:
                    if (ye & 1) O !== 1 || F.type.toLowerCase() !== U.tagName.toLowerCase() ? (u = oe()) : (u = B(U, F, Z, Y, X, ie))
                    else if (ye & 6) {
                        F.slotScopeIds = X
                        const E = l(U)
                        if (
                            (e(F, E, null, Z, Y, isSVGContainer(E), ie),
                            (u = he ? G(U) : a(U)),
                            u && isComment(u) && u.data === "teleport end" && (u = a(u)),
                            isAsyncWrapper(F))
                        ) {
                            let $
                            he
                                ? (($ = createVNode(Fragment$1)), ($.anchor = u ? u.previousSibling : E.lastChild))
                                : ($ = U.nodeType === 3 ? createTextVNode("") : createVNode("div")),
                                ($.el = U),
                                (F.component.subTree = $)
                        }
                    } else
                        ye & 64
                            ? O !== 8
                                ? (u = oe())
                                : (u = F.type.hydrate(U, F, Z, Y, X, ie, t, D))
                            : ye & 128 && (u = F.type.hydrate(U, F, Z, Y, isSVGContainer(l(U)), X, ie, t, A))
            }
            return Te != null && setRef(Te, null, Y, F), u
        },
        B = (U, F, Z, Y, X, ie) => {
            ie = ie || !!F.dynamicChildren
            const { type: he, props: oe, patchFlag: le, shapeFlag: Te, dirs: ye } = F,
                Ae = (he === "input" && ye) || he === "option"
            if (Ae || le !== -1) {
                if ((ye && invokeDirectiveHook(F, null, Z, "created"), oe))
                    if (Ae || !ie || le & 48)
                        for (const u in oe)
                            ((Ae && u.endsWith("value")) || (isOn(u) && !isReservedProp(u))) && i(U, u, null, oe[u], !1, void 0, Z)
                    else oe.onClick && i(U, "onClick", null, oe.onClick, !1, void 0, Z)
                let O
                if (
                    ((O = oe && oe.onVnodeBeforeMount) && invokeVNodeHook(O, Z, F),
                    ye && invokeDirectiveHook(F, null, Z, "beforeMount"),
                    ((O = oe && oe.onVnodeMounted) || ye) &&
                        queueEffectWithSuspense(() => {
                            O && invokeVNodeHook(O, Z, F), ye && invokeDirectiveHook(F, null, Z, "mounted")
                        }, Y),
                    Te & 16 && !(oe && (oe.innerHTML || oe.textContent)))
                ) {
                    let u = D(U.firstChild, F, U, Z, Y, X, ie)
                    for (; u; ) {
                        hasMismatch = !0
                        const E = u
                        ;(u = u.nextSibling), c(E)
                    }
                } else Te & 8 && U.textContent !== F.children && ((hasMismatch = !0), (U.textContent = F.children))
            }
            return U.nextSibling
        },
        D = (U, F, Z, Y, X, ie, he) => {
            he = he || !!F.dynamicChildren
            const oe = F.children,
                le = oe.length
            for (let Te = 0; Te < le; Te++) {
                const ye = he ? oe[Te] : (oe[Te] = normalizeVNode(oe[Te]))
                if (U) U = A(U, ye, Y, X, ie, he)
                else {
                    if (ye.type === Text && !ye.children) continue
                    ;(hasMismatch = !0), n(null, ye, Z, null, Y, X, isSVGContainer(Z), ie)
                }
            }
            return U
        },
        I = (U, F, Z, Y, X, ie) => {
            const { slotScopeIds: he } = F
            he && (X = X ? X.concat(he) : he)
            const oe = l(U),
                le = D(a(U), F, oe, Z, Y, X, ie)
            return le && isComment(le) && le.data === "]" ? a((F.anchor = le)) : ((hasMismatch = !0), g((F.anchor = v("]")), oe, le), le)
        },
        L = (U, F, Z, Y, X, ie) => {
            if (((hasMismatch = !0), (F.el = null), ie)) {
                const le = G(U)
                for (;;) {
                    const Te = a(U)
                    if (Te && Te !== le) c(Te)
                    else break
                }
            }
            const he = a(U),
                oe = l(U)
            return c(U), n(null, F, oe, he, Z, Y, isSVGContainer(oe), X), he
        },
        G = (U) => {
            let F = 0
            for (; U; )
                if (((U = a(U)), U && isComment(U) && (U.data === "[" && F++, U.data === "]"))) {
                    if (F === 0) return a(U)
                    F--
                }
            return U
        }
    return [_, A]
}
const queuePostRenderEffect = queueEffectWithSuspense
function createRenderer(t) {
    return baseCreateRenderer(t)
}
function createHydrationRenderer(t) {
    return baseCreateRenderer(t, createHydrationFunctions)
}
function baseCreateRenderer(t, e) {
    const n = getGlobalThis()
    n.__VUE__ = !0
    const {
            insert: i,
            remove: o,
            patchProp: a,
            createElement: l,
            createText: c,
            createComment: g,
            setText: v,
            setElementText: _,
            parentNode: A,
            nextSibling: B,
            setScopeId: D = NOOP,
            cloneNode: I,
            insertStaticContent: L,
        } = t,
        G = (H, j, q, ae = null, te = null, fe = null, Se = !1, ue = null, me = !!j.dynamicChildren) => {
            if (H === j) return
            H && !isSameVNodeType(H, j) && ((ae = ee(H)), T(H, te, fe, !0), (H = null)),
                j.patchFlag === -2 && ((me = !1), (j.dynamicChildren = null))
            const { type: _e, ref: Ce, shapeFlag: ke } = j
            switch (_e) {
                case Text:
                    U(H, j, q, ae)
                    break
                case Comment:
                    F(H, j, q, ae)
                    break
                case Static:
                    H == null && Z(j, q, ae, Se)
                    break
                case Fragment$1:
                    O(H, j, q, ae, te, fe, Se, ue, me)
                    break
                default:
                    ke & 1
                        ? ie(H, j, q, ae, te, fe, Se, ue, me)
                        : ke & 6
                        ? u(H, j, q, ae, te, fe, Se, ue, me)
                        : (ke & 64 || ke & 128) && _e.process(H, j, q, ae, te, fe, Se, ue, me, xe)
            }
            Ce != null && te && setRef(Ce, H && H.ref, fe, j || H, !j)
        },
        U = (H, j, q, ae) => {
            if (H == null) i((j.el = c(j.children)), q, ae)
            else {
                const te = (j.el = H.el)
                j.children !== H.children && v(te, j.children)
            }
        },
        F = (H, j, q, ae) => {
            H == null ? i((j.el = g(j.children || "")), q, ae) : (j.el = H.el)
        },
        Z = (H, j, q, ae) => {
            ;[H.el, H.anchor] = L(H.children, j, q, ae, H.el, H.anchor)
        },
        Y = ({ el: H, anchor: j }, q, ae) => {
            let te
            for (; H && H !== j; ) (te = B(H)), i(H, q, ae), (H = te)
            i(j, q, ae)
        },
        X = ({ el: H, anchor: j }) => {
            let q
            for (; H && H !== j; ) (q = B(H)), o(H), (H = q)
            o(j)
        },
        ie = (H, j, q, ae, te, fe, Se, ue, me) => {
            ;(Se = Se || j.type === "svg"), H == null ? he(j, q, ae, te, fe, Se, ue, me) : Te(H, j, te, fe, Se, ue, me)
        },
        he = (H, j, q, ae, te, fe, Se, ue) => {
            let me, _e
            const { type: Ce, props: ke, shapeFlag: Re, transition: Ne, patchFlag: Me, dirs: He } = H
            if (H.el && I !== void 0 && Me === -1) me = H.el = I(H.el)
            else {
                if (
                    ((me = H.el = l(H.type, fe, ke && ke.is, ke)),
                    Re & 8 ? _(me, H.children) : Re & 16 && le(H.children, me, null, ae, te, fe && Ce !== "foreignObject", Se, ue),
                    He && invokeDirectiveHook(H, null, ae, "created"),
                    ke)
                ) {
                    for (const Le in ke) Le !== "value" && !isReservedProp(Le) && a(me, Le, null, ke[Le], fe, H.children, ae, te, J)
                    "value" in ke && a(me, "value", null, ke.value), (_e = ke.onVnodeBeforeMount) && invokeVNodeHook(_e, ae, H)
                }
                oe(me, H, H.scopeId, Se, ae)
            }
            He && invokeDirectiveHook(H, null, ae, "beforeMount")
            const Fe = (!te || (te && !te.pendingBranch)) && Ne && !Ne.persisted
            Fe && Ne.beforeEnter(me),
                i(me, j, q),
                ((_e = ke && ke.onVnodeMounted) || Fe || He) &&
                    queuePostRenderEffect(() => {
                        _e && invokeVNodeHook(_e, ae, H), Fe && Ne.enter(me), He && invokeDirectiveHook(H, null, ae, "mounted")
                    }, te)
        },
        oe = (H, j, q, ae, te) => {
            if ((q && D(H, q), ae)) for (let fe = 0; fe < ae.length; fe++) D(H, ae[fe])
            if (te) {
                let fe = te.subTree
                if (j === fe) {
                    const Se = te.vnode
                    oe(H, Se, Se.scopeId, Se.slotScopeIds, te.parent)
                }
            }
        },
        le = (H, j, q, ae, te, fe, Se, ue, me = 0) => {
            for (let _e = me; _e < H.length; _e++) {
                const Ce = (H[_e] = ue ? cloneIfMounted(H[_e]) : normalizeVNode(H[_e]))
                G(null, Ce, j, q, ae, te, fe, Se, ue)
            }
        },
        Te = (H, j, q, ae, te, fe, Se) => {
            const ue = (j.el = H.el)
            let { patchFlag: me, dynamicChildren: _e, dirs: Ce } = j
            me |= H.patchFlag & 16
            const ke = H.props || EMPTY_OBJ,
                Re = j.props || EMPTY_OBJ
            let Ne
            q && toggleRecurse(q, !1),
                (Ne = Re.onVnodeBeforeUpdate) && invokeVNodeHook(Ne, q, j, H),
                Ce && invokeDirectiveHook(j, H, q, "beforeUpdate"),
                q && toggleRecurse(q, !0)
            const Me = te && j.type !== "foreignObject"
            if ((_e ? ye(H.dynamicChildren, _e, ue, q, ae, Me, fe) : Se || R(H, j, ue, null, q, ae, Me, fe, !1), me > 0)) {
                if (me & 16) Ae(ue, j, ke, Re, q, ae, te)
                else if (
                    (me & 2 && ke.class !== Re.class && a(ue, "class", null, Re.class, te),
                    me & 4 && a(ue, "style", ke.style, Re.style, te),
                    me & 8)
                ) {
                    const He = j.dynamicProps
                    for (let Fe = 0; Fe < He.length; Fe++) {
                        const Le = He[Fe],
                            $t = ke[Le],
                            nt = Re[Le]
                        ;(nt !== $t || Le === "value") && a(ue, Le, $t, nt, te, H.children, q, ae, J)
                    }
                }
                me & 1 && H.children !== j.children && _(ue, j.children)
            } else !Se && _e == null && Ae(ue, j, ke, Re, q, ae, te)
            ;((Ne = Re.onVnodeUpdated) || Ce) &&
                queuePostRenderEffect(() => {
                    Ne && invokeVNodeHook(Ne, q, j, H), Ce && invokeDirectiveHook(j, H, q, "updated")
                }, ae)
        },
        ye = (H, j, q, ae, te, fe, Se) => {
            for (let ue = 0; ue < j.length; ue++) {
                const me = H[ue],
                    _e = j[ue],
                    Ce = me.el && (me.type === Fragment$1 || !isSameVNodeType(me, _e) || me.shapeFlag & 70) ? A(me.el) : q
                G(me, _e, Ce, null, ae, te, fe, Se, !0)
            }
        },
        Ae = (H, j, q, ae, te, fe, Se) => {
            if (q !== ae) {
                for (const ue in ae) {
                    if (isReservedProp(ue)) continue
                    const me = ae[ue],
                        _e = q[ue]
                    me !== _e && ue !== "value" && a(H, ue, _e, me, Se, j.children, te, fe, J)
                }
                if (q !== EMPTY_OBJ) for (const ue in q) !isReservedProp(ue) && !(ue in ae) && a(H, ue, q[ue], null, Se, j.children, te, fe, J)
                "value" in ae && a(H, "value", q.value, ae.value)
            }
        },
        O = (H, j, q, ae, te, fe, Se, ue, me) => {
            const _e = (j.el = H ? H.el : c("")),
                Ce = (j.anchor = H ? H.anchor : c(""))
            let { patchFlag: ke, dynamicChildren: Re, slotScopeIds: Ne } = j
            Ne && (ue = ue ? ue.concat(Ne) : Ne),
                H == null
                    ? (i(_e, q, ae), i(Ce, q, ae), le(j.children, q, Ce, te, fe, Se, ue, me))
                    : ke > 0 && ke & 64 && Re && H.dynamicChildren
                    ? (ye(H.dynamicChildren, Re, q, te, fe, Se, ue),
                      (j.key != null || (te && j === te.subTree)) && traverseStaticChildren(H, j, !0))
                    : R(H, j, q, Ce, te, fe, Se, ue, me)
        },
        u = (H, j, q, ae, te, fe, Se, ue, me) => {
            ;(j.slotScopeIds = ue),
                H == null ? (j.shapeFlag & 512 ? te.ctx.activate(j, q, ae, Se, me) : E(j, q, ae, te, fe, Se, me)) : $(H, j, me)
        },
        E = (H, j, q, ae, te, fe, Se) => {
            const ue = (H.component = createComponentInstance(H, ae, te))
            if ((isKeepAlive(H) && (ue.ctx.renderer = xe), setupComponent(ue), ue.asyncDep)) {
                if ((te && te.registerDep(ue, N), !H.el)) {
                    const me = (ue.subTree = createVNode(Comment))
                    F(null, me, j, q)
                }
                return
            }
            N(ue, H, j, q, te, fe, Se)
        },
        $ = (H, j, q) => {
            const ae = (j.component = H.component)
            if (shouldUpdateComponent(H, j, q))
                if (ae.asyncDep && !ae.asyncResolved) {
                    M(ae, j, q)
                    return
                } else (ae.next = j), invalidateJob(ae.update), ae.update()
            else (j.el = H.el), (ae.vnode = j)
        },
        N = (H, j, q, ae, te, fe, Se) => {
            const ue = () => {
                    if (H.isMounted) {
                        let { next: Ce, bu: ke, u: Re, parent: Ne, vnode: Me } = H,
                            He = Ce,
                            Fe
                        toggleRecurse(H, !1),
                            Ce ? ((Ce.el = Me.el), M(H, Ce, Se)) : (Ce = Me),
                            ke && invokeArrayFns(ke),
                            (Fe = Ce.props && Ce.props.onVnodeBeforeUpdate) && invokeVNodeHook(Fe, Ne, Ce, Me),
                            toggleRecurse(H, !0)
                        const Le = renderComponentRoot(H),
                            $t = H.subTree
                        ;(H.subTree = Le),
                            G($t, Le, A($t.el), ee($t), H, te, fe),
                            (Ce.el = Le.el),
                            He === null && updateHOCHostEl(H, Le.el),
                            Re && queuePostRenderEffect(Re, te),
                            (Fe = Ce.props && Ce.props.onVnodeUpdated) && queuePostRenderEffect(() => invokeVNodeHook(Fe, Ne, Ce, Me), te)
                    } else {
                        let Ce
                        const { el: ke, props: Re } = j,
                            { bm: Ne, m: Me, parent: He } = H,
                            Fe = isAsyncWrapper(j)
                        if (
                            (toggleRecurse(H, !1),
                            Ne && invokeArrayFns(Ne),
                            !Fe && (Ce = Re && Re.onVnodeBeforeMount) && invokeVNodeHook(Ce, He, j),
                            toggleRecurse(H, !0),
                            ke && de)
                        ) {
                            const Le = () => {
                                ;(H.subTree = renderComponentRoot(H)), de(ke, H.subTree, H, te, null)
                            }
                            Fe ? j.type.__asyncLoader().then(() => !H.isUnmounted && Le()) : Le()
                        } else {
                            const Le = (H.subTree = renderComponentRoot(H))
                            G(null, Le, q, ae, H, te, fe), (j.el = Le.el)
                        }
                        if ((Me && queuePostRenderEffect(Me, te), !Fe && (Ce = Re && Re.onVnodeMounted))) {
                            const Le = j
                            queuePostRenderEffect(() => invokeVNodeHook(Ce, He, Le), te)
                        }
                        ;(j.shapeFlag & 256 || (He && isAsyncWrapper(He.vnode) && He.vnode.shapeFlag & 256)) &&
                            H.a &&
                            queuePostRenderEffect(H.a, te),
                            (H.isMounted = !0),
                            (j = q = ae = null)
                    }
                },
                me = (H.effect = new ReactiveEffect(ue, () => queueJob(_e), H.scope)),
                _e = (H.update = () => me.run())
            ;(_e.id = H.uid), toggleRecurse(H, !0), _e()
        },
        M = (H, j, q) => {
            j.component = H
            const ae = H.vnode.props
            ;(H.vnode = j),
                (H.next = null),
                updateProps(H, j.props, ae, q),
                updateSlots(H, j.children, q),
                pauseTracking(),
                flushPreFlushCbs(),
                resetTracking()
        },
        R = (H, j, q, ae, te, fe, Se, ue, me = !1) => {
            const _e = H && H.children,
                Ce = H ? H.shapeFlag : 0,
                ke = j.children,
                { patchFlag: Re, shapeFlag: Ne } = j
            if (Re > 0) {
                if (Re & 128) {
                    S(_e, ke, q, ae, te, fe, Se, ue, me)
                    return
                } else if (Re & 256) {
                    C(_e, ke, q, ae, te, fe, Se, ue, me)
                    return
                }
            }
            Ne & 8
                ? (Ce & 16 && J(_e, te, fe), ke !== _e && _(q, ke))
                : Ce & 16
                ? Ne & 16
                    ? S(_e, ke, q, ae, te, fe, Se, ue, me)
                    : J(_e, te, fe, !0)
                : (Ce & 8 && _(q, ""), Ne & 16 && le(ke, q, ae, te, fe, Se, ue, me))
        },
        C = (H, j, q, ae, te, fe, Se, ue, me) => {
            ;(H = H || EMPTY_ARR), (j = j || EMPTY_ARR)
            const _e = H.length,
                Ce = j.length,
                ke = Math.min(_e, Ce)
            let Re
            for (Re = 0; Re < ke; Re++) {
                const Ne = (j[Re] = me ? cloneIfMounted(j[Re]) : normalizeVNode(j[Re]))
                G(H[Re], Ne, q, null, te, fe, Se, ue, me)
            }
            _e > Ce ? J(H, te, fe, !0, !1, ke) : le(j, q, ae, te, fe, Se, ue, me, ke)
        },
        S = (H, j, q, ae, te, fe, Se, ue, me) => {
            let _e = 0
            const Ce = j.length
            let ke = H.length - 1,
                Re = Ce - 1
            for (; _e <= ke && _e <= Re; ) {
                const Ne = H[_e],
                    Me = (j[_e] = me ? cloneIfMounted(j[_e]) : normalizeVNode(j[_e]))
                if (isSameVNodeType(Ne, Me)) G(Ne, Me, q, null, te, fe, Se, ue, me)
                else break
                _e++
            }
            for (; _e <= ke && _e <= Re; ) {
                const Ne = H[ke],
                    Me = (j[Re] = me ? cloneIfMounted(j[Re]) : normalizeVNode(j[Re]))
                if (isSameVNodeType(Ne, Me)) G(Ne, Me, q, null, te, fe, Se, ue, me)
                else break
                ke--, Re--
            }
            if (_e > ke) {
                if (_e <= Re) {
                    const Ne = Re + 1,
                        Me = Ne < Ce ? j[Ne].el : ae
                    for (; _e <= Re; ) G(null, (j[_e] = me ? cloneIfMounted(j[_e]) : normalizeVNode(j[_e])), q, Me, te, fe, Se, ue, me), _e++
                }
            } else if (_e > Re) for (; _e <= ke; ) T(H[_e], te, fe, !0), _e++
            else {
                const Ne = _e,
                    Me = _e,
                    He = new Map()
                for (_e = Me; _e <= Re; _e++) {
                    const Ze = (j[_e] = me ? cloneIfMounted(j[_e]) : normalizeVNode(j[_e]))
                    Ze.key != null && He.set(Ze.key, _e)
                }
                let Fe,
                    Le = 0
                const $t = Re - Me + 1
                let nt = !1,
                    lt = 0
                const Zr = new Array($t)
                for (_e = 0; _e < $t; _e++) Zr[_e] = 0
                for (_e = Ne; _e <= ke; _e++) {
                    const Ze = H[_e]
                    if (Le >= $t) {
                        T(Ze, te, fe, !0)
                        continue
                    }
                    let Xr
                    if (Ze.key != null) Xr = He.get(Ze.key)
                    else
                        for (Fe = Me; Fe <= Re; Fe++)
                            if (Zr[Fe - Me] === 0 && isSameVNodeType(Ze, j[Fe])) {
                                Xr = Fe
                                break
                            }
                    Xr === void 0
                        ? T(Ze, te, fe, !0)
                        : ((Zr[Xr - Me] = _e + 1), Xr >= lt ? (lt = Xr) : (nt = !0), G(Ze, j[Xr], q, null, te, fe, Se, ue, me), Le++)
                }
                const kt = nt ? getSequence(Zr) : EMPTY_ARR
                for (Fe = kt.length - 1, _e = $t - 1; _e >= 0; _e--) {
                    const Ze = Me + _e,
                        Xr = j[Ze],
                        dt = Ze + 1 < Ce ? j[Ze + 1].el : ae
                    Zr[_e] === 0 ? G(null, Xr, q, dt, te, fe, Se, ue, me) : nt && (Fe < 0 || _e !== kt[Fe] ? b(Xr, q, dt, 2) : Fe--)
                }
            }
        },
        b = (H, j, q, ae, te = null) => {
            const { el: fe, type: Se, transition: ue, children: me, shapeFlag: _e } = H
            if (_e & 6) {
                b(H.component.subTree, j, q, ae)
                return
            }
            if (_e & 128) {
                H.suspense.move(j, q, ae)
                return
            }
            if (_e & 64) {
                Se.move(H, j, q, xe)
                return
            }
            if (Se === Fragment$1) {
                i(fe, j, q)
                for (let ke = 0; ke < me.length; ke++) b(me[ke], j, q, ae)
                i(H.anchor, j, q)
                return
            }
            if (Se === Static) {
                Y(H, j, q)
                return
            }
            if (ae !== 2 && _e & 1 && ue)
                if (ae === 0) ue.beforeEnter(fe), i(fe, j, q), queuePostRenderEffect(() => ue.enter(fe), te)
                else {
                    const { leave: ke, delayLeave: Re, afterLeave: Ne } = ue,
                        Me = () => i(fe, j, q),
                        He = () => {
                            ke(fe, () => {
                                Me(), Ne && Ne()
                            })
                        }
                    Re ? Re(fe, Me, He) : He()
                }
            else i(fe, j, q)
        },
        T = (H, j, q, ae = !1, te = !1) => {
            const { type: fe, props: Se, ref: ue, children: me, dynamicChildren: _e, shapeFlag: Ce, patchFlag: ke, dirs: Re } = H
            if ((ue != null && setRef(ue, null, q, H, !0), Ce & 256)) {
                j.ctx.deactivate(H)
                return
            }
            const Ne = Ce & 1 && Re,
                Me = !isAsyncWrapper(H)
            let He
            if ((Me && (He = Se && Se.onVnodeBeforeUnmount) && invokeVNodeHook(He, j, H), Ce & 6)) W(H.component, q, ae)
            else {
                if (Ce & 128) {
                    H.suspense.unmount(q, ae)
                    return
                }
                Ne && invokeDirectiveHook(H, null, j, "beforeUnmount"),
                    Ce & 64
                        ? H.type.remove(H, j, q, te, xe, ae)
                        : _e && (fe !== Fragment$1 || (ke > 0 && ke & 64))
                        ? J(_e, j, q, !1, !0)
                        : ((fe === Fragment$1 && ke & 384) || (!te && Ce & 16)) && J(me, j, q),
                    ae && Q(H)
            }
            ;((Me && (He = Se && Se.onVnodeUnmounted)) || Ne) &&
                queuePostRenderEffect(() => {
                    He && invokeVNodeHook(He, j, H), Ne && invokeDirectiveHook(H, null, j, "unmounted")
                }, q)
        },
        Q = (H) => {
            const { type: j, el: q, anchor: ae, transition: te } = H
            if (j === Fragment$1) {
                k(q, ae)
                return
            }
            if (j === Static) {
                X(H)
                return
            }
            const fe = () => {
                o(q), te && !te.persisted && te.afterLeave && te.afterLeave()
            }
            if (H.shapeFlag & 1 && te && !te.persisted) {
                const { leave: Se, delayLeave: ue } = te,
                    me = () => Se(q, fe)
                ue ? ue(H.el, fe, me) : me()
            } else fe()
        },
        k = (H, j) => {
            let q
            for (; H !== j; ) (q = B(H)), o(H), (H = q)
            o(j)
        },
        W = (H, j, q) => {
            const { bum: ae, scope: te, update: fe, subTree: Se, um: ue } = H
            ae && invokeArrayFns(ae),
                te.stop(),
                fe && ((fe.active = !1), T(Se, H, j, q)),
                ue && queuePostRenderEffect(ue, j),
                queuePostRenderEffect(() => {
                    H.isUnmounted = !0
                }, j),
                j &&
                    j.pendingBranch &&
                    !j.isUnmounted &&
                    H.asyncDep &&
                    !H.asyncResolved &&
                    H.suspenseId === j.pendingId &&
                    (j.deps--, j.deps === 0 && j.resolve())
        },
        J = (H, j, q, ae = !1, te = !1, fe = 0) => {
            for (let Se = fe; Se < H.length; Se++) T(H[Se], j, q, ae, te)
        },
        ee = (H) => (H.shapeFlag & 6 ? ee(H.component.subTree) : H.shapeFlag & 128 ? H.suspense.next() : B(H.anchor || H.el)),
        ne = (H, j, q) => {
            H == null ? j._vnode && T(j._vnode, null, null, !0) : G(j._vnode || null, H, j, null, null, null, q),
                flushPreFlushCbs(),
                flushPostFlushCbs(),
                (j._vnode = H)
        },
        xe = { p: G, um: T, m: b, r: Q, mt: E, mc: le, pc: R, pbc: ye, n: ee, o: t }
    let ce, de
    return e && ([ce, de] = e(xe)), { render: ne, hydrate: ce, createApp: createAppAPI(ne, ce) }
}
function toggleRecurse({ effect: t, update: e }, n) {
    t.allowRecurse = e.allowRecurse = n
}
function traverseStaticChildren(t, e, n = !1) {
    const i = t.children,
        o = e.children
    if (isArray$1(i) && isArray$1(o))
        for (let a = 0; a < i.length; a++) {
            const l = i[a]
            let c = o[a]
            c.shapeFlag & 1 &&
                !c.dynamicChildren &&
                ((c.patchFlag <= 0 || c.patchFlag === 32) && ((c = o[a] = cloneIfMounted(o[a])), (c.el = l.el)),
                n || traverseStaticChildren(l, c))
        }
}
function getSequence(t) {
    const e = t.slice(),
        n = [0]
    let i, o, a, l, c
    const g = t.length
    for (i = 0; i < g; i++) {
        const v = t[i]
        if (v !== 0) {
            if (((o = n[n.length - 1]), t[o] < v)) {
                ;(e[i] = o), n.push(i)
                continue
            }
            for (a = 0, l = n.length - 1; a < l; ) (c = (a + l) >> 1), t[n[c]] < v ? (a = c + 1) : (l = c)
            v < t[n[a]] && (a > 0 && (e[i] = n[a - 1]), (n[a] = i))
        }
    }
    for (a = n.length, l = n[a - 1]; a-- > 0; ) (n[a] = l), (l = e[l])
    return n
}
const isTeleport = (t) => t.__isTeleport,
    isTeleportDisabled = (t) => t && (t.disabled || t.disabled === ""),
    isTargetSVG = (t) => typeof SVGElement != "undefined" && t instanceof SVGElement,
    resolveTarget = (t, e) => {
        const n = t && t.to
        return isString(n) ? (e ? e(n) : null) : n
    },
    TeleportImpl = {
        __isTeleport: !0,
        process(t, e, n, i, o, a, l, c, g, v) {
            const {
                    mc: _,
                    pc: A,
                    pbc: B,
                    o: { insert: D, querySelector: I, createText: L, createComment: G },
                } = v,
                U = isTeleportDisabled(e.props)
            let { shapeFlag: F, children: Z, dynamicChildren: Y } = e
            if (t == null) {
                const X = (e.el = L("")),
                    ie = (e.anchor = L(""))
                D(X, n, i), D(ie, n, i)
                const he = (e.target = resolveTarget(e.props, I)),
                    oe = (e.targetAnchor = L(""))
                he && (D(oe, he), (l = l || isTargetSVG(he)))
                const le = (Te, ye) => {
                    F & 16 && _(Z, Te, ye, o, a, l, c, g)
                }
                U ? le(n, ie) : he && le(he, oe)
            } else {
                e.el = t.el
                const X = (e.anchor = t.anchor),
                    ie = (e.target = t.target),
                    he = (e.targetAnchor = t.targetAnchor),
                    oe = isTeleportDisabled(t.props),
                    le = oe ? n : ie,
                    Te = oe ? X : he
                if (
                    ((l = l || isTargetSVG(ie)),
                    Y ? (B(t.dynamicChildren, Y, le, o, a, l, c), traverseStaticChildren(t, e, !0)) : g || A(t, e, le, Te, o, a, l, c, !1),
                    U)
                )
                    oe || moveTeleport(e, n, X, v, 1)
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const ye = (e.target = resolveTarget(e.props, I))
                    ye && moveTeleport(e, ye, null, v, 0)
                } else oe && moveTeleport(e, ie, he, v, 1)
            }
        },
        remove(t, e, n, i, { um: o, o: { remove: a } }, l) {
            const { shapeFlag: c, children: g, anchor: v, targetAnchor: _, target: A, props: B } = t
            if ((A && a(_), (l || !isTeleportDisabled(B)) && (a(v), c & 16)))
                for (let D = 0; D < g.length; D++) {
                    const I = g[D]
                    o(I, e, n, !0, !!I.dynamicChildren)
                }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport,
    }
function moveTeleport(t, e, n, { o: { insert: i }, m: o }, a = 2) {
    a === 0 && i(t.targetAnchor, e, n)
    const { el: l, anchor: c, shapeFlag: g, children: v, props: _ } = t,
        A = a === 2
    if ((A && i(l, e, n), (!A || isTeleportDisabled(_)) && g & 16)) for (let B = 0; B < v.length; B++) o(v[B], e, n, 2)
    A && i(c, e, n)
}
function hydrateTeleport(t, e, n, i, o, a, { o: { nextSibling: l, parentNode: c, querySelector: g } }, v) {
    const _ = (e.target = resolveTarget(e.props, g))
    if (_) {
        const A = _._lpa || _.firstChild
        if (e.shapeFlag & 16)
            if (isTeleportDisabled(e.props)) (e.anchor = v(l(t), e, c(t), n, i, o, a)), (e.targetAnchor = A)
            else {
                e.anchor = l(t)
                let B = A
                for (; B; )
                    if (((B = l(B)), B && B.nodeType === 8 && B.data === "teleport anchor")) {
                        ;(e.targetAnchor = B), (_._lpa = e.targetAnchor && l(e.targetAnchor))
                        break
                    }
                v(A, e, _, n, i, o, a)
            }
    }
    return e.anchor && l(e.anchor)
}
const Teleport = TeleportImpl,
    Fragment$1 = Symbol(void 0),
    Text = Symbol(void 0),
    Comment = Symbol(void 0),
    Static = Symbol(void 0),
    blockStack = []
let currentBlock = null
function openBlock(t = !1) {
    blockStack.push((currentBlock = t ? null : []))
}
function closeBlock() {
    blockStack.pop(), (currentBlock = blockStack[blockStack.length - 1] || null)
}
let isBlockTreeEnabled = 1
function setBlockTracking(t) {
    isBlockTreeEnabled += t
}
function setupBlock(t) {
    return (
        (t.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null),
        closeBlock(),
        isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(t),
        t
    )
}
function createElementBlock(t, e, n, i, o, a) {
    return setupBlock(createBaseVNode(t, e, n, i, o, a, !0))
}
function createBlock$1(t, e, n, i, o) {
    return setupBlock(createVNode(t, e, n, i, o, !0))
}
function isVNode(t) {
    return t ? t.__v_isVNode === !0 : !1
}
function isSameVNodeType(t, e) {
    return t.type === e.type && t.key === e.key
}
function transformVNodeArgs(t) {}
const InternalObjectKey = "__vInternal",
    normalizeKey = ({ key: t }) => (t != null ? t : null),
    normalizeRef = ({ ref: t, ref_key: e, ref_for: n }) =>
        t != null ? (isString(t) || isRef(t) || isFunction(t) ? { i: currentRenderingInstance, r: t, k: e, f: !!n } : t) : null
function createBaseVNode(t, e = null, n = null, i = 0, o = null, a = t === Fragment$1 ? 0 : 1, l = !1, c = !1) {
    const g = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && normalizeKey(e),
        ref: e && normalizeRef(e),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: a,
        patchFlag: i,
        dynamicProps: o,
        dynamicChildren: null,
        appContext: null,
    }
    return (
        c ? (normalizeChildren(g, n), a & 128 && t.normalize(g)) : n && (g.shapeFlag |= isString(n) ? 8 : 16),
        isBlockTreeEnabled > 0 && !l && currentBlock && (g.patchFlag > 0 || a & 6) && g.patchFlag !== 32 && currentBlock.push(g),
        g
    )
}
const createVNode = _createVNode
function _createVNode(t, e = null, n = null, i = 0, o = null, a = !1) {
    if (((!t || t === NULL_DYNAMIC_COMPONENT) && (t = Comment), isVNode(t))) {
        const c = cloneVNode(t, e, !0)
        return (
            n && normalizeChildren(c, n),
            isBlockTreeEnabled > 0 &&
                !a &&
                currentBlock &&
                (c.shapeFlag & 6 ? (currentBlock[currentBlock.indexOf(t)] = c) : currentBlock.push(c)),
            (c.patchFlag |= -2),
            c
        )
    }
    if ((isClassComponent(t) && (t = t.__vccOpts), e)) {
        e = guardReactiveProps(e)
        let { class: c, style: g } = e
        c && !isString(c) && (e.class = normalizeClass(c)),
            isObject(g) && (isProxy(g) && !isArray$1(g) && (g = extend({}, g)), (e.style = normalizeStyle(g)))
    }
    const l = isString(t) ? 1 : isSuspense(t) ? 128 : isTeleport(t) ? 64 : isObject(t) ? 4 : isFunction(t) ? 2 : 0
    return createBaseVNode(t, e, n, i, o, l, a, !0)
}
function guardReactiveProps(t) {
    return t ? (isProxy(t) || InternalObjectKey in t ? extend({}, t) : t) : null
}
function cloneVNode(t, e, n = !1) {
    const { props: i, ref: o, patchFlag: a, children: l } = t,
        c = e ? mergeProps(i || {}, e) : i
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: c,
        key: c && normalizeKey(c),
        ref: e && e.ref ? (n && o ? (isArray$1(o) ? o.concat(normalizeRef(e)) : [o, normalizeRef(e)]) : normalizeRef(e)) : o,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: l,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== Fragment$1 ? (a === -1 ? 16 : a | 16) : a,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && cloneVNode(t.ssContent),
        ssFallback: t.ssFallback && cloneVNode(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
    }
}
function createTextVNode(t = " ", e = 0) {
    return createVNode(Text, null, t, e)
}
function createStaticVNode(t, e) {
    const n = createVNode(Static, null, t)
    return (n.staticCount = e), n
}
function createCommentVNode(t = "", e = !1) {
    return e ? (openBlock(), createBlock$1(Comment, null, t)) : createVNode(Comment, null, t)
}
function normalizeVNode(t) {
    return t == null || typeof t == "boolean"
        ? createVNode(Comment)
        : isArray$1(t)
        ? createVNode(Fragment$1, null, t.slice())
        : typeof t == "object"
        ? cloneIfMounted(t)
        : createVNode(Text, null, String(t))
}
function cloneIfMounted(t) {
    return t.el === null || t.memo ? t : cloneVNode(t)
}
function normalizeChildren(t, e) {
    let n = 0
    const { shapeFlag: i } = t
    if (e == null) e = null
    else if (isArray$1(e)) n = 16
    else if (typeof e == "object")
        if (i & 65) {
            const o = e.default
            o && (o._c && (o._d = !1), normalizeChildren(t, o()), o._c && (o._d = !0))
            return
        } else {
            n = 32
            const o = e._
            !o && !(InternalObjectKey in e)
                ? (e._ctx = currentRenderingInstance)
                : o === 3 &&
                  currentRenderingInstance &&
                  (currentRenderingInstance.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (t.patchFlag |= 1024)))
        }
    else
        isFunction(e)
            ? ((e = { default: e, _ctx: currentRenderingInstance }), (n = 32))
            : ((e = String(e)), i & 64 ? ((n = 16), (e = [createTextVNode(e)])) : (n = 8))
    ;(t.children = e), (t.shapeFlag |= n)
}
function mergeProps(...t) {
    const e = {}
    for (let n = 0; n < t.length; n++) {
        const i = t[n]
        for (const o in i)
            if (o === "class") e.class !== i.class && (e.class = normalizeClass([e.class, i.class]))
            else if (o === "style") e.style = normalizeStyle([e.style, i.style])
            else if (isOn(o)) {
                const a = e[o],
                    l = i[o]
                l && a !== l && !(isArray$1(a) && a.includes(l)) && (e[o] = a ? [].concat(a, l) : l)
            } else o !== "" && (e[o] = i[o])
    }
    return e
}
function invokeVNodeHook(t, e, n, i = null) {
    callWithAsyncErrorHandling(t, e, 7, [n, i])
}
const emptyAppContext = createAppContext()
let uid$1 = 0
function createComponentInstance(t, e, n) {
    const i = t.type,
        o = (e ? e.appContext : t.appContext) || emptyAppContext,
        a = {
            uid: uid$1++,
            vnode: t,
            type: i,
            parent: e,
            appContext: o,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new EffectScope(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(o.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: normalizePropsOptions(i, o),
            emitsOptions: normalizeEmitsOptions(i, o),
            emit: null,
            emitted: null,
            propsDefaults: EMPTY_OBJ,
            inheritAttrs: i.inheritAttrs,
            ctx: EMPTY_OBJ,
            data: EMPTY_OBJ,
            props: EMPTY_OBJ,
            attrs: EMPTY_OBJ,
            slots: EMPTY_OBJ,
            refs: EMPTY_OBJ,
            setupState: EMPTY_OBJ,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null,
        }
    return (a.ctx = { _: a }), (a.root = e ? e.root : a), (a.emit = emit$1.bind(null, a)), t.ce && t.ce(a), a
}
let currentInstance = null
const getCurrentInstance = () => currentInstance || currentRenderingInstance,
    setCurrentInstance = (t) => {
        ;(currentInstance = t), t.scope.on()
    },
    unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off(), (currentInstance = null)
    }
function isStatefulComponent(t) {
    return t.vnode.shapeFlag & 4
}
let isInSSRComponentSetup = !1
function setupComponent(t, e = !1) {
    isInSSRComponentSetup = e
    const { props: n, children: i } = t.vnode,
        o = isStatefulComponent(t)
    initProps(t, n, o, e), initSlots(t, i)
    const a = o ? setupStatefulComponent(t, e) : void 0
    return (isInSSRComponentSetup = !1), a
}
function setupStatefulComponent(t, e) {
    const n = t.type
    ;(t.accessCache = Object.create(null)), (t.proxy = markRaw(new Proxy(t.ctx, PublicInstanceProxyHandlers)))
    const { setup: i } = n
    if (i) {
        const o = (t.setupContext = i.length > 1 ? createSetupContext(t) : null)
        setCurrentInstance(t), pauseTracking()
        const a = callWithErrorHandling(i, t, 0, [t.props, o])
        if ((resetTracking(), unsetCurrentInstance(), isPromise(a))) {
            if ((a.then(unsetCurrentInstance, unsetCurrentInstance), e))
                return a
                    .then((l) => {
                        handleSetupResult(t, l, e)
                    })
                    .catch((l) => {
                        handleError(l, t, 0)
                    })
            t.asyncDep = a
        } else handleSetupResult(t, a, e)
    } else finishComponentSetup(t, e)
}
function handleSetupResult(t, e, n) {
    isFunction(e) ? (t.type.__ssrInlineRender ? (t.ssrRender = e) : (t.render = e)) : isObject(e) && (t.setupState = proxyRefs(e)),
        finishComponentSetup(t, n)
}
let compile$1, installWithProxy
function registerRuntimeCompiler(t) {
    ;(compile$1 = t),
        (installWithProxy = (e) => {
            e.render._rc && (e.withProxy = new Proxy(e.ctx, RuntimeCompiledPublicInstanceProxyHandlers))
        })
}
const isRuntimeOnly = () => !compile$1
function finishComponentSetup(t, e, n) {
    const i = t.type
    if (!t.render) {
        if (!e && compile$1 && !i.render) {
            const o = i.template
            if (o) {
                const { isCustomElement: a, compilerOptions: l } = t.appContext.config,
                    { delimiters: c, compilerOptions: g } = i,
                    v = extend(extend({ isCustomElement: a, delimiters: c }, l), g)
                i.render = compile$1(o, v)
            }
        }
        ;(t.render = i.render || NOOP), installWithProxy && installWithProxy(t)
    }
    setCurrentInstance(t), pauseTracking(), applyOptions(t), resetTracking(), unsetCurrentInstance()
}
function createAttrsProxy(t) {
    return new Proxy(t.attrs, {
        get(e, n) {
            return track(t, "get", "$attrs"), e[n]
        },
    })
}
function createSetupContext(t) {
    const e = (i) => {
        t.exposed = i || {}
    }
    let n
    return {
        get attrs() {
            return n || (n = createAttrsProxy(t))
        },
        slots: t.slots,
        emit: t.emit,
        expose: e,
    }
}
function getExposeProxy(t) {
    if (t.exposed)
        return (
            t.exposeProxy ||
            (t.exposeProxy = new Proxy(proxyRefs(markRaw(t.exposed)), {
                get(e, n) {
                    if (n in e) return e[n]
                    if (n in publicPropertiesMap) return publicPropertiesMap[n](t)
                },
            }))
        )
}
const classifyRE = /(?:^|[-_])(\w)/g,
    classify = (t) => t.replace(classifyRE, (e) => e.toUpperCase()).replace(/[-_]/g, "")
function getComponentName(t, e = !0) {
    return isFunction(t) ? t.displayName || t.name : t.name || (e && t.__name)
}
function formatComponentName(t, e, n = !1) {
    let i = getComponentName(e)
    if (!i && e.__file) {
        const o = e.__file.match(/([^/\\]+)\.\w+$/)
        o && (i = o[1])
    }
    if (!i && t && t.parent) {
        const o = (a) => {
            for (const l in a) if (a[l] === e) return l
        }
        i = o(t.components || t.parent.type.components) || o(t.appContext.components)
    }
    return i ? classify(i) : n ? "App" : "Anonymous"
}
function isClassComponent(t) {
    return isFunction(t) && "__vccOpts" in t
}
const computed = (t, e) => computed$1(t, e, isInSSRComponentSetup)
function defineProps() {
    return null
}
function defineEmits() {
    return null
}
function defineExpose(t) {}
function withDefaults(t, e) {
    return null
}
function useSlots() {
    return getContext().slots
}
function useAttrs() {
    return getContext().attrs
}
function getContext() {
    const t = getCurrentInstance()
    return t.setupContext || (t.setupContext = createSetupContext(t))
}
function mergeDefaults(t, e) {
    const n = isArray$1(t) ? t.reduce((i, o) => ((i[o] = {}), i), {}) : t
    for (const i in e) {
        const o = n[i]
        o ? (isArray$1(o) || isFunction(o) ? (n[i] = { type: o, default: e[i] }) : (o.default = e[i])) : o === null && (n[i] = { default: e[i] })
    }
    return n
}
function createPropsRestProxy(t, e) {
    const n = {}
    for (const i in t) e.includes(i) || Object.defineProperty(n, i, { enumerable: !0, get: () => t[i] })
    return n
}
function withAsyncContext(t) {
    const e = getCurrentInstance()
    let n = t()
    return (
        unsetCurrentInstance(),
        isPromise(n) &&
            (n = n.catch((i) => {
                throw (setCurrentInstance(e), i)
            })),
        [n, () => setCurrentInstance(e)]
    )
}
function h$1(t, e, n) {
    const i = arguments.length
    return i === 2
        ? isObject(e) && !isArray$1(e)
            ? isVNode(e)
                ? createVNode(t, null, [e])
                : createVNode(t, e)
            : createVNode(t, null, e)
        : (i > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : i === 3 && isVNode(n) && (n = [n]), createVNode(t, e, n))
}
const ssrContextKey = Symbol(""),
    useSSRContext = () => {
        {
            const t = inject(ssrContextKey)
            return (
                t || warn("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t
            )
        }
    }
function initCustomFormatter() {}
function withMemo(t, e, n, i) {
    const o = n[i]
    if (o && isMemoSame(o, t)) return o
    const a = e()
    return (a.memo = t.slice()), (n[i] = a)
}
function isMemoSame(t, e) {
    const n = t.memo
    if (n.length != e.length) return !1
    for (let i = 0; i < n.length; i++) if (hasChanged(n[i], e[i])) return !1
    return isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(t), !0
}
const version$k = "3.2.38",
    _ssrUtils = { createComponentInstance, setupComponent, renderComponentRoot, setCurrentRenderingInstance, isVNode, normalizeVNode },
    ssrUtils = _ssrUtils,
    resolveFilter = null,
    compatUtils = null,
    svgNS = "http://www.w3.org/2000/svg",
    doc = typeof document != "undefined" ? document : null,
    templateContainer = doc && doc.createElement("template"),
    nodeOps = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        },
        remove: (t) => {
            const e = t.parentNode
            e && e.removeChild(t)
        },
        createElement: (t, e, n, i) => {
            const o = e ? doc.createElementNS(svgNS, t) : doc.createElement(t, n ? { is: n } : void 0)
            return t === "select" && i && i.multiple != null && o.setAttribute("multiple", i.multiple), o
        },
        createText: (t) => doc.createTextNode(t),
        createComment: (t) => doc.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: (t) => t.parentNode,
        nextSibling: (t) => t.nextSibling,
        querySelector: (t) => doc.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        cloneNode(t) {
            const e = t.cloneNode(!0)
            return "_value" in t && (e._value = t._value), e
        },
        insertStaticContent(t, e, n, i, o, a) {
            const l = n ? n.previousSibling : e.lastChild
            if (o && (o === a || o.nextSibling)) for (; e.insertBefore(o.cloneNode(!0), n), !(o === a || !(o = o.nextSibling)); );
            else {
                templateContainer.innerHTML = i ? `<svg>${t}</svg>` : t
                const c = templateContainer.content
                if (i) {
                    const g = c.firstChild
                    for (; g.firstChild; ) c.appendChild(g.firstChild)
                    c.removeChild(g)
                }
                e.insertBefore(c, n)
            }
            return [l ? l.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        },
    }
function patchClass(t, e, n) {
    const i = t._vtc
    i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : (t.className = e)
}
function patchStyle(t, e, n) {
    const i = t.style,
        o = isString(n)
    if (n && !o) {
        for (const a in n) setStyle(i, a, n[a])
        if (e && !isString(e)) for (const a in e) n[a] == null && setStyle(i, a, "")
    } else {
        const a = i.display
        o ? e !== n && (i.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (i.display = a)
    }
}
const importantRE = /\s*!important$/
function setStyle(t, e, n) {
    if (isArray$1(n)) n.forEach((i) => setStyle(t, e, i))
    else if ((n == null && (n = ""), e.startsWith("--"))) t.setProperty(e, n)
    else {
        const i = autoPrefix(t, e)
        importantRE.test(n) ? t.setProperty(hyphenate(i), n.replace(importantRE, ""), "important") : (t[i] = n)
    }
}
const prefixes = ["Webkit", "Moz", "ms"],
    prefixCache = {}
function autoPrefix(t, e) {
    const n = prefixCache[e]
    if (n) return n
    let i = camelize(e)
    if (i !== "filter" && i in t) return (prefixCache[e] = i)
    i = capitalize(i)
    for (let o = 0; o < prefixes.length; o++) {
        const a = prefixes[o] + i
        if (a in t) return (prefixCache[e] = a)
    }
    return e
}
const xlinkNS = "http://www.w3.org/1999/xlink"
function patchAttr(t, e, n, i, o) {
    if (i && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(xlinkNS, e.slice(6, e.length)) : t.setAttributeNS(xlinkNS, e, n)
    else {
        const a = isSpecialBooleanAttr(e)
        n == null || (a && !includeBooleanAttr(n)) ? t.removeAttribute(e) : t.setAttribute(e, a ? "" : n)
    }
}
function patchDOMProp(t, e, n, i, o, a, l) {
    if (e === "innerHTML" || e === "textContent") {
        i && l(i, o, a), (t[e] = n == null ? "" : n)
        return
    }
    if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
        t._value = n
        const g = n == null ? "" : n
        ;(t.value !== g || t.tagName === "OPTION") && (t.value = g), n == null && t.removeAttribute(e)
        return
    }
    let c = !1
    if (n === "" || n == null) {
        const g = typeof t[e]
        g === "boolean"
            ? (n = includeBooleanAttr(n))
            : n == null && g === "string"
            ? ((n = ""), (c = !0))
            : g === "number" && ((n = 0), (c = !0))
    }
    try {
        t[e] = n
    } catch {}
    c && t.removeAttribute(e)
}
const [_getNow, skipTimestampCheck] = (() => {
    let t = Date.now,
        e = !1
    if (typeof window != "undefined") {
        Date.now() > document.createEvent("Event").timeStamp && (t = performance.now.bind(performance))
        const n = navigator.userAgent.match(/firefox\/(\d+)/i)
        e = !!(n && Number(n[1]) <= 53)
    }
    return [t, e]
})()
let cachedNow = 0
const p = Promise.resolve(),
    reset = () => {
        cachedNow = 0
    },
    getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()))
function addEventListener(t, e, n, i) {
    t.addEventListener(e, n, i)
}
function removeEventListener(t, e, n, i) {
    t.removeEventListener(e, n, i)
}
function patchEvent(t, e, n, i, o = null) {
    const a = t._vei || (t._vei = {}),
        l = a[e]
    if (i && l) l.value = i
    else {
        const [c, g] = parseName(e)
        if (i) {
            const v = (a[e] = createInvoker(i, o))
            addEventListener(t, c, v, g)
        } else l && (removeEventListener(t, c, l, g), (a[e] = void 0))
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/
function parseName(t) {
    let e
    if (optionsModifierRE.test(t)) {
        e = {}
        let i
        for (; (i = t.match(optionsModifierRE)); ) (t = t.slice(0, t.length - i[0].length)), (e[i[0].toLowerCase()] = !0)
    }
    return [t[2] === ":" ? t.slice(3) : hyphenate(t.slice(2)), e]
}
function createInvoker(t, e) {
    const n = (i) => {
        const o = i.timeStamp || _getNow()
        ;(skipTimestampCheck || o >= n.attached - 1) && callWithAsyncErrorHandling(patchStopImmediatePropagation(i, n.value), e, 5, [i])
    }
    return (n.value = t), (n.attached = getNow()), n
}
function patchStopImmediatePropagation(t, e) {
    if (isArray$1(e)) {
        const n = t.stopImmediatePropagation
        return (
            (t.stopImmediatePropagation = () => {
                n.call(t), (t._stopped = !0)
            }),
            e.map((i) => (o) => !o._stopped && i && i(o))
        )
    } else return e
}
const nativeOnRE = /^on[a-z]/,
    patchProp = (t, e, n, i, o = !1, a, l, c, g) => {
        e === "class"
            ? patchClass(t, i, o)
            : e === "style"
            ? patchStyle(t, n, i)
            : isOn(e)
            ? isModelListener(e) || patchEvent(t, e, n, i, l)
            : (e[0] === "." ? ((e = e.slice(1)), !0) : e[0] === "^" ? ((e = e.slice(1)), !1) : shouldSetAsProp(t, e, i, o))
            ? patchDOMProp(t, e, i, a, l, c, g)
            : (e === "true-value" ? (t._trueValue = i) : e === "false-value" && (t._falseValue = i), patchAttr(t, e, i, o))
    }
function shouldSetAsProp(t, e, n, i) {
    return i
        ? !!(e === "innerHTML" || e === "textContent" || (e in t && nativeOnRE.test(e) && isFunction(n)))
        : e === "spellcheck" ||
          e === "draggable" ||
          e === "translate" ||
          e === "form" ||
          (e === "list" && t.tagName === "INPUT") ||
          (e === "type" && t.tagName === "TEXTAREA") ||
          (nativeOnRE.test(e) && isString(n))
        ? !1
        : e in t
}
function defineCustomElement(t, e) {
    const n = defineComponent(t)
    class i extends VueElement {
        constructor(a) {
            super(n, a, e)
        }
    }
    return (i.def = n), i
}
const defineSSRCustomElement = (t) => defineCustomElement(t, hydrate),
    BaseClass = typeof HTMLElement != "undefined" ? HTMLElement : class {}
class VueElement extends BaseClass {
    constructor(e, n = {}, i) {
        super(),
            (this._def = e),
            (this._props = n),
            (this._instance = null),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            this.shadowRoot && i ? i(this._createVNode(), this.shadowRoot) : this.attachShadow({ mode: "open" })
    }
    connectedCallback() {
        ;(this._connected = !0), this._instance || this._resolveDef()
    }
    disconnectedCallback() {
        ;(this._connected = !1),
            nextTick(() => {
                this._connected || (render(null, this.shadowRoot), (this._instance = null))
            })
    }
    _resolveDef() {
        if (this._resolved) return
        this._resolved = !0
        for (let i = 0; i < this.attributes.length; i++) this._setAttr(this.attributes[i].name)
        new MutationObserver((i) => {
            for (const o of i) this._setAttr(o.attributeName)
        }).observe(this, { attributes: !0 })
        const e = (i) => {
                const { props: o, styles: a } = i,
                    l = !isArray$1(o),
                    c = o ? (l ? Object.keys(o) : o) : []
                let g
                if (l)
                    for (const v in this._props) {
                        const _ = o[v]
                        ;(_ === Number || (_ && _.type === Number)) &&
                            ((this._props[v] = toNumber(this._props[v])), ((g || (g = Object.create(null)))[v] = !0))
                    }
                this._numberProps = g
                for (const v of Object.keys(this)) v[0] !== "_" && this._setProp(v, this[v], !0, !1)
                for (const v of c.map(camelize))
                    Object.defineProperty(this, v, {
                        get() {
                            return this._getProp(v)
                        },
                        set(_) {
                            this._setProp(v, _)
                        },
                    })
                this._applyStyles(a), this._update()
            },
            n = this._def.__asyncLoader
        n ? n().then(e) : e(this._def)
    }
    _setAttr(e) {
        let n = this.getAttribute(e)
        this._numberProps && this._numberProps[e] && (n = toNumber(n)), this._setProp(camelize(e), n, !1)
    }
    _getProp(e) {
        return this._props[e]
    }
    _setProp(e, n, i = !0, o = !0) {
        n !== this._props[e] &&
            ((this._props[e] = n),
            o && this._instance && this._update(),
            i &&
                (n === !0
                    ? this.setAttribute(hyphenate(e), "")
                    : typeof n == "string" || typeof n == "number"
                    ? this.setAttribute(hyphenate(e), n + "")
                    : n || this.removeAttribute(hyphenate(e))))
    }
    _update() {
        render(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const e = createVNode(this._def, extend({}, this._props))
        return (
            this._instance ||
                (e.ce = (n) => {
                    ;(this._instance = n),
                        (n.isCE = !0),
                        (n.emit = (o, ...a) => {
                            this.dispatchEvent(new CustomEvent(o, { detail: a }))
                        })
                    let i = this
                    for (; (i = i && (i.parentNode || i.host)); )
                        if (i instanceof VueElement) {
                            n.parent = i._instance
                            break
                        }
                }),
            e
        )
    }
    _applyStyles(e) {
        e &&
            e.forEach((n) => {
                const i = document.createElement("style")
                ;(i.textContent = n), this.shadowRoot.appendChild(i)
            })
    }
}
function useCssModule(t = "$style") {
    {
        const e = getCurrentInstance()
        if (!e) return EMPTY_OBJ
        const n = e.type.__cssModules
        if (!n) return EMPTY_OBJ
        const i = n[t]
        return i || EMPTY_OBJ
    }
}
function useCssVars(t) {
    const e = getCurrentInstance()
    if (!e) return
    const n = () => setVarsOnVNode(e.subTree, t(e.proxy))
    watchPostEffect(n),
        onMounted(() => {
            const i = new MutationObserver(n)
            i.observe(e.subTree.el.parentNode, { childList: !0 }), onUnmounted(() => i.disconnect())
        })
}
function setVarsOnVNode(t, e) {
    if (t.shapeFlag & 128) {
        const n = t.suspense
        ;(t = n.activeBranch),
            n.pendingBranch &&
                !n.isHydrating &&
                n.effects.push(() => {
                    setVarsOnVNode(n.activeBranch, e)
                })
    }
    for (; t.component; ) t = t.component.subTree
    if (t.shapeFlag & 1 && t.el) setVarsOnNode(t.el, e)
    else if (t.type === Fragment$1) t.children.forEach((n) => setVarsOnVNode(n, e))
    else if (t.type === Static) {
        let { el: n, anchor: i } = t
        for (; n && (setVarsOnNode(n, e), n !== i); ) n = n.nextSibling
    }
}
function setVarsOnNode(t, e) {
    if (t.nodeType === 1) {
        const n = t.style
        for (const i in e) n.setProperty(`--${i}`, e[i])
    }
}
const TRANSITION = "transition",
    ANIMATION = "animation",
    Transition = (t, { slots: e }) => h$1(BaseTransition, resolveTransitionProps(t), e)
Transition.displayName = "Transition"
const DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
    },
    TransitionPropsValidators = (Transition.props = extend({}, BaseTransition.props, DOMTransitionPropsValidators)),
    callHook = (t, e = []) => {
        isArray$1(t) ? t.forEach((n) => n(...e)) : t && t(...e)
    },
    hasExplicitCallback = (t) => (t ? (isArray$1(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1)
function resolveTransitionProps(t) {
    const e = {}
    for (const Ae in t) Ae in DOMTransitionPropsValidators || (e[Ae] = t[Ae])
    if (t.css === !1) return e
    const {
            name: n = "v",
            type: i,
            duration: o,
            enterFromClass: a = `${n}-enter-from`,
            enterActiveClass: l = `${n}-enter-active`,
            enterToClass: c = `${n}-enter-to`,
            appearFromClass: g = a,
            appearActiveClass: v = l,
            appearToClass: _ = c,
            leaveFromClass: A = `${n}-leave-from`,
            leaveActiveClass: B = `${n}-leave-active`,
            leaveToClass: D = `${n}-leave-to`,
        } = t,
        I = normalizeDuration(o),
        L = I && I[0],
        G = I && I[1],
        {
            onBeforeEnter: U,
            onEnter: F,
            onEnterCancelled: Z,
            onLeave: Y,
            onLeaveCancelled: X,
            onBeforeAppear: ie = U,
            onAppear: he = F,
            onAppearCancelled: oe = Z,
        } = e,
        le = (Ae, O, u) => {
            removeTransitionClass(Ae, O ? _ : c), removeTransitionClass(Ae, O ? v : l), u && u()
        },
        Te = (Ae, O) => {
            ;(Ae._isLeaving = !1), removeTransitionClass(Ae, A), removeTransitionClass(Ae, D), removeTransitionClass(Ae, B), O && O()
        },
        ye = (Ae) => (O, u) => {
            const E = Ae ? he : F,
                $ = () => le(O, Ae, u)
            callHook(E, [O, $]),
                nextFrame(() => {
                    removeTransitionClass(O, Ae ? g : a),
                        addTransitionClass(O, Ae ? _ : c),
                        hasExplicitCallback(E) || whenTransitionEnds(O, i, L, $)
                })
        }
    return extend(e, {
        onBeforeEnter(Ae) {
            callHook(U, [Ae]), addTransitionClass(Ae, a), addTransitionClass(Ae, l)
        },
        onBeforeAppear(Ae) {
            callHook(ie, [Ae]), addTransitionClass(Ae, g), addTransitionClass(Ae, v)
        },
        onEnter: ye(!1),
        onAppear: ye(!0),
        onLeave(Ae, O) {
            Ae._isLeaving = !0
            const u = () => Te(Ae, O)
            addTransitionClass(Ae, A),
                forceReflow(),
                addTransitionClass(Ae, B),
                nextFrame(() => {
                    !Ae._isLeaving ||
                        (removeTransitionClass(Ae, A), addTransitionClass(Ae, D), hasExplicitCallback(Y) || whenTransitionEnds(Ae, i, G, u))
                }),
                callHook(Y, [Ae, u])
        },
        onEnterCancelled(Ae) {
            le(Ae, !1), callHook(Z, [Ae])
        },
        onAppearCancelled(Ae) {
            le(Ae, !0), callHook(oe, [Ae])
        },
        onLeaveCancelled(Ae) {
            Te(Ae), callHook(X, [Ae])
        },
    })
}
function normalizeDuration(t) {
    if (t == null) return null
    if (isObject(t)) return [NumberOf(t.enter), NumberOf(t.leave)]
    {
        const e = NumberOf(t)
        return [e, e]
    }
}
function NumberOf(t) {
    return toNumber(t)
}
function addTransitionClass(t, e) {
    e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set())).add(e)
}
function removeTransitionClass(t, e) {
    e.split(/\s+/).forEach((i) => i && t.classList.remove(i))
    const { _vtc: n } = t
    n && (n.delete(e), n.size || (t._vtc = void 0))
}
function nextFrame(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let endId = 0
function whenTransitionEnds(t, e, n, i) {
    const o = (t._endId = ++endId),
        a = () => {
            o === t._endId && i()
        }
    if (n) return setTimeout(a, n)
    const { type: l, timeout: c, propCount: g } = getTransitionInfo(t, e)
    if (!l) return i()
    const v = l + "end"
    let _ = 0
    const A = () => {
            t.removeEventListener(v, B), a()
        },
        B = (D) => {
            D.target === t && ++_ >= g && A()
        }
    setTimeout(() => {
        _ < g && A()
    }, c + 1),
        t.addEventListener(v, B)
}
function getTransitionInfo(t, e) {
    const n = window.getComputedStyle(t),
        i = (I) => (n[I] || "").split(", "),
        o = i(TRANSITION + "Delay"),
        a = i(TRANSITION + "Duration"),
        l = getTimeout(o, a),
        c = i(ANIMATION + "Delay"),
        g = i(ANIMATION + "Duration"),
        v = getTimeout(c, g)
    let _ = null,
        A = 0,
        B = 0
    e === TRANSITION
        ? l > 0 && ((_ = TRANSITION), (A = l), (B = a.length))
        : e === ANIMATION
        ? v > 0 && ((_ = ANIMATION), (A = v), (B = g.length))
        : ((A = Math.max(l, v)), (_ = A > 0 ? (l > v ? TRANSITION : ANIMATION) : null), (B = _ ? (_ === TRANSITION ? a.length : g.length) : 0))
    const D = _ === TRANSITION && /\b(transform|all)(,|$)/.test(n[TRANSITION + "Property"])
    return { type: _, timeout: A, propCount: B, hasTransform: D }
}
function getTimeout(t, e) {
    for (; t.length < e.length; ) t = t.concat(t)
    return Math.max(...e.map((n, i) => toMs(n) + toMs(t[i])))
}
function toMs(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}
function forceReflow() {
    return document.body.offsetHeight
}
const positionMap = new WeakMap(),
    newPositionMap = new WeakMap(),
    TransitionGroupImpl = {
        name: "TransitionGroup",
        props: extend({}, TransitionPropsValidators, { tag: String, moveClass: String }),
        setup(t, { slots: e }) {
            const n = getCurrentInstance(),
                i = useTransitionState()
            let o, a
            return (
                onUpdated(() => {
                    if (!o.length) return
                    const l = t.moveClass || `${t.name || "v"}-move`
                    if (!hasCSSTransform(o[0].el, n.vnode.el, l)) return
                    o.forEach(callPendingCbs), o.forEach(recordPosition)
                    const c = o.filter(applyTranslation)
                    forceReflow(),
                        c.forEach((g) => {
                            const v = g.el,
                                _ = v.style
                            addTransitionClass(v, l), (_.transform = _.webkitTransform = _.transitionDuration = "")
                            const A = (v._moveCb = (B) => {
                                ;(B && B.target !== v) ||
                                    ((!B || /transform$/.test(B.propertyName)) &&
                                        (v.removeEventListener("transitionend", A), (v._moveCb = null), removeTransitionClass(v, l)))
                            })
                            v.addEventListener("transitionend", A)
                        })
                }),
                () => {
                    const l = toRaw(t),
                        c = resolveTransitionProps(l)
                    let g = l.tag || Fragment$1
                    ;(o = a), (a = e.default ? getTransitionRawChildren(e.default()) : [])
                    for (let v = 0; v < a.length; v++) {
                        const _ = a[v]
                        _.key != null && setTransitionHooks(_, resolveTransitionHooks(_, c, i, n))
                    }
                    if (o)
                        for (let v = 0; v < o.length; v++) {
                            const _ = o[v]
                            setTransitionHooks(_, resolveTransitionHooks(_, c, i, n)), positionMap.set(_, _.el.getBoundingClientRect())
                        }
                    return createVNode(g, null, a)
                }
            )
        },
    },
    TransitionGroup = TransitionGroupImpl
function callPendingCbs(t) {
    const e = t.el
    e._moveCb && e._moveCb(), e._enterCb && e._enterCb()
}
function recordPosition(t) {
    newPositionMap.set(t, t.el.getBoundingClientRect())
}
function applyTranslation(t) {
    const e = positionMap.get(t),
        n = newPositionMap.get(t),
        i = e.left - n.left,
        o = e.top - n.top
    if (i || o) {
        const a = t.el.style
        return (a.transform = a.webkitTransform = `translate(${i}px,${o}px)`), (a.transitionDuration = "0s"), t
    }
}
function hasCSSTransform(t, e, n) {
    const i = t.cloneNode()
    t._vtc &&
        t._vtc.forEach((l) => {
            l.split(/\s+/).forEach((c) => c && i.classList.remove(c))
        }),
        n.split(/\s+/).forEach((l) => l && i.classList.add(l)),
        (i.style.display = "none")
    const o = e.nodeType === 1 ? e : e.parentNode
    o.appendChild(i)
    const { hasTransform: a } = getTransitionInfo(i)
    return o.removeChild(i), a
}
const getModelAssigner = (t) => {
    const e = t.props["onUpdate:modelValue"] || !1
    return isArray$1(e) ? (n) => invokeArrayFns(e, n) : e
}
function onCompositionStart(t) {
    t.target.composing = !0
}
function onCompositionEnd(t) {
    const e = t.target
    e.composing && ((e.composing = !1), e.dispatchEvent(new Event("input")))
}
const vModelText = {
        created(t, { modifiers: { lazy: e, trim: n, number: i } }, o) {
            t._assign = getModelAssigner(o)
            const a = i || (o.props && o.props.type === "number")
            addEventListener(t, e ? "change" : "input", (l) => {
                if (l.target.composing) return
                let c = t.value
                n && (c = c.trim()), a && (c = toNumber(c)), t._assign(c)
            }),
                n &&
                    addEventListener(t, "change", () => {
                        t.value = t.value.trim()
                    }),
                e ||
                    (addEventListener(t, "compositionstart", onCompositionStart),
                    addEventListener(t, "compositionend", onCompositionEnd),
                    addEventListener(t, "change", onCompositionEnd))
        },
        mounted(t, { value: e }) {
            t.value = e == null ? "" : e
        },
        beforeUpdate(t, { value: e, modifiers: { lazy: n, trim: i, number: o } }, a) {
            if (
                ((t._assign = getModelAssigner(a)),
                t.composing ||
                    (document.activeElement === t &&
                        t.type !== "range" &&
                        (n || (i && t.value.trim() === e) || ((o || t.type === "number") && toNumber(t.value) === e))))
            )
                return
            const l = e == null ? "" : e
            t.value !== l && (t.value = l)
        },
    },
    vModelCheckbox = {
        deep: !0,
        created(t, e, n) {
            ;(t._assign = getModelAssigner(n)),
                addEventListener(t, "change", () => {
                    const i = t._modelValue,
                        o = getValue(t),
                        a = t.checked,
                        l = t._assign
                    if (isArray$1(i)) {
                        const c = looseIndexOf(i, o),
                            g = c !== -1
                        if (a && !g) l(i.concat(o))
                        else if (!a && g) {
                            const v = [...i]
                            v.splice(c, 1), l(v)
                        }
                    } else if (isSet(i)) {
                        const c = new Set(i)
                        a ? c.add(o) : c.delete(o), l(c)
                    } else l(getCheckboxValue(t, a))
                })
        },
        mounted: setChecked,
        beforeUpdate(t, e, n) {
            ;(t._assign = getModelAssigner(n)), setChecked(t, e, n)
        },
    }
function setChecked(t, { value: e, oldValue: n }, i) {
    ;(t._modelValue = e),
        isArray$1(e)
            ? (t.checked = looseIndexOf(e, i.props.value) > -1)
            : isSet(e)
            ? (t.checked = e.has(i.props.value))
            : e !== n && (t.checked = looseEqual(e, getCheckboxValue(t, !0)))
}
const vModelRadio = {
        created(t, { value: e }, n) {
            ;(t.checked = looseEqual(e, n.props.value)),
                (t._assign = getModelAssigner(n)),
                addEventListener(t, "change", () => {
                    t._assign(getValue(t))
                })
        },
        beforeUpdate(t, { value: e, oldValue: n }, i) {
            ;(t._assign = getModelAssigner(i)), e !== n && (t.checked = looseEqual(e, i.props.value))
        },
    },
    vModelSelect = {
        deep: !0,
        created(t, { value: e, modifiers: { number: n } }, i) {
            const o = isSet(e)
            addEventListener(t, "change", () => {
                const a = Array.prototype.filter.call(t.options, (l) => l.selected).map((l) => (n ? toNumber(getValue(l)) : getValue(l)))
                t._assign(t.multiple ? (o ? new Set(a) : a) : a[0])
            }),
                (t._assign = getModelAssigner(i))
        },
        mounted(t, { value: e }) {
            setSelected(t, e)
        },
        beforeUpdate(t, e, n) {
            t._assign = getModelAssigner(n)
        },
        updated(t, { value: e }) {
            setSelected(t, e)
        },
    }
function setSelected(t, e) {
    const n = t.multiple
    if (!(n && !isArray$1(e) && !isSet(e))) {
        for (let i = 0, o = t.options.length; i < o; i++) {
            const a = t.options[i],
                l = getValue(a)
            if (n) isArray$1(e) ? (a.selected = looseIndexOf(e, l) > -1) : (a.selected = e.has(l))
            else if (looseEqual(getValue(a), e)) {
                t.selectedIndex !== i && (t.selectedIndex = i)
                return
            }
        }
        !n && t.selectedIndex !== -1 && (t.selectedIndex = -1)
    }
}
function getValue(t) {
    return "_value" in t ? t._value : t.value
}
function getCheckboxValue(t, e) {
    const n = e ? "_trueValue" : "_falseValue"
    return n in t ? t[n] : e
}
const vModelDynamic = {
    created(t, e, n) {
        callModelHook(t, e, n, null, "created")
    },
    mounted(t, e, n) {
        callModelHook(t, e, n, null, "mounted")
    },
    beforeUpdate(t, e, n, i) {
        callModelHook(t, e, n, i, "beforeUpdate")
    },
    updated(t, e, n, i) {
        callModelHook(t, e, n, i, "updated")
    },
}
function resolveDynamicModel(t, e) {
    switch (t) {
        case "SELECT":
            return vModelSelect
        case "TEXTAREA":
            return vModelText
        default:
            switch (e) {
                case "checkbox":
                    return vModelCheckbox
                case "radio":
                    return vModelRadio
                default:
                    return vModelText
            }
    }
}
function callModelHook(t, e, n, i, o) {
    const l = resolveDynamicModel(t.tagName, n.props && n.props.type)[o]
    l && l(t, e, n, i)
}
function initVModelForSSR() {
    ;(vModelText.getSSRProps = ({ value: t }) => ({ value: t })),
        (vModelRadio.getSSRProps = ({ value: t }, e) => {
            if (e.props && looseEqual(e.props.value, t)) return { checked: !0 }
        }),
        (vModelCheckbox.getSSRProps = ({ value: t }, e) => {
            if (isArray$1(t)) {
                if (e.props && looseIndexOf(t, e.props.value) > -1) return { checked: !0 }
            } else if (isSet(t)) {
                if (e.props && t.has(e.props.value)) return { checked: !0 }
            } else if (t) return { checked: !0 }
        }),
        (vModelDynamic.getSSRProps = (t, e) => {
            if (typeof e.type != "string") return
            const n = resolveDynamicModel(e.type.toUpperCase(), e.props && e.props.type)
            if (n.getSSRProps) return n.getSSRProps(t, e)
        })
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"],
    modifierGuards = {
        stop: (t) => t.stopPropagation(),
        prevent: (t) => t.preventDefault(),
        self: (t) => t.target !== t.currentTarget,
        ctrl: (t) => !t.ctrlKey,
        shift: (t) => !t.shiftKey,
        alt: (t) => !t.altKey,
        meta: (t) => !t.metaKey,
        left: (t) => "button" in t && t.button !== 0,
        middle: (t) => "button" in t && t.button !== 1,
        right: (t) => "button" in t && t.button !== 2,
        exact: (t, e) => systemModifiers.some((n) => t[`${n}Key`] && !e.includes(n)),
    },
    withModifiers =
        (t, e) =>
        (n, ...i) => {
            for (let o = 0; o < e.length; o++) {
                const a = modifierGuards[e[o]]
                if (a && a(n, e)) return
            }
            return t(n, ...i)
        },
    keyNames = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" },
    withKeys = (t, e) => (n) => {
        if (!("key" in n)) return
        const i = hyphenate(n.key)
        if (e.some((o) => o === i || keyNames[o] === i)) return t(n)
    },
    vShow = {
        beforeMount(t, { value: e }, { transition: n }) {
            ;(t._vod = t.style.display === "none" ? "" : t.style.display), n && e ? n.beforeEnter(t) : setDisplay(t, e)
        },
        mounted(t, { value: e }, { transition: n }) {
            n && e && n.enter(t)
        },
        updated(t, { value: e, oldValue: n }, { transition: i }) {
            !e != !n &&
                (i
                    ? e
                        ? (i.beforeEnter(t), setDisplay(t, !0), i.enter(t))
                        : i.leave(t, () => {
                              setDisplay(t, !1)
                          })
                    : setDisplay(t, e))
        },
        beforeUnmount(t, { value: e }) {
            setDisplay(t, e)
        },
    }
function setDisplay(t, e) {
    t.style.display = e ? t._vod : "none"
}
function initVShowForSSR() {
    vShow.getSSRProps = ({ value: t }) => {
        if (!t) return { style: { display: "none" } }
    }
}
const rendererOptions = extend({ patchProp }, nodeOps)
let renderer,
    enabledHydration = !1
function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions))
}
function ensureHydrationRenderer() {
    return (renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions)), (enabledHydration = !0), renderer
}
const render = (...t) => {
        ensureRenderer().render(...t)
    },
    hydrate = (...t) => {
        ensureHydrationRenderer().hydrate(...t)
    },
    createApp = (...t) => {
        const e = ensureRenderer().createApp(...t),
            { mount: n } = e
        return (
            (e.mount = (i) => {
                const o = normalizeContainer(i)
                if (!o) return
                const a = e._component
                !isFunction(a) && !a.render && !a.template && (a.template = o.innerHTML), (o.innerHTML = "")
                const l = n(o, !1, o instanceof SVGElement)
                return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), l
            }),
            e
        )
    },
    createSSRApp = (...t) => {
        const e = ensureHydrationRenderer().createApp(...t),
            { mount: n } = e
        return (
            (e.mount = (i) => {
                const o = normalizeContainer(i)
                if (o) return n(o, !0, o instanceof SVGElement)
            }),
            e
        )
    }
function normalizeContainer(t) {
    return isString(t) ? document.querySelector(t) : t
}
let ssrDirectiveInitialized = !1
const initDirectivesForSSR = () => {
        ssrDirectiveInitialized || ((ssrDirectiveInitialized = !0), initVModelForSSR(), initVShowForSSR())
    },
    compile = () => {}
var vue_runtime_esmBundler = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            compile,
            EffectScope,
            ReactiveEffect,
            customRef,
            effect: effect$3,
            effectScope,
            getCurrentScope,
            isProxy,
            isReactive,
            isReadonly,
            isRef,
            isShallow,
            markRaw,
            onScopeDispose,
            proxyRefs,
            reactive,
            readonly: readonly$1,
            ref,
            shallowReactive,
            shallowReadonly,
            shallowRef,
            stop,
            toRaw,
            toRef,
            toRefs,
            triggerRef,
            unref,
            camelize,
            capitalize,
            normalizeClass,
            normalizeProps,
            normalizeStyle,
            toDisplayString,
            toHandlerKey,
            BaseTransition,
            Comment,
            Fragment: Fragment$1,
            KeepAlive,
            Static,
            Suspense,
            Teleport,
            Text,
            callWithAsyncErrorHandling,
            callWithErrorHandling,
            cloneVNode,
            compatUtils,
            computed,
            createBlock: createBlock$1,
            createCommentVNode,
            createElementBlock,
            createElementVNode: createBaseVNode,
            createHydrationRenderer,
            createPropsRestProxy,
            createRenderer,
            createSlots,
            createStaticVNode,
            createTextVNode,
            createVNode,
            defineAsyncComponent,
            defineComponent,
            defineEmits,
            defineExpose,
            defineProps,
            get devtools() {
                return devtools
            },
            getCurrentInstance,
            getTransitionRawChildren,
            guardReactiveProps,
            h: h$1,
            handleError,
            initCustomFormatter,
            inject,
            isMemoSame,
            isRuntimeOnly,
            isVNode,
            mergeDefaults,
            mergeProps,
            nextTick,
            onActivated,
            onBeforeMount,
            onBeforeUnmount,
            onBeforeUpdate,
            onDeactivated,
            onErrorCaptured,
            onMounted,
            onRenderTracked,
            onRenderTriggered,
            onServerPrefetch,
            onUnmounted,
            onUpdated,
            openBlock,
            popScopeId,
            provide,
            pushScopeId,
            queuePostFlushCb,
            registerRuntimeCompiler,
            renderList,
            renderSlot,
            resolveComponent,
            resolveDirective,
            resolveDynamicComponent,
            resolveFilter,
            resolveTransitionHooks,
            setBlockTracking,
            setDevtoolsHook,
            setTransitionHooks,
            ssrContextKey,
            ssrUtils,
            toHandlers,
            transformVNodeArgs,
            useAttrs,
            useSSRContext,
            useSlots,
            useTransitionState,
            version: version$k,
            warn,
            watch,
            watchEffect,
            watchPostEffect,
            watchSyncEffect,
            withAsyncContext,
            withCtx,
            withDefaults,
            withDirectives,
            withMemo,
            withScopeId,
            Transition,
            TransitionGroup,
            VueElement,
            createApp,
            createSSRApp,
            defineCustomElement,
            defineSSRCustomElement,
            hydrate,
            initDirectivesForSSR,
            render,
            useCssModule,
            useCssVars,
            vModelCheckbox,
            vModelDynamic,
            vModelRadio,
            vModelSelect,
            vModelText,
            vShow,
            withKeys,
            withModifiers,
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
)
/*!
 * vue-router v4.1.5
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */ const isBrowser = typeof window != "undefined"
function isESModule(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const assign$2 = Object.assign
function applyToParams(t, e) {
    const n = {}
    for (const i in e) {
        const o = e[i]
        n[i] = isArray(o) ? o.map(t) : t(o)
    }
    return n
}
const noop$2 = () => {},
    isArray = Array.isArray,
    TRAILING_SLASH_RE = /\/$/,
    removeTrailingSlash = (t) => t.replace(TRAILING_SLASH_RE, "")
function parseURL(t, e, n = "/") {
    let i,
        o = {},
        a = "",
        l = ""
    const c = e.indexOf("#")
    let g = e.indexOf("?")
    return (
        c < g && c >= 0 && (g = -1),
        g > -1 && ((i = e.slice(0, g)), (a = e.slice(g + 1, c > -1 ? c : e.length)), (o = t(a))),
        c > -1 && ((i = i || e.slice(0, c)), (l = e.slice(c, e.length))),
        (i = resolveRelativePath(i != null ? i : e, n)),
        { fullPath: i + (a && "?") + a + l, path: i, query: o, hash: l }
    )
}
function stringifyURL(t, e) {
    const n = e.query ? t(e.query) : ""
    return e.path + (n && "?") + n + (e.hash || "")
}
function stripBase(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}
function isSameRouteLocation(t, e, n) {
    const i = e.matched.length - 1,
        o = n.matched.length - 1
    return (
        i > -1 &&
        i === o &&
        isSameRouteRecord(e.matched[i], n.matched[o]) &&
        isSameRouteLocationParams(e.params, n.params) &&
        t(e.query) === t(n.query) &&
        e.hash === n.hash
    )
}
function isSameRouteRecord(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}
function isSameRouteLocationParams(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1
    for (const n in t) if (!isSameRouteLocationParamsValue(t[n], e[n])) return !1
    return !0
}
function isSameRouteLocationParamsValue(t, e) {
    return isArray(t) ? isEquivalentArray(t, e) : isArray(e) ? isEquivalentArray(e, t) : t === e
}
function isEquivalentArray(t, e) {
    return isArray(e) ? t.length === e.length && t.every((n, i) => n === e[i]) : t.length === 1 && t[0] === e
}
function resolveRelativePath(t, e) {
    if (t.startsWith("/")) return t
    if (!t) return e
    const n = e.split("/"),
        i = t.split("/")
    let o = n.length - 1,
        a,
        l
    for (a = 0; a < i.length; a++)
        if (((l = i[a]), l !== "."))
            if (l === "..") o > 1 && o--
            else break
    return n.slice(0, o).join("/") + "/" + i.slice(a - (a === i.length ? 1 : 0)).join("/")
}
var NavigationType
;(function (t) {
    ;(t.pop = "pop"), (t.push = "push")
})(NavigationType || (NavigationType = {}))
var NavigationDirection
;(function (t) {
    ;(t.back = "back"), (t.forward = "forward"), (t.unknown = "")
})(NavigationDirection || (NavigationDirection = {}))
function normalizeBase(t) {
    if (!t)
        if (isBrowser) {
            const e = document.querySelector("base")
            ;(t = (e && e.getAttribute("href")) || "/"), (t = t.replace(/^\w+:\/\/[^\/]+/, ""))
        } else t = "/"
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), removeTrailingSlash(t)
}
const BEFORE_HASH_RE = /^[^#]+#/
function createHref(t, e) {
    return t.replace(BEFORE_HASH_RE, "#") + e
}
function getElementPosition(t, e) {
    const n = document.documentElement.getBoundingClientRect(),
        i = t.getBoundingClientRect()
    return { behavior: e.behavior, left: i.left - n.left - (e.left || 0), top: i.top - n.top - (e.top || 0) }
}
const computeScrollPosition = () => ({ left: window.pageXOffset, top: window.pageYOffset })
function scrollToPosition(t) {
    let e
    if ("el" in t) {
        const n = t.el,
            i = typeof n == "string" && n.startsWith("#"),
            o = typeof n == "string" ? (i ? document.getElementById(n.slice(1)) : document.querySelector(n)) : n
        if (!o) return
        e = getElementPosition(o, t)
    } else e = t
    "scrollBehavior" in document.documentElement.style
        ? window.scrollTo(e)
        : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}
function getScrollKey(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const scrollPositions = new Map()
function saveScrollPosition(t, e) {
    scrollPositions.set(t, e)
}
function getSavedScrollPosition(t) {
    const e = scrollPositions.get(t)
    return scrollPositions.delete(t), e
}
let createBaseLocation = () => location.protocol + "//" + location.host
function createCurrentLocation(t, e) {
    const { pathname: n, search: i, hash: o } = e,
        a = t.indexOf("#")
    if (a > -1) {
        let c = o.includes(t.slice(a)) ? t.slice(a).length : 1,
            g = o.slice(c)
        return g[0] !== "/" && (g = "/" + g), stripBase(g, "")
    }
    return stripBase(n, t) + i + o
}
function useHistoryListeners(t, e, n, i) {
    let o = [],
        a = [],
        l = null
    const c = ({ state: B }) => {
        const D = createCurrentLocation(t, location),
            I = n.value,
            L = e.value
        let G = 0
        if (B) {
            if (((n.value = D), (e.value = B), l && l === I)) {
                l = null
                return
            }
            G = L ? B.position - L.position : 0
        } else i(D)
        o.forEach((U) => {
            U(n.value, I, {
                delta: G,
                type: NavigationType.pop,
                direction: G ? (G > 0 ? NavigationDirection.forward : NavigationDirection.back) : NavigationDirection.unknown,
            })
        })
    }
    function g() {
        l = n.value
    }
    function v(B) {
        o.push(B)
        const D = () => {
            const I = o.indexOf(B)
            I > -1 && o.splice(I, 1)
        }
        return a.push(D), D
    }
    function _() {
        const { history: B } = window
        !B.state || B.replaceState(assign$2({}, B.state, { scroll: computeScrollPosition() }), "")
    }
    function A() {
        for (const B of a) B()
        ;(a = []), window.removeEventListener("popstate", c), window.removeEventListener("beforeunload", _)
    }
    return window.addEventListener("popstate", c), window.addEventListener("beforeunload", _), { pauseListeners: g, listen: v, destroy: A }
}
function buildState(t, e, n, i = !1, o = !1) {
    return { back: t, current: e, forward: n, replaced: i, position: window.history.length, scroll: o ? computeScrollPosition() : null }
}
function useHistoryStateNavigation(t) {
    const { history: e, location: n } = window,
        i = { value: createCurrentLocation(t, n) },
        o = { value: e.state }
    o.value || a(i.value, { back: null, current: i.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0)
    function a(g, v, _) {
        const A = t.indexOf("#"),
            B = A > -1 ? (n.host && document.querySelector("base") ? t : t.slice(A)) + g : createBaseLocation() + t + g
        try {
            e[_ ? "replaceState" : "pushState"](v, "", B), (o.value = v)
        } catch (D) {
            console.error(D), n[_ ? "replace" : "assign"](B)
        }
    }
    function l(g, v) {
        const _ = assign$2({}, e.state, buildState(o.value.back, g, o.value.forward, !0), v, { position: o.value.position })
        a(g, _, !0), (i.value = g)
    }
    function c(g, v) {
        const _ = assign$2({}, o.value, e.state, { forward: g, scroll: computeScrollPosition() })
        a(_.current, _, !0)
        const A = assign$2({}, buildState(i.value, g, null), { position: _.position + 1 }, v)
        a(g, A, !1), (i.value = g)
    }
    return { location: i, state: o, push: c, replace: l }
}
function createWebHistory(t) {
    t = normalizeBase(t)
    const e = useHistoryStateNavigation(t),
        n = useHistoryListeners(t, e.state, e.location, e.replace)
    function i(a, l = !0) {
        l || n.pauseListeners(), history.go(a)
    }
    const o = assign$2({ location: "", base: t, go: i, createHref: createHref.bind(null, t) }, e, n)
    return (
        Object.defineProperty(o, "location", { enumerable: !0, get: () => e.location.value }),
        Object.defineProperty(o, "state", { enumerable: !0, get: () => e.state.value }),
        o
    )
}
function isRouteLocation(t) {
    return typeof t == "string" || (t && typeof t == "object")
}
function isRouteName(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const START_LOCATION_NORMALIZED = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0,
    },
    NavigationFailureSymbol = Symbol("")
var NavigationFailureType
;(function (t) {
    ;(t[(t.aborted = 4)] = "aborted"), (t[(t.cancelled = 8)] = "cancelled"), (t[(t.duplicated = 16)] = "duplicated")
})(NavigationFailureType || (NavigationFailureType = {}))
function createRouterError(t, e) {
    return assign$2(new Error(), { type: t, [NavigationFailureSymbol]: !0 }, e)
}
function isNavigationFailure(t, e) {
    return t instanceof Error && NavigationFailureSymbol in t && (e == null || !!(t.type & e))
}
const BASE_PARAM_PATTERN = "[^/]+?",
    BASE_PATH_PARSER_OPTIONS = { sensitive: !1, strict: !1, start: !0, end: !0 },
    REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g
function tokensToParser(t, e) {
    const n = assign$2({}, BASE_PATH_PARSER_OPTIONS, e),
        i = []
    let o = n.start ? "^" : ""
    const a = []
    for (const v of t) {
        const _ = v.length ? [] : [90]
        n.strict && !v.length && (o += "/")
        for (let A = 0; A < v.length; A++) {
            const B = v[A]
            let D = 40 + (n.sensitive ? 0.25 : 0)
            if (B.type === 0) A || (o += "/"), (o += B.value.replace(REGEX_CHARS_RE, "\\$&")), (D += 40)
            else if (B.type === 1) {
                const { value: I, repeatable: L, optional: G, regexp: U } = B
                a.push({ name: I, repeatable: L, optional: G })
                const F = U || BASE_PARAM_PATTERN
                if (F !== BASE_PARAM_PATTERN) {
                    D += 10
                    try {
                        new RegExp(`(${F})`)
                    } catch (Y) {
                        throw new Error(`Invalid custom RegExp for param "${I}" (${F}): ` + Y.message)
                    }
                }
                let Z = L ? `((?:${F})(?:/(?:${F}))*)` : `(${F})`
                A || (Z = G && v.length < 2 ? `(?:/${Z})` : "/" + Z),
                    G && (Z += "?"),
                    (o += Z),
                    (D += 20),
                    G && (D += -8),
                    L && (D += -20),
                    F === ".*" && (D += -50)
            }
            _.push(D)
        }
        i.push(_)
    }
    if (n.strict && n.end) {
        const v = i.length - 1
        i[v][i[v].length - 1] += 0.7000000000000001
    }
    n.strict || (o += "/?"), n.end ? (o += "$") : n.strict && (o += "(?:/|$)")
    const l = new RegExp(o, n.sensitive ? "" : "i")
    function c(v) {
        const _ = v.match(l),
            A = {}
        if (!_) return null
        for (let B = 1; B < _.length; B++) {
            const D = _[B] || "",
                I = a[B - 1]
            A[I.name] = D && I.repeatable ? D.split("/") : D
        }
        return A
    }
    function g(v) {
        let _ = "",
            A = !1
        for (const B of t) {
            ;(!A || !_.endsWith("/")) && (_ += "/"), (A = !1)
            for (const D of B)
                if (D.type === 0) _ += D.value
                else if (D.type === 1) {
                    const { value: I, repeatable: L, optional: G } = D,
                        U = I in v ? v[I] : ""
                    if (isArray(U) && !L) throw new Error(`Provided param "${I}" is an array but it is not repeatable (* or + modifiers)`)
                    const F = isArray(U) ? U.join("/") : U
                    if (!F)
                        if (G) B.length < 2 && (_.endsWith("/") ? (_ = _.slice(0, -1)) : (A = !0))
                        else throw new Error(`Missing required param "${I}"`)
                    _ += F
                }
        }
        return _ || "/"
    }
    return { re: l, score: i, keys: a, parse: c, stringify: g }
}
function compareScoreArray(t, e) {
    let n = 0
    for (; n < t.length && n < e.length; ) {
        const i = e[n] - t[n]
        if (i) return i
        n++
    }
    return t.length < e.length
        ? t.length === 1 && t[0] === 40 + 40
            ? -1
            : 1
        : t.length > e.length
        ? e.length === 1 && e[0] === 40 + 40
            ? 1
            : -1
        : 0
}
function comparePathParserScore(t, e) {
    let n = 0
    const i = t.score,
        o = e.score
    for (; n < i.length && n < o.length; ) {
        const a = compareScoreArray(i[n], o[n])
        if (a) return a
        n++
    }
    if (Math.abs(o.length - i.length) === 1) {
        if (isLastScoreNegative(i)) return 1
        if (isLastScoreNegative(o)) return -1
    }
    return o.length - i.length
}
function isLastScoreNegative(t) {
    const e = t[t.length - 1]
    return t.length > 0 && e[e.length - 1] < 0
}
const ROOT_TOKEN = { type: 0, value: "" },
    VALID_PARAM_RE = /[a-zA-Z0-9_]/
function tokenizePath(t) {
    if (!t) return [[]]
    if (t === "/") return [[ROOT_TOKEN]]
    if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`)
    function e(D) {
        throw new Error(`ERR (${n})/"${v}": ${D}`)
    }
    let n = 0,
        i = n
    const o = []
    let a
    function l() {
        a && o.push(a), (a = [])
    }
    let c = 0,
        g,
        v = "",
        _ = ""
    function A() {
        !v ||
            (n === 0
                ? a.push({ type: 0, value: v })
                : n === 1 || n === 2 || n === 3
                ? (a.length > 1 && (g === "*" || g === "+") && e(`A repeatable param (${v}) must be alone in its segment. eg: '/:ids+.`),
                  a.push({ type: 1, value: v, regexp: _, repeatable: g === "*" || g === "+", optional: g === "*" || g === "?" }))
                : e("Invalid state to consume buffer"),
            (v = ""))
    }
    function B() {
        v += g
    }
    for (; c < t.length; ) {
        if (((g = t[c++]), g === "\\" && n !== 2)) {
            ;(i = n), (n = 4)
            continue
        }
        switch (n) {
            case 0:
                g === "/" ? (v && A(), l()) : g === ":" ? (A(), (n = 1)) : B()
                break
            case 4:
                B(), (n = i)
                break
            case 1:
                g === "(" ? (n = 2) : VALID_PARAM_RE.test(g) ? B() : (A(), (n = 0), g !== "*" && g !== "?" && g !== "+" && c--)
                break
            case 2:
                g === ")" ? (_[_.length - 1] == "\\" ? (_ = _.slice(0, -1) + g) : (n = 3)) : (_ += g)
                break
            case 3:
                A(), (n = 0), g !== "*" && g !== "?" && g !== "+" && c--, (_ = "")
                break
            default:
                e("Unknown state")
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${v}"`), A(), l(), o
}
function createRouteRecordMatcher(t, e, n) {
    const i = tokensToParser(tokenizePath(t.path), n),
        o = assign$2(i, { record: t, parent: e, children: [], alias: [] })
    return e && !o.record.aliasOf == !e.record.aliasOf && e.children.push(o), o
}
function createRouterMatcher(t, e) {
    const n = [],
        i = new Map()
    e = mergeOptions$1({ strict: !1, end: !0, sensitive: !1 }, e)
    function o(_) {
        return i.get(_)
    }
    function a(_, A, B) {
        const D = !B,
            I = normalizeRouteRecord(_)
        I.aliasOf = B && B.record
        const L = mergeOptions$1(e, _),
            G = [I]
        if ("alias" in _) {
            const Z = typeof _.alias == "string" ? [_.alias] : _.alias
            for (const Y of Z)
                G.push(assign$2({}, I, { components: B ? B.record.components : I.components, path: Y, aliasOf: B ? B.record : I }))
        }
        let U, F
        for (const Z of G) {
            const { path: Y } = Z
            if (A && Y[0] !== "/") {
                const X = A.record.path,
                    ie = X[X.length - 1] === "/" ? "" : "/"
                Z.path = A.record.path + (Y && ie + Y)
            }
            if (
                ((U = createRouteRecordMatcher(Z, A, L)),
                B ? B.alias.push(U) : ((F = F || U), F !== U && F.alias.push(U), D && _.name && !isAliasRecord(U) && l(_.name)),
                I.children)
            ) {
                const X = I.children
                for (let ie = 0; ie < X.length; ie++) a(X[ie], U, B && B.children[ie])
            }
            ;(B = B || U), g(U)
        }
        return F
            ? () => {
                  l(F)
              }
            : noop$2
    }
    function l(_) {
        if (isRouteName(_)) {
            const A = i.get(_)
            A && (i.delete(_), n.splice(n.indexOf(A), 1), A.children.forEach(l), A.alias.forEach(l))
        } else {
            const A = n.indexOf(_)
            A > -1 && (n.splice(A, 1), _.record.name && i.delete(_.record.name), _.children.forEach(l), _.alias.forEach(l))
        }
    }
    function c() {
        return n
    }
    function g(_) {
        let A = 0
        for (; A < n.length && comparePathParserScore(_, n[A]) >= 0 && (_.record.path !== n[A].record.path || !isRecordChildOf(_, n[A])); ) A++
        n.splice(A, 0, _), _.record.name && !isAliasRecord(_) && i.set(_.record.name, _)
    }
    function v(_, A) {
        let B,
            D = {},
            I,
            L
        if ("name" in _ && _.name) {
            if (((B = i.get(_.name)), !B)) throw createRouterError(1, { location: _ })
            ;(L = B.record.name),
                (D = assign$2(
                    paramsFromLocation(
                        A.params,
                        B.keys.filter((F) => !F.optional).map((F) => F.name)
                    ),
                    _.params &&
                        paramsFromLocation(
                            _.params,
                            B.keys.map((F) => F.name)
                        )
                )),
                (I = B.stringify(D))
        } else if ("path" in _) (I = _.path), (B = n.find((F) => F.re.test(I))), B && ((D = B.parse(I)), (L = B.record.name))
        else {
            if (((B = A.name ? i.get(A.name) : n.find((F) => F.re.test(A.path))), !B))
                throw createRouterError(1, { location: _, currentLocation: A })
            ;(L = B.record.name), (D = assign$2({}, A.params, _.params)), (I = B.stringify(D))
        }
        const G = []
        let U = B
        for (; U; ) G.unshift(U.record), (U = U.parent)
        return { name: L, path: I, params: D, matched: G, meta: mergeMetaFields(G) }
    }
    return t.forEach((_) => a(_)), { addRoute: a, resolve: v, removeRoute: l, getRoutes: c, getRecordMatcher: o }
}
function paramsFromLocation(t, e) {
    const n = {}
    for (const i of e) i in t && (n[i] = t[i])
    return n
}
function normalizeRouteRecord(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: normalizeRecordProps(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && { default: t.component },
    }
}
function normalizeRecordProps(t) {
    const e = {},
        n = t.props || !1
    if ("component" in t) e.default = n
    else for (const i in t.components) e[i] = typeof n == "boolean" ? n : n[i]
    return e
}
function isAliasRecord(t) {
    for (; t; ) {
        if (t.record.aliasOf) return !0
        t = t.parent
    }
    return !1
}
function mergeMetaFields(t) {
    return t.reduce((e, n) => assign$2(e, n.meta), {})
}
function mergeOptions$1(t, e) {
    const n = {}
    for (const i in t) n[i] = i in e ? e[i] : t[i]
    return n
}
function isRecordChildOf(t, e) {
    return e.children.some((n) => n === t || isRecordChildOf(t, n))
}
const HASH_RE = /#/g,
    AMPERSAND_RE = /&/g,
    SLASH_RE = /\//g,
    EQUAL_RE = /=/g,
    IM_RE = /\?/g,
    PLUS_RE = /\+/g,
    ENC_BRACKET_OPEN_RE = /%5B/g,
    ENC_BRACKET_CLOSE_RE = /%5D/g,
    ENC_CARET_RE = /%5E/g,
    ENC_BACKTICK_RE = /%60/g,
    ENC_CURLY_OPEN_RE = /%7B/g,
    ENC_PIPE_RE = /%7C/g,
    ENC_CURLY_CLOSE_RE = /%7D/g,
    ENC_SPACE_RE = /%20/g
function commonEncode(t) {
    return encodeURI("" + t)
        .replace(ENC_PIPE_RE, "|")
        .replace(ENC_BRACKET_OPEN_RE, "[")
        .replace(ENC_BRACKET_CLOSE_RE, "]")
}
function encodeHash(t) {
    return commonEncode(t).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^")
}
function encodeQueryValue(t) {
    return commonEncode(t)
        .replace(PLUS_RE, "%2B")
        .replace(ENC_SPACE_RE, "+")
        .replace(HASH_RE, "%23")
        .replace(AMPERSAND_RE, "%26")
        .replace(ENC_BACKTICK_RE, "`")
        .replace(ENC_CURLY_OPEN_RE, "{")
        .replace(ENC_CURLY_CLOSE_RE, "}")
        .replace(ENC_CARET_RE, "^")
}
function encodeQueryKey(t) {
    return encodeQueryValue(t).replace(EQUAL_RE, "%3D")
}
function encodePath(t) {
    return commonEncode(t).replace(HASH_RE, "%23").replace(IM_RE, "%3F")
}
function encodeParam$1(t) {
    return t == null ? "" : encodePath(t).replace(SLASH_RE, "%2F")
}
function decode$j(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {}
    return "" + t
}
function parseQuery(t) {
    const e = {}
    if (t === "" || t === "?") return e
    const i = (t[0] === "?" ? t.slice(1) : t).split("&")
    for (let o = 0; o < i.length; ++o) {
        const a = i[o].replace(PLUS_RE, " "),
            l = a.indexOf("="),
            c = decode$j(l < 0 ? a : a.slice(0, l)),
            g = l < 0 ? null : decode$j(a.slice(l + 1))
        if (c in e) {
            let v = e[c]
            isArray(v) || (v = e[c] = [v]), v.push(g)
        } else e[c] = g
    }
    return e
}
function stringifyQuery(t) {
    let e = ""
    for (let n in t) {
        const i = t[n]
        if (((n = encodeQueryKey(n)), i == null)) {
            i !== void 0 && (e += (e.length ? "&" : "") + n)
            continue
        }
        ;(isArray(i) ? i.map((a) => a && encodeQueryValue(a)) : [i && encodeQueryValue(i)]).forEach((a) => {
            a !== void 0 && ((e += (e.length ? "&" : "") + n), a != null && (e += "=" + a))
        })
    }
    return e
}
function normalizeQuery(t) {
    const e = {}
    for (const n in t) {
        const i = t[n]
        i !== void 0 && (e[n] = isArray(i) ? i.map((o) => (o == null ? null : "" + o)) : i == null ? i : "" + i)
    }
    return e
}
const matchedRouteKey = Symbol(""),
    viewDepthKey = Symbol(""),
    routerKey = Symbol(""),
    routeLocationKey = Symbol(""),
    routerViewLocationKey = Symbol("")
function useCallbacks() {
    let t = []
    function e(i) {
        return (
            t.push(i),
            () => {
                const o = t.indexOf(i)
                o > -1 && t.splice(o, 1)
            }
        )
    }
    function n() {
        t = []
    }
    return { add: e, list: () => t, reset: n }
}
function guardToPromiseFn(t, e, n, i, o) {
    const a = i && (i.enterCallbacks[o] = i.enterCallbacks[o] || [])
    return () =>
        new Promise((l, c) => {
            const g = (A) => {
                    A === !1
                        ? c(createRouterError(4, { from: n, to: e }))
                        : A instanceof Error
                        ? c(A)
                        : isRouteLocation(A)
                        ? c(createRouterError(2, { from: e, to: A }))
                        : (a && i.enterCallbacks[o] === a && typeof A == "function" && a.push(A), l())
                },
                v = t.call(i && i.instances[o], e, n, g)
            let _ = Promise.resolve(v)
            t.length < 3 && (_ = _.then(g)), _.catch((A) => c(A))
        })
}
function extractComponentsGuards(t, e, n, i) {
    const o = []
    for (const a of t)
        for (const l in a.components) {
            let c = a.components[l]
            if (!(e !== "beforeRouteEnter" && !a.instances[l]))
                if (isRouteComponent(c)) {
                    const v = (c.__vccOpts || c)[e]
                    v && o.push(guardToPromiseFn(v, n, i, a, l))
                } else {
                    let g = c()
                    o.push(() =>
                        g.then((v) => {
                            if (!v) return Promise.reject(new Error(`Couldn't resolve component "${l}" at "${a.path}"`))
                            const _ = isESModule(v) ? v.default : v
                            a.components[l] = _
                            const B = (_.__vccOpts || _)[e]
                            return B && guardToPromiseFn(B, n, i, a, l)()
                        })
                    )
                }
        }
    return o
}
function isRouteComponent(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}
function useLink(t) {
    const e = inject(routerKey),
        n = inject(routeLocationKey),
        i = computed(() => e.resolve(unref(t.to))),
        o = computed(() => {
            const { matched: g } = i.value,
                { length: v } = g,
                _ = g[v - 1],
                A = n.matched
            if (!_ || !A.length) return -1
            const B = A.findIndex(isSameRouteRecord.bind(null, _))
            if (B > -1) return B
            const D = getOriginalPath(g[v - 2])
            return v > 1 && getOriginalPath(_) === D && A[A.length - 1].path !== D ? A.findIndex(isSameRouteRecord.bind(null, g[v - 2])) : B
        }),
        a = computed(() => o.value > -1 && includesParams(n.params, i.value.params)),
        l = computed(() => o.value > -1 && o.value === n.matched.length - 1 && isSameRouteLocationParams(n.params, i.value.params))
    function c(g = {}) {
        return guardEvent(g) ? e[unref(t.replace) ? "replace" : "push"](unref(t.to)).catch(noop$2) : Promise.resolve()
    }
    return { route: i, href: computed(() => i.value.href), isActive: a, isExactActive: l, navigate: c }
}
const RouterLinkImpl = defineComponent({
        name: "RouterLink",
        compatConfig: { MODE: 3 },
        props: {
            to: { type: [String, Object], required: !0 },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: { type: String, default: "page" },
        },
        useLink,
        setup(t, { slots: e }) {
            const n = reactive(useLink(t)),
                { options: i } = inject(routerKey),
                o = computed(() => ({
                    [getLinkClass(t.activeClass, i.linkActiveClass, "router-link-active")]: n.isActive,
                    [getLinkClass(t.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive,
                }))
            return () => {
                const a = e.default && e.default(n)
                return t.custom
                    ? a
                    : h$1(
                          "a",
                          { "aria-current": n.isExactActive ? t.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: o.value },
                          a
                      )
            }
        },
    }),
    RouterLink = RouterLinkImpl
function guardEvent(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target")
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}
function includesParams(t, e) {
    for (const n in e) {
        const i = e[n],
            o = t[n]
        if (typeof i == "string") {
            if (i !== o) return !1
        } else if (!isArray(o) || o.length !== i.length || i.some((a, l) => a !== o[l])) return !1
    }
    return !0
}
function getOriginalPath(t) {
    return t ? (t.aliasOf ? t.aliasOf.path : t.path) : ""
}
const getLinkClass = (t, e, n) => (t != null ? t : e != null ? e : n),
    RouterViewImpl = defineComponent({
        name: "RouterView",
        inheritAttrs: !1,
        props: { name: { type: String, default: "default" }, route: Object },
        compatConfig: { MODE: 3 },
        setup(t, { attrs: e, slots: n }) {
            const i = inject(routerViewLocationKey),
                o = computed(() => t.route || i.value),
                a = inject(viewDepthKey, 0),
                l = computed(() => {
                    let v = unref(a)
                    const { matched: _ } = o.value
                    let A
                    for (; (A = _[v]) && !A.components; ) v++
                    return v
                }),
                c = computed(() => o.value.matched[l.value])
            provide(
                viewDepthKey,
                computed(() => l.value + 1)
            ),
                provide(matchedRouteKey, c),
                provide(routerViewLocationKey, o)
            const g = ref()
            return (
                watch(
                    () => [g.value, c.value, t.name],
                    ([v, _, A], [B, D, I]) => {
                        _ &&
                            ((_.instances[A] = v),
                            D &&
                                D !== _ &&
                                v &&
                                v === B &&
                                (_.leaveGuards.size || (_.leaveGuards = D.leaveGuards),
                                _.updateGuards.size || (_.updateGuards = D.updateGuards))),
                            v && _ && (!D || !isSameRouteRecord(_, D) || !B) && (_.enterCallbacks[A] || []).forEach((L) => L(v))
                    },
                    { flush: "post" }
                ),
                () => {
                    const v = o.value,
                        _ = t.name,
                        A = c.value,
                        B = A && A.components[_]
                    if (!B) return normalizeSlot(n.default, { Component: B, route: v })
                    const D = A.props[_],
                        I = D ? (D === !0 ? v.params : typeof D == "function" ? D(v) : D) : null,
                        G = h$1(
                            B,
                            assign$2({}, I, e, {
                                onVnodeUnmounted: (U) => {
                                    U.component.isUnmounted && (A.instances[_] = null)
                                },
                                ref: g,
                            })
                        )
                    return normalizeSlot(n.default, { Component: G, route: v }) || G
                }
            )
        },
    })
function normalizeSlot(t, e) {
    if (!t) return null
    const n = t(e)
    return n.length === 1 ? n[0] : n
}
const RouterView = RouterViewImpl
function createRouter(t) {
    const e = createRouterMatcher(t.routes, t),
        n = t.parseQuery || parseQuery,
        i = t.stringifyQuery || stringifyQuery,
        o = t.history,
        a = useCallbacks(),
        l = useCallbacks(),
        c = useCallbacks(),
        g = shallowRef(START_LOCATION_NORMALIZED)
    let v = START_LOCATION_NORMALIZED
    isBrowser && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual")
    const _ = applyToParams.bind(null, (k) => "" + k),
        A = applyToParams.bind(null, encodeParam$1),
        B = applyToParams.bind(null, decode$j)
    function D(k, W) {
        let J, ee
        return isRouteName(k) ? ((J = e.getRecordMatcher(k)), (ee = W)) : (ee = k), e.addRoute(ee, J)
    }
    function I(k) {
        const W = e.getRecordMatcher(k)
        W && e.removeRoute(W)
    }
    function L() {
        return e.getRoutes().map((k) => k.record)
    }
    function G(k) {
        return !!e.getRecordMatcher(k)
    }
    function U(k, W) {
        if (((W = assign$2({}, W || g.value)), typeof k == "string")) {
            const de = parseURL(n, k, W.path),
                H = e.resolve({ path: de.path }, W),
                j = o.createHref(de.fullPath)
            return assign$2(de, H, { params: B(H.params), hash: decode$j(de.hash), redirectedFrom: void 0, href: j })
        }
        let J
        if ("path" in k) J = assign$2({}, k, { path: parseURL(n, k.path, W.path).path })
        else {
            const de = assign$2({}, k.params)
            for (const H in de) de[H] == null && delete de[H]
            ;(J = assign$2({}, k, { params: A(k.params) })), (W.params = A(W.params))
        }
        const ee = e.resolve(J, W),
            ne = k.hash || ""
        ee.params = _(B(ee.params))
        const xe = stringifyURL(i, assign$2({}, k, { hash: encodeHash(ne), path: ee.path })),
            ce = o.createHref(xe)
        return assign$2({ fullPath: xe, hash: ne, query: i === stringifyQuery ? normalizeQuery(k.query) : k.query || {} }, ee, {
            redirectedFrom: void 0,
            href: ce,
        })
    }
    function F(k) {
        return typeof k == "string" ? parseURL(n, k, g.value.path) : assign$2({}, k)
    }
    function Z(k, W) {
        if (v !== k) return createRouterError(8, { from: W, to: k })
    }
    function Y(k) {
        return he(k)
    }
    function X(k) {
        return Y(assign$2(F(k), { replace: !0 }))
    }
    function ie(k) {
        const W = k.matched[k.matched.length - 1]
        if (W && W.redirect) {
            const { redirect: J } = W
            let ee = typeof J == "function" ? J(k) : J
            return (
                typeof ee == "string" && ((ee = ee.includes("?") || ee.includes("#") ? (ee = F(ee)) : { path: ee }), (ee.params = {})),
                assign$2({ query: k.query, hash: k.hash, params: "path" in ee ? {} : k.params }, ee)
            )
        }
    }
    function he(k, W) {
        const J = (v = U(k)),
            ee = g.value,
            ne = k.state,
            xe = k.force,
            ce = k.replace === !0,
            de = ie(J)
        if (de) return he(assign$2(F(de), { state: typeof de == "object" ? assign$2({}, ne, de.state) : ne, force: xe, replace: ce }), W || J)
        const H = J
        H.redirectedFrom = W
        let j
        return (
            !xe && isSameRouteLocation(i, ee, J) && ((j = createRouterError(16, { to: H, from: ee })), C(ee, ee, !0, !1)),
            (j ? Promise.resolve(j) : le(H, ee))
                .catch((q) => (isNavigationFailure(q) ? (isNavigationFailure(q, 2) ? q : R(q)) : N(q, H, ee)))
                .then((q) => {
                    if (q) {
                        if (isNavigationFailure(q, 2))
                            return he(
                                assign$2({ replace: ce }, F(q.to), {
                                    state: typeof q.to == "object" ? assign$2({}, ne, q.to.state) : ne,
                                    force: xe,
                                }),
                                W || H
                            )
                    } else q = ye(H, ee, !0, ce, ne)
                    return Te(H, ee, q), q
                })
        )
    }
    function oe(k, W) {
        const J = Z(k, W)
        return J ? Promise.reject(J) : Promise.resolve()
    }
    function le(k, W) {
        let J
        const [ee, ne, xe] = extractChangingRecords(k, W)
        J = extractComponentsGuards(ee.reverse(), "beforeRouteLeave", k, W)
        for (const de of ee)
            de.leaveGuards.forEach((H) => {
                J.push(guardToPromiseFn(H, k, W))
            })
        const ce = oe.bind(null, k, W)
        return (
            J.push(ce),
            runGuardQueue(J)
                .then(() => {
                    J = []
                    for (const de of a.list()) J.push(guardToPromiseFn(de, k, W))
                    return J.push(ce), runGuardQueue(J)
                })
                .then(() => {
                    J = extractComponentsGuards(ne, "beforeRouteUpdate", k, W)
                    for (const de of ne)
                        de.updateGuards.forEach((H) => {
                            J.push(guardToPromiseFn(H, k, W))
                        })
                    return J.push(ce), runGuardQueue(J)
                })
                .then(() => {
                    J = []
                    for (const de of k.matched)
                        if (de.beforeEnter && !W.matched.includes(de))
                            if (isArray(de.beforeEnter)) for (const H of de.beforeEnter) J.push(guardToPromiseFn(H, k, W))
                            else J.push(guardToPromiseFn(de.beforeEnter, k, W))
                    return J.push(ce), runGuardQueue(J)
                })
                .then(
                    () => (
                        k.matched.forEach((de) => (de.enterCallbacks = {})),
                        (J = extractComponentsGuards(xe, "beforeRouteEnter", k, W)),
                        J.push(ce),
                        runGuardQueue(J)
                    )
                )
                .then(() => {
                    J = []
                    for (const de of l.list()) J.push(guardToPromiseFn(de, k, W))
                    return J.push(ce), runGuardQueue(J)
                })
                .catch((de) => (isNavigationFailure(de, 8) ? de : Promise.reject(de)))
        )
    }
    function Te(k, W, J) {
        for (const ee of c.list()) ee(k, W, J)
    }
    function ye(k, W, J, ee, ne) {
        const xe = Z(k, W)
        if (xe) return xe
        const ce = W === START_LOCATION_NORMALIZED,
            de = isBrowser ? history.state : {}
        J && (ee || ce ? o.replace(k.fullPath, assign$2({ scroll: ce && de && de.scroll }, ne)) : o.push(k.fullPath, ne)),
            (g.value = k),
            C(k, W, J, ce),
            R()
    }
    let Ae
    function O() {
        Ae ||
            (Ae = o.listen((k, W, J) => {
                if (!Q.listening) return
                const ee = U(k),
                    ne = ie(ee)
                if (ne) {
                    he(assign$2(ne, { replace: !0 }), ee).catch(noop$2)
                    return
                }
                v = ee
                const xe = g.value
                isBrowser && saveScrollPosition(getScrollKey(xe.fullPath, J.delta), computeScrollPosition()),
                    le(ee, xe)
                        .catch((ce) =>
                            isNavigationFailure(ce, 12)
                                ? ce
                                : isNavigationFailure(ce, 2)
                                ? (he(ce.to, ee)
                                      .then((de) => {
                                          isNavigationFailure(de, 20) && !J.delta && J.type === NavigationType.pop && o.go(-1, !1)
                                      })
                                      .catch(noop$2),
                                  Promise.reject())
                                : (J.delta && o.go(-J.delta, !1), N(ce, ee, xe))
                        )
                        .then((ce) => {
                            ;(ce = ce || ye(ee, xe, !1)),
                                ce &&
                                    (J.delta && !isNavigationFailure(ce, 8)
                                        ? o.go(-J.delta, !1)
                                        : J.type === NavigationType.pop && isNavigationFailure(ce, 20) && o.go(-1, !1)),
                                Te(ee, xe, ce)
                        })
                        .catch(noop$2)
            }))
    }
    let u = useCallbacks(),
        E = useCallbacks(),
        $
    function N(k, W, J) {
        R(k)
        const ee = E.list()
        return ee.length ? ee.forEach((ne) => ne(k, W, J)) : console.error(k), Promise.reject(k)
    }
    function M() {
        return $ && g.value !== START_LOCATION_NORMALIZED
            ? Promise.resolve()
            : new Promise((k, W) => {
                  u.add([k, W])
              })
    }
    function R(k) {
        return $ || (($ = !k), O(), u.list().forEach(([W, J]) => (k ? J(k) : W())), u.reset()), k
    }
    function C(k, W, J, ee) {
        const { scrollBehavior: ne } = t
        if (!isBrowser || !ne) return Promise.resolve()
        const xe = (!J && getSavedScrollPosition(getScrollKey(k.fullPath, 0))) || ((ee || !J) && history.state && history.state.scroll) || null
        return nextTick()
            .then(() => ne(k, W, xe))
            .then((ce) => ce && scrollToPosition(ce))
            .catch((ce) => N(ce, k, W))
    }
    const S = (k) => o.go(k)
    let b
    const T = new Set(),
        Q = {
            currentRoute: g,
            listening: !0,
            addRoute: D,
            removeRoute: I,
            hasRoute: G,
            getRoutes: L,
            resolve: U,
            options: t,
            push: Y,
            replace: X,
            go: S,
            back: () => S(-1),
            forward: () => S(1),
            beforeEach: a.add,
            beforeResolve: l.add,
            afterEach: c.add,
            onError: E.add,
            isReady: M,
            install(k) {
                const W = this
                k.component("RouterLink", RouterLink),
                    k.component("RouterView", RouterView),
                    (k.config.globalProperties.$router = W),
                    Object.defineProperty(k.config.globalProperties, "$route", { enumerable: !0, get: () => unref(g) }),
                    isBrowser && !b && g.value === START_LOCATION_NORMALIZED && ((b = !0), Y(o.location).catch((ne) => {}))
                const J = {}
                for (const ne in START_LOCATION_NORMALIZED) J[ne] = computed(() => g.value[ne])
                k.provide(routerKey, W), k.provide(routeLocationKey, reactive(J)), k.provide(routerViewLocationKey, g)
                const ee = k.unmount
                T.add(k),
                    (k.unmount = function () {
                        T.delete(k),
                            T.size < 1 &&
                                ((v = START_LOCATION_NORMALIZED),
                                Ae && Ae(),
                                (Ae = null),
                                (g.value = START_LOCATION_NORMALIZED),
                                (b = !1),
                                ($ = !1)),
                            ee()
                    })
            },
        }
    return Q
}
function runGuardQueue(t) {
    return t.reduce((e, n) => e.then(() => n()), Promise.resolve())
}
function extractChangingRecords(t, e) {
    const n = [],
        i = [],
        o = [],
        a = Math.max(e.matched.length, t.matched.length)
    for (let l = 0; l < a; l++) {
        const c = e.matched[l]
        c && (t.matched.find((v) => isSameRouteRecord(v, c)) ? i.push(c) : n.push(c))
        const g = t.matched[l]
        g && (e.matched.find((v) => isSameRouteRecord(v, g)) || o.push(g))
    }
    return [n, i, o]
}
function useRouter() {
    return inject(routerKey)
}
function useRoute() {
    return inject(routeLocationKey)
}
var commonjsGlobal =
    typeof globalThis != "undefined"
        ? globalThis
        : typeof window != "undefined"
        ? window
        : typeof global != "undefined"
        ? global
        : typeof self != "undefined"
        ? self
        : {}
function getDefaultExportFromCjs(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function getAugmentedNamespace(t) {
    if (t.__esModule) return t
    var e = Object.defineProperty({}, "__esModule", { value: !0 })
    return (
        Object.keys(t).forEach(function (n) {
            var i = Object.getOwnPropertyDescriptor(t, n)
            Object.defineProperty(
                e,
                n,
                i.get
                    ? i
                    : {
                          enumerable: !0,
                          get: function () {
                              return t[n]
                          },
                      }
            )
        }),
        e
    )
}
function commonjsRequire$1(t) {
    throw new Error(
        'Could not dynamically require "' +
            t +
            '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
    )
}
var bn$2 = { exports: {} }
;(function (t) {
    ;(function (e, n) {
        function i(O, u) {
            if (!O) throw new Error(u || "Assertion failed")
        }
        function o(O, u) {
            O.super_ = u
            var E = function () {}
            ;(E.prototype = u.prototype), (O.prototype = new E()), (O.prototype.constructor = O)
        }
        function a(O, u, E) {
            if (a.isBN(O)) return O
            ;(this.negative = 0),
                (this.words = null),
                (this.length = 0),
                (this.red = null),
                O !== null && ((u === "le" || u === "be") && ((E = u), (u = 10)), this._init(O || 0, u || 10, E || "be"))
        }
        typeof e == "object" ? (e.exports = a) : (n.BN = a), (a.BN = a), (a.wordSize = 26)
        var l
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? (l = window.Buffer) : (l = require("buffer").Buffer)
        } catch {}
        ;(a.isBN = function (u) {
            return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words)
        }),
            (a.max = function (u, E) {
                return u.cmp(E) > 0 ? u : E
            }),
            (a.min = function (u, E) {
                return u.cmp(E) < 0 ? u : E
            }),
            (a.prototype._init = function (u, E, $) {
                if (typeof u == "number") return this._initNumber(u, E, $)
                if (typeof u == "object") return this._initArray(u, E, $)
                E === "hex" && (E = 16), i(E === (E | 0) && E >= 2 && E <= 36), (u = u.toString().replace(/\s+/g, ""))
                var N = 0
                u[0] === "-" && (N++, (this.negative = 1)),
                    N < u.length &&
                        (E === 16 ? this._parseHex(u, N, $) : (this._parseBase(u, E, N), $ === "le" && this._initArray(this.toArray(), E, $)))
            }),
            (a.prototype._initNumber = function (u, E, $) {
                u < 0 && ((this.negative = 1), (u = -u)),
                    u < 67108864
                        ? ((this.words = [u & 67108863]), (this.length = 1))
                        : u < 4503599627370496
                        ? ((this.words = [u & 67108863, (u / 67108864) & 67108863]), (this.length = 2))
                        : (i(u < 9007199254740992), (this.words = [u & 67108863, (u / 67108864) & 67108863, 1]), (this.length = 3)),
                    $ === "le" && this._initArray(this.toArray(), E, $)
            }),
            (a.prototype._initArray = function (u, E, $) {
                if ((i(typeof u.length == "number"), u.length <= 0)) return (this.words = [0]), (this.length = 1), this
                ;(this.length = Math.ceil(u.length / 3)), (this.words = new Array(this.length))
                for (var N = 0; N < this.length; N++) this.words[N] = 0
                var M,
                    R,
                    C = 0
                if ($ === "be")
                    for (N = u.length - 1, M = 0; N >= 0; N -= 3)
                        (R = u[N] | (u[N - 1] << 8) | (u[N - 2] << 16)),
                            (this.words[M] |= (R << C) & 67108863),
                            (this.words[M + 1] = (R >>> (26 - C)) & 67108863),
                            (C += 24),
                            C >= 26 && ((C -= 26), M++)
                else if ($ === "le")
                    for (N = 0, M = 0; N < u.length; N += 3)
                        (R = u[N] | (u[N + 1] << 8) | (u[N + 2] << 16)),
                            (this.words[M] |= (R << C) & 67108863),
                            (this.words[M + 1] = (R >>> (26 - C)) & 67108863),
                            (C += 24),
                            C >= 26 && ((C -= 26), M++)
                return this._strip()
            })
        function c(O, u) {
            var E = O.charCodeAt(u)
            if (E >= 48 && E <= 57) return E - 48
            if (E >= 65 && E <= 70) return E - 55
            if (E >= 97 && E <= 102) return E - 87
            i(!1, "Invalid character in " + O)
        }
        function g(O, u, E) {
            var $ = c(O, E)
            return E - 1 >= u && ($ |= c(O, E - 1) << 4), $
        }
        a.prototype._parseHex = function (u, E, $) {
            ;(this.length = Math.ceil((u.length - E) / 6)), (this.words = new Array(this.length))
            for (var N = 0; N < this.length; N++) this.words[N] = 0
            var M = 0,
                R = 0,
                C
            if ($ === "be")
                for (N = u.length - 1; N >= E; N -= 2)
                    (C = g(u, E, N) << M),
                        (this.words[R] |= C & 67108863),
                        M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= C >>> 26)) : (M += 8)
            else {
                var S = u.length - E
                for (N = S % 2 === 0 ? E + 1 : E; N < u.length; N += 2)
                    (C = g(u, E, N) << M),
                        (this.words[R] |= C & 67108863),
                        M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= C >>> 26)) : (M += 8)
            }
            this._strip()
        }
        function v(O, u, E, $) {
            for (var N = 0, M = 0, R = Math.min(O.length, E), C = u; C < R; C++) {
                var S = O.charCodeAt(C) - 48
                ;(N *= $), S >= 49 ? (M = S - 49 + 10) : S >= 17 ? (M = S - 17 + 10) : (M = S), i(S >= 0 && M < $, "Invalid character"), (N += M)
            }
            return N
        }
        ;(a.prototype._parseBase = function (u, E, $) {
            ;(this.words = [0]), (this.length = 1)
            for (var N = 0, M = 1; M <= 67108863; M *= E) N++
            N--, (M = (M / E) | 0)
            for (var R = u.length - $, C = R % N, S = Math.min(R, R - C) + $, b = 0, T = $; T < S; T += N)
                (b = v(u, T, T + N, E)), this.imuln(M), this.words[0] + b < 67108864 ? (this.words[0] += b) : this._iaddn(b)
            if (C !== 0) {
                var Q = 1
                for (b = v(u, T, u.length, E), T = 0; T < C; T++) Q *= E
                this.imuln(Q), this.words[0] + b < 67108864 ? (this.words[0] += b) : this._iaddn(b)
            }
            this._strip()
        }),
            (a.prototype.copy = function (u) {
                u.words = new Array(this.length)
                for (var E = 0; E < this.length; E++) u.words[E] = this.words[E]
                ;(u.length = this.length), (u.negative = this.negative), (u.red = this.red)
            })
        function _(O, u) {
            ;(O.words = u.words), (O.length = u.length), (O.negative = u.negative), (O.red = u.red)
        }
        if (
            ((a.prototype._move = function (u) {
                _(u, this)
            }),
            (a.prototype.clone = function () {
                var u = new a(null)
                return this.copy(u), u
            }),
            (a.prototype._expand = function (u) {
                for (; this.length < u; ) this.words[this.length++] = 0
                return this
            }),
            (a.prototype._strip = function () {
                for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                return this._normSign()
            }),
            (a.prototype._normSign = function () {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            typeof Symbol != "undefined" && typeof Symbol.for == "function")
        )
            try {
                a.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
            } catch {
                a.prototype.inspect = A
            }
        else a.prototype.inspect = A
        function A() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var B = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000",
            ],
            D = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            I = [
                0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
                11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
                17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ]
        ;(a.prototype.toString = function (u, E) {
            ;(u = u || 10), (E = E | 0 || 1)
            var $
            if (u === 16 || u === "hex") {
                $ = ""
                for (var N = 0, M = 0, R = 0; R < this.length; R++) {
                    var C = this.words[R],
                        S = (((C << N) | M) & 16777215).toString(16)
                    ;(M = (C >>> (24 - N)) & 16777215),
                        (N += 2),
                        N >= 26 && ((N -= 26), R--),
                        M !== 0 || R !== this.length - 1 ? ($ = B[6 - S.length] + S + $) : ($ = S + $)
                }
                for (M !== 0 && ($ = M.toString(16) + $); $.length % E !== 0; ) $ = "0" + $
                return this.negative !== 0 && ($ = "-" + $), $
            }
            if (u === (u | 0) && u >= 2 && u <= 36) {
                var b = D[u],
                    T = I[u]
                $ = ""
                var Q = this.clone()
                for (Q.negative = 0; !Q.isZero(); ) {
                    var k = Q.modrn(T).toString(u)
                    ;(Q = Q.idivn(T)), Q.isZero() ? ($ = k + $) : ($ = B[b - k.length] + k + $)
                }
                for (this.isZero() && ($ = "0" + $); $.length % E !== 0; ) $ = "0" + $
                return this.negative !== 0 && ($ = "-" + $), $
            }
            i(!1, "Base should be between 2 and 36")
        }),
            (a.prototype.toNumber = function () {
                var u = this.words[0]
                return (
                    this.length === 2
                        ? (u += this.words[1] * 67108864)
                        : this.length === 3 && this.words[2] === 1
                        ? (u += 4503599627370496 + this.words[1] * 67108864)
                        : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"),
                    this.negative !== 0 ? -u : u
                )
            }),
            (a.prototype.toJSON = function () {
                return this.toString(16, 2)
            }),
            l &&
                (a.prototype.toBuffer = function (u, E) {
                    return this.toArrayLike(l, u, E)
                }),
            (a.prototype.toArray = function (u, E) {
                return this.toArrayLike(Array, u, E)
            })
        var L = function (u, E) {
            return u.allocUnsafe ? u.allocUnsafe(E) : new u(E)
        }
        ;(a.prototype.toArrayLike = function (u, E, $) {
            this._strip()
            var N = this.byteLength(),
                M = $ || Math.max(1, N)
            i(N <= M, "byte array longer than desired length"), i(M > 0, "Requested array length <= 0")
            var R = L(u, M),
                C = E === "le" ? "LE" : "BE"
            return this["_toArrayLike" + C](R, N), R
        }),
            (a.prototype._toArrayLikeLE = function (u, E) {
                for (var $ = 0, N = 0, M = 0, R = 0; M < this.length; M++) {
                    var C = (this.words[M] << R) | N
                    ;(u[$++] = C & 255),
                        $ < u.length && (u[$++] = (C >> 8) & 255),
                        $ < u.length && (u[$++] = (C >> 16) & 255),
                        R === 6 ? ($ < u.length && (u[$++] = (C >> 24) & 255), (N = 0), (R = 0)) : ((N = C >>> 24), (R += 2))
                }
                if ($ < u.length) for (u[$++] = N; $ < u.length; ) u[$++] = 0
            }),
            (a.prototype._toArrayLikeBE = function (u, E) {
                for (var $ = u.length - 1, N = 0, M = 0, R = 0; M < this.length; M++) {
                    var C = (this.words[M] << R) | N
                    ;(u[$--] = C & 255),
                        $ >= 0 && (u[$--] = (C >> 8) & 255),
                        $ >= 0 && (u[$--] = (C >> 16) & 255),
                        R === 6 ? ($ >= 0 && (u[$--] = (C >> 24) & 255), (N = 0), (R = 0)) : ((N = C >>> 24), (R += 2))
                }
                if ($ >= 0) for (u[$--] = N; $ >= 0; ) u[$--] = 0
            }),
            Math.clz32
                ? (a.prototype._countBits = function (u) {
                      return 32 - Math.clz32(u)
                  })
                : (a.prototype._countBits = function (u) {
                      var E = u,
                          $ = 0
                      return (
                          E >= 4096 && (($ += 13), (E >>>= 13)),
                          E >= 64 && (($ += 7), (E >>>= 7)),
                          E >= 8 && (($ += 4), (E >>>= 4)),
                          E >= 2 && (($ += 2), (E >>>= 2)),
                          $ + E
                      )
                  }),
            (a.prototype._zeroBits = function (u) {
                if (u === 0) return 26
                var E = u,
                    $ = 0
                return (
                    (E & 8191) === 0 && (($ += 13), (E >>>= 13)),
                    (E & 127) === 0 && (($ += 7), (E >>>= 7)),
                    (E & 15) === 0 && (($ += 4), (E >>>= 4)),
                    (E & 3) === 0 && (($ += 2), (E >>>= 2)),
                    (E & 1) === 0 && $++,
                    $
                )
            }),
            (a.prototype.bitLength = function () {
                var u = this.words[this.length - 1],
                    E = this._countBits(u)
                return (this.length - 1) * 26 + E
            })
        function G(O) {
            for (var u = new Array(O.bitLength()), E = 0; E < u.length; E++) {
                var $ = (E / 26) | 0,
                    N = E % 26
                u[E] = (O.words[$] >>> N) & 1
            }
            return u
        }
        ;(a.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var u = 0, E = 0; E < this.length; E++) {
                var $ = this._zeroBits(this.words[E])
                if (((u += $), $ !== 26)) break
            }
            return u
        }),
            (a.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }),
            (a.prototype.toTwos = function (u) {
                return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone()
            }),
            (a.prototype.fromTwos = function (u) {
                return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone()
            }),
            (a.prototype.isNeg = function () {
                return this.negative !== 0
            }),
            (a.prototype.neg = function () {
                return this.clone().ineg()
            }),
            (a.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }),
            (a.prototype.iuor = function (u) {
                for (; this.length < u.length; ) this.words[this.length++] = 0
                for (var E = 0; E < u.length; E++) this.words[E] = this.words[E] | u.words[E]
                return this._strip()
            }),
            (a.prototype.ior = function (u) {
                return i((this.negative | u.negative) === 0), this.iuor(u)
            }),
            (a.prototype.or = function (u) {
                return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this)
            }),
            (a.prototype.uor = function (u) {
                return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this)
            }),
            (a.prototype.iuand = function (u) {
                var E
                this.length > u.length ? (E = u) : (E = this)
                for (var $ = 0; $ < E.length; $++) this.words[$] = this.words[$] & u.words[$]
                return (this.length = E.length), this._strip()
            }),
            (a.prototype.iand = function (u) {
                return i((this.negative | u.negative) === 0), this.iuand(u)
            }),
            (a.prototype.and = function (u) {
                return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this)
            }),
            (a.prototype.uand = function (u) {
                return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this)
            }),
            (a.prototype.iuxor = function (u) {
                var E, $
                this.length > u.length ? ((E = this), ($ = u)) : ((E = u), ($ = this))
                for (var N = 0; N < $.length; N++) this.words[N] = E.words[N] ^ $.words[N]
                if (this !== E) for (; N < E.length; N++) this.words[N] = E.words[N]
                return (this.length = E.length), this._strip()
            }),
            (a.prototype.ixor = function (u) {
                return i((this.negative | u.negative) === 0), this.iuxor(u)
            }),
            (a.prototype.xor = function (u) {
                return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this)
            }),
            (a.prototype.uxor = function (u) {
                return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this)
            }),
            (a.prototype.inotn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = Math.ceil(u / 26) | 0,
                    $ = u % 26
                this._expand(E), $ > 0 && E--
                for (var N = 0; N < E; N++) this.words[N] = ~this.words[N] & 67108863
                return $ > 0 && (this.words[N] = ~this.words[N] & (67108863 >> (26 - $))), this._strip()
            }),
            (a.prototype.notn = function (u) {
                return this.clone().inotn(u)
            }),
            (a.prototype.setn = function (u, E) {
                i(typeof u == "number" && u >= 0)
                var $ = (u / 26) | 0,
                    N = u % 26
                return (
                    this._expand($ + 1),
                    E ? (this.words[$] = this.words[$] | (1 << N)) : (this.words[$] = this.words[$] & ~(1 << N)),
                    this._strip()
                )
            }),
            (a.prototype.iadd = function (u) {
                var E
                if (this.negative !== 0 && u.negative === 0)
                    return (this.negative = 0), (E = this.isub(u)), (this.negative ^= 1), this._normSign()
                if (this.negative === 0 && u.negative !== 0) return (u.negative = 0), (E = this.isub(u)), (u.negative = 1), E._normSign()
                var $, N
                this.length > u.length ? (($ = this), (N = u)) : (($ = u), (N = this))
                for (var M = 0, R = 0; R < N.length; R++)
                    (E = ($.words[R] | 0) + (N.words[R] | 0) + M), (this.words[R] = E & 67108863), (M = E >>> 26)
                for (; M !== 0 && R < $.length; R++) (E = ($.words[R] | 0) + M), (this.words[R] = E & 67108863), (M = E >>> 26)
                if (((this.length = $.length), M !== 0)) (this.words[this.length] = M), this.length++
                else if ($ !== this) for (; R < $.length; R++) this.words[R] = $.words[R]
                return this
            }),
            (a.prototype.add = function (u) {
                var E
                return u.negative !== 0 && this.negative === 0
                    ? ((u.negative = 0), (E = this.sub(u)), (u.negative ^= 1), E)
                    : u.negative === 0 && this.negative !== 0
                    ? ((this.negative = 0), (E = u.sub(this)), (this.negative = 1), E)
                    : this.length > u.length
                    ? this.clone().iadd(u)
                    : u.clone().iadd(this)
            }),
            (a.prototype.isub = function (u) {
                if (u.negative !== 0) {
                    u.negative = 0
                    var E = this.iadd(u)
                    return (u.negative = 1), E._normSign()
                } else if (this.negative !== 0) return (this.negative = 0), this.iadd(u), (this.negative = 1), this._normSign()
                var $ = this.cmp(u)
                if ($ === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
                var N, M
                $ > 0 ? ((N = this), (M = u)) : ((N = u), (M = this))
                for (var R = 0, C = 0; C < M.length; C++)
                    (E = (N.words[C] | 0) - (M.words[C] | 0) + R), (R = E >> 26), (this.words[C] = E & 67108863)
                for (; R !== 0 && C < N.length; C++) (E = (N.words[C] | 0) + R), (R = E >> 26), (this.words[C] = E & 67108863)
                if (R === 0 && C < N.length && N !== this) for (; C < N.length; C++) this.words[C] = N.words[C]
                return (this.length = Math.max(this.length, C)), N !== this && (this.negative = 1), this._strip()
            }),
            (a.prototype.sub = function (u) {
                return this.clone().isub(u)
            })
        function U(O, u, E) {
            E.negative = u.negative ^ O.negative
            var $ = (O.length + u.length) | 0
            ;(E.length = $), ($ = ($ - 1) | 0)
            var N = O.words[0] | 0,
                M = u.words[0] | 0,
                R = N * M,
                C = R & 67108863,
                S = (R / 67108864) | 0
            E.words[0] = C
            for (var b = 1; b < $; b++) {
                for (var T = S >>> 26, Q = S & 67108863, k = Math.min(b, u.length - 1), W = Math.max(0, b - O.length + 1); W <= k; W++) {
                    var J = (b - W) | 0
                    ;(N = O.words[J] | 0), (M = u.words[W] | 0), (R = N * M + Q), (T += (R / 67108864) | 0), (Q = R & 67108863)
                }
                ;(E.words[b] = Q | 0), (S = T | 0)
            }
            return S !== 0 ? (E.words[b] = S | 0) : E.length--, E._strip()
        }
        var F = function (u, E, $) {
            var N = u.words,
                M = E.words,
                R = $.words,
                C = 0,
                S,
                b,
                T,
                Q = N[0] | 0,
                k = Q & 8191,
                W = Q >>> 13,
                J = N[1] | 0,
                ee = J & 8191,
                ne = J >>> 13,
                xe = N[2] | 0,
                ce = xe & 8191,
                de = xe >>> 13,
                H = N[3] | 0,
                j = H & 8191,
                q = H >>> 13,
                ae = N[4] | 0,
                te = ae & 8191,
                fe = ae >>> 13,
                Se = N[5] | 0,
                ue = Se & 8191,
                me = Se >>> 13,
                _e = N[6] | 0,
                Ce = _e & 8191,
                ke = _e >>> 13,
                Re = N[7] | 0,
                Ne = Re & 8191,
                Me = Re >>> 13,
                He = N[8] | 0,
                Fe = He & 8191,
                Le = He >>> 13,
                $t = N[9] | 0,
                nt = $t & 8191,
                lt = $t >>> 13,
                Zr = M[0] | 0,
                kt = Zr & 8191,
                Ze = Zr >>> 13,
                Xr = M[1] | 0,
                dt = Xr & 8191,
                Bt = Xr >>> 13,
                Ya = M[2] | 0,
                Gt = Ya & 8191,
                Vt = Ya >>> 13,
                il = M[3] | 0,
                Er = il & 8191,
                Pr = il >>> 13,
                ol = M[4] | 0,
                Mr = ol & 8191,
                Dr = ol >>> 13,
                sl = M[5] | 0,
                Ur = sl & 8191,
                Hr = sl >>> 13,
                al = M[6] | 0,
                jr = al & 8191,
                qr = al >>> 13,
                fl = M[7] | 0,
                Kr = fl & 8191,
                Gr = fl >>> 13,
                cl = M[8] | 0,
                Wr = cl & 8191,
                Yr = cl >>> 13,
                ul = M[9] | 0,
                Jr = ul & 8191,
                Qr = ul >>> 13
            ;($.negative = u.negative ^ E.negative),
                ($.length = 19),
                (S = Math.imul(k, kt)),
                (b = Math.imul(k, Ze)),
                (b = (b + Math.imul(W, kt)) | 0),
                (T = Math.imul(W, Ze))
            var Qa = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (Qa >>> 26)) | 0),
                (Qa &= 67108863),
                (S = Math.imul(ee, kt)),
                (b = Math.imul(ee, Ze)),
                (b = (b + Math.imul(ne, kt)) | 0),
                (T = Math.imul(ne, Ze)),
                (S = (S + Math.imul(k, dt)) | 0),
                (b = (b + Math.imul(k, Bt)) | 0),
                (b = (b + Math.imul(W, dt)) | 0),
                (T = (T + Math.imul(W, Bt)) | 0)
            var Za = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (Za >>> 26)) | 0),
                (Za &= 67108863),
                (S = Math.imul(ce, kt)),
                (b = Math.imul(ce, Ze)),
                (b = (b + Math.imul(de, kt)) | 0),
                (T = Math.imul(de, Ze)),
                (S = (S + Math.imul(ee, dt)) | 0),
                (b = (b + Math.imul(ee, Bt)) | 0),
                (b = (b + Math.imul(ne, dt)) | 0),
                (T = (T + Math.imul(ne, Bt)) | 0),
                (S = (S + Math.imul(k, Gt)) | 0),
                (b = (b + Math.imul(k, Vt)) | 0),
                (b = (b + Math.imul(W, Gt)) | 0),
                (T = (T + Math.imul(W, Vt)) | 0)
            var el = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (el >>> 26)) | 0),
                (el &= 67108863),
                (S = Math.imul(j, kt)),
                (b = Math.imul(j, Ze)),
                (b = (b + Math.imul(q, kt)) | 0),
                (T = Math.imul(q, Ze)),
                (S = (S + Math.imul(ce, dt)) | 0),
                (b = (b + Math.imul(ce, Bt)) | 0),
                (b = (b + Math.imul(de, dt)) | 0),
                (T = (T + Math.imul(de, Bt)) | 0),
                (S = (S + Math.imul(ee, Gt)) | 0),
                (b = (b + Math.imul(ee, Vt)) | 0),
                (b = (b + Math.imul(ne, Gt)) | 0),
                (T = (T + Math.imul(ne, Vt)) | 0),
                (S = (S + Math.imul(k, Er)) | 0),
                (b = (b + Math.imul(k, Pr)) | 0),
                (b = (b + Math.imul(W, Er)) | 0),
                (T = (T + Math.imul(W, Pr)) | 0)
            var tl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (tl >>> 26)) | 0),
                (tl &= 67108863),
                (S = Math.imul(te, kt)),
                (b = Math.imul(te, Ze)),
                (b = (b + Math.imul(fe, kt)) | 0),
                (T = Math.imul(fe, Ze)),
                (S = (S + Math.imul(j, dt)) | 0),
                (b = (b + Math.imul(j, Bt)) | 0),
                (b = (b + Math.imul(q, dt)) | 0),
                (T = (T + Math.imul(q, Bt)) | 0),
                (S = (S + Math.imul(ce, Gt)) | 0),
                (b = (b + Math.imul(ce, Vt)) | 0),
                (b = (b + Math.imul(de, Gt)) | 0),
                (T = (T + Math.imul(de, Vt)) | 0),
                (S = (S + Math.imul(ee, Er)) | 0),
                (b = (b + Math.imul(ee, Pr)) | 0),
                (b = (b + Math.imul(ne, Er)) | 0),
                (T = (T + Math.imul(ne, Pr)) | 0),
                (S = (S + Math.imul(k, Mr)) | 0),
                (b = (b + Math.imul(k, Dr)) | 0),
                (b = (b + Math.imul(W, Mr)) | 0),
                (T = (T + Math.imul(W, Dr)) | 0)
            var rl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (rl >>> 26)) | 0),
                (rl &= 67108863),
                (S = Math.imul(ue, kt)),
                (b = Math.imul(ue, Ze)),
                (b = (b + Math.imul(me, kt)) | 0),
                (T = Math.imul(me, Ze)),
                (S = (S + Math.imul(te, dt)) | 0),
                (b = (b + Math.imul(te, Bt)) | 0),
                (b = (b + Math.imul(fe, dt)) | 0),
                (T = (T + Math.imul(fe, Bt)) | 0),
                (S = (S + Math.imul(j, Gt)) | 0),
                (b = (b + Math.imul(j, Vt)) | 0),
                (b = (b + Math.imul(q, Gt)) | 0),
                (T = (T + Math.imul(q, Vt)) | 0),
                (S = (S + Math.imul(ce, Er)) | 0),
                (b = (b + Math.imul(ce, Pr)) | 0),
                (b = (b + Math.imul(de, Er)) | 0),
                (T = (T + Math.imul(de, Pr)) | 0),
                (S = (S + Math.imul(ee, Mr)) | 0),
                (b = (b + Math.imul(ee, Dr)) | 0),
                (b = (b + Math.imul(ne, Mr)) | 0),
                (T = (T + Math.imul(ne, Dr)) | 0),
                (S = (S + Math.imul(k, Ur)) | 0),
                (b = (b + Math.imul(k, Hr)) | 0),
                (b = (b + Math.imul(W, Ur)) | 0),
                (T = (T + Math.imul(W, Hr)) | 0)
            var dl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (dl >>> 26)) | 0),
                (dl &= 67108863),
                (S = Math.imul(Ce, kt)),
                (b = Math.imul(Ce, Ze)),
                (b = (b + Math.imul(ke, kt)) | 0),
                (T = Math.imul(ke, Ze)),
                (S = (S + Math.imul(ue, dt)) | 0),
                (b = (b + Math.imul(ue, Bt)) | 0),
                (b = (b + Math.imul(me, dt)) | 0),
                (T = (T + Math.imul(me, Bt)) | 0),
                (S = (S + Math.imul(te, Gt)) | 0),
                (b = (b + Math.imul(te, Vt)) | 0),
                (b = (b + Math.imul(fe, Gt)) | 0),
                (T = (T + Math.imul(fe, Vt)) | 0),
                (S = (S + Math.imul(j, Er)) | 0),
                (b = (b + Math.imul(j, Pr)) | 0),
                (b = (b + Math.imul(q, Er)) | 0),
                (T = (T + Math.imul(q, Pr)) | 0),
                (S = (S + Math.imul(ce, Mr)) | 0),
                (b = (b + Math.imul(ce, Dr)) | 0),
                (b = (b + Math.imul(de, Mr)) | 0),
                (T = (T + Math.imul(de, Dr)) | 0),
                (S = (S + Math.imul(ee, Ur)) | 0),
                (b = (b + Math.imul(ee, Hr)) | 0),
                (b = (b + Math.imul(ne, Ur)) | 0),
                (T = (T + Math.imul(ne, Hr)) | 0),
                (S = (S + Math.imul(k, jr)) | 0),
                (b = (b + Math.imul(k, qr)) | 0),
                (b = (b + Math.imul(W, jr)) | 0),
                (T = (T + Math.imul(W, qr)) | 0)
            var hl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (hl >>> 26)) | 0),
                (hl &= 67108863),
                (S = Math.imul(Ne, kt)),
                (b = Math.imul(Ne, Ze)),
                (b = (b + Math.imul(Me, kt)) | 0),
                (T = Math.imul(Me, Ze)),
                (S = (S + Math.imul(Ce, dt)) | 0),
                (b = (b + Math.imul(Ce, Bt)) | 0),
                (b = (b + Math.imul(ke, dt)) | 0),
                (T = (T + Math.imul(ke, Bt)) | 0),
                (S = (S + Math.imul(ue, Gt)) | 0),
                (b = (b + Math.imul(ue, Vt)) | 0),
                (b = (b + Math.imul(me, Gt)) | 0),
                (T = (T + Math.imul(me, Vt)) | 0),
                (S = (S + Math.imul(te, Er)) | 0),
                (b = (b + Math.imul(te, Pr)) | 0),
                (b = (b + Math.imul(fe, Er)) | 0),
                (T = (T + Math.imul(fe, Pr)) | 0),
                (S = (S + Math.imul(j, Mr)) | 0),
                (b = (b + Math.imul(j, Dr)) | 0),
                (b = (b + Math.imul(q, Mr)) | 0),
                (T = (T + Math.imul(q, Dr)) | 0),
                (S = (S + Math.imul(ce, Ur)) | 0),
                (b = (b + Math.imul(ce, Hr)) | 0),
                (b = (b + Math.imul(de, Ur)) | 0),
                (T = (T + Math.imul(de, Hr)) | 0),
                (S = (S + Math.imul(ee, jr)) | 0),
                (b = (b + Math.imul(ee, qr)) | 0),
                (b = (b + Math.imul(ne, jr)) | 0),
                (T = (T + Math.imul(ne, qr)) | 0),
                (S = (S + Math.imul(k, Kr)) | 0),
                (b = (b + Math.imul(k, Gr)) | 0),
                (b = (b + Math.imul(W, Kr)) | 0),
                (T = (T + Math.imul(W, Gr)) | 0)
            var pl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (pl >>> 26)) | 0),
                (pl &= 67108863),
                (S = Math.imul(Fe, kt)),
                (b = Math.imul(Fe, Ze)),
                (b = (b + Math.imul(Le, kt)) | 0),
                (T = Math.imul(Le, Ze)),
                (S = (S + Math.imul(Ne, dt)) | 0),
                (b = (b + Math.imul(Ne, Bt)) | 0),
                (b = (b + Math.imul(Me, dt)) | 0),
                (T = (T + Math.imul(Me, Bt)) | 0),
                (S = (S + Math.imul(Ce, Gt)) | 0),
                (b = (b + Math.imul(Ce, Vt)) | 0),
                (b = (b + Math.imul(ke, Gt)) | 0),
                (T = (T + Math.imul(ke, Vt)) | 0),
                (S = (S + Math.imul(ue, Er)) | 0),
                (b = (b + Math.imul(ue, Pr)) | 0),
                (b = (b + Math.imul(me, Er)) | 0),
                (T = (T + Math.imul(me, Pr)) | 0),
                (S = (S + Math.imul(te, Mr)) | 0),
                (b = (b + Math.imul(te, Dr)) | 0),
                (b = (b + Math.imul(fe, Mr)) | 0),
                (T = (T + Math.imul(fe, Dr)) | 0),
                (S = (S + Math.imul(j, Ur)) | 0),
                (b = (b + Math.imul(j, Hr)) | 0),
                (b = (b + Math.imul(q, Ur)) | 0),
                (T = (T + Math.imul(q, Hr)) | 0),
                (S = (S + Math.imul(ce, jr)) | 0),
                (b = (b + Math.imul(ce, qr)) | 0),
                (b = (b + Math.imul(de, jr)) | 0),
                (T = (T + Math.imul(de, qr)) | 0),
                (S = (S + Math.imul(ee, Kr)) | 0),
                (b = (b + Math.imul(ee, Gr)) | 0),
                (b = (b + Math.imul(ne, Kr)) | 0),
                (T = (T + Math.imul(ne, Gr)) | 0),
                (S = (S + Math.imul(k, Wr)) | 0),
                (b = (b + Math.imul(k, Yr)) | 0),
                (b = (b + Math.imul(W, Wr)) | 0),
                (T = (T + Math.imul(W, Yr)) | 0)
            var gl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (gl >>> 26)) | 0),
                (gl &= 67108863),
                (S = Math.imul(nt, kt)),
                (b = Math.imul(nt, Ze)),
                (b = (b + Math.imul(lt, kt)) | 0),
                (T = Math.imul(lt, Ze)),
                (S = (S + Math.imul(Fe, dt)) | 0),
                (b = (b + Math.imul(Fe, Bt)) | 0),
                (b = (b + Math.imul(Le, dt)) | 0),
                (T = (T + Math.imul(Le, Bt)) | 0),
                (S = (S + Math.imul(Ne, Gt)) | 0),
                (b = (b + Math.imul(Ne, Vt)) | 0),
                (b = (b + Math.imul(Me, Gt)) | 0),
                (T = (T + Math.imul(Me, Vt)) | 0),
                (S = (S + Math.imul(Ce, Er)) | 0),
                (b = (b + Math.imul(Ce, Pr)) | 0),
                (b = (b + Math.imul(ke, Er)) | 0),
                (T = (T + Math.imul(ke, Pr)) | 0),
                (S = (S + Math.imul(ue, Mr)) | 0),
                (b = (b + Math.imul(ue, Dr)) | 0),
                (b = (b + Math.imul(me, Mr)) | 0),
                (T = (T + Math.imul(me, Dr)) | 0),
                (S = (S + Math.imul(te, Ur)) | 0),
                (b = (b + Math.imul(te, Hr)) | 0),
                (b = (b + Math.imul(fe, Ur)) | 0),
                (T = (T + Math.imul(fe, Hr)) | 0),
                (S = (S + Math.imul(j, jr)) | 0),
                (b = (b + Math.imul(j, qr)) | 0),
                (b = (b + Math.imul(q, jr)) | 0),
                (T = (T + Math.imul(q, qr)) | 0),
                (S = (S + Math.imul(ce, Kr)) | 0),
                (b = (b + Math.imul(ce, Gr)) | 0),
                (b = (b + Math.imul(de, Kr)) | 0),
                (T = (T + Math.imul(de, Gr)) | 0),
                (S = (S + Math.imul(ee, Wr)) | 0),
                (b = (b + Math.imul(ee, Yr)) | 0),
                (b = (b + Math.imul(ne, Wr)) | 0),
                (T = (T + Math.imul(ne, Yr)) | 0),
                (S = (S + Math.imul(k, Jr)) | 0),
                (b = (b + Math.imul(k, Qr)) | 0),
                (b = (b + Math.imul(W, Jr)) | 0),
                (T = (T + Math.imul(W, Qr)) | 0)
            var ml = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (ml >>> 26)) | 0),
                (ml &= 67108863),
                (S = Math.imul(nt, dt)),
                (b = Math.imul(nt, Bt)),
                (b = (b + Math.imul(lt, dt)) | 0),
                (T = Math.imul(lt, Bt)),
                (S = (S + Math.imul(Fe, Gt)) | 0),
                (b = (b + Math.imul(Fe, Vt)) | 0),
                (b = (b + Math.imul(Le, Gt)) | 0),
                (T = (T + Math.imul(Le, Vt)) | 0),
                (S = (S + Math.imul(Ne, Er)) | 0),
                (b = (b + Math.imul(Ne, Pr)) | 0),
                (b = (b + Math.imul(Me, Er)) | 0),
                (T = (T + Math.imul(Me, Pr)) | 0),
                (S = (S + Math.imul(Ce, Mr)) | 0),
                (b = (b + Math.imul(Ce, Dr)) | 0),
                (b = (b + Math.imul(ke, Mr)) | 0),
                (T = (T + Math.imul(ke, Dr)) | 0),
                (S = (S + Math.imul(ue, Ur)) | 0),
                (b = (b + Math.imul(ue, Hr)) | 0),
                (b = (b + Math.imul(me, Ur)) | 0),
                (T = (T + Math.imul(me, Hr)) | 0),
                (S = (S + Math.imul(te, jr)) | 0),
                (b = (b + Math.imul(te, qr)) | 0),
                (b = (b + Math.imul(fe, jr)) | 0),
                (T = (T + Math.imul(fe, qr)) | 0),
                (S = (S + Math.imul(j, Kr)) | 0),
                (b = (b + Math.imul(j, Gr)) | 0),
                (b = (b + Math.imul(q, Kr)) | 0),
                (T = (T + Math.imul(q, Gr)) | 0),
                (S = (S + Math.imul(ce, Wr)) | 0),
                (b = (b + Math.imul(ce, Yr)) | 0),
                (b = (b + Math.imul(de, Wr)) | 0),
                (T = (T + Math.imul(de, Yr)) | 0),
                (S = (S + Math.imul(ee, Jr)) | 0),
                (b = (b + Math.imul(ee, Qr)) | 0),
                (b = (b + Math.imul(ne, Jr)) | 0),
                (T = (T + Math.imul(ne, Qr)) | 0)
            var yl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (yl >>> 26)) | 0),
                (yl &= 67108863),
                (S = Math.imul(nt, Gt)),
                (b = Math.imul(nt, Vt)),
                (b = (b + Math.imul(lt, Gt)) | 0),
                (T = Math.imul(lt, Vt)),
                (S = (S + Math.imul(Fe, Er)) | 0),
                (b = (b + Math.imul(Fe, Pr)) | 0),
                (b = (b + Math.imul(Le, Er)) | 0),
                (T = (T + Math.imul(Le, Pr)) | 0),
                (S = (S + Math.imul(Ne, Mr)) | 0),
                (b = (b + Math.imul(Ne, Dr)) | 0),
                (b = (b + Math.imul(Me, Mr)) | 0),
                (T = (T + Math.imul(Me, Dr)) | 0),
                (S = (S + Math.imul(Ce, Ur)) | 0),
                (b = (b + Math.imul(Ce, Hr)) | 0),
                (b = (b + Math.imul(ke, Ur)) | 0),
                (T = (T + Math.imul(ke, Hr)) | 0),
                (S = (S + Math.imul(ue, jr)) | 0),
                (b = (b + Math.imul(ue, qr)) | 0),
                (b = (b + Math.imul(me, jr)) | 0),
                (T = (T + Math.imul(me, qr)) | 0),
                (S = (S + Math.imul(te, Kr)) | 0),
                (b = (b + Math.imul(te, Gr)) | 0),
                (b = (b + Math.imul(fe, Kr)) | 0),
                (T = (T + Math.imul(fe, Gr)) | 0),
                (S = (S + Math.imul(j, Wr)) | 0),
                (b = (b + Math.imul(j, Yr)) | 0),
                (b = (b + Math.imul(q, Wr)) | 0),
                (T = (T + Math.imul(q, Yr)) | 0),
                (S = (S + Math.imul(ce, Jr)) | 0),
                (b = (b + Math.imul(ce, Qr)) | 0),
                (b = (b + Math.imul(de, Jr)) | 0),
                (T = (T + Math.imul(de, Qr)) | 0)
            var bl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (bl >>> 26)) | 0),
                (bl &= 67108863),
                (S = Math.imul(nt, Er)),
                (b = Math.imul(nt, Pr)),
                (b = (b + Math.imul(lt, Er)) | 0),
                (T = Math.imul(lt, Pr)),
                (S = (S + Math.imul(Fe, Mr)) | 0),
                (b = (b + Math.imul(Fe, Dr)) | 0),
                (b = (b + Math.imul(Le, Mr)) | 0),
                (T = (T + Math.imul(Le, Dr)) | 0),
                (S = (S + Math.imul(Ne, Ur)) | 0),
                (b = (b + Math.imul(Ne, Hr)) | 0),
                (b = (b + Math.imul(Me, Ur)) | 0),
                (T = (T + Math.imul(Me, Hr)) | 0),
                (S = (S + Math.imul(Ce, jr)) | 0),
                (b = (b + Math.imul(Ce, qr)) | 0),
                (b = (b + Math.imul(ke, jr)) | 0),
                (T = (T + Math.imul(ke, qr)) | 0),
                (S = (S + Math.imul(ue, Kr)) | 0),
                (b = (b + Math.imul(ue, Gr)) | 0),
                (b = (b + Math.imul(me, Kr)) | 0),
                (T = (T + Math.imul(me, Gr)) | 0),
                (S = (S + Math.imul(te, Wr)) | 0),
                (b = (b + Math.imul(te, Yr)) | 0),
                (b = (b + Math.imul(fe, Wr)) | 0),
                (T = (T + Math.imul(fe, Yr)) | 0),
                (S = (S + Math.imul(j, Jr)) | 0),
                (b = (b + Math.imul(j, Qr)) | 0),
                (b = (b + Math.imul(q, Jr)) | 0),
                (T = (T + Math.imul(q, Qr)) | 0)
            var vl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (vl >>> 26)) | 0),
                (vl &= 67108863),
                (S = Math.imul(nt, Mr)),
                (b = Math.imul(nt, Dr)),
                (b = (b + Math.imul(lt, Mr)) | 0),
                (T = Math.imul(lt, Dr)),
                (S = (S + Math.imul(Fe, Ur)) | 0),
                (b = (b + Math.imul(Fe, Hr)) | 0),
                (b = (b + Math.imul(Le, Ur)) | 0),
                (T = (T + Math.imul(Le, Hr)) | 0),
                (S = (S + Math.imul(Ne, jr)) | 0),
                (b = (b + Math.imul(Ne, qr)) | 0),
                (b = (b + Math.imul(Me, jr)) | 0),
                (T = (T + Math.imul(Me, qr)) | 0),
                (S = (S + Math.imul(Ce, Kr)) | 0),
                (b = (b + Math.imul(Ce, Gr)) | 0),
                (b = (b + Math.imul(ke, Kr)) | 0),
                (T = (T + Math.imul(ke, Gr)) | 0),
                (S = (S + Math.imul(ue, Wr)) | 0),
                (b = (b + Math.imul(ue, Yr)) | 0),
                (b = (b + Math.imul(me, Wr)) | 0),
                (T = (T + Math.imul(me, Yr)) | 0),
                (S = (S + Math.imul(te, Jr)) | 0),
                (b = (b + Math.imul(te, Qr)) | 0),
                (b = (b + Math.imul(fe, Jr)) | 0),
                (T = (T + Math.imul(fe, Qr)) | 0)
            var ef = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (ef >>> 26)) | 0),
                (ef &= 67108863),
                (S = Math.imul(nt, Ur)),
                (b = Math.imul(nt, Hr)),
                (b = (b + Math.imul(lt, Ur)) | 0),
                (T = Math.imul(lt, Hr)),
                (S = (S + Math.imul(Fe, jr)) | 0),
                (b = (b + Math.imul(Fe, qr)) | 0),
                (b = (b + Math.imul(Le, jr)) | 0),
                (T = (T + Math.imul(Le, qr)) | 0),
                (S = (S + Math.imul(Ne, Kr)) | 0),
                (b = (b + Math.imul(Ne, Gr)) | 0),
                (b = (b + Math.imul(Me, Kr)) | 0),
                (T = (T + Math.imul(Me, Gr)) | 0),
                (S = (S + Math.imul(Ce, Wr)) | 0),
                (b = (b + Math.imul(Ce, Yr)) | 0),
                (b = (b + Math.imul(ke, Wr)) | 0),
                (T = (T + Math.imul(ke, Yr)) | 0),
                (S = (S + Math.imul(ue, Jr)) | 0),
                (b = (b + Math.imul(ue, Qr)) | 0),
                (b = (b + Math.imul(me, Jr)) | 0),
                (T = (T + Math.imul(me, Qr)) | 0)
            var tf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (tf >>> 26)) | 0),
                (tf &= 67108863),
                (S = Math.imul(nt, jr)),
                (b = Math.imul(nt, qr)),
                (b = (b + Math.imul(lt, jr)) | 0),
                (T = Math.imul(lt, qr)),
                (S = (S + Math.imul(Fe, Kr)) | 0),
                (b = (b + Math.imul(Fe, Gr)) | 0),
                (b = (b + Math.imul(Le, Kr)) | 0),
                (T = (T + Math.imul(Le, Gr)) | 0),
                (S = (S + Math.imul(Ne, Wr)) | 0),
                (b = (b + Math.imul(Ne, Yr)) | 0),
                (b = (b + Math.imul(Me, Wr)) | 0),
                (T = (T + Math.imul(Me, Yr)) | 0),
                (S = (S + Math.imul(Ce, Jr)) | 0),
                (b = (b + Math.imul(Ce, Qr)) | 0),
                (b = (b + Math.imul(ke, Jr)) | 0),
                (T = (T + Math.imul(ke, Qr)) | 0)
            var rf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (rf >>> 26)) | 0),
                (rf &= 67108863),
                (S = Math.imul(nt, Kr)),
                (b = Math.imul(nt, Gr)),
                (b = (b + Math.imul(lt, Kr)) | 0),
                (T = Math.imul(lt, Gr)),
                (S = (S + Math.imul(Fe, Wr)) | 0),
                (b = (b + Math.imul(Fe, Yr)) | 0),
                (b = (b + Math.imul(Le, Wr)) | 0),
                (T = (T + Math.imul(Le, Yr)) | 0),
                (S = (S + Math.imul(Ne, Jr)) | 0),
                (b = (b + Math.imul(Ne, Qr)) | 0),
                (b = (b + Math.imul(Me, Jr)) | 0),
                (T = (T + Math.imul(Me, Qr)) | 0)
            var nf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (nf >>> 26)) | 0),
                (nf &= 67108863),
                (S = Math.imul(nt, Wr)),
                (b = Math.imul(nt, Yr)),
                (b = (b + Math.imul(lt, Wr)) | 0),
                (T = Math.imul(lt, Yr)),
                (S = (S + Math.imul(Fe, Jr)) | 0),
                (b = (b + Math.imul(Fe, Qr)) | 0),
                (b = (b + Math.imul(Le, Jr)) | 0),
                (T = (T + Math.imul(Le, Qr)) | 0)
            var of = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (of >>> 26)) | 0),
                (of &= 67108863),
                (S = Math.imul(nt, Jr)),
                (b = Math.imul(nt, Qr)),
                (b = (b + Math.imul(lt, Jr)) | 0),
                (T = Math.imul(lt, Qr))
            var sf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            return (
                (C = (((T + (b >>> 13)) | 0) + (sf >>> 26)) | 0),
                (sf &= 67108863),
                (R[0] = Qa),
                (R[1] = Za),
                (R[2] = el),
                (R[3] = tl),
                (R[4] = rl),
                (R[5] = dl),
                (R[6] = hl),
                (R[7] = pl),
                (R[8] = gl),
                (R[9] = ml),
                (R[10] = yl),
                (R[11] = bl),
                (R[12] = vl),
                (R[13] = ef),
                (R[14] = tf),
                (R[15] = rf),
                (R[16] = nf),
                (R[17] = of),
                (R[18] = sf),
                C !== 0 && ((R[19] = C), $.length++),
                $
            )
        }
        Math.imul || (F = U)
        function Z(O, u, E) {
            ;(E.negative = u.negative ^ O.negative), (E.length = O.length + u.length)
            for (var $ = 0, N = 0, M = 0; M < E.length - 1; M++) {
                var R = N
                N = 0
                for (var C = $ & 67108863, S = Math.min(M, u.length - 1), b = Math.max(0, M - O.length + 1); b <= S; b++) {
                    var T = M - b,
                        Q = O.words[T] | 0,
                        k = u.words[b] | 0,
                        W = Q * k,
                        J = W & 67108863
                    ;(R = (R + ((W / 67108864) | 0)) | 0),
                        (J = (J + C) | 0),
                        (C = J & 67108863),
                        (R = (R + (J >>> 26)) | 0),
                        (N += R >>> 26),
                        (R &= 67108863)
                }
                ;(E.words[M] = C), ($ = R), (R = N)
            }
            return $ !== 0 ? (E.words[M] = $) : E.length--, E._strip()
        }
        function Y(O, u, E) {
            return Z(O, u, E)
        }
        ;(a.prototype.mulTo = function (u, E) {
            var $,
                N = this.length + u.length
            return (
                this.length === 10 && u.length === 10
                    ? ($ = F(this, u, E))
                    : N < 63
                    ? ($ = U(this, u, E))
                    : N < 1024
                    ? ($ = Z(this, u, E))
                    : ($ = Y(this, u, E)),
                $
            )
        }),
            (a.prototype.mul = function (u) {
                var E = new a(null)
                return (E.words = new Array(this.length + u.length)), this.mulTo(u, E)
            }),
            (a.prototype.mulf = function (u) {
                var E = new a(null)
                return (E.words = new Array(this.length + u.length)), Y(this, u, E)
            }),
            (a.prototype.imul = function (u) {
                return this.clone().mulTo(u, this)
            }),
            (a.prototype.imuln = function (u) {
                var E = u < 0
                E && (u = -u), i(typeof u == "number"), i(u < 67108864)
                for (var $ = 0, N = 0; N < this.length; N++) {
                    var M = (this.words[N] | 0) * u,
                        R = (M & 67108863) + ($ & 67108863)
                    ;($ >>= 26), ($ += (M / 67108864) | 0), ($ += R >>> 26), (this.words[N] = R & 67108863)
                }
                return $ !== 0 && ((this.words[N] = $), this.length++), E ? this.ineg() : this
            }),
            (a.prototype.muln = function (u) {
                return this.clone().imuln(u)
            }),
            (a.prototype.sqr = function () {
                return this.mul(this)
            }),
            (a.prototype.isqr = function () {
                return this.imul(this.clone())
            }),
            (a.prototype.pow = function (u) {
                var E = G(u)
                if (E.length === 0) return new a(1)
                for (var $ = this, N = 0; N < E.length && E[N] === 0; N++, $ = $.sqr());
                if (++N < E.length) for (var M = $.sqr(); N < E.length; N++, M = M.sqr()) E[N] !== 0 && ($ = $.mul(M))
                return $
            }),
            (a.prototype.iushln = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = (67108863 >>> (26 - E)) << (26 - E),
                    M
                if (E !== 0) {
                    var R = 0
                    for (M = 0; M < this.length; M++) {
                        var C = this.words[M] & N,
                            S = ((this.words[M] | 0) - C) << E
                        ;(this.words[M] = S | R), (R = C >>> (26 - E))
                    }
                    R && ((this.words[M] = R), this.length++)
                }
                if ($ !== 0) {
                    for (M = this.length - 1; M >= 0; M--) this.words[M + $] = this.words[M]
                    for (M = 0; M < $; M++) this.words[M] = 0
                    this.length += $
                }
                return this._strip()
            }),
            (a.prototype.ishln = function (u) {
                return i(this.negative === 0), this.iushln(u)
            }),
            (a.prototype.iushrn = function (u, E, $) {
                i(typeof u == "number" && u >= 0)
                var N
                E ? (N = (E - (E % 26)) / 26) : (N = 0)
                var M = u % 26,
                    R = Math.min((u - M) / 26, this.length),
                    C = 67108863 ^ ((67108863 >>> M) << M),
                    S = $
                if (((N -= R), (N = Math.max(0, N)), S)) {
                    for (var b = 0; b < R; b++) S.words[b] = this.words[b]
                    S.length = R
                }
                if (R !== 0)
                    if (this.length > R) for (this.length -= R, b = 0; b < this.length; b++) this.words[b] = this.words[b + R]
                    else (this.words[0] = 0), (this.length = 1)
                var T = 0
                for (b = this.length - 1; b >= 0 && (T !== 0 || b >= N); b--) {
                    var Q = this.words[b] | 0
                    ;(this.words[b] = (T << (26 - M)) | (Q >>> M)), (T = Q & C)
                }
                return S && T !== 0 && (S.words[S.length++] = T), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip()
            }),
            (a.prototype.ishrn = function (u, E, $) {
                return i(this.negative === 0), this.iushrn(u, E, $)
            }),
            (a.prototype.shln = function (u) {
                return this.clone().ishln(u)
            }),
            (a.prototype.ushln = function (u) {
                return this.clone().iushln(u)
            }),
            (a.prototype.shrn = function (u) {
                return this.clone().ishrn(u)
            }),
            (a.prototype.ushrn = function (u) {
                return this.clone().iushrn(u)
            }),
            (a.prototype.testn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = 1 << E
                if (this.length <= $) return !1
                var M = this.words[$]
                return !!(M & N)
            }),
            (a.prototype.imaskn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26
                if ((i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)) return this
                if ((E !== 0 && $++, (this.length = Math.min($, this.length)), E !== 0)) {
                    var N = 67108863 ^ ((67108863 >>> E) << E)
                    this.words[this.length - 1] &= N
                }
                return this._strip()
            }),
            (a.prototype.maskn = function (u) {
                return this.clone().imaskn(u)
            }),
            (a.prototype.iaddn = function (u) {
                return (
                    i(typeof u == "number"),
                    i(u < 67108864),
                    u < 0
                        ? this.isubn(-u)
                        : this.negative !== 0
                        ? this.length === 1 && (this.words[0] | 0) <= u
                            ? ((this.words[0] = u - (this.words[0] | 0)), (this.negative = 0), this)
                            : ((this.negative = 0), this.isubn(u), (this.negative = 1), this)
                        : this._iaddn(u)
                )
            }),
            (a.prototype._iaddn = function (u) {
                this.words[0] += u
                for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
                    (this.words[E] -= 67108864), E === this.length - 1 ? (this.words[E + 1] = 1) : this.words[E + 1]++
                return (this.length = Math.max(this.length, E + 1)), this
            }),
            (a.prototype.isubn = function (u) {
                if ((i(typeof u == "number"), i(u < 67108864), u < 0)) return this.iaddn(-u)
                if (this.negative !== 0) return (this.negative = 0), this.iaddn(u), (this.negative = 1), this
                if (((this.words[0] -= u), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1)
                else for (var E = 0; E < this.length && this.words[E] < 0; E++) (this.words[E] += 67108864), (this.words[E + 1] -= 1)
                return this._strip()
            }),
            (a.prototype.addn = function (u) {
                return this.clone().iaddn(u)
            }),
            (a.prototype.subn = function (u) {
                return this.clone().isubn(u)
            }),
            (a.prototype.iabs = function () {
                return (this.negative = 0), this
            }),
            (a.prototype.abs = function () {
                return this.clone().iabs()
            }),
            (a.prototype._ishlnsubmul = function (u, E, $) {
                var N = u.length + $,
                    M
                this._expand(N)
                var R,
                    C = 0
                for (M = 0; M < u.length; M++) {
                    R = (this.words[M + $] | 0) + C
                    var S = (u.words[M] | 0) * E
                    ;(R -= S & 67108863), (C = (R >> 26) - ((S / 67108864) | 0)), (this.words[M + $] = R & 67108863)
                }
                for (; M < this.length - $; M++) (R = (this.words[M + $] | 0) + C), (C = R >> 26), (this.words[M + $] = R & 67108863)
                if (C === 0) return this._strip()
                for (i(C === -1), C = 0, M = 0; M < this.length; M++)
                    (R = -(this.words[M] | 0) + C), (C = R >> 26), (this.words[M] = R & 67108863)
                return (this.negative = 1), this._strip()
            }),
            (a.prototype._wordDiv = function (u, E) {
                var $ = this.length - u.length,
                    N = this.clone(),
                    M = u,
                    R = M.words[M.length - 1] | 0,
                    C = this._countBits(R)
                ;($ = 26 - C), $ !== 0 && ((M = M.ushln($)), N.iushln($), (R = M.words[M.length - 1] | 0))
                var S = N.length - M.length,
                    b
                if (E !== "mod") {
                    ;(b = new a(null)), (b.length = S + 1), (b.words = new Array(b.length))
                    for (var T = 0; T < b.length; T++) b.words[T] = 0
                }
                var Q = N.clone()._ishlnsubmul(M, 1, S)
                Q.negative === 0 && ((N = Q), b && (b.words[S] = 1))
                for (var k = S - 1; k >= 0; k--) {
                    var W = (N.words[M.length + k] | 0) * 67108864 + (N.words[M.length + k - 1] | 0)
                    for (W = Math.min((W / R) | 0, 67108863), N._ishlnsubmul(M, W, k); N.negative !== 0; )
                        W--, (N.negative = 0), N._ishlnsubmul(M, 1, k), N.isZero() || (N.negative ^= 1)
                    b && (b.words[k] = W)
                }
                return b && b._strip(), N._strip(), E !== "div" && $ !== 0 && N.iushrn($), { div: b || null, mod: N }
            }),
            (a.prototype.divmod = function (u, E, $) {
                if ((i(!u.isZero()), this.isZero())) return { div: new a(0), mod: new a(0) }
                var N, M, R
                return this.negative !== 0 && u.negative === 0
                    ? ((R = this.neg().divmod(u, E)),
                      E !== "mod" && (N = R.div.neg()),
                      E !== "div" && ((M = R.mod.neg()), $ && M.negative !== 0 && M.iadd(u)),
                      { div: N, mod: M })
                    : this.negative === 0 && u.negative !== 0
                    ? ((R = this.divmod(u.neg(), E)), E !== "mod" && (N = R.div.neg()), { div: N, mod: R.mod })
                    : (this.negative & u.negative) !== 0
                    ? ((R = this.neg().divmod(u.neg(), E)),
                      E !== "div" && ((M = R.mod.neg()), $ && M.negative !== 0 && M.isub(u)),
                      { div: R.div, mod: M })
                    : u.length > this.length || this.cmp(u) < 0
                    ? { div: new a(0), mod: this }
                    : u.length === 1
                    ? E === "div"
                        ? { div: this.divn(u.words[0]), mod: null }
                        : E === "mod"
                        ? { div: null, mod: new a(this.modrn(u.words[0])) }
                        : { div: this.divn(u.words[0]), mod: new a(this.modrn(u.words[0])) }
                    : this._wordDiv(u, E)
            }),
            (a.prototype.div = function (u) {
                return this.divmod(u, "div", !1).div
            }),
            (a.prototype.mod = function (u) {
                return this.divmod(u, "mod", !1).mod
            }),
            (a.prototype.umod = function (u) {
                return this.divmod(u, "mod", !0).mod
            }),
            (a.prototype.divRound = function (u) {
                var E = this.divmod(u)
                if (E.mod.isZero()) return E.div
                var $ = E.div.negative !== 0 ? E.mod.isub(u) : E.mod,
                    N = u.ushrn(1),
                    M = u.andln(1),
                    R = $.cmp(N)
                return R < 0 || (M === 1 && R === 0) ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1)
            }),
            (a.prototype.modrn = function (u) {
                var E = u < 0
                E && (u = -u), i(u <= 67108863)
                for (var $ = (1 << 26) % u, N = 0, M = this.length - 1; M >= 0; M--) N = ($ * N + (this.words[M] | 0)) % u
                return E ? -N : N
            }),
            (a.prototype.modn = function (u) {
                return this.modrn(u)
            }),
            (a.prototype.idivn = function (u) {
                var E = u < 0
                E && (u = -u), i(u <= 67108863)
                for (var $ = 0, N = this.length - 1; N >= 0; N--) {
                    var M = (this.words[N] | 0) + $ * 67108864
                    ;(this.words[N] = (M / u) | 0), ($ = M % u)
                }
                return this._strip(), E ? this.ineg() : this
            }),
            (a.prototype.divn = function (u) {
                return this.clone().idivn(u)
            }),
            (a.prototype.egcd = function (u) {
                i(u.negative === 0), i(!u.isZero())
                var E = this,
                    $ = u.clone()
                E.negative !== 0 ? (E = E.umod(u)) : (E = E.clone())
                for (var N = new a(1), M = new a(0), R = new a(0), C = new a(1), S = 0; E.isEven() && $.isEven(); ) E.iushrn(1), $.iushrn(1), ++S
                for (var b = $.clone(), T = E.clone(); !E.isZero(); ) {
                    for (var Q = 0, k = 1; (E.words[0] & k) === 0 && Q < 26; ++Q, k <<= 1);
                    if (Q > 0) for (E.iushrn(Q); Q-- > 0; ) (N.isOdd() || M.isOdd()) && (N.iadd(b), M.isub(T)), N.iushrn(1), M.iushrn(1)
                    for (var W = 0, J = 1; ($.words[0] & J) === 0 && W < 26; ++W, J <<= 1);
                    if (W > 0) for ($.iushrn(W); W-- > 0; ) (R.isOdd() || C.isOdd()) && (R.iadd(b), C.isub(T)), R.iushrn(1), C.iushrn(1)
                    E.cmp($) >= 0 ? (E.isub($), N.isub(R), M.isub(C)) : ($.isub(E), R.isub(N), C.isub(M))
                }
                return { a: R, b: C, gcd: $.iushln(S) }
            }),
            (a.prototype._invmp = function (u) {
                i(u.negative === 0), i(!u.isZero())
                var E = this,
                    $ = u.clone()
                E.negative !== 0 ? (E = E.umod(u)) : (E = E.clone())
                for (var N = new a(1), M = new a(0), R = $.clone(); E.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
                    for (var C = 0, S = 1; (E.words[0] & S) === 0 && C < 26; ++C, S <<= 1);
                    if (C > 0) for (E.iushrn(C); C-- > 0; ) N.isOdd() && N.iadd(R), N.iushrn(1)
                    for (var b = 0, T = 1; ($.words[0] & T) === 0 && b < 26; ++b, T <<= 1);
                    if (b > 0) for ($.iushrn(b); b-- > 0; ) M.isOdd() && M.iadd(R), M.iushrn(1)
                    E.cmp($) >= 0 ? (E.isub($), N.isub(M)) : ($.isub(E), M.isub(N))
                }
                var Q
                return E.cmpn(1) === 0 ? (Q = N) : (Q = M), Q.cmpn(0) < 0 && Q.iadd(u), Q
            }),
            (a.prototype.gcd = function (u) {
                if (this.isZero()) return u.abs()
                if (u.isZero()) return this.abs()
                var E = this.clone(),
                    $ = u.clone()
                ;(E.negative = 0), ($.negative = 0)
                for (var N = 0; E.isEven() && $.isEven(); N++) E.iushrn(1), $.iushrn(1)
                do {
                    for (; E.isEven(); ) E.iushrn(1)
                    for (; $.isEven(); ) $.iushrn(1)
                    var M = E.cmp($)
                    if (M < 0) {
                        var R = E
                        ;(E = $), ($ = R)
                    } else if (M === 0 || $.cmpn(1) === 0) break
                    E.isub($)
                } while (!0)
                return $.iushln(N)
            }),
            (a.prototype.invm = function (u) {
                return this.egcd(u).a.umod(u)
            }),
            (a.prototype.isEven = function () {
                return (this.words[0] & 1) === 0
            }),
            (a.prototype.isOdd = function () {
                return (this.words[0] & 1) === 1
            }),
            (a.prototype.andln = function (u) {
                return this.words[0] & u
            }),
            (a.prototype.bincn = function (u) {
                i(typeof u == "number")
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = 1 << E
                if (this.length <= $) return this._expand($ + 1), (this.words[$] |= N), this
                for (var M = N, R = $; M !== 0 && R < this.length; R++) {
                    var C = this.words[R] | 0
                    ;(C += M), (M = C >>> 26), (C &= 67108863), (this.words[R] = C)
                }
                return M !== 0 && ((this.words[R] = M), this.length++), this
            }),
            (a.prototype.isZero = function () {
                return this.length === 1 && this.words[0] === 0
            }),
            (a.prototype.cmpn = function (u) {
                var E = u < 0
                if (this.negative !== 0 && !E) return -1
                if (this.negative === 0 && E) return 1
                this._strip()
                var $
                if (this.length > 1) $ = 1
                else {
                    E && (u = -u), i(u <= 67108863, "Number is too big")
                    var N = this.words[0] | 0
                    $ = N === u ? 0 : N < u ? -1 : 1
                }
                return this.negative !== 0 ? -$ | 0 : $
            }),
            (a.prototype.cmp = function (u) {
                if (this.negative !== 0 && u.negative === 0) return -1
                if (this.negative === 0 && u.negative !== 0) return 1
                var E = this.ucmp(u)
                return this.negative !== 0 ? -E | 0 : E
            }),
            (a.prototype.ucmp = function (u) {
                if (this.length > u.length) return 1
                if (this.length < u.length) return -1
                for (var E = 0, $ = this.length - 1; $ >= 0; $--) {
                    var N = this.words[$] | 0,
                        M = u.words[$] | 0
                    if (N !== M) {
                        N < M ? (E = -1) : N > M && (E = 1)
                        break
                    }
                }
                return E
            }),
            (a.prototype.gtn = function (u) {
                return this.cmpn(u) === 1
            }),
            (a.prototype.gt = function (u) {
                return this.cmp(u) === 1
            }),
            (a.prototype.gten = function (u) {
                return this.cmpn(u) >= 0
            }),
            (a.prototype.gte = function (u) {
                return this.cmp(u) >= 0
            }),
            (a.prototype.ltn = function (u) {
                return this.cmpn(u) === -1
            }),
            (a.prototype.lt = function (u) {
                return this.cmp(u) === -1
            }),
            (a.prototype.lten = function (u) {
                return this.cmpn(u) <= 0
            }),
            (a.prototype.lte = function (u) {
                return this.cmp(u) <= 0
            }),
            (a.prototype.eqn = function (u) {
                return this.cmpn(u) === 0
            }),
            (a.prototype.eq = function (u) {
                return this.cmp(u) === 0
            }),
            (a.red = function (u) {
                return new ye(u)
            }),
            (a.prototype.toRed = function (u) {
                return (
                    i(!this.red, "Already a number in reduction context"),
                    i(this.negative === 0, "red works only with positives"),
                    u.convertTo(this)._forceRed(u)
                )
            }),
            (a.prototype.fromRed = function () {
                return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }),
            (a.prototype._forceRed = function (u) {
                return (this.red = u), this
            }),
            (a.prototype.forceRed = function (u) {
                return i(!this.red, "Already a number in reduction context"), this._forceRed(u)
            }),
            (a.prototype.redAdd = function (u) {
                return i(this.red, "redAdd works only with red numbers"), this.red.add(this, u)
            }),
            (a.prototype.redIAdd = function (u) {
                return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u)
            }),
            (a.prototype.redSub = function (u) {
                return i(this.red, "redSub works only with red numbers"), this.red.sub(this, u)
            }),
            (a.prototype.redISub = function (u) {
                return i(this.red, "redISub works only with red numbers"), this.red.isub(this, u)
            }),
            (a.prototype.redShl = function (u) {
                return i(this.red, "redShl works only with red numbers"), this.red.shl(this, u)
            }),
            (a.prototype.redMul = function (u) {
                return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u)
            }),
            (a.prototype.redIMul = function (u) {
                return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u)
            }),
            (a.prototype.redSqr = function () {
                return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }),
            (a.prototype.redISqr = function () {
                return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }),
            (a.prototype.redSqrt = function () {
                return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }),
            (a.prototype.redInvm = function () {
                return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }),
            (a.prototype.redNeg = function () {
                return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }),
            (a.prototype.redPow = function (u) {
                return i(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u)
            })
        var X = { k256: null, p224: null, p192: null, p25519: null }
        function ie(O, u) {
            ;(this.name = O),
                (this.p = new a(u, 16)),
                (this.n = this.p.bitLength()),
                (this.k = new a(1).iushln(this.n).isub(this.p)),
                (this.tmp = this._tmp())
        }
        ;(ie.prototype._tmp = function () {
            var u = new a(null)
            return (u.words = new Array(Math.ceil(this.n / 13))), u
        }),
            (ie.prototype.ireduce = function (u) {
                var E = u,
                    $
                do this.split(E, this.tmp), (E = this.imulK(E)), (E = E.iadd(this.tmp)), ($ = E.bitLength())
                while ($ > this.n)
                var N = $ < this.n ? -1 : E.ucmp(this.p)
                return N === 0 ? ((E.words[0] = 0), (E.length = 1)) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E
            }),
            (ie.prototype.split = function (u, E) {
                u.iushrn(this.n, 0, E)
            }),
            (ie.prototype.imulK = function (u) {
                return u.imul(this.k)
            })
        function he() {
            ie.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        o(he, ie),
            (he.prototype.split = function (u, E) {
                for (var $ = 4194303, N = Math.min(u.length, 9), M = 0; M < N; M++) E.words[M] = u.words[M]
                if (((E.length = N), u.length <= 9)) {
                    ;(u.words[0] = 0), (u.length = 1)
                    return
                }
                var R = u.words[9]
                for (E.words[E.length++] = R & $, M = 10; M < u.length; M++) {
                    var C = u.words[M] | 0
                    ;(u.words[M - 10] = ((C & $) << 4) | (R >>> 22)), (R = C)
                }
                ;(R >>>= 22), (u.words[M - 10] = R), R === 0 && u.length > 10 ? (u.length -= 10) : (u.length -= 9)
            }),
            (he.prototype.imulK = function (u) {
                ;(u.words[u.length] = 0), (u.words[u.length + 1] = 0), (u.length += 2)
                for (var E = 0, $ = 0; $ < u.length; $++) {
                    var N = u.words[$] | 0
                    ;(E += N * 977), (u.words[$] = E & 67108863), (E = N * 64 + ((E / 67108864) | 0))
                }
                return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u
            })
        function oe() {
            ie.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        o(oe, ie)
        function le() {
            ie.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        o(le, ie)
        function Te() {
            ie.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        o(Te, ie),
            (Te.prototype.imulK = function (u) {
                for (var E = 0, $ = 0; $ < u.length; $++) {
                    var N = (u.words[$] | 0) * 19 + E,
                        M = N & 67108863
                    ;(N >>>= 26), (u.words[$] = M), (E = N)
                }
                return E !== 0 && (u.words[u.length++] = E), u
            }),
            (a._prime = function (u) {
                if (X[u]) return X[u]
                var E
                if (u === "k256") E = new he()
                else if (u === "p224") E = new oe()
                else if (u === "p192") E = new le()
                else if (u === "p25519") E = new Te()
                else throw new Error("Unknown prime " + u)
                return (X[u] = E), E
            })
        function ye(O) {
            if (typeof O == "string") {
                var u = a._prime(O)
                ;(this.m = u.p), (this.prime = u)
            } else i(O.gtn(1), "modulus must be greater than 1"), (this.m = O), (this.prime = null)
        }
        ;(ye.prototype._verify1 = function (u) {
            i(u.negative === 0, "red works only with positives"), i(u.red, "red works only with red numbers")
        }),
            (ye.prototype._verify2 = function (u, E) {
                i((u.negative | E.negative) === 0, "red works only with positives"),
                    i(u.red && u.red === E.red, "red works only with red numbers")
            }),
            (ye.prototype.imod = function (u) {
                return this.prime ? this.prime.ireduce(u)._forceRed(this) : (_(u, u.umod(this.m)._forceRed(this)), u)
            }),
            (ye.prototype.neg = function (u) {
                return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this)
            }),
            (ye.prototype.add = function (u, E) {
                this._verify2(u, E)
                var $ = u.add(E)
                return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this)
            }),
            (ye.prototype.iadd = function (u, E) {
                this._verify2(u, E)
                var $ = u.iadd(E)
                return $.cmp(this.m) >= 0 && $.isub(this.m), $
            }),
            (ye.prototype.sub = function (u, E) {
                this._verify2(u, E)
                var $ = u.sub(E)
                return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this)
            }),
            (ye.prototype.isub = function (u, E) {
                this._verify2(u, E)
                var $ = u.isub(E)
                return $.cmpn(0) < 0 && $.iadd(this.m), $
            }),
            (ye.prototype.shl = function (u, E) {
                return this._verify1(u), this.imod(u.ushln(E))
            }),
            (ye.prototype.imul = function (u, E) {
                return this._verify2(u, E), this.imod(u.imul(E))
            }),
            (ye.prototype.mul = function (u, E) {
                return this._verify2(u, E), this.imod(u.mul(E))
            }),
            (ye.prototype.isqr = function (u) {
                return this.imul(u, u.clone())
            }),
            (ye.prototype.sqr = function (u) {
                return this.mul(u, u)
            }),
            (ye.prototype.sqrt = function (u) {
                if (u.isZero()) return u.clone()
                var E = this.m.andln(3)
                if ((i(E % 2 === 1), E === 3)) {
                    var $ = this.m.add(new a(1)).iushrn(2)
                    return this.pow(u, $)
                }
                for (var N = this.m.subn(1), M = 0; !N.isZero() && N.andln(1) === 0; ) M++, N.iushrn(1)
                i(!N.isZero())
                var R = new a(1).toRed(this),
                    C = R.redNeg(),
                    S = this.m.subn(1).iushrn(1),
                    b = this.m.bitLength()
                for (b = new a(2 * b * b).toRed(this); this.pow(b, S).cmp(C) !== 0; ) b.redIAdd(C)
                for (var T = this.pow(b, N), Q = this.pow(u, N.addn(1).iushrn(1)), k = this.pow(u, N), W = M; k.cmp(R) !== 0; ) {
                    for (var J = k, ee = 0; J.cmp(R) !== 0; ee++) J = J.redSqr()
                    i(ee < W)
                    var ne = this.pow(T, new a(1).iushln(W - ee - 1))
                    ;(Q = Q.redMul(ne)), (T = ne.redSqr()), (k = k.redMul(T)), (W = ee)
                }
                return Q
            }),
            (ye.prototype.invm = function (u) {
                var E = u._invmp(this.m)
                return E.negative !== 0 ? ((E.negative = 0), this.imod(E).redNeg()) : this.imod(E)
            }),
            (ye.prototype.pow = function (u, E) {
                if (E.isZero()) return new a(1).toRed(this)
                if (E.cmpn(1) === 0) return u.clone()
                var $ = 4,
                    N = new Array(1 << $)
                ;(N[0] = new a(1).toRed(this)), (N[1] = u)
                for (var M = 2; M < N.length; M++) N[M] = this.mul(N[M - 1], u)
                var R = N[0],
                    C = 0,
                    S = 0,
                    b = E.bitLength() % 26
                for (b === 0 && (b = 26), M = E.length - 1; M >= 0; M--) {
                    for (var T = E.words[M], Q = b - 1; Q >= 0; Q--) {
                        var k = (T >> Q) & 1
                        if ((R !== N[0] && (R = this.sqr(R)), k === 0 && C === 0)) {
                            S = 0
                            continue
                        }
                        ;(C <<= 1), (C |= k), S++, !(S !== $ && (M !== 0 || Q !== 0)) && ((R = this.mul(R, N[C])), (S = 0), (C = 0))
                    }
                    b = 26
                }
                return R
            }),
            (ye.prototype.convertTo = function (u) {
                var E = u.umod(this.m)
                return E === u ? E.clone() : E
            }),
            (ye.prototype.convertFrom = function (u) {
                var E = u.clone()
                return (E.red = null), E
            }),
            (a.mont = function (u) {
                return new Ae(u)
            })
        function Ae(O) {
            ye.call(this, O),
                (this.shift = this.m.bitLength()),
                this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
                (this.r = new a(1).iushln(this.shift)),
                (this.r2 = this.imod(this.r.sqr())),
                (this.rinv = this.r._invmp(this.m)),
                (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                (this.minv = this.minv.umod(this.r)),
                (this.minv = this.r.sub(this.minv))
        }
        o(Ae, ye),
            (Ae.prototype.convertTo = function (u) {
                return this.imod(u.ushln(this.shift))
            }),
            (Ae.prototype.convertFrom = function (u) {
                var E = this.imod(u.mul(this.rinv))
                return (E.red = null), E
            }),
            (Ae.prototype.imul = function (u, E) {
                if (u.isZero() || E.isZero()) return (u.words[0] = 0), (u.length = 1), u
                var $ = u.imul(E),
                    N = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    M = $.isub(N).iushrn(this.shift),
                    R = M
                return M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)), R._forceRed(this)
            }),
            (Ae.prototype.mul = function (u, E) {
                if (u.isZero() || E.isZero()) return new a(0)._forceRed(this)
                var $ = u.mul(E),
                    N = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    M = $.isub(N).iushrn(this.shift),
                    R = M
                return M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)), R._forceRed(this)
            }),
            (Ae.prototype.invm = function (u) {
                var E = this.imod(u._invmp(this.m).mul(this.r2))
                return E._forceRed(this)
            })
    })(t, commonjsGlobal)
})(bn$2)
var _BN = bn$2.exports
const version$j = "logger/5.7.0"
let _permanentCensorErrors = !1,
    _censorErrors = !1
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 }
let _logLevel = LogLevels.default,
    _globalLogger = null
function _checkNormalize() {
    try {
        const t = []
        if (
            (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }),
            t.length)
        )
            throw new Error("missing " + t.join(", "))
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const _normalizeError = _checkNormalize()
var LogLevel
;(function (t) {
    ;(t.DEBUG = "DEBUG"), (t.INFO = "INFO"), (t.WARNING = "WARNING"), (t.ERROR = "ERROR"), (t.OFF = "OFF")
})(LogLevel || (LogLevel = {}))
var ErrorCode
;(function (t) {
    ;(t.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
        (t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
        (t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
        (t.NETWORK_ERROR = "NETWORK_ERROR"),
        (t.SERVER_ERROR = "SERVER_ERROR"),
        (t.TIMEOUT = "TIMEOUT"),
        (t.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
        (t.NUMERIC_FAULT = "NUMERIC_FAULT"),
        (t.MISSING_NEW = "MISSING_NEW"),
        (t.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
        (t.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
        (t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
        (t.CALL_EXCEPTION = "CALL_EXCEPTION"),
        (t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
        (t.NONCE_EXPIRED = "NONCE_EXPIRED"),
        (t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
        (t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
        (t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"),
        (t.ACTION_REJECTED = "ACTION_REJECTED")
})(ErrorCode || (ErrorCode = {}))
const HEX = "0123456789abcdef"
class Logger {
    constructor(e) {
        Object.defineProperty(this, "version", { enumerable: !0, value: e, writable: !1 })
    }
    _log(e, n) {
        const i = e.toLowerCase()
        LogLevels[i] == null && this.throwArgumentError("invalid log level name", "logLevel", e),
            !(_logLevel > LogLevels[i]) && console.log.apply(console, n)
    }
    debug(...e) {
        this._log(Logger.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Logger.levels.INFO, e)
    }
    warn(...e) {
        this._log(Logger.levels.WARNING, e)
    }
    makeError(e, n, i) {
        if (_censorErrors) return this.makeError("censored error", n, {})
        n || (n = Logger.errors.UNKNOWN_ERROR), i || (i = {})
        const o = []
        Object.keys(i).forEach((g) => {
            const v = i[g]
            try {
                if (v instanceof Uint8Array) {
                    let _ = ""
                    for (let A = 0; A < v.length; A++) (_ += HEX[v[A] >> 4]), (_ += HEX[v[A] & 15])
                    o.push(g + "=Uint8Array(0x" + _ + ")")
                } else o.push(g + "=" + JSON.stringify(v))
            } catch {
                o.push(g + "=" + JSON.stringify(i[g].toString()))
            }
        }),
            o.push(`code=${n}`),
            o.push(`version=${this.version}`)
        const a = e
        let l = ""
        switch (n) {
            case ErrorCode.NUMERIC_FAULT: {
                l = "NUMERIC_FAULT"
                const g = e
                switch (g) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        l += "-" + g
                        break
                    case "negative-power":
                    case "negative-width":
                        l += "-unsupported"
                        break
                    case "unbound-bitwise-result":
                        l += "-unbound-result"
                        break
                }
                break
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                l = n
                break
        }
        l && (e += " [ See: https://links.ethers.org/v5-errors-" + l + " ]"), o.length && (e += " (" + o.join(", ") + ")")
        const c = new Error(e)
        return (
            (c.reason = a),
            (c.code = n),
            Object.keys(i).forEach(function (g) {
                c[g] = i[g]
            }),
            c
        )
    }
    throwError(e, n, i) {
        throw this.makeError(e, n, i)
    }
    throwArgumentError(e, n, i) {
        return this.throwError(e, Logger.errors.INVALID_ARGUMENT, { argument: n, value: i })
    }
    assert(e, n, i, o) {
        e || this.throwError(n, i, o)
    }
    assertArgument(e, n, i, o) {
        e || this.throwArgumentError(n, i, o)
    }
    checkNormalize(e) {
        _normalizeError &&
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize",
                form: _normalizeError,
            })
    }
    checkSafeUint53(e, n) {
        typeof e == "number" &&
            (n == null && (n = "value not safe"),
            (e < 0 || e >= 9007199254740991) &&
                this.throwError(n, Logger.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: e }),
            e % 1 && this.throwError(n, Logger.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: e }))
    }
    checkArgumentCount(e, n, i) {
        i ? (i = ": " + i) : (i = ""),
            e < n && this.throwError("missing argument" + i, Logger.errors.MISSING_ARGUMENT, { count: e, expectedCount: n }),
            e > n && this.throwError("too many arguments" + i, Logger.errors.UNEXPECTED_ARGUMENT, { count: e, expectedCount: n })
    }
    checkNew(e, n) {
        ;(e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: n.name })
    }
    checkAbstract(e, n) {
        e === n
            ? this.throwError(
                  "cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class",
                  Logger.errors.UNSUPPORTED_OPERATION,
                  { name: e.name, operation: "new" }
              )
            : (e === Object || e == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: n.name })
    }
    static globalLogger() {
        return _globalLogger || (_globalLogger = new Logger(version$j)), _globalLogger
    }
    static setCensorship(e, n) {
        if (
            (!e &&
                n &&
                this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "setCensorship",
                }),
            _permanentCensorErrors)
        ) {
            if (!e) return
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" })
        }
        ;(_censorErrors = !!e), (_permanentCensorErrors = !!n)
    }
    static setLogLevel(e) {
        const n = LogLevels[e.toLowerCase()]
        if (n == null) {
            Logger.globalLogger().warn("invalid log level - " + e)
            return
        }
        _logLevel = n
    }
    static from(e) {
        return new Logger(e)
    }
}
Logger.errors = ErrorCode
Logger.levels = LogLevel
const version$i = "bytes/5.7.0",
    logger$p = new Logger(version$i)
function isHexable(t) {
    return !!t.toHexString
}
function addSlice(t) {
    return (
        t.slice ||
            (t.slice = function () {
                const e = Array.prototype.slice.call(arguments)
                return addSlice(new Uint8Array(Array.prototype.slice.apply(t, e)))
            }),
        t
    )
}
function isBytesLike(t) {
    return (isHexString(t) && !(t.length % 2)) || isBytes$1(t)
}
function isInteger(t) {
    return typeof t == "number" && t == t && t % 1 === 0
}
function isBytes$1(t) {
    if (t == null) return !1
    if (t.constructor === Uint8Array) return !0
    if (typeof t == "string" || !isInteger(t.length) || t.length < 0) return !1
    for (let e = 0; e < t.length; e++) {
        const n = t[e]
        if (!isInteger(n) || n < 0 || n >= 256) return !1
    }
    return !0
}
function arrayify(t, e) {
    if ((e || (e = {}), typeof t == "number")) {
        logger$p.checkSafeUint53(t, "invalid arrayify value")
        const n = []
        for (; t; ) n.unshift(t & 255), (t = parseInt(String(t / 256)))
        return n.length === 0 && n.push(0), addSlice(new Uint8Array(n))
    }
    if (
        (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t),
        isHexable(t) && (t = t.toHexString()),
        isHexString(t))
    ) {
        let n = t.substring(2)
        n.length % 2 &&
            (e.hexPad === "left"
                ? (n = "0" + n)
                : e.hexPad === "right"
                ? (n += "0")
                : logger$p.throwArgumentError("hex data is odd-length", "value", t))
        const i = []
        for (let o = 0; o < n.length; o += 2) i.push(parseInt(n.substring(o, o + 2), 16))
        return addSlice(new Uint8Array(i))
    }
    return isBytes$1(t) ? addSlice(new Uint8Array(t)) : logger$p.throwArgumentError("invalid arrayify value", "value", t)
}
function concat$2(t) {
    const e = t.map((o) => arrayify(o)),
        n = e.reduce((o, a) => o + a.length, 0),
        i = new Uint8Array(n)
    return e.reduce((o, a) => (i.set(a, o), o + a.length), 0), addSlice(i)
}
function stripZeros(t) {
    let e = arrayify(t)
    if (e.length === 0) return e
    let n = 0
    for (; n < e.length && e[n] === 0; ) n++
    return n && (e = e.slice(n)), e
}
function zeroPad(t, e) {
    ;(t = arrayify(t)), t.length > e && logger$p.throwArgumentError("value out of range", "value", arguments[0])
    const n = new Uint8Array(e)
    return n.set(t, e - t.length), addSlice(n)
}
function isHexString(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || (e && t.length !== 2 + 2 * e))
}
const HexCharacters = "0123456789abcdef"
function hexlify(t, e) {
    if ((e || (e = {}), typeof t == "number")) {
        logger$p.checkSafeUint53(t, "invalid hexlify value")
        let n = ""
        for (; t; ) (n = HexCharacters[t & 15] + n), (t = Math.floor(t / 16))
        return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00"
    }
    if (typeof t == "bigint") return (t = t.toString(16)), t.length % 2 ? "0x0" + t : "0x" + t
    if ((e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), isHexable(t))) return t.toHexString()
    if (isHexString(t))
        return (
            t.length % 2 &&
                (e.hexPad === "left"
                    ? (t = "0x0" + t.substring(2))
                    : e.hexPad === "right"
                    ? (t += "0")
                    : logger$p.throwArgumentError("hex data is odd-length", "value", t)),
            t.toLowerCase()
        )
    if (isBytes$1(t)) {
        let n = "0x"
        for (let i = 0; i < t.length; i++) {
            let o = t[i]
            n += HexCharacters[(o & 240) >> 4] + HexCharacters[o & 15]
        }
        return n
    }
    return logger$p.throwArgumentError("invalid hexlify value", "value", t)
}
function hexDataLength(t) {
    if (typeof t != "string") t = hexlify(t)
    else if (!isHexString(t) || t.length % 2) return null
    return (t.length - 2) / 2
}
function hexDataSlice(t, e, n) {
    return (
        typeof t != "string"
            ? (t = hexlify(t))
            : (!isHexString(t) || t.length % 2) && logger$p.throwArgumentError("invalid hexData", "value", t),
        (e = 2 + 2 * e),
        n != null ? "0x" + t.substring(e, 2 + 2 * n) : "0x" + t.substring(e)
    )
}
function hexConcat(t) {
    let e = "0x"
    return (
        t.forEach((n) => {
            e += hexlify(n).substring(2)
        }),
        e
    )
}
function hexValue(t) {
    const e = hexStripZeros(hexlify(t, { hexPad: "left" }))
    return e === "0x" ? "0x0" : e
}
function hexStripZeros(t) {
    typeof t != "string" && (t = hexlify(t)),
        isHexString(t) || logger$p.throwArgumentError("invalid hex string", "value", t),
        (t = t.substring(2))
    let e = 0
    for (; e < t.length && t[e] === "0"; ) e++
    return "0x" + t.substring(e)
}
function hexZeroPad(t, e) {
    for (
        typeof t != "string" ? (t = hexlify(t)) : isHexString(t) || logger$p.throwArgumentError("invalid hex string", "value", t),
            t.length > 2 * e + 2 && logger$p.throwArgumentError("value out of range", "value", arguments[1]);
        t.length < 2 * e + 2;

    )
        t = "0x0" + t.substring(2)
    return t
}
function splitSignature(t) {
    const e = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0, yParityAndS: "0x", compact: "0x" }
    if (isBytesLike(t)) {
        let n = arrayify(t)
        n.length === 64
            ? ((e.v = 27 + (n[32] >> 7)), (n[32] &= 127), (e.r = hexlify(n.slice(0, 32))), (e.s = hexlify(n.slice(32, 64))))
            : n.length === 65
            ? ((e.r = hexlify(n.slice(0, 32))), (e.s = hexlify(n.slice(32, 64))), (e.v = n[64]))
            : logger$p.throwArgumentError("invalid signature string", "signature", t),
            e.v < 27 && (e.v === 0 || e.v === 1 ? (e.v += 27) : logger$p.throwArgumentError("signature invalid v byte", "signature", t)),
            (e.recoveryParam = 1 - (e.v % 2)),
            e.recoveryParam && (n[32] |= 128),
            (e._vs = hexlify(n.slice(32, 64)))
    } else {
        if (((e.r = t.r), (e.s = t.s), (e.v = t.v), (e.recoveryParam = t.recoveryParam), (e._vs = t._vs), e._vs != null)) {
            const o = zeroPad(arrayify(e._vs), 32)
            e._vs = hexlify(o)
            const a = o[0] >= 128 ? 1 : 0
            e.recoveryParam == null
                ? (e.recoveryParam = a)
                : e.recoveryParam !== a && logger$p.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t),
                (o[0] &= 127)
            const l = hexlify(o)
            e.s == null ? (e.s = l) : e.s !== l && logger$p.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null)
            e.v == null
                ? logger$p.throwArgumentError("signature missing v and recoveryParam", "signature", t)
                : e.v === 0 || e.v === 1
                ? (e.recoveryParam = e.v)
                : (e.recoveryParam = 1 - (e.v % 2))
        else if (e.v == null) e.v = 27 + e.recoveryParam
        else {
            const o = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2)
            e.recoveryParam !== o && logger$p.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !isHexString(e.r)
            ? logger$p.throwArgumentError("signature missing or invalid r", "signature", t)
            : (e.r = hexZeroPad(e.r, 32)),
            e.s == null || !isHexString(e.s)
                ? logger$p.throwArgumentError("signature missing or invalid s", "signature", t)
                : (e.s = hexZeroPad(e.s, 32))
        const n = arrayify(e.s)
        n[0] >= 128 && logger$p.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (n[0] |= 128)
        const i = hexlify(n)
        e._vs && (isHexString(e._vs) || logger$p.throwArgumentError("signature invalid _vs", "signature", t), (e._vs = hexZeroPad(e._vs, 32))),
            e._vs == null ? (e._vs = i) : e._vs !== i && logger$p.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return (e.yParityAndS = e._vs), (e.compact = e.r + e.yParityAndS.substring(2)), e
}
const version$h = "bignumber/5.7.0"
var BN$1 = _BN.BN
const logger$o = new Logger(version$h),
    _constructorGuard$2 = {},
    MAX_SAFE = 9007199254740991
let _warnedToStringRadix = !1
class BigNumber {
    constructor(e, n) {
        e !== _constructorGuard$2 &&
            logger$o.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)",
            }),
            (this._hex = n),
            (this._isBigNumber = !0),
            Object.freeze(this)
    }
    fromTwos(e) {
        return toBigNumber(toBN(this).fromTwos(e))
    }
    toTwos(e) {
        return toBigNumber(toBN(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this
    }
    add(e) {
        return toBigNumber(toBN(this).add(toBN(e)))
    }
    sub(e) {
        return toBigNumber(toBN(this).sub(toBN(e)))
    }
    div(e) {
        return BigNumber.from(e).isZero() && throwFault("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(e)))
    }
    mul(e) {
        return toBigNumber(toBN(this).mul(toBN(e)))
    }
    mod(e) {
        const n = toBN(e)
        return n.isNeg() && throwFault("division-by-zero", "mod"), toBigNumber(toBN(this).umod(n))
    }
    pow(e) {
        const n = toBN(e)
        return n.isNeg() && throwFault("negative-power", "pow"), toBigNumber(toBN(this).pow(n))
    }
    and(e) {
        const n = toBN(e)
        return (this.isNegative() || n.isNeg()) && throwFault("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(n))
    }
    or(e) {
        const n = toBN(e)
        return (this.isNegative() || n.isNeg()) && throwFault("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(n))
    }
    xor(e) {
        const n = toBN(e)
        return (this.isNegative() || n.isNeg()) && throwFault("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(n))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && throwFault("negative-width", "mask"), toBigNumber(toBN(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && throwFault("negative-width", "shl"), toBigNumber(toBN(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && throwFault("negative-width", "shr"), toBigNumber(toBN(this).shrn(e))
    }
    eq(e) {
        return toBN(this).eq(toBN(e))
    }
    lt(e) {
        return toBN(this).lt(toBN(e))
    }
    lte(e) {
        return toBN(this).lte(toBN(e))
    }
    gt(e) {
        return toBN(this).gt(toBN(e))
    }
    gte(e) {
        return toBN(this).gte(toBN(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return toBN(this).isZero()
    }
    toNumber() {
        try {
            return toBN(this).toNumber()
        } catch {
            throwFault("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return logger$o.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, { value: this.toString() })
    }
    toString() {
        return (
            arguments.length > 0 &&
                (arguments[0] === 10
                    ? _warnedToStringRadix ||
                      ((_warnedToStringRadix = !0), logger$o.warn("BigNumber.toString does not accept any parameters; base-10 is assumed"))
                    : arguments[0] === 16
                    ? logger$o.throwError(
                          "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
                          Logger.errors.UNEXPECTED_ARGUMENT,
                          {}
                      )
                    : logger$o.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})),
            toBN(this).toString(10)
        )
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return { type: "BigNumber", hex: this.toHexString() }
    }
    static from(e) {
        if (e instanceof BigNumber) return e
        if (typeof e == "string")
            return e.match(/^-?0x[0-9a-f]+$/i)
                ? new BigNumber(_constructorGuard$2, toHex$1(e))
                : e.match(/^-?[0-9]+$/)
                ? new BigNumber(_constructorGuard$2, toHex$1(new BN$1(e)))
                : logger$o.throwArgumentError("invalid BigNumber string", "value", e)
        if (typeof e == "number")
            return (
                e % 1 && throwFault("underflow", "BigNumber.from", e),
                (e >= MAX_SAFE || e <= -MAX_SAFE) && throwFault("overflow", "BigNumber.from", e),
                BigNumber.from(String(e))
            )
        const n = e
        if (typeof n == "bigint") return BigNumber.from(n.toString())
        if (isBytes$1(n)) return BigNumber.from(hexlify(n))
        if (n)
            if (n.toHexString) {
                const i = n.toHexString()
                if (typeof i == "string") return BigNumber.from(i)
            } else {
                let i = n._hex
                if (
                    (i == null && n.type === "BigNumber" && (i = n.hex),
                    typeof i == "string" && (isHexString(i) || (i[0] === "-" && isHexString(i.substring(1)))))
                )
                    return BigNumber.from(i)
            }
        return logger$o.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}
function toHex$1(t) {
    if (typeof t != "string") return toHex$1(t.toString(16))
    if (t[0] === "-")
        return (
            (t = t.substring(1)),
            t[0] === "-" && logger$o.throwArgumentError("invalid hex", "value", t),
            (t = toHex$1(t)),
            t === "0x00" ? t : "-" + t
        )
    if ((t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x")) return "0x00"
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00"; ) t = "0x" + t.substring(4)
    return t
}
function toBigNumber(t) {
    return BigNumber.from(toHex$1(t))
}
function toBN(t) {
    const e = BigNumber.from(t).toHexString()
    return e[0] === "-" ? new BN$1("-" + e.substring(3), 16) : new BN$1(e.substring(2), 16)
}
function throwFault(t, e, n) {
    const i = { fault: t, operation: e }
    return n != null && (i.value = n), logger$o.throwError(t, Logger.errors.NUMERIC_FAULT, i)
}
function _base36To16(t) {
    return new BN$1(t, 36).toString(16)
}
const version$g = "properties/5.7.0"
var __awaiter$9 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$n = new Logger(version$g)
function defineReadOnly(t, e, n) {
    Object.defineProperty(t, e, { enumerable: !0, value: n, writable: !1 })
}
function getStatic(t, e) {
    for (let n = 0; n < 32; n++) {
        if (t[e]) return t[e]
        if (!t.prototype || typeof t.prototype != "object") break
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}
function resolveProperties(t) {
    return __awaiter$9(this, void 0, void 0, function* () {
        const e = Object.keys(t).map((i) => {
            const o = t[i]
            return Promise.resolve(o).then((a) => ({ key: i, value: a }))
        })
        return (yield Promise.all(e)).reduce((i, o) => ((i[o.key] = o.value), i), {})
    })
}
function checkProperties(t, e) {
    ;(!t || typeof t != "object") && logger$n.throwArgumentError("invalid object", "object", t),
        Object.keys(t).forEach((n) => {
            e[n] || logger$n.throwArgumentError("invalid object key - " + n, "transaction:" + n, t)
        })
}
function shallowCopy(t) {
    const e = {}
    for (const n in t) e[n] = t[n]
    return e
}
const opaque = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 }
function _isFrozen(t) {
    if (t == null || opaque[typeof t]) return !0
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1
        const e = Object.keys(t)
        for (let n = 0; n < e.length; n++) {
            let i = null
            try {
                i = t[e[n]]
            } catch {
                continue
            }
            if (!_isFrozen(i)) return !1
        }
        return !0
    }
    return logger$n.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}
function _deepCopy(t) {
    if (_isFrozen(t)) return t
    if (Array.isArray(t)) return Object.freeze(t.map((e) => deepCopy(e)))
    if (typeof t == "object") {
        const e = {}
        for (const n in t) {
            const i = t[n]
            i !== void 0 && defineReadOnly(e, n, deepCopy(i))
        }
        return e
    }
    return logger$n.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}
function deepCopy(t) {
    return _deepCopy(t)
}
class Description {
    constructor(e) {
        for (const n in e) this[n] = deepCopy(e[n])
    }
}
const version$f = "abi/5.7.0",
    logger$m = new Logger(version$f),
    _constructorGuard$1 = {}
let ModifiersBytes = { calldata: !0, memory: !0, storage: !0 },
    ModifiersNest = { calldata: !0, memory: !0 }
function checkModifier(t, e) {
    if (t === "bytes" || t === "string") {
        if (ModifiersBytes[e]) return !0
    } else if (t === "address") {
        if (e === "payable") return !0
    } else if ((t.indexOf("[") >= 0 || t === "tuple") && ModifiersNest[e]) return !0
    return (ModifiersBytes[e] || e === "payable") && logger$m.throwArgumentError("invalid modifier", "name", e), !1
}
function parseParamType(t, e) {
    let n = t
    function i(c) {
        logger$m.throwArgumentError(`unexpected character at position ${c}`, "param", t)
    }
    t = t.replace(/\s/g, " ")
    function o(c) {
        let g = { type: "", name: "", parent: c, state: { allowType: !0 } }
        return e && (g.indexed = !1), g
    }
    let a = { type: "", name: "", state: { allowType: !0 } },
        l = a
    for (let c = 0; c < t.length; c++) {
        let g = t[c]
        switch (g) {
            case "(":
                l.state.allowType && l.type === "" ? (l.type = "tuple") : l.state.allowParams || i(c),
                    (l.state.allowType = !1),
                    (l.type = verifyType(l.type)),
                    (l.components = [o(l)]),
                    (l = l.components[0])
                break
            case ")":
                delete l.state,
                    l.name === "indexed" && (e || i(c), (l.indexed = !0), (l.name = "")),
                    checkModifier(l.type, l.name) && (l.name = ""),
                    (l.type = verifyType(l.type))
                let v = l
                ;(l = l.parent), l || i(c), delete v.parent, (l.state.allowParams = !1), (l.state.allowName = !0), (l.state.allowArray = !0)
                break
            case ",":
                delete l.state,
                    l.name === "indexed" && (e || i(c), (l.indexed = !0), (l.name = "")),
                    checkModifier(l.type, l.name) && (l.name = ""),
                    (l.type = verifyType(l.type))
                let _ = o(l.parent)
                l.parent.components.push(_), delete l.parent, (l = _)
                break
            case " ":
                l.state.allowType &&
                    l.type !== "" &&
                    ((l.type = verifyType(l.type)), delete l.state.allowType, (l.state.allowName = !0), (l.state.allowParams = !0)),
                    l.state.allowName &&
                        l.name !== "" &&
                        (l.name === "indexed"
                            ? (e || i(c), l.indexed && i(c), (l.indexed = !0), (l.name = ""))
                            : checkModifier(l.type, l.name)
                            ? (l.name = "")
                            : (l.state.allowName = !1))
                break
            case "[":
                l.state.allowArray || i(c), (l.type += g), (l.state.allowArray = !1), (l.state.allowName = !1), (l.state.readArray = !0)
                break
            case "]":
                l.state.readArray || i(c), (l.type += g), (l.state.readArray = !1), (l.state.allowArray = !0), (l.state.allowName = !0)
                break
            default:
                l.state.allowType
                    ? ((l.type += g), (l.state.allowParams = !0), (l.state.allowArray = !0))
                    : l.state.allowName
                    ? ((l.name += g), delete l.state.allowArray)
                    : l.state.readArray
                    ? (l.type += g)
                    : i(c)
        }
    }
    return (
        l.parent && logger$m.throwArgumentError("unexpected eof", "param", t),
        delete a.state,
        l.name === "indexed"
            ? (e || i(n.length - 7), l.indexed && i(n.length - 7), (l.indexed = !0), (l.name = ""))
            : checkModifier(l.type, l.name) && (l.name = ""),
        (a.type = verifyType(a.type)),
        a
    )
}
function populate(t, e) {
    for (let n in e) defineReadOnly(t, n, e[n])
}
const FormatTypes = Object.freeze({ sighash: "sighash", minimal: "minimal", full: "full", json: "json" }),
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/)
class ParamType {
    constructor(e, n) {
        e !== _constructorGuard$1 &&
            logger$m.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, { operation: "new ParamType()" }),
            populate(this, n)
        let i = this.type.match(paramTypeArray)
        i
            ? populate(this, {
                  arrayLength: parseInt(i[2] || "-1"),
                  arrayChildren: ParamType.fromObject({ type: i[1], components: this.components }),
                  baseType: "array",
              })
            : populate(this, { arrayLength: null, arrayChildren: null, baseType: this.components != null ? "tuple" : this.type }),
            (this._isParamType = !0),
            Object.freeze(this)
    }
    format(e) {
        if (
            (e || (e = FormatTypes.sighash),
            FormatTypes[e] || logger$m.throwArgumentError("invalid format type", "format", e),
            e === FormatTypes.json)
        ) {
            let i = { type: this.baseType === "tuple" ? "tuple" : this.type, name: this.name || void 0 }
            return (
                typeof this.indexed == "boolean" && (i.indexed = this.indexed),
                this.components && (i.components = this.components.map((o) => JSON.parse(o.format(e)))),
                JSON.stringify(i)
            )
        }
        let n = ""
        return (
            this.baseType === "array"
                ? ((n += this.arrayChildren.format(e)), (n += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
                : this.baseType === "tuple"
                ? (e !== FormatTypes.sighash && (n += this.type),
                  (n += "(" + this.components.map((i) => i.format(e)).join(e === FormatTypes.full ? ", " : ",") + ")"))
                : (n += this.type),
            e !== FormatTypes.sighash &&
                (this.indexed === !0 && (n += " indexed"), e === FormatTypes.full && this.name && (n += " " + this.name)),
            n
        )
    }
    static from(e, n) {
        return typeof e == "string" ? ParamType.fromString(e, n) : ParamType.fromObject(e)
    }
    static fromObject(e) {
        return ParamType.isParamType(e)
            ? e
            : new ParamType(_constructorGuard$1, {
                  name: e.name || null,
                  type: verifyType(e.type),
                  indexed: e.indexed == null ? null : !!e.indexed,
                  components: e.components ? e.components.map(ParamType.fromObject) : null,
              })
    }
    static fromString(e, n) {
        function i(o) {
            return ParamType.fromObject({ name: o.name, type: o.type, indexed: o.indexed, components: o.components })
        }
        return i(parseParamType(e, !!n))
    }
    static isParamType(e) {
        return !!(e != null && e._isParamType)
    }
}
function parseParams(t, e) {
    return splitNesting(t).map((n) => ParamType.fromString(n, e))
}
class Fragment {
    constructor(e, n) {
        e !== _constructorGuard$1 &&
            logger$m.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, { operation: "new Fragment()" }),
            populate(this, n),
            (this._isFragment = !0),
            Object.freeze(this)
    }
    static from(e) {
        return Fragment.isFragment(e) ? e : typeof e == "string" ? Fragment.fromString(e) : Fragment.fromObject(e)
    }
    static fromObject(e) {
        if (Fragment.isFragment(e)) return e
        switch (e.type) {
            case "function":
                return FunctionFragment.fromObject(e)
            case "event":
                return EventFragment.fromObject(e)
            case "constructor":
                return ConstructorFragment.fromObject(e)
            case "error":
                return ErrorFragment.fromObject(e)
            case "fallback":
            case "receive":
                return null
        }
        return logger$m.throwArgumentError("invalid fragment object", "value", e)
    }
    static fromString(e) {
        return (
            (e = e.replace(/\s/g, " ")),
            (e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
            (e = e.trim()),
            e.split(" ")[0] === "event"
                ? EventFragment.fromString(e.substring(5).trim())
                : e.split(" ")[0] === "function"
                ? FunctionFragment.fromString(e.substring(8).trim())
                : e.split("(")[0].trim() === "constructor"
                ? ConstructorFragment.fromString(e.trim())
                : e.split(" ")[0] === "error"
                ? ErrorFragment.fromString(e.substring(5).trim())
                : logger$m.throwArgumentError("unsupported fragment", "value", e)
        )
    }
    static isFragment(e) {
        return !!(e && e._isFragment)
    }
}
class EventFragment extends Fragment {
    format(e) {
        if (
            (e || (e = FormatTypes.sighash),
            FormatTypes[e] || logger$m.throwArgumentError("invalid format type", "format", e),
            e === FormatTypes.json)
        )
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
            })
        let n = ""
        return (
            e !== FormatTypes.sighash && (n += "event "),
            (n += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") "),
            e !== FormatTypes.sighash && this.anonymous && (n += "anonymous "),
            n.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? EventFragment.fromString(e) : EventFragment.fromObject(e)
    }
    static fromObject(e) {
        if (EventFragment.isEventFragment(e)) return e
        e.type !== "event" && logger$m.throwArgumentError("invalid event object", "value", e)
        const n = {
            name: verifyIdentifier(e.name),
            anonymous: e.anonymous,
            inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
            type: "event",
        }
        return new EventFragment(_constructorGuard$1, n)
    }
    static fromString(e) {
        let n = e.match(regexParen)
        n || logger$m.throwArgumentError("invalid event string", "value", e)
        let i = !1
        return (
            n[3].split(" ").forEach((o) => {
                switch (o.trim()) {
                    case "anonymous":
                        i = !0
                        break
                    case "":
                        break
                    default:
                        logger$m.warn("unknown modifier: " + o)
                }
            }),
            EventFragment.fromObject({ name: n[1].trim(), anonymous: i, inputs: parseParams(n[2], !0), type: "event" })
        )
    }
    static isEventFragment(e) {
        return e && e._isFragment && e.type === "event"
    }
}
function parseGas(t, e) {
    e.gas = null
    let n = t.split("@")
    return n.length !== 1
        ? (n.length > 2 && logger$m.throwArgumentError("invalid human-readable ABI signature", "value", t),
          n[1].match(/^[0-9]+$/) || logger$m.throwArgumentError("invalid human-readable ABI signature gas", "value", t),
          (e.gas = BigNumber.from(n[1])),
          n[0])
        : t
}
function parseModifiers(t, e) {
    ;(e.constant = !1),
        (e.payable = !1),
        (e.stateMutability = "nonpayable"),
        t.split(" ").forEach((n) => {
            switch (n.trim()) {
                case "constant":
                    e.constant = !0
                    break
                case "payable":
                    ;(e.payable = !0), (e.stateMutability = "payable")
                    break
                case "nonpayable":
                    ;(e.payable = !1), (e.stateMutability = "nonpayable")
                    break
                case "pure":
                    ;(e.constant = !0), (e.stateMutability = "pure")
                    break
                case "view":
                    ;(e.constant = !0), (e.stateMutability = "view")
                    break
                case "external":
                case "public":
                case "":
                    break
                default:
                    console.log("unknown modifier: " + n)
            }
        })
}
function verifyState(t) {
    let e = { constant: !1, payable: !0, stateMutability: "payable" }
    return (
        t.stateMutability != null
            ? ((e.stateMutability = t.stateMutability),
              (e.constant = e.stateMutability === "view" || e.stateMutability === "pure"),
              t.constant != null &&
                  !!t.constant !== e.constant &&
                  logger$m.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t),
              (e.payable = e.stateMutability === "payable"),
              t.payable != null &&
                  !!t.payable !== e.payable &&
                  logger$m.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t))
            : t.payable != null
            ? ((e.payable = !!t.payable),
              t.constant == null &&
                  !e.payable &&
                  t.type !== "constructor" &&
                  logger$m.throwArgumentError("unable to determine stateMutability", "value", t),
              (e.constant = !!t.constant),
              e.constant ? (e.stateMutability = "view") : (e.stateMutability = e.payable ? "payable" : "nonpayable"),
              e.payable && e.constant && logger$m.throwArgumentError("cannot have constant payable function", "value", t))
            : t.constant != null
            ? ((e.constant = !!t.constant), (e.payable = !e.constant), (e.stateMutability = e.constant ? "view" : "payable"))
            : t.type !== "constructor" && logger$m.throwArgumentError("unable to determine stateMutability", "value", t),
        e
    )
}
class ConstructorFragment extends Fragment {
    format(e) {
        if (
            (e || (e = FormatTypes.sighash),
            FormatTypes[e] || logger$m.throwArgumentError("invalid format type", "format", e),
            e === FormatTypes.json)
        )
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
            })
        e === FormatTypes.sighash &&
            logger$m.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, { operation: "format(sighash)" })
        let n = "constructor(" + this.inputs.map((i) => i.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") "
        return this.stateMutability && this.stateMutability !== "nonpayable" && (n += this.stateMutability + " "), n.trim()
    }
    static from(e) {
        return typeof e == "string" ? ConstructorFragment.fromString(e) : ConstructorFragment.fromObject(e)
    }
    static fromObject(e) {
        if (ConstructorFragment.isConstructorFragment(e)) return e
        e.type !== "constructor" && logger$m.throwArgumentError("invalid constructor object", "value", e)
        let n = verifyState(e)
        n.constant && logger$m.throwArgumentError("constructor cannot be constant", "value", e)
        const i = {
            name: null,
            type: e.type,
            inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
            payable: n.payable,
            stateMutability: n.stateMutability,
            gas: e.gas ? BigNumber.from(e.gas) : null,
        }
        return new ConstructorFragment(_constructorGuard$1, i)
    }
    static fromString(e) {
        let n = { type: "constructor" }
        e = parseGas(e, n)
        let i = e.match(regexParen)
        return (
            (!i || i[1].trim() !== "constructor") && logger$m.throwArgumentError("invalid constructor string", "value", e),
            (n.inputs = parseParams(i[2].trim(), !1)),
            parseModifiers(i[3].trim(), n),
            ConstructorFragment.fromObject(n)
        )
    }
    static isConstructorFragment(e) {
        return e && e._isFragment && e.type === "constructor"
    }
}
class FunctionFragment extends ConstructorFragment {
    format(e) {
        if (
            (e || (e = FormatTypes.sighash),
            FormatTypes[e] || logger$m.throwArgumentError("invalid format type", "format", e),
            e === FormatTypes.json)
        )
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
                outputs: this.outputs.map((i) => JSON.parse(i.format(e))),
            })
        let n = ""
        return (
            e !== FormatTypes.sighash && (n += "function "),
            (n += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") "),
            e !== FormatTypes.sighash &&
                (this.stateMutability
                    ? this.stateMutability !== "nonpayable" && (n += this.stateMutability + " ")
                    : this.constant && (n += "view "),
                this.outputs && this.outputs.length && (n += "returns (" + this.outputs.map((i) => i.format(e)).join(", ") + ") "),
                this.gas != null && (n += "@" + this.gas.toString() + " ")),
            n.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? FunctionFragment.fromString(e) : FunctionFragment.fromObject(e)
    }
    static fromObject(e) {
        if (FunctionFragment.isFunctionFragment(e)) return e
        e.type !== "function" && logger$m.throwArgumentError("invalid function object", "value", e)
        let n = verifyState(e)
        const i = {
            type: e.type,
            name: verifyIdentifier(e.name),
            constant: n.constant,
            inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [],
            outputs: e.outputs ? e.outputs.map(ParamType.fromObject) : [],
            payable: n.payable,
            stateMutability: n.stateMutability,
            gas: e.gas ? BigNumber.from(e.gas) : null,
        }
        return new FunctionFragment(_constructorGuard$1, i)
    }
    static fromString(e) {
        let n = { type: "function" }
        e = parseGas(e, n)
        let i = e.split(" returns ")
        i.length > 2 && logger$m.throwArgumentError("invalid function string", "value", e)
        let o = i[0].match(regexParen)
        if (
            (o || logger$m.throwArgumentError("invalid function signature", "value", e),
            (n.name = o[1].trim()),
            n.name && verifyIdentifier(n.name),
            (n.inputs = parseParams(o[2], !1)),
            parseModifiers(o[3].trim(), n),
            i.length > 1)
        ) {
            let a = i[1].match(regexParen)
            ;(a[1].trim() != "" || a[3].trim() != "") && logger$m.throwArgumentError("unexpected tokens", "value", e),
                (n.outputs = parseParams(a[2], !1))
        } else n.outputs = []
        return FunctionFragment.fromObject(n)
    }
    static isFunctionFragment(e) {
        return e && e._isFragment && e.type === "function"
    }
}
function checkForbidden(t) {
    const e = t.format()
    return (
        (e === "Error(string)" || e === "Panic(uint256)") &&
            logger$m.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t),
        t
    )
}
class ErrorFragment extends Fragment {
    format(e) {
        if (
            (e || (e = FormatTypes.sighash),
            FormatTypes[e] || logger$m.throwArgumentError("invalid format type", "format", e),
            e === FormatTypes.json)
        )
            return JSON.stringify({ type: "error", name: this.name, inputs: this.inputs.map((i) => JSON.parse(i.format(e))) })
        let n = ""
        return (
            e !== FormatTypes.sighash && (n += "error "),
            (n += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === FormatTypes.full ? ", " : ",") + ") "),
            n.trim()
        )
    }
    static from(e) {
        return typeof e == "string" ? ErrorFragment.fromString(e) : ErrorFragment.fromObject(e)
    }
    static fromObject(e) {
        if (ErrorFragment.isErrorFragment(e)) return e
        e.type !== "error" && logger$m.throwArgumentError("invalid error object", "value", e)
        const n = { type: e.type, name: verifyIdentifier(e.name), inputs: e.inputs ? e.inputs.map(ParamType.fromObject) : [] }
        return checkForbidden(new ErrorFragment(_constructorGuard$1, n))
    }
    static fromString(e) {
        let n = { type: "error" },
            i = e.match(regexParen)
        return (
            i || logger$m.throwArgumentError("invalid error signature", "value", e),
            (n.name = i[1].trim()),
            n.name && verifyIdentifier(n.name),
            (n.inputs = parseParams(i[2], !1)),
            checkForbidden(ErrorFragment.fromObject(n))
        )
    }
    static isErrorFragment(e) {
        return e && e._isFragment && e.type === "error"
    }
}
function verifyType(t) {
    return t.match(/^uint($|[^1-9])/) ? (t = "uint256" + t.substring(4)) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$")
function verifyIdentifier(t) {
    return (!t || !t.match(regexIdentifier)) && logger$m.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$")
function splitNesting(t) {
    t = t.trim()
    let e = [],
        n = "",
        i = 0
    for (let o = 0; o < t.length; o++) {
        let a = t[o]
        a === "," && i === 0
            ? (e.push(n), (n = ""))
            : ((n += a), a === "(" ? i++ : a === ")" && (i--, i === -1 && logger$m.throwArgumentError("unbalanced parenthesis", "value", t)))
    }
    return n && e.push(n), e
}
const logger$l = new Logger(version$f)
function checkResultErrors(t) {
    const e = [],
        n = function (i, o) {
            if (!!Array.isArray(o))
                for (let a in o) {
                    const l = i.slice()
                    l.push(a)
                    try {
                        n(l, o[a])
                    } catch (c) {
                        e.push({ path: l, error: c })
                    }
                }
        }
    return n([], t), e
}
class Coder {
    constructor(e, n, i, o) {
        ;(this.name = e), (this.type = n), (this.localName = i), (this.dynamic = o)
    }
    _throwError(e, n) {
        logger$l.throwArgumentError(e, this.localName, n)
    }
}
class Writer$2 {
    constructor(e) {
        defineReadOnly(this, "wordSize", e || 32), (this._data = []), (this._dataLength = 0), (this._padding = new Uint8Array(e))
    }
    get data() {
        return hexConcat(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(e) {
        return this._data.push(e), (this._dataLength += e.length), e.length
    }
    appendWriter(e) {
        return this._writeData(concat$2(e._data))
    }
    writeBytes(e) {
        let n = arrayify(e)
        const i = n.length % this.wordSize
        return i && (n = concat$2([n, this._padding.slice(i)])), this._writeData(n)
    }
    _getValue(e) {
        let n = arrayify(BigNumber.from(e))
        return (
            n.length > this.wordSize &&
                logger$l.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, { length: this.wordSize, offset: n.length }),
            n.length % this.wordSize && (n = concat$2([this._padding.slice(n.length % this.wordSize), n])),
            n
        )
    }
    writeValue(e) {
        return this._writeData(this._getValue(e))
    }
    writeUpdatableValue() {
        const e = this._data.length
        return (
            this._data.push(this._padding),
            (this._dataLength += this.wordSize),
            (n) => {
                this._data[e] = this._getValue(n)
            }
        )
    }
}
class Reader$2 {
    constructor(e, n, i, o) {
        defineReadOnly(this, "_data", arrayify(e)),
            defineReadOnly(this, "wordSize", n || 32),
            defineReadOnly(this, "_coerceFunc", i),
            defineReadOnly(this, "allowLoose", o),
            (this._offset = 0)
    }
    get data() {
        return hexlify(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(e, n) {
        let i = e.match("^u?int([0-9]+)$")
        return i && parseInt(i[1]) <= 48 && (n = n.toNumber()), n
    }
    coerce(e, n) {
        return this._coerceFunc ? this._coerceFunc(e, n) : Reader$2.coerce(e, n)
    }
    _peekBytes(e, n, i) {
        let o = Math.ceil(n / this.wordSize) * this.wordSize
        return (
            this._offset + o > this._data.length &&
                (this.allowLoose && i && this._offset + n <= this._data.length
                    ? (o = n)
                    : logger$l.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                          length: this._data.length,
                          offset: this._offset + o,
                      })),
            this._data.slice(this._offset, this._offset + o)
        )
    }
    subReader(e) {
        return new Reader$2(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose)
    }
    readBytes(e, n) {
        let i = this._peekBytes(0, e, !!n)
        return (this._offset += i.length), i.slice(0, e)
    }
    readValue() {
        return BigNumber.from(this.readBytes(this.wordSize))
    }
}
var sha3$1 = { exports: {} }
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ ;(function (t) {
    ;(function () {
        var e = "input is invalid type",
            n = "finalize already called",
            i = typeof window == "object",
            o = i ? window : {}
        o.JS_SHA3_NO_WINDOW && (i = !1)
        var a = !i && typeof self == "object",
            l = !o.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node
        l ? (o = commonjsGlobal) : a && (o = self)
        var c = !o.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
            g = !o.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
            v = "0123456789abcdef".split(""),
            _ = [31, 7936, 2031616, 520093696],
            A = [4, 1024, 262144, 67108864],
            B = [1, 256, 65536, 16777216],
            D = [6, 1536, 393216, 100663296],
            I = [0, 8, 16, 24],
            L = [
                1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648,
                138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770,
                2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0,
                2147516424, 2147483648,
            ],
            G = [224, 256, 384, 512],
            U = [128, 256],
            F = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            Z = { 128: 168, 256: 136 }
        ;(o.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
            (Array.isArray = function (k) {
                return Object.prototype.toString.call(k) === "[object Array]"
            }),
            g &&
                (o.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
                (ArrayBuffer.isView = function (k) {
                    return typeof k == "object" && k.buffer && k.buffer.constructor === ArrayBuffer
                })
        for (
            var Y = function (k, W, J) {
                    return function (ee) {
                        return new b(k, W, k).update(ee)[J]()
                    }
                },
                X = function (k, W, J) {
                    return function (ee, ne) {
                        return new b(k, W, ne).update(ee)[J]()
                    }
                },
                ie = function (k, W, J) {
                    return function (ee, ne, xe, ce) {
                        return u["cshake" + k].update(ee, ne, xe, ce)[J]()
                    }
                },
                he = function (k, W, J) {
                    return function (ee, ne, xe, ce) {
                        return u["kmac" + k].update(ee, ne, xe, ce)[J]()
                    }
                },
                oe = function (k, W, J, ee) {
                    for (var ne = 0; ne < F.length; ++ne) {
                        var xe = F[ne]
                        k[xe] = W(J, ee, xe)
                    }
                    return k
                },
                le = function (k, W) {
                    var J = Y(k, W, "hex")
                    return (
                        (J.create = function () {
                            return new b(k, W, k)
                        }),
                        (J.update = function (ee) {
                            return J.create().update(ee)
                        }),
                        oe(J, Y, k, W)
                    )
                },
                Te = function (k, W) {
                    var J = X(k, W, "hex")
                    return (
                        (J.create = function (ee) {
                            return new b(k, W, ee)
                        }),
                        (J.update = function (ee, ne) {
                            return J.create(ne).update(ee)
                        }),
                        oe(J, X, k, W)
                    )
                },
                ye = function (k, W) {
                    var J = Z[k],
                        ee = ie(k, W, "hex")
                    return (
                        (ee.create = function (ne, xe, ce) {
                            return !xe && !ce ? u["shake" + k].create(ne) : new b(k, W, ne).bytepad([xe, ce], J)
                        }),
                        (ee.update = function (ne, xe, ce, de) {
                            return ee.create(xe, ce, de).update(ne)
                        }),
                        oe(ee, ie, k, W)
                    )
                },
                Ae = function (k, W) {
                    var J = Z[k],
                        ee = he(k, W, "hex")
                    return (
                        (ee.create = function (ne, xe, ce) {
                            return new T(k, W, xe).bytepad(["KMAC", ce], J).bytepad([ne], J)
                        }),
                        (ee.update = function (ne, xe, ce, de) {
                            return ee.create(ne, ce, de).update(xe)
                        }),
                        oe(ee, he, k, W)
                    )
                },
                O = [
                    { name: "keccak", padding: B, bits: G, createMethod: le },
                    { name: "sha3", padding: D, bits: G, createMethod: le },
                    { name: "shake", padding: _, bits: U, createMethod: Te },
                    { name: "cshake", padding: A, bits: U, createMethod: ye },
                    { name: "kmac", padding: A, bits: U, createMethod: Ae },
                ],
                u = {},
                E = [],
                $ = 0;
            $ < O.length;
            ++$
        )
            for (var N = O[$], M = N.bits, R = 0; R < M.length; ++R) {
                var C = N.name + "_" + M[R]
                if ((E.push(C), (u[C] = N.createMethod(M[R], N.padding)), N.name !== "sha3")) {
                    var S = N.name + M[R]
                    E.push(S), (u[S] = u[C])
                }
            }
        function b(k, W, J) {
            ;(this.blocks = []),
                (this.s = []),
                (this.padding = W),
                (this.outputBits = J),
                (this.reset = !0),
                (this.finalized = !1),
                (this.block = 0),
                (this.start = 0),
                (this.blockCount = (1600 - (k << 1)) >> 5),
                (this.byteCount = this.blockCount << 2),
                (this.outputBlocks = J >> 5),
                (this.extraBytes = (J & 31) >> 3)
            for (var ee = 0; ee < 50; ++ee) this.s[ee] = 0
        }
        ;(b.prototype.update = function (k) {
            if (this.finalized) throw new Error(n)
            var W,
                J = typeof k
            if (J !== "string") {
                if (J === "object") {
                    if (k === null) throw new Error(e)
                    if (g && k.constructor === ArrayBuffer) k = new Uint8Array(k)
                    else if (!Array.isArray(k) && (!g || !ArrayBuffer.isView(k))) throw new Error(e)
                } else throw new Error(e)
                W = !0
            }
            for (var ee = this.blocks, ne = this.byteCount, xe = k.length, ce = this.blockCount, de = 0, H = this.s, j, q; de < xe; ) {
                if (this.reset) for (this.reset = !1, ee[0] = this.block, j = 1; j < ce + 1; ++j) ee[j] = 0
                if (W) for (j = this.start; de < xe && j < ne; ++de) ee[j >> 2] |= k[de] << I[j++ & 3]
                else
                    for (j = this.start; de < xe && j < ne; ++de)
                        (q = k.charCodeAt(de)),
                            q < 128
                                ? (ee[j >> 2] |= q << I[j++ & 3])
                                : q < 2048
                                ? ((ee[j >> 2] |= (192 | (q >> 6)) << I[j++ & 3]), (ee[j >> 2] |= (128 | (q & 63)) << I[j++ & 3]))
                                : q < 55296 || q >= 57344
                                ? ((ee[j >> 2] |= (224 | (q >> 12)) << I[j++ & 3]),
                                  (ee[j >> 2] |= (128 | ((q >> 6) & 63)) << I[j++ & 3]),
                                  (ee[j >> 2] |= (128 | (q & 63)) << I[j++ & 3]))
                                : ((q = 65536 + (((q & 1023) << 10) | (k.charCodeAt(++de) & 1023))),
                                  (ee[j >> 2] |= (240 | (q >> 18)) << I[j++ & 3]),
                                  (ee[j >> 2] |= (128 | ((q >> 12) & 63)) << I[j++ & 3]),
                                  (ee[j >> 2] |= (128 | ((q >> 6) & 63)) << I[j++ & 3]),
                                  (ee[j >> 2] |= (128 | (q & 63)) << I[j++ & 3]))
                if (((this.lastByteIndex = j), j >= ne)) {
                    for (this.start = j - ne, this.block = ee[ce], j = 0; j < ce; ++j) H[j] ^= ee[j]
                    Q(H), (this.reset = !0)
                } else this.start = j
            }
            return this
        }),
            (b.prototype.encode = function (k, W) {
                var J = k & 255,
                    ee = 1,
                    ne = [J]
                for (k = k >> 8, J = k & 255; J > 0; ) ne.unshift(J), (k = k >> 8), (J = k & 255), ++ee
                return W ? ne.push(ee) : ne.unshift(ee), this.update(ne), ne.length
            }),
            (b.prototype.encodeString = function (k) {
                var W,
                    J = typeof k
                if (J !== "string") {
                    if (J === "object") {
                        if (k === null) throw new Error(e)
                        if (g && k.constructor === ArrayBuffer) k = new Uint8Array(k)
                        else if (!Array.isArray(k) && (!g || !ArrayBuffer.isView(k))) throw new Error(e)
                    } else throw new Error(e)
                    W = !0
                }
                var ee = 0,
                    ne = k.length
                if (W) ee = ne
                else
                    for (var xe = 0; xe < k.length; ++xe) {
                        var ce = k.charCodeAt(xe)
                        ce < 128
                            ? (ee += 1)
                            : ce < 2048
                            ? (ee += 2)
                            : ce < 55296 || ce >= 57344
                            ? (ee += 3)
                            : ((ce = 65536 + (((ce & 1023) << 10) | (k.charCodeAt(++xe) & 1023))), (ee += 4))
                    }
                return (ee += this.encode(ee * 8)), this.update(k), ee
            }),
            (b.prototype.bytepad = function (k, W) {
                for (var J = this.encode(W), ee = 0; ee < k.length; ++ee) J += this.encodeString(k[ee])
                var ne = W - (J % W),
                    xe = []
                return (xe.length = ne), this.update(xe), this
            }),
            (b.prototype.finalize = function () {
                if (!this.finalized) {
                    this.finalized = !0
                    var k = this.blocks,
                        W = this.lastByteIndex,
                        J = this.blockCount,
                        ee = this.s
                    if (((k[W >> 2] |= this.padding[W & 3]), this.lastByteIndex === this.byteCount))
                        for (k[0] = k[J], W = 1; W < J + 1; ++W) k[W] = 0
                    for (k[J - 1] |= 2147483648, W = 0; W < J; ++W) ee[W] ^= k[W]
                    Q(ee)
                }
            }),
            (b.prototype.toString = b.prototype.hex =
                function () {
                    this.finalize()
                    for (
                        var k = this.blockCount, W = this.s, J = this.outputBlocks, ee = this.extraBytes, ne = 0, xe = 0, ce = "", de;
                        xe < J;

                    ) {
                        for (ne = 0; ne < k && xe < J; ++ne, ++xe)
                            (de = W[ne]),
                                (ce +=
                                    v[(de >> 4) & 15] +
                                    v[de & 15] +
                                    v[(de >> 12) & 15] +
                                    v[(de >> 8) & 15] +
                                    v[(de >> 20) & 15] +
                                    v[(de >> 16) & 15] +
                                    v[(de >> 28) & 15] +
                                    v[(de >> 24) & 15])
                        xe % k === 0 && (Q(W), (ne = 0))
                    }
                    return (
                        ee &&
                            ((de = W[ne]),
                            (ce += v[(de >> 4) & 15] + v[de & 15]),
                            ee > 1 && (ce += v[(de >> 12) & 15] + v[(de >> 8) & 15]),
                            ee > 2 && (ce += v[(de >> 20) & 15] + v[(de >> 16) & 15])),
                        ce
                    )
                }),
            (b.prototype.arrayBuffer = function () {
                this.finalize()
                var k = this.blockCount,
                    W = this.s,
                    J = this.outputBlocks,
                    ee = this.extraBytes,
                    ne = 0,
                    xe = 0,
                    ce = this.outputBits >> 3,
                    de
                ee ? (de = new ArrayBuffer((J + 1) << 2)) : (de = new ArrayBuffer(ce))
                for (var H = new Uint32Array(de); xe < J; ) {
                    for (ne = 0; ne < k && xe < J; ++ne, ++xe) H[xe] = W[ne]
                    xe % k === 0 && Q(W)
                }
                return ee && ((H[ne] = W[ne]), (de = de.slice(0, ce))), de
            }),
            (b.prototype.buffer = b.prototype.arrayBuffer),
            (b.prototype.digest = b.prototype.array =
                function () {
                    this.finalize()
                    for (
                        var k = this.blockCount, W = this.s, J = this.outputBlocks, ee = this.extraBytes, ne = 0, xe = 0, ce = [], de, H;
                        xe < J;

                    ) {
                        for (ne = 0; ne < k && xe < J; ++ne, ++xe)
                            (de = xe << 2),
                                (H = W[ne]),
                                (ce[de] = H & 255),
                                (ce[de + 1] = (H >> 8) & 255),
                                (ce[de + 2] = (H >> 16) & 255),
                                (ce[de + 3] = (H >> 24) & 255)
                        xe % k === 0 && Q(W)
                    }
                    return (
                        ee &&
                            ((de = xe << 2),
                            (H = W[ne]),
                            (ce[de] = H & 255),
                            ee > 1 && (ce[de + 1] = (H >> 8) & 255),
                            ee > 2 && (ce[de + 2] = (H >> 16) & 255)),
                        ce
                    )
                })
        function T(k, W, J) {
            b.call(this, k, W, J)
        }
        ;(T.prototype = new b()),
            (T.prototype.finalize = function () {
                return this.encode(this.outputBits, !0), b.prototype.finalize.call(this)
            })
        var Q = function (k) {
            var W,
                J,
                ee,
                ne,
                xe,
                ce,
                de,
                H,
                j,
                q,
                ae,
                te,
                fe,
                Se,
                ue,
                me,
                _e,
                Ce,
                ke,
                Re,
                Ne,
                Me,
                He,
                Fe,
                Le,
                $t,
                nt,
                lt,
                Zr,
                kt,
                Ze,
                Xr,
                dt,
                Bt,
                Ya,
                Gt,
                Vt,
                il,
                Er,
                Pr,
                ol,
                Mr,
                Dr,
                sl,
                Ur,
                Hr,
                al,
                jr,
                qr,
                fl,
                Kr,
                Gr,
                cl,
                Wr,
                Yr,
                ul,
                Jr,
                Qr,
                Qa,
                Za,
                el,
                tl,
                rl
            for (ee = 0; ee < 48; ee += 2)
                (ne = k[0] ^ k[10] ^ k[20] ^ k[30] ^ k[40]),
                    (xe = k[1] ^ k[11] ^ k[21] ^ k[31] ^ k[41]),
                    (ce = k[2] ^ k[12] ^ k[22] ^ k[32] ^ k[42]),
                    (de = k[3] ^ k[13] ^ k[23] ^ k[33] ^ k[43]),
                    (H = k[4] ^ k[14] ^ k[24] ^ k[34] ^ k[44]),
                    (j = k[5] ^ k[15] ^ k[25] ^ k[35] ^ k[45]),
                    (q = k[6] ^ k[16] ^ k[26] ^ k[36] ^ k[46]),
                    (ae = k[7] ^ k[17] ^ k[27] ^ k[37] ^ k[47]),
                    (te = k[8] ^ k[18] ^ k[28] ^ k[38] ^ k[48]),
                    (fe = k[9] ^ k[19] ^ k[29] ^ k[39] ^ k[49]),
                    (W = te ^ ((ce << 1) | (de >>> 31))),
                    (J = fe ^ ((de << 1) | (ce >>> 31))),
                    (k[0] ^= W),
                    (k[1] ^= J),
                    (k[10] ^= W),
                    (k[11] ^= J),
                    (k[20] ^= W),
                    (k[21] ^= J),
                    (k[30] ^= W),
                    (k[31] ^= J),
                    (k[40] ^= W),
                    (k[41] ^= J),
                    (W = ne ^ ((H << 1) | (j >>> 31))),
                    (J = xe ^ ((j << 1) | (H >>> 31))),
                    (k[2] ^= W),
                    (k[3] ^= J),
                    (k[12] ^= W),
                    (k[13] ^= J),
                    (k[22] ^= W),
                    (k[23] ^= J),
                    (k[32] ^= W),
                    (k[33] ^= J),
                    (k[42] ^= W),
                    (k[43] ^= J),
                    (W = ce ^ ((q << 1) | (ae >>> 31))),
                    (J = de ^ ((ae << 1) | (q >>> 31))),
                    (k[4] ^= W),
                    (k[5] ^= J),
                    (k[14] ^= W),
                    (k[15] ^= J),
                    (k[24] ^= W),
                    (k[25] ^= J),
                    (k[34] ^= W),
                    (k[35] ^= J),
                    (k[44] ^= W),
                    (k[45] ^= J),
                    (W = H ^ ((te << 1) | (fe >>> 31))),
                    (J = j ^ ((fe << 1) | (te >>> 31))),
                    (k[6] ^= W),
                    (k[7] ^= J),
                    (k[16] ^= W),
                    (k[17] ^= J),
                    (k[26] ^= W),
                    (k[27] ^= J),
                    (k[36] ^= W),
                    (k[37] ^= J),
                    (k[46] ^= W),
                    (k[47] ^= J),
                    (W = q ^ ((ne << 1) | (xe >>> 31))),
                    (J = ae ^ ((xe << 1) | (ne >>> 31))),
                    (k[8] ^= W),
                    (k[9] ^= J),
                    (k[18] ^= W),
                    (k[19] ^= J),
                    (k[28] ^= W),
                    (k[29] ^= J),
                    (k[38] ^= W),
                    (k[39] ^= J),
                    (k[48] ^= W),
                    (k[49] ^= J),
                    (Se = k[0]),
                    (ue = k[1]),
                    (Hr = (k[11] << 4) | (k[10] >>> 28)),
                    (al = (k[10] << 4) | (k[11] >>> 28)),
                    (lt = (k[20] << 3) | (k[21] >>> 29)),
                    (Zr = (k[21] << 3) | (k[20] >>> 29)),
                    (Za = (k[31] << 9) | (k[30] >>> 23)),
                    (el = (k[30] << 9) | (k[31] >>> 23)),
                    (Mr = (k[40] << 18) | (k[41] >>> 14)),
                    (Dr = (k[41] << 18) | (k[40] >>> 14)),
                    (Bt = (k[2] << 1) | (k[3] >>> 31)),
                    (Ya = (k[3] << 1) | (k[2] >>> 31)),
                    (me = (k[13] << 12) | (k[12] >>> 20)),
                    (_e = (k[12] << 12) | (k[13] >>> 20)),
                    (jr = (k[22] << 10) | (k[23] >>> 22)),
                    (qr = (k[23] << 10) | (k[22] >>> 22)),
                    (kt = (k[33] << 13) | (k[32] >>> 19)),
                    (Ze = (k[32] << 13) | (k[33] >>> 19)),
                    (tl = (k[42] << 2) | (k[43] >>> 30)),
                    (rl = (k[43] << 2) | (k[42] >>> 30)),
                    (Wr = (k[5] << 30) | (k[4] >>> 2)),
                    (Yr = (k[4] << 30) | (k[5] >>> 2)),
                    (Gt = (k[14] << 6) | (k[15] >>> 26)),
                    (Vt = (k[15] << 6) | (k[14] >>> 26)),
                    (Ce = (k[25] << 11) | (k[24] >>> 21)),
                    (ke = (k[24] << 11) | (k[25] >>> 21)),
                    (fl = (k[34] << 15) | (k[35] >>> 17)),
                    (Kr = (k[35] << 15) | (k[34] >>> 17)),
                    (Xr = (k[45] << 29) | (k[44] >>> 3)),
                    (dt = (k[44] << 29) | (k[45] >>> 3)),
                    (Fe = (k[6] << 28) | (k[7] >>> 4)),
                    (Le = (k[7] << 28) | (k[6] >>> 4)),
                    (ul = (k[17] << 23) | (k[16] >>> 9)),
                    (Jr = (k[16] << 23) | (k[17] >>> 9)),
                    (il = (k[26] << 25) | (k[27] >>> 7)),
                    (Er = (k[27] << 25) | (k[26] >>> 7)),
                    (Re = (k[36] << 21) | (k[37] >>> 11)),
                    (Ne = (k[37] << 21) | (k[36] >>> 11)),
                    (Gr = (k[47] << 24) | (k[46] >>> 8)),
                    (cl = (k[46] << 24) | (k[47] >>> 8)),
                    (sl = (k[8] << 27) | (k[9] >>> 5)),
                    (Ur = (k[9] << 27) | (k[8] >>> 5)),
                    ($t = (k[18] << 20) | (k[19] >>> 12)),
                    (nt = (k[19] << 20) | (k[18] >>> 12)),
                    (Qr = (k[29] << 7) | (k[28] >>> 25)),
                    (Qa = (k[28] << 7) | (k[29] >>> 25)),
                    (Pr = (k[38] << 8) | (k[39] >>> 24)),
                    (ol = (k[39] << 8) | (k[38] >>> 24)),
                    (Me = (k[48] << 14) | (k[49] >>> 18)),
                    (He = (k[49] << 14) | (k[48] >>> 18)),
                    (k[0] = Se ^ (~me & Ce)),
                    (k[1] = ue ^ (~_e & ke)),
                    (k[10] = Fe ^ (~$t & lt)),
                    (k[11] = Le ^ (~nt & Zr)),
                    (k[20] = Bt ^ (~Gt & il)),
                    (k[21] = Ya ^ (~Vt & Er)),
                    (k[30] = sl ^ (~Hr & jr)),
                    (k[31] = Ur ^ (~al & qr)),
                    (k[40] = Wr ^ (~ul & Qr)),
                    (k[41] = Yr ^ (~Jr & Qa)),
                    (k[2] = me ^ (~Ce & Re)),
                    (k[3] = _e ^ (~ke & Ne)),
                    (k[12] = $t ^ (~lt & kt)),
                    (k[13] = nt ^ (~Zr & Ze)),
                    (k[22] = Gt ^ (~il & Pr)),
                    (k[23] = Vt ^ (~Er & ol)),
                    (k[32] = Hr ^ (~jr & fl)),
                    (k[33] = al ^ (~qr & Kr)),
                    (k[42] = ul ^ (~Qr & Za)),
                    (k[43] = Jr ^ (~Qa & el)),
                    (k[4] = Ce ^ (~Re & Me)),
                    (k[5] = ke ^ (~Ne & He)),
                    (k[14] = lt ^ (~kt & Xr)),
                    (k[15] = Zr ^ (~Ze & dt)),
                    (k[24] = il ^ (~Pr & Mr)),
                    (k[25] = Er ^ (~ol & Dr)),
                    (k[34] = jr ^ (~fl & Gr)),
                    (k[35] = qr ^ (~Kr & cl)),
                    (k[44] = Qr ^ (~Za & tl)),
                    (k[45] = Qa ^ (~el & rl)),
                    (k[6] = Re ^ (~Me & Se)),
                    (k[7] = Ne ^ (~He & ue)),
                    (k[16] = kt ^ (~Xr & Fe)),
                    (k[17] = Ze ^ (~dt & Le)),
                    (k[26] = Pr ^ (~Mr & Bt)),
                    (k[27] = ol ^ (~Dr & Ya)),
                    (k[36] = fl ^ (~Gr & sl)),
                    (k[37] = Kr ^ (~cl & Ur)),
                    (k[46] = Za ^ (~tl & Wr)),
                    (k[47] = el ^ (~rl & Yr)),
                    (k[8] = Me ^ (~Se & me)),
                    (k[9] = He ^ (~ue & _e)),
                    (k[18] = Xr ^ (~Fe & $t)),
                    (k[19] = dt ^ (~Le & nt)),
                    (k[28] = Mr ^ (~Bt & Gt)),
                    (k[29] = Dr ^ (~Ya & Vt)),
                    (k[38] = Gr ^ (~sl & Hr)),
                    (k[39] = cl ^ (~Ur & al)),
                    (k[48] = tl ^ (~Wr & ul)),
                    (k[49] = rl ^ (~Yr & Jr)),
                    (k[0] ^= L[ee]),
                    (k[1] ^= L[ee + 1])
        }
        if (c) t.exports = u
        else for ($ = 0; $ < E.length; ++$) o[E[$]] = u[E[$]]
    })()
})(sha3$1)
var sha3 = sha3$1.exports
function keccak256(t) {
    return "0x" + sha3.keccak_256(arrayify(t))
}
const version$e = "rlp/5.7.0",
    logger$k = new Logger(version$e)
function arrayifyInteger(t) {
    const e = []
    for (; t; ) e.unshift(t & 255), (t >>= 8)
    return e
}
function unarrayifyInteger(t, e, n) {
    let i = 0
    for (let o = 0; o < n; o++) i = i * 256 + t[e + o]
    return i
}
function _encode(t) {
    if (Array.isArray(t)) {
        let i = []
        if (
            (t.forEach(function (a) {
                i = i.concat(_encode(a))
            }),
            i.length <= 55)
        )
            return i.unshift(192 + i.length), i
        const o = arrayifyInteger(i.length)
        return o.unshift(247 + o.length), o.concat(i)
    }
    isBytesLike(t) || logger$k.throwArgumentError("RLP object must be BytesLike", "object", t)
    const e = Array.prototype.slice.call(arrayify(t))
    if (e.length === 1 && e[0] <= 127) return e
    if (e.length <= 55) return e.unshift(128 + e.length), e
    const n = arrayifyInteger(e.length)
    return n.unshift(183 + n.length), n.concat(e)
}
function encode$h(t) {
    return hexlify(_encode(t))
}
function _decodeChildren(t, e, n, i) {
    const o = []
    for (; n < e + 1 + i; ) {
        const a = _decode(t, n)
        o.push(a.result), (n += a.consumed), n > e + 1 + i && logger$k.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {})
    }
    return { consumed: 1 + i, result: o }
}
function _decode(t, e) {
    if ((t.length === 0 && logger$k.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {}), t[e] >= 248)) {
        const n = t[e] - 247
        e + 1 + n > t.length && logger$k.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {})
        const i = unarrayifyInteger(t, e + 1, n)
        return (
            e + 1 + n + i > t.length && logger$k.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {}),
            _decodeChildren(t, e, e + 1 + n, n + i)
        )
    } else if (t[e] >= 192) {
        const n = t[e] - 192
        return (
            e + 1 + n > t.length && logger$k.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {}),
            _decodeChildren(t, e, e + 1, n)
        )
    } else if (t[e] >= 184) {
        const n = t[e] - 183
        e + 1 + n > t.length && logger$k.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {})
        const i = unarrayifyInteger(t, e + 1, n)
        e + 1 + n + i > t.length && logger$k.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {})
        const o = hexlify(t.slice(e + 1 + n, e + 1 + n + i))
        return { consumed: 1 + n + i, result: o }
    } else if (t[e] >= 128) {
        const n = t[e] - 128
        e + 1 + n > t.length && logger$k.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {})
        const i = hexlify(t.slice(e + 1, e + 1 + n))
        return { consumed: 1 + n, result: i }
    }
    return { consumed: 1, result: hexlify(t[e]) }
}
function decode$i(t) {
    const e = arrayify(t),
        n = _decode(e, 0)
    return n.consumed !== e.length && logger$k.throwArgumentError("invalid rlp data", "data", t), n.result
}
const version$d = "address/5.7.0",
    logger$j = new Logger(version$d)
function getChecksumAddress(t) {
    isHexString(t, 20) || logger$j.throwArgumentError("invalid address", "address", t), (t = t.toLowerCase())
    const e = t.substring(2).split(""),
        n = new Uint8Array(40)
    for (let o = 0; o < 40; o++) n[o] = e[o].charCodeAt(0)
    const i = arrayify(keccak256(n))
    for (let o = 0; o < 40; o += 2)
        i[o >> 1] >> 4 >= 8 && (e[o] = e[o].toUpperCase()), (i[o >> 1] & 15) >= 8 && (e[o + 1] = e[o + 1].toUpperCase())
    return "0x" + e.join("")
}
const MAX_SAFE_INTEGER$1 = 9007199254740991
function log10(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const ibanLookup = {}
for (let t = 0; t < 10; t++) ibanLookup[String(t)] = String(t)
for (let t = 0; t < 26; t++) ibanLookup[String.fromCharCode(65 + t)] = String(10 + t)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER$1))
function ibanChecksum(t) {
    ;(t = t.toUpperCase()), (t = t.substring(4) + t.substring(0, 2) + "00")
    let e = t
        .split("")
        .map((i) => ibanLookup[i])
        .join("")
    for (; e.length >= safeDigits; ) {
        let i = e.substring(0, safeDigits)
        e = (parseInt(i, 10) % 97) + e.substring(i.length)
    }
    let n = String(98 - (parseInt(e, 10) % 97))
    for (; n.length < 2; ) n = "0" + n
    return n
}
function getAddress(t) {
    let e = null
    if ((typeof t != "string" && logger$j.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)))
        t.substring(0, 2) !== "0x" && (t = "0x" + t),
            (e = getChecksumAddress(t)),
            t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && logger$j.throwArgumentError("bad address checksum", "address", t)
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (
            t.substring(2, 4) !== ibanChecksum(t) && logger$j.throwArgumentError("bad icap checksum", "address", t),
                e = _base36To16(t.substring(4));
            e.length < 40;

        )
            e = "0" + e
        e = getChecksumAddress("0x" + e)
    } else logger$j.throwArgumentError("invalid address", "address", t)
    return e
}
function isAddress(t) {
    try {
        return getAddress(t), !0
    } catch {}
    return !1
}
function getContractAddress(t) {
    let e = null
    try {
        e = getAddress(t.from)
    } catch {
        logger$j.throwArgumentError("missing from address", "transaction", t)
    }
    const n = stripZeros(arrayify(BigNumber.from(t.nonce).toHexString()))
    return getAddress(hexDataSlice(keccak256(encode$h([e, n])), 12))
}
class AddressCoder extends Coder {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, n) {
        try {
            n = getAddress(n)
        } catch (i) {
            this._throwError(i.message, n)
        }
        return e.writeValue(n)
    }
    decode(e) {
        return getAddress(hexZeroPad(e.readValue().toHexString(), 20))
    }
}
class AnonymousCoder extends Coder {
    constructor(e) {
        super(e.name, e.type, void 0, e.dynamic), (this.coder = e)
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, n) {
        return this.coder.encode(e, n)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
const logger$i = new Logger(version$f)
function pack(t, e, n) {
    let i = null
    if (Array.isArray(n)) i = n
    else if (n && typeof n == "object") {
        let g = {}
        i = e.map((v) => {
            const _ = v.localName
            return (
                _ ||
                    logger$i.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: v,
                        value: n,
                    }),
                g[_] &&
                    logger$i.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: v,
                        value: n,
                    }),
                (g[_] = !0),
                n[_]
            )
        })
    } else logger$i.throwArgumentError("invalid tuple value", "tuple", n)
    e.length !== i.length && logger$i.throwArgumentError("types/value length mismatch", "tuple", n)
    let o = new Writer$2(t.wordSize),
        a = new Writer$2(t.wordSize),
        l = []
    e.forEach((g, v) => {
        let _ = i[v]
        if (g.dynamic) {
            let A = a.length
            g.encode(a, _)
            let B = o.writeUpdatableValue()
            l.push((D) => {
                B(D + A)
            })
        } else g.encode(o, _)
    }),
        l.forEach((g) => {
            g(o.length)
        })
    let c = t.appendWriter(o)
    return (c += t.appendWriter(a)), c
}
function unpack(t, e) {
    let n = [],
        i = t.subReader(0)
    e.forEach((a) => {
        let l = null
        if (a.dynamic) {
            let c = t.readValue(),
                g = i.subReader(c.toNumber())
            try {
                l = a.decode(g)
            } catch (v) {
                if (v.code === Logger.errors.BUFFER_OVERRUN) throw v
                ;(l = v), (l.baseType = a.name), (l.name = a.localName), (l.type = a.type)
            }
        } else
            try {
                l = a.decode(t)
            } catch (c) {
                if (c.code === Logger.errors.BUFFER_OVERRUN) throw c
                ;(l = c), (l.baseType = a.name), (l.name = a.localName), (l.type = a.type)
            }
        l != null && n.push(l)
    })
    const o = e.reduce((a, l) => {
        const c = l.localName
        return c && (a[c] || (a[c] = 0), a[c]++), a
    }, {})
    e.forEach((a, l) => {
        let c = a.localName
        if (!c || o[c] !== 1 || (c === "length" && (c = "_length"), n[c] != null)) return
        const g = n[l]
        g instanceof Error
            ? Object.defineProperty(n, c, {
                  enumerable: !0,
                  get: () => {
                      throw g
                  },
              })
            : (n[c] = g)
    })
    for (let a = 0; a < n.length; a++) {
        const l = n[a]
        l instanceof Error &&
            Object.defineProperty(n, a, {
                enumerable: !0,
                get: () => {
                    throw l
                },
            })
    }
    return Object.freeze(n)
}
class ArrayCoder extends Coder {
    constructor(e, n, i) {
        const o = e.type + "[" + (n >= 0 ? n : "") + "]",
            a = n === -1 || e.dynamic
        super("array", o, i, a), (this.coder = e), (this.length = n)
    }
    defaultValue() {
        const e = this.coder.defaultValue(),
            n = []
        for (let i = 0; i < this.length; i++) n.push(e)
        return n
    }
    encode(e, n) {
        Array.isArray(n) || this._throwError("expected array value", n)
        let i = this.length
        i === -1 && ((i = n.length), e.writeValue(n.length)),
            logger$i.checkArgumentCount(n.length, i, "coder array" + (this.localName ? " " + this.localName : ""))
        let o = []
        for (let a = 0; a < n.length; a++) o.push(this.coder)
        return pack(e, o, n)
    }
    decode(e) {
        let n = this.length
        n === -1 &&
            ((n = e.readValue().toNumber()),
            n * 32 > e._data.length &&
                logger$i.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, { length: e._data.length, count: n }))
        let i = []
        for (let o = 0; o < n; o++) i.push(new AnonymousCoder(this.coder))
        return e.coerce(this.name, unpack(e, i))
    }
}
class BooleanCoder extends Coder {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, n) {
        return e.writeValue(n ? 1 : 0)
    }
    decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
    }
}
class DynamicBytesCoder extends Coder {
    constructor(e, n) {
        super(e, e, n, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, n) {
        n = arrayify(n)
        let i = e.writeValue(n.length)
        return (i += e.writeBytes(n)), i
    }
    decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return e.coerce(this.name, hexlify(super.decode(e)))
    }
}
class FixedBytesCoder extends Coder {
    constructor(e, n) {
        let i = "bytes" + String(e)
        super(i, i, n, !1), (this.size = e)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, n) {
        let i = arrayify(n)
        return i.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(i)
    }
    decode(e) {
        return e.coerce(this.name, hexlify(e.readBytes(this.size)))
    }
}
class NullCoder extends Coder {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, n) {
        return n != null && this._throwError("not null", n), e.writeBytes([])
    }
    decode(e) {
        return e.readBytes(0), e.coerce(this.name, null)
    }
}
const AddressZero = "0x0000000000000000000000000000000000000000",
    NegativeOne$1 = BigNumber.from(-1),
    Zero$1 = BigNumber.from(0),
    One$1 = BigNumber.from(1),
    MaxUint256$1 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000"
class NumberCoder extends Coder {
    constructor(e, n, i) {
        const o = (n ? "int" : "uint") + e * 8
        super(o, o, i, !1), (this.size = e), (this.signed = n)
    }
    defaultValue() {
        return 0
    }
    encode(e, n) {
        let i = BigNumber.from(n),
            o = MaxUint256$1.mask(e.wordSize * 8)
        if (this.signed) {
            let a = o.mask(this.size * 8 - 1)
            ;(i.gt(a) || i.lt(a.add(One$1).mul(NegativeOne$1))) && this._throwError("value out-of-bounds", n)
        } else (i.lt(Zero$1) || i.gt(o.mask(this.size * 8))) && this._throwError("value out-of-bounds", n)
        return (
            (i = i.toTwos(this.size * 8).mask(this.size * 8)),
            this.signed && (i = i.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
            e.writeValue(i)
        )
    }
    decode(e) {
        let n = e.readValue().mask(this.size * 8)
        return this.signed && (n = n.fromTwos(this.size * 8)), e.coerce(this.name, n)
    }
}
const version$c = "strings/5.7.0",
    logger$h = new Logger(version$c)
var UnicodeNormalizationForm
;(function (t) {
    ;(t.current = ""), (t.NFC = "NFC"), (t.NFD = "NFD"), (t.NFKC = "NFKC"), (t.NFKD = "NFKD")
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}))
var Utf8ErrorReason
;(function (t) {
    ;(t.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
        (t.BAD_PREFIX = "bad codepoint prefix"),
        (t.OVERRUN = "string overrun"),
        (t.MISSING_CONTINUE = "missing continuation byte"),
        (t.OUT_OF_RANGE = "out of UTF-8 range"),
        (t.UTF16_SURROGATE = "UTF-16 surrogate"),
        (t.OVERLONG = "overlong representation")
})(Utf8ErrorReason || (Utf8ErrorReason = {}))
function errorFunc(t, e, n, i, o) {
    return logger$h.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", n)
}
function ignoreFunc(t, e, n, i, o) {
    if (t === Utf8ErrorReason.BAD_PREFIX || t === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let a = 0
        for (let l = e + 1; l < n.length && n[l] >> 6 === 2; l++) a++
        return a
    }
    return t === Utf8ErrorReason.OVERRUN ? n.length - e - 1 : 0
}
function replaceFunc(t, e, n, i, o) {
    return t === Utf8ErrorReason.OVERLONG ? (i.push(o), 0) : (i.push(65533), ignoreFunc(t, e, n))
}
const Utf8ErrorFuncs = Object.freeze({ error: errorFunc, ignore: ignoreFunc, replace: replaceFunc })
function getUtf8CodePoints(t, e) {
    e == null && (e = Utf8ErrorFuncs.error), (t = arrayify(t))
    const n = []
    let i = 0
    for (; i < t.length; ) {
        const o = t[i++]
        if (o >> 7 === 0) {
            n.push(o)
            continue
        }
        let a = null,
            l = null
        if ((o & 224) === 192) (a = 1), (l = 127)
        else if ((o & 240) === 224) (a = 2), (l = 2047)
        else if ((o & 248) === 240) (a = 3), (l = 65535)
        else {
            ;(o & 192) === 128 ? (i += e(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, t, n)) : (i += e(Utf8ErrorReason.BAD_PREFIX, i - 1, t, n))
            continue
        }
        if (i - 1 + a >= t.length) {
            i += e(Utf8ErrorReason.OVERRUN, i - 1, t, n)
            continue
        }
        let c = o & ((1 << (8 - a - 1)) - 1)
        for (let g = 0; g < a; g++) {
            let v = t[i]
            if ((v & 192) != 128) {
                ;(i += e(Utf8ErrorReason.MISSING_CONTINUE, i, t, n)), (c = null)
                break
            }
            ;(c = (c << 6) | (v & 63)), i++
        }
        if (c !== null) {
            if (c > 1114111) {
                i += e(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - a, t, n, c)
                continue
            }
            if (c >= 55296 && c <= 57343) {
                i += e(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - a, t, n, c)
                continue
            }
            if (c <= l) {
                i += e(Utf8ErrorReason.OVERLONG, i - 1 - a, t, n, c)
                continue
            }
            n.push(c)
        }
    }
    return n
}
function toUtf8Bytes(t, e = UnicodeNormalizationForm.current) {
    e != UnicodeNormalizationForm.current && (logger$h.checkNormalize(), (t = t.normalize(e)))
    let n = []
    for (let i = 0; i < t.length; i++) {
        const o = t.charCodeAt(i)
        if (o < 128) n.push(o)
        else if (o < 2048) n.push((o >> 6) | 192), n.push((o & 63) | 128)
        else if ((o & 64512) == 55296) {
            i++
            const a = t.charCodeAt(i)
            if (i >= t.length || (a & 64512) !== 56320) throw new Error("invalid utf-8 string")
            const l = 65536 + ((o & 1023) << 10) + (a & 1023)
            n.push((l >> 18) | 240), n.push(((l >> 12) & 63) | 128), n.push(((l >> 6) & 63) | 128), n.push((l & 63) | 128)
        } else n.push((o >> 12) | 224), n.push(((o >> 6) & 63) | 128), n.push((o & 63) | 128)
    }
    return arrayify(n)
}
function _toUtf8String(t) {
    return t
        .map((e) => (e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320))))
        .join("")
}
function toUtf8String(t, e) {
    return _toUtf8String(getUtf8CodePoints(t, e))
}
function toUtf8CodePoints(t, e = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(t, e))
}
class StringCoder extends DynamicBytesCoder {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, n) {
        return super.encode(e, toUtf8Bytes(n))
    }
    decode(e) {
        return toUtf8String(super.decode(e))
    }
}
class TupleCoder extends Coder {
    constructor(e, n) {
        let i = !1
        const o = []
        e.forEach((l) => {
            l.dynamic && (i = !0), o.push(l.type)
        })
        const a = "tuple(" + o.join(",") + ")"
        super("tuple", a, n, i), (this.coders = e)
    }
    defaultValue() {
        const e = []
        this.coders.forEach((i) => {
            e.push(i.defaultValue())
        })
        const n = this.coders.reduce((i, o) => {
            const a = o.localName
            return a && (i[a] || (i[a] = 0), i[a]++), i
        }, {})
        return (
            this.coders.forEach((i, o) => {
                let a = i.localName
                !a || n[a] !== 1 || (a === "length" && (a = "_length"), e[a] == null && (e[a] = e[o]))
            }),
            Object.freeze(e)
        )
    }
    encode(e, n) {
        return pack(e, this.coders, n)
    }
    decode(e) {
        return e.coerce(this.name, unpack(e, this.coders))
    }
}
const logger$g = new Logger(version$f),
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/),
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/)
class AbiCoder {
    constructor(e) {
        defineReadOnly(this, "coerceFunc", e || null)
    }
    _getCoder(e) {
        switch (e.baseType) {
            case "address":
                return new AddressCoder(e.name)
            case "bool":
                return new BooleanCoder(e.name)
            case "string":
                return new StringCoder(e.name)
            case "bytes":
                return new BytesCoder(e.name)
            case "array":
                return new ArrayCoder(this._getCoder(e.arrayChildren), e.arrayLength, e.name)
            case "tuple":
                return new TupleCoder(
                    (e.components || []).map((i) => this._getCoder(i)),
                    e.name
                )
            case "":
                return new NullCoder(e.name)
        }
        let n = e.type.match(paramTypeNumber)
        if (n) {
            let i = parseInt(n[2] || "256")
            return (
                (i === 0 || i > 256 || i % 8 !== 0) && logger$g.throwArgumentError("invalid " + n[1] + " bit length", "param", e),
                new NumberCoder(i / 8, n[1] === "int", e.name)
            )
        }
        if (((n = e.type.match(paramTypeBytes)), n)) {
            let i = parseInt(n[1])
            return (i === 0 || i > 32) && logger$g.throwArgumentError("invalid bytes length", "param", e), new FixedBytesCoder(i, e.name)
        }
        return logger$g.throwArgumentError("invalid type", "type", e.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(e, n) {
        return new Reader$2(e, this._getWordSize(), this.coerceFunc, n)
    }
    _getWriter() {
        return new Writer$2(this._getWordSize())
    }
    getDefaultValue(e) {
        const n = e.map((o) => this._getCoder(ParamType.from(o)))
        return new TupleCoder(n, "_").defaultValue()
    }
    encode(e, n) {
        e.length !== n.length &&
            logger$g.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                count: { types: e.length, values: n.length },
                value: { types: e, values: n },
            })
        const i = e.map((l) => this._getCoder(ParamType.from(l))),
            o = new TupleCoder(i, "_"),
            a = this._getWriter()
        return o.encode(a, n), a.data
    }
    decode(e, n, i) {
        const o = e.map((l) => this._getCoder(ParamType.from(l)))
        return new TupleCoder(o, "_").decode(this._getReader(arrayify(n), i))
    }
}
const defaultAbiCoder = new AbiCoder()
function id(t) {
    return keccak256(toUtf8Bytes(t))
}
const version$b = "hash/5.7.0"
function decode$h(t) {
    t = atob(t)
    const e = []
    for (let n = 0; n < t.length; n++) e.push(t.charCodeAt(n))
    return arrayify(e)
}
function encode$g(t) {
    t = arrayify(t)
    let e = ""
    for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
    return btoa(e)
}
function flat(t, e) {
    e == null && (e = 1)
    const n = [],
        i = n.forEach,
        o = function (a, l) {
            i.call(a, function (c) {
                l > 0 && Array.isArray(c) ? o(c, l - 1) : n.push(c)
            })
        }
    return o(t, e), n
}
function fromEntries(t) {
    const e = {}
    for (let n = 0; n < t.length; n++) {
        const i = t[n]
        e[i[0]] = i[1]
    }
    return e
}
function decode_arithmetic(t) {
    let e = 0
    function n() {
        return (t[e++] << 8) | t[e++]
    }
    let i = n(),
        o = 1,
        a = [0, 1]
    for (let X = 1; X < i; X++) a.push((o += n()))
    let l = n(),
        c = e
    e += l
    let g = 0,
        v = 0
    function _() {
        return g == 0 && ((v = (v << 8) | t[e++]), (g = 8)), (v >> --g) & 1
    }
    const A = 31,
        B = Math.pow(2, A),
        D = B >>> 1,
        I = D >> 1,
        L = B - 1
    let G = 0
    for (let X = 0; X < A; X++) G = (G << 1) | _()
    let U = [],
        F = 0,
        Z = B
    for (;;) {
        let X = Math.floor(((G - F + 1) * o - 1) / Z),
            ie = 0,
            he = i
        for (; he - ie > 1; ) {
            let Te = (ie + he) >>> 1
            X < a[Te] ? (he = Te) : (ie = Te)
        }
        if (ie == 0) break
        U.push(ie)
        let oe = F + Math.floor((Z * a[ie]) / o),
            le = F + Math.floor((Z * a[ie + 1]) / o) - 1
        for (; ((oe ^ le) & D) == 0; ) (G = ((G << 1) & L) | _()), (oe = (oe << 1) & L), (le = ((le << 1) & L) | 1)
        for (; oe & ~le & I; ) (G = (G & D) | ((G << 1) & (L >>> 1)) | _()), (oe = (oe << 1) ^ D), (le = ((le ^ D) << 1) | D | 1)
        ;(F = oe), (Z = 1 + le - oe)
    }
    let Y = i - 4
    return U.map((X) => {
        switch (X - Y) {
            case 3:
                return Y + 65792 + ((t[c++] << 16) | (t[c++] << 8) | t[c++])
            case 2:
                return Y + 256 + ((t[c++] << 8) | t[c++])
            case 1:
                return Y + t[c++]
            default:
                return X - 1
        }
    })
}
function read_payload(t) {
    let e = 0
    return () => t[e++]
}
function read_compressed_payload(t) {
    return read_payload(decode_arithmetic(t))
}
function signed(t) {
    return t & 1 ? ~t >> 1 : t >> 1
}
function read_counts(t, e) {
    let n = Array(t)
    for (let i = 0; i < t; i++) n[i] = 1 + e()
    return n
}
function read_ascending(t, e) {
    let n = Array(t)
    for (let i = 0, o = -1; i < t; i++) n[i] = o += 1 + e()
    return n
}
function read_deltas(t, e) {
    let n = Array(t)
    for (let i = 0, o = 0; i < t; i++) n[i] = o += signed(e())
    return n
}
function read_member_array(t, e) {
    let n = read_ascending(t(), t),
        i = t(),
        o = read_ascending(i, t),
        a = read_counts(i, t)
    for (let l = 0; l < i; l++) for (let c = 0; c < a[l]; c++) n.push(o[l] + c)
    return e ? n.map((l) => e[l]) : n
}
function read_mapped_map(t) {
    let e = []
    for (;;) {
        let n = t()
        if (n == 0) break
        e.push(read_linear_table(n, t))
    }
    for (;;) {
        let n = t() - 1
        if (n < 0) break
        e.push(read_replacement_table(n, t))
    }
    return fromEntries(flat(e))
}
function read_zero_terminated_array(t) {
    let e = []
    for (;;) {
        let n = t()
        if (n == 0) break
        e.push(n)
    }
    return e
}
function read_transposed(t, e, n) {
    let i = Array(t)
        .fill(void 0)
        .map(() => [])
    for (let o = 0; o < e; o++) read_deltas(t, n).forEach((a, l) => i[l].push(a))
    return i
}
function read_linear_table(t, e) {
    let n = 1 + e(),
        i = e(),
        o = read_zero_terminated_array(e),
        a = read_transposed(o.length, 1 + t, e)
    return flat(
        a.map((l, c) => {
            const g = l[0],
                v = l.slice(1)
            return Array(o[c])
                .fill(void 0)
                .map((_, A) => {
                    let B = A * i
                    return [g + A * n, v.map((D) => D + B)]
                })
        })
    )
}
function read_replacement_table(t, e) {
    let n = 1 + e()
    return read_transposed(n, 1 + t, e).map((o) => [o[0], o.slice(1)])
}
function read_emoji_trie(t) {
    let e = read_member_array(t).sort((i, o) => i - o)
    return n()
    function n() {
        let i = []
        for (;;) {
            let v = read_member_array(t, e)
            if (v.length == 0) break
            i.push({ set: new Set(v), node: n() })
        }
        i.sort((v, _) => _.set.size - v.set.size)
        let o = t(),
            a = o % 3
        o = (o / 3) | 0
        let l = !!(o & 1)
        o >>= 1
        let c = o == 1,
            g = o == 2
        return { branches: i, valid: a, fe0f: l, save: c, check: g }
    }
}
function getData() {
    return read_compressed_payload(
        decode$h(
            "AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="
        )
    )
}
const r$1 = getData(),
    VALID = new Set(read_member_array(r$1)),
    IGNORED = new Set(read_member_array(r$1)),
    MAPPED = read_mapped_map(r$1),
    EMOJI_ROOT = read_emoji_trie(r$1),
    HYPHEN = 45,
    UNDERSCORE = 95
function explode_cp(t) {
    return toUtf8CodePoints(t)
}
function filter_fe0f(t) {
    return t.filter((e) => e != 65039)
}
function ens_normalize_post_check(t) {
    for (let e of t.split(".")) {
        let n = explode_cp(e)
        try {
            for (let i = n.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) if (n[i] !== UNDERSCORE) throw new Error("underscore only allowed at start")
            if (n.length >= 4 && n.every((i) => i < 128) && n[2] === HYPHEN && n[3] === HYPHEN) throw new Error("invalid label extension")
        } catch (i) {
            throw new Error(`Invalid label "${e}": ${i.message}`)
        }
    }
    return t
}
function ens_normalize(t) {
    return ens_normalize_post_check(normalize(t, filter_fe0f))
}
function normalize(t, e) {
    let n = explode_cp(t).reverse(),
        i = []
    for (; n.length; ) {
        let o = consume_emoji_reversed(n)
        if (o) {
            i.push(...e(o))
            continue
        }
        let a = n.pop()
        if (VALID.has(a)) {
            i.push(a)
            continue
        }
        if (IGNORED.has(a)) continue
        let l = MAPPED[a]
        if (l) {
            i.push(...l)
            continue
        }
        throw new Error(`Disallowed codepoint: 0x${a.toString(16).toUpperCase()}`)
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint(...i)))
}
function nfc(t) {
    return t.normalize("NFC")
}
function consume_emoji_reversed(t, e) {
    var n
    let i = EMOJI_ROOT,
        o,
        a,
        l = [],
        c = t.length
    for (e && (e.length = 0); c; ) {
        let g = t[--c]
        if (((i = (n = i.branches.find((v) => v.set.has(g))) === null || n === void 0 ? void 0 : n.node), !i)) break
        if (i.save) a = g
        else if (i.check && g === a) break
        l.push(g),
            i.fe0f && (l.push(65039), c > 0 && t[c - 1] == 65039 && c--),
            i.valid && ((o = l.slice()), i.valid == 2 && o.splice(1, 1), e && e.push(...t.slice(c).reverse()), (t.length = c))
    }
    return o
}
const logger$f = new Logger(version$b),
    Zeros = new Uint8Array(32)
Zeros.fill(0)
function checkComponent(t) {
    if (t.length === 0) throw new Error("invalid ENS name; empty component")
    return t
}
function ensNameSplit(t) {
    const e = toUtf8Bytes(ens_normalize(t)),
        n = []
    if (t.length === 0) return n
    let i = 0
    for (let o = 0; o < e.length; o++) e[o] === 46 && (n.push(checkComponent(e.slice(i, o))), (i = o + 1))
    if (i >= e.length) throw new Error("invalid ENS name; empty component")
    return n.push(checkComponent(e.slice(i))), n
}
function namehash(t) {
    typeof t != "string" && logger$f.throwArgumentError("invalid ENS name; not a string", "name", t)
    let e = Zeros
    const n = ensNameSplit(t)
    for (; n.length; ) e = keccak256(concat$2([e, keccak256(n.pop())]))
    return hexlify(e)
}
function dnsEncode(t) {
    return (
        hexlify(
            concat$2(
                ensNameSplit(t).map((e) => {
                    if (e.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes")
                    const n = new Uint8Array(e.length + 1)
                    return n.set(e, 1), (n[0] = n.length - 1), n
                })
            )
        ) + "00"
    )
}
var __awaiter$8 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$e = new Logger(version$b),
    padding = new Uint8Array(32)
padding.fill(0)
const NegativeOne = BigNumber.from(-1),
    Zero = BigNumber.from(0),
    One = BigNumber.from(1),
    MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
function hexPadRight(t) {
    const e = arrayify(t),
        n = e.length % 32
    return n ? hexConcat([e, padding.slice(n)]) : hexlify(e)
}
const hexTrue = hexZeroPad(One.toHexString(), 32),
    hexFalse = hexZeroPad(Zero.toHexString(), 32),
    domainFieldTypes = { name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32" },
    domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"]
function checkString(t) {
    return function (e) {
        return typeof e != "string" && logger$e.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (t) {
        try {
            return BigNumber.from(t).toString()
        } catch {}
        return logger$e.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
    },
    verifyingContract: function (t) {
        try {
            return getAddress(t).toLowerCase()
        } catch {}
        return logger$e.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function (t) {
        try {
            const e = arrayify(t)
            if (e.length !== 32) throw new Error("bad length")
            return hexlify(e)
        } catch {}
        return logger$e.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
    },
}
function getBaseEncoder(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/)
        if (e) {
            const n = e[1] === "",
                i = parseInt(e[2] || "256")
            ;(i % 8 !== 0 || i > 256 || (e[2] && e[2] !== String(i))) && logger$e.throwArgumentError("invalid numeric width", "type", t)
            const o = MaxUint256.mask(n ? i - 1 : i),
                a = n ? o.add(One).mul(NegativeOne) : Zero
            return function (l) {
                const c = BigNumber.from(l)
                return (
                    (c.lt(a) || c.gt(o)) && logger$e.throwArgumentError(`value out-of-bounds for ${t}`, "value", l),
                    hexZeroPad(c.toTwos(256).toHexString(), 32)
                )
            }
        }
    }
    {
        const e = t.match(/^bytes(\d+)$/)
        if (e) {
            const n = parseInt(e[1])
            return (
                (n === 0 || n > 32 || e[1] !== String(n)) && logger$e.throwArgumentError("invalid bytes width", "type", t),
                function (i) {
                    return arrayify(i).length !== n && logger$e.throwArgumentError(`invalid length for ${t}`, "value", i), hexPadRight(i)
                }
            )
        }
    }
    switch (t) {
        case "address":
            return function (e) {
                return hexZeroPad(getAddress(e), 32)
            }
        case "bool":
            return function (e) {
                return e ? hexTrue : hexFalse
            }
        case "bytes":
            return function (e) {
                return keccak256(e)
            }
        case "string":
            return function (e) {
                return id(e)
            }
    }
    return null
}
function encodeType(t, e) {
    return `${t}(${e.map(({ name: n, type: i }) => i + " " + n).join(",")})`
}
class TypedDataEncoder {
    constructor(e) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(e))), defineReadOnly(this, "_encoderCache", {}), defineReadOnly(this, "_types", {})
        const n = {},
            i = {},
            o = {}
        Object.keys(e).forEach((c) => {
            ;(n[c] = {}), (i[c] = []), (o[c] = {})
        })
        for (const c in e) {
            const g = {}
            e[c].forEach((v) => {
                g[v.name] &&
                    logger$e.throwArgumentError(`duplicate variable name ${JSON.stringify(v.name)} in ${JSON.stringify(c)}`, "types", e),
                    (g[v.name] = !0)
                const _ = v.type.match(/^([^\x5b]*)(\x5b|$)/)[1]
                _ === c && logger$e.throwArgumentError(`circular type reference to ${JSON.stringify(_)}`, "types", e),
                    !getBaseEncoder(_) &&
                        (i[_] || logger$e.throwArgumentError(`unknown type ${JSON.stringify(_)}`, "types", e), i[_].push(c), (n[c][_] = !0))
            })
        }
        const a = Object.keys(i).filter((c) => i[c].length === 0)
        a.length === 0
            ? logger$e.throwArgumentError("missing primary type", "types", e)
            : a.length > 1 &&
              logger$e.throwArgumentError(`ambiguous primary types or unused types: ${a.map((c) => JSON.stringify(c)).join(", ")}`, "types", e),
            defineReadOnly(this, "primaryType", a[0])
        function l(c, g) {
            g[c] && logger$e.throwArgumentError(`circular type reference to ${JSON.stringify(c)}`, "types", e),
                (g[c] = !0),
                Object.keys(n[c]).forEach((v) => {
                    !i[v] ||
                        (l(v, g),
                        Object.keys(g).forEach((_) => {
                            o[_][v] = !0
                        }))
                }),
                delete g[c]
        }
        l(this.primaryType, {})
        for (const c in o) {
            const g = Object.keys(o[c])
            g.sort(), (this._types[c] = encodeType(c, e[c]) + g.map((v) => encodeType(v, e[v])).join(""))
        }
    }
    getEncoder(e) {
        let n = this._encoderCache[e]
        return n || (n = this._encoderCache[e] = this._getEncoder(e)), n
    }
    _getEncoder(e) {
        {
            const o = getBaseEncoder(e)
            if (o) return o
        }
        const n = e.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (n) {
            const o = n[1],
                a = this.getEncoder(o),
                l = parseInt(n[3])
            return (c) => {
                l >= 0 && c.length !== l && logger$e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", c)
                let g = c.map(a)
                return this._types[o] && (g = g.map(keccak256)), keccak256(hexConcat(g))
            }
        }
        const i = this.types[e]
        if (i) {
            const o = id(this._types[e])
            return (a) => {
                const l = i.map(({ name: c, type: g }) => {
                    const v = this.getEncoder(g)(a[c])
                    return this._types[g] ? keccak256(v) : v
                })
                return l.unshift(o), hexConcat(l)
            }
        }
        return logger$e.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const n = this._types[e]
        return n || logger$e.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), n
    }
    encodeData(e, n) {
        return this.getEncoder(e)(n)
    }
    hashStruct(e, n) {
        return keccak256(this.encodeData(e, n))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, n, i) {
        if (getBaseEncoder(e)) return i(e, n)
        const o = e.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (o) {
            const l = o[1],
                c = parseInt(o[3])
            return (
                c >= 0 && n.length !== c && logger$e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", n),
                n.map((g) => this._visit(l, g, i))
            )
        }
        const a = this.types[e]
        return a
            ? a.reduce((l, { name: c, type: g }) => ((l[c] = this._visit(g, n[c], i)), l), {})
            : logger$e.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, n) {
        return this._visit(this.primaryType, e, n)
    }
    static from(e) {
        return new TypedDataEncoder(e)
    }
    static getPrimaryType(e) {
        return TypedDataEncoder.from(e).primaryType
    }
    static hashStruct(e, n, i) {
        return TypedDataEncoder.from(n).hashStruct(e, i)
    }
    static hashDomain(e) {
        const n = []
        for (const i in e) {
            const o = domainFieldTypes[i]
            o || logger$e.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(i)}`, "domain", e), n.push({ name: i, type: o })
        }
        return (
            n.sort((i, o) => domainFieldNames.indexOf(i.name) - domainFieldNames.indexOf(o.name)),
            TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: n }, e)
        )
    }
    static encode(e, n, i) {
        return hexConcat(["0x1901", TypedDataEncoder.hashDomain(e), TypedDataEncoder.from(n).hash(i)])
    }
    static hash(e, n, i) {
        return keccak256(TypedDataEncoder.encode(e, n, i))
    }
    static resolveNames(e, n, i, o) {
        return __awaiter$8(this, void 0, void 0, function* () {
            e = shallowCopy(e)
            const a = {}
            e.verifyingContract && !isHexString(e.verifyingContract, 20) && (a[e.verifyingContract] = "0x")
            const l = TypedDataEncoder.from(n)
            l.visit(i, (c, g) => (c === "address" && !isHexString(g, 20) && (a[g] = "0x"), g))
            for (const c in a) a[c] = yield o(c)
            return (
                e.verifyingContract && a[e.verifyingContract] && (e.verifyingContract = a[e.verifyingContract]),
                (i = l.visit(i, (c, g) => (c === "address" && a[g] ? a[g] : g))),
                { domain: e, value: i }
            )
        })
    }
    static getPayload(e, n, i) {
        TypedDataEncoder.hashDomain(e)
        const o = {},
            a = []
        domainFieldNames.forEach((g) => {
            const v = e[g]
            v != null && ((o[g] = domainChecks[g](v)), a.push({ name: g, type: domainFieldTypes[g] }))
        })
        const l = TypedDataEncoder.from(n),
            c = shallowCopy(n)
        return (
            c.EIP712Domain
                ? logger$e.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", n)
                : (c.EIP712Domain = a),
            l.encode(i),
            {
                types: c,
                domain: o,
                primaryType: l.primaryType,
                message: l.visit(i, (g, v) => {
                    if (g.match(/^bytes(\d*)/)) return hexlify(arrayify(v))
                    if (g.match(/^u?int/)) return BigNumber.from(v).toString()
                    switch (g) {
                        case "address":
                            return v.toLowerCase()
                        case "bool":
                            return !!v
                        case "string":
                            return typeof v != "string" && logger$e.throwArgumentError("invalid string", "value", v), v
                    }
                    return logger$e.throwArgumentError("unsupported type", "type", g)
                }),
            }
        )
    }
}
const logger$d = new Logger(version$f)
class LogDescription extends Description {}
class TransactionDescription extends Description {}
class ErrorDescription extends Description {}
class Indexed extends Description {
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] },
}
function wrapAccessError(t, e) {
    const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`)
    return (n.error = e), n
}
class Interface {
    constructor(e) {
        let n = []
        typeof e == "string" ? (n = JSON.parse(e)) : (n = e),
            defineReadOnly(
                this,
                "fragments",
                n.map((i) => Fragment.from(i)).filter((i) => i != null)
            ),
            defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")()),
            defineReadOnly(this, "functions", {}),
            defineReadOnly(this, "errors", {}),
            defineReadOnly(this, "events", {}),
            defineReadOnly(this, "structs", {}),
            this.fragments.forEach((i) => {
                let o = null
                switch (i.type) {
                    case "constructor":
                        if (this.deploy) {
                            logger$d.warn("duplicate definition - constructor")
                            return
                        }
                        defineReadOnly(this, "deploy", i)
                        return
                    case "function":
                        o = this.functions
                        break
                    case "event":
                        o = this.events
                        break
                    case "error":
                        o = this.errors
                        break
                    default:
                        return
                }
                let a = i.format()
                if (o[a]) {
                    logger$d.warn("duplicate definition - " + a)
                    return
                }
                o[a] = i
            }),
            this.deploy || defineReadOnly(this, "deploy", ConstructorFragment.from({ payable: !1, type: "constructor" })),
            defineReadOnly(this, "_isInterface", !0)
    }
    format(e) {
        e || (e = FormatTypes.full),
            e === FormatTypes.sighash && logger$d.throwArgumentError("interface does not support formatting sighash", "format", e)
        const n = this.fragments.map((i) => i.format(e))
        return e === FormatTypes.json ? JSON.stringify(n.map((i) => JSON.parse(i))) : n
    }
    static getAbiCoder() {
        return defaultAbiCoder
    }
    static getAddress(e) {
        return getAddress(e)
    }
    static getSighash(e) {
        return hexDataSlice(id(e.format()), 0, 4)
    }
    static getEventTopic(e) {
        return id(e.format())
    }
    getFunction(e) {
        if (isHexString(e)) {
            for (const i in this.functions) if (e === this.getSighash(i)) return this.functions[i]
            logger$d.throwArgumentError("no matching function", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const i = e.trim(),
                o = Object.keys(this.functions).filter((a) => a.split("(")[0] === i)
            return (
                o.length === 0
                    ? logger$d.throwArgumentError("no matching function", "name", i)
                    : o.length > 1 && logger$d.throwArgumentError("multiple matching functions", "name", i),
                this.functions[o[0]]
            )
        }
        const n = this.functions[FunctionFragment.fromString(e).format()]
        return n || logger$d.throwArgumentError("no matching function", "signature", e), n
    }
    getEvent(e) {
        if (isHexString(e)) {
            const i = e.toLowerCase()
            for (const o in this.events) if (i === this.getEventTopic(o)) return this.events[o]
            logger$d.throwArgumentError("no matching event", "topichash", i)
        }
        if (e.indexOf("(") === -1) {
            const i = e.trim(),
                o = Object.keys(this.events).filter((a) => a.split("(")[0] === i)
            return (
                o.length === 0
                    ? logger$d.throwArgumentError("no matching event", "name", i)
                    : o.length > 1 && logger$d.throwArgumentError("multiple matching events", "name", i),
                this.events[o[0]]
            )
        }
        const n = this.events[EventFragment.fromString(e).format()]
        return n || logger$d.throwArgumentError("no matching event", "signature", e), n
    }
    getError(e) {
        if (isHexString(e)) {
            const i = getStatic(this.constructor, "getSighash")
            for (const o in this.errors) {
                const a = this.errors[o]
                if (e === i(a)) return this.errors[o]
            }
            logger$d.throwArgumentError("no matching error", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const i = e.trim(),
                o = Object.keys(this.errors).filter((a) => a.split("(")[0] === i)
            return (
                o.length === 0
                    ? logger$d.throwArgumentError("no matching error", "name", i)
                    : o.length > 1 && logger$d.throwArgumentError("multiple matching errors", "name", i),
                this.errors[o[0]]
            )
        }
        const n = this.errors[FunctionFragment.fromString(e).format()]
        return n || logger$d.throwArgumentError("no matching error", "signature", e), n
    }
    getSighash(e) {
        if (typeof e == "string")
            try {
                e = this.getFunction(e)
            } catch (n) {
                try {
                    e = this.getError(e)
                } catch {
                    throw n
                }
            }
        return getStatic(this.constructor, "getSighash")(e)
    }
    getEventTopic(e) {
        return typeof e == "string" && (e = this.getEvent(e)), getStatic(this.constructor, "getEventTopic")(e)
    }
    _decodeParams(e, n) {
        return this._abiCoder.decode(e, n)
    }
    _encodeParams(e, n) {
        return this._abiCoder.encode(e, n)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, n) {
        typeof e == "string" && (e = this.getError(e))
        const i = arrayify(n)
        return (
            hexlify(i.slice(0, 4)) !== this.getSighash(e) &&
                logger$d.throwArgumentError(`data signature does not match error ${e.name}.`, "data", hexlify(i)),
            this._decodeParams(e.inputs, i.slice(4))
        )
    }
    encodeErrorResult(e, n) {
        return typeof e == "string" && (e = this.getError(e)), hexlify(concat$2([this.getSighash(e), this._encodeParams(e.inputs, n || [])]))
    }
    decodeFunctionData(e, n) {
        typeof e == "string" && (e = this.getFunction(e))
        const i = arrayify(n)
        return (
            hexlify(i.slice(0, 4)) !== this.getSighash(e) &&
                logger$d.throwArgumentError(`data signature does not match function ${e.name}.`, "data", hexlify(i)),
            this._decodeParams(e.inputs, i.slice(4))
        )
    }
    encodeFunctionData(e, n) {
        return typeof e == "string" && (e = this.getFunction(e)), hexlify(concat$2([this.getSighash(e), this._encodeParams(e.inputs, n || [])]))
    }
    decodeFunctionResult(e, n) {
        typeof e == "string" && (e = this.getFunction(e))
        let i = arrayify(n),
            o = null,
            a = "",
            l = null,
            c = null,
            g = null
        switch (i.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(e.outputs, i)
                } catch {}
                break
            case 4: {
                const v = hexlify(i.slice(0, 4)),
                    _ = BuiltinErrors[v]
                if (_)
                    (l = this._abiCoder.decode(_.inputs, i.slice(4))),
                        (c = _.name),
                        (g = _.signature),
                        _.reason && (o = l[0]),
                        c === "Error"
                            ? (a = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(l[0])}`)
                            : c === "Panic" && (a = `; VM Exception while processing transaction: reverted with panic code ${l[0]}`)
                else
                    try {
                        const A = this.getError(v)
                        ;(l = this._abiCoder.decode(A.inputs, i.slice(4))), (c = A.name), (g = A.format())
                    } catch {}
                break
            }
        }
        return logger$d.throwError("call revert exception" + a, Logger.errors.CALL_EXCEPTION, {
            method: e.format(),
            data: hexlify(n),
            errorArgs: l,
            errorName: c,
            errorSignature: g,
            reason: o,
        })
    }
    encodeFunctionResult(e, n) {
        return typeof e == "string" && (e = this.getFunction(e)), hexlify(this._abiCoder.encode(e.outputs, n || []))
    }
    encodeFilterTopics(e, n) {
        typeof e == "string" && (e = this.getEvent(e)),
            n.length > e.inputs.length &&
                logger$d.throwError("too many arguments for " + e.format(), Logger.errors.UNEXPECTED_ARGUMENT, { argument: "values", value: n })
        let i = []
        e.anonymous || i.push(this.getEventTopic(e))
        const o = (a, l) =>
            a.type === "string"
                ? id(l)
                : a.type === "bytes"
                ? keccak256(hexlify(l))
                : (a.type === "bool" && typeof l == "boolean" && (l = l ? "0x01" : "0x00"),
                  a.type.match(/^u?int/) && (l = BigNumber.from(l).toHexString()),
                  a.type === "address" && this._abiCoder.encode(["address"], [l]),
                  hexZeroPad(hexlify(l), 32))
        for (
            n.forEach((a, l) => {
                let c = e.inputs[l]
                if (!c.indexed) {
                    a != null && logger$d.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + c.name, a)
                    return
                }
                a == null
                    ? i.push(null)
                    : c.baseType === "array" || c.baseType === "tuple"
                    ? logger$d.throwArgumentError("filtering with tuples or arrays not supported", "contract." + c.name, a)
                    : Array.isArray(a)
                    ? i.push(a.map((g) => o(c, g)))
                    : i.push(o(c, a))
            });
            i.length && i[i.length - 1] === null;

        )
            i.pop()
        return i
    }
    encodeEventLog(e, n) {
        typeof e == "string" && (e = this.getEvent(e))
        const i = [],
            o = [],
            a = []
        return (
            e.anonymous || i.push(this.getEventTopic(e)),
            n.length !== e.inputs.length && logger$d.throwArgumentError("event arguments/values mismatch", "values", n),
            e.inputs.forEach((l, c) => {
                const g = n[c]
                if (l.indexed)
                    if (l.type === "string") i.push(id(g))
                    else if (l.type === "bytes") i.push(keccak256(g))
                    else {
                        if (l.baseType === "tuple" || l.baseType === "array") throw new Error("not implemented")
                        i.push(this._abiCoder.encode([l.type], [g]))
                    }
                else o.push(l), a.push(g)
            }),
            { data: this._abiCoder.encode(o, a), topics: i }
        )
    }
    decodeEventLog(e, n, i) {
        if ((typeof e == "string" && (e = this.getEvent(e)), i != null && !e.anonymous)) {
            let B = this.getEventTopic(e)
            ;(!isHexString(i[0], 32) || i[0].toLowerCase() !== B) &&
                logger$d.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, {
                    argument: "topics[0]",
                    expected: B,
                    value: i[0],
                }),
                (i = i.slice(1))
        }
        let o = [],
            a = [],
            l = []
        e.inputs.forEach((B, D) => {
            B.indexed
                ? B.type === "string" || B.type === "bytes" || B.baseType === "tuple" || B.baseType === "array"
                    ? (o.push(ParamType.fromObject({ type: "bytes32", name: B.name })), l.push(!0))
                    : (o.push(B), l.push(!1))
                : (a.push(B), l.push(!1))
        })
        let c = i != null ? this._abiCoder.decode(o, concat$2(i)) : null,
            g = this._abiCoder.decode(a, n, !0),
            v = [],
            _ = 0,
            A = 0
        e.inputs.forEach((B, D) => {
            if (B.indexed)
                if (c == null) v[D] = new Indexed({ _isIndexed: !0, hash: null })
                else if (l[D]) v[D] = new Indexed({ _isIndexed: !0, hash: c[A++] })
                else
                    try {
                        v[D] = c[A++]
                    } catch (I) {
                        v[D] = I
                    }
            else
                try {
                    v[D] = g[_++]
                } catch (I) {
                    v[D] = I
                }
            if (B.name && v[B.name] == null) {
                const I = v[D]
                I instanceof Error
                    ? Object.defineProperty(v, B.name, {
                          enumerable: !0,
                          get: () => {
                              throw wrapAccessError(`property ${JSON.stringify(B.name)}`, I)
                          },
                      })
                    : (v[B.name] = I)
            }
        })
        for (let B = 0; B < v.length; B++) {
            const D = v[B]
            D instanceof Error &&
                Object.defineProperty(v, B, {
                    enumerable: !0,
                    get: () => {
                        throw wrapAccessError(`index ${B}`, D)
                    },
                })
        }
        return Object.freeze(v)
    }
    parseTransaction(e) {
        let n = this.getFunction(e.data.substring(0, 10).toLowerCase())
        return n
            ? new TransactionDescription({
                  args: this._abiCoder.decode(n.inputs, "0x" + e.data.substring(10)),
                  functionFragment: n,
                  name: n.name,
                  signature: n.format(),
                  sighash: this.getSighash(n),
                  value: BigNumber.from(e.value || "0"),
              })
            : null
    }
    parseLog(e) {
        let n = this.getEvent(e.topics[0])
        return !n || n.anonymous
            ? null
            : new LogDescription({
                  eventFragment: n,
                  name: n.name,
                  signature: n.format(),
                  topic: this.getEventTopic(n),
                  args: this.decodeEventLog(n, e.data, e.topics),
              })
    }
    parseError(e) {
        const n = hexlify(e)
        let i = this.getError(n.substring(0, 10).toLowerCase())
        return i
            ? new ErrorDescription({
                  args: this._abiCoder.decode(i.inputs, "0x" + n.substring(10)),
                  errorFragment: i,
                  name: i.name,
                  signature: i.format(),
                  sighash: this.getSighash(i),
              })
            : null
    }
    static isInterface(e) {
        return !!(e && e._isInterface)
    }
}
const version$a = "abstract-provider/5.7.0"
var __awaiter$7 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$c = new Logger(version$a)
class ForkEvent extends Description {
    static isForkEvent(e) {
        return !!(e && e._isForkEvent)
    }
}
class Provider$1 {
    constructor() {
        logger$c.checkAbstract(new.target, Provider$1), defineReadOnly(this, "_isProvider", !0)
    }
    getFeeData() {
        return __awaiter$7(this, void 0, void 0, function* () {
            const { block: e, gasPrice: n } = yield resolveProperties({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((l) => null),
            })
            let i = null,
                o = null,
                a = null
            return (
                e && e.baseFeePerGas && ((i = e.baseFeePerGas), (a = BigNumber.from("1500000000")), (o = e.baseFeePerGas.mul(2).add(a))),
                { lastBaseFeePerGas: i, maxFeePerGas: o, maxPriorityFeePerGas: a, gasPrice: n }
            )
        })
    }
    addListener(e, n) {
        return this.on(e, n)
    }
    removeListener(e, n) {
        return this.off(e, n)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const version$9 = "abstract-signer/5.7.0"
var __awaiter$6 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$b = new Logger(version$9),
    allowedTransactionKeys$2 = [
        "accessList",
        "ccipReadEnabled",
        "chainId",
        "customData",
        "data",
        "from",
        "gasLimit",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "to",
        "type",
        "value",
    ],
    forwardErrors = [Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED]
class Signer {
    constructor() {
        logger$b.checkAbstract(new.target, Signer), defineReadOnly(this, "_isSigner", !0)
    }
    getBalance(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas")
            const n = yield resolveProperties(this.checkTransaction(e))
            return yield this.provider.estimateGas(n)
        })
    }
    call(e, n) {
        return __awaiter$6(this, void 0, void 0, function* () {
            this._checkProvider("call")
            const i = yield resolveProperties(this.checkTransaction(e))
            return yield this.provider.call(i, n)
        })
    }
    sendTransaction(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction")
            const n = yield this.populateTransaction(e),
                i = yield this.signTransaction(n)
            return yield this.provider.sendTransaction(i)
        })
    }
    getChainId() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const i in e)
            allowedTransactionKeys$2.indexOf(i) === -1 && logger$b.throwArgumentError("invalid transaction key: " + i, "transaction", e)
        const n = shallowCopy(e)
        return (
            n.from == null
                ? (n.from = this.getAddress())
                : (n.from = Promise.all([Promise.resolve(n.from), this.getAddress()]).then(
                      (i) => (
                          i[0].toLowerCase() !== i[1].toLowerCase() && logger$b.throwArgumentError("from address mismatch", "transaction", e),
                          i[0]
                      )
                  )),
            n
        )
    }
    populateTransaction(e) {
        return __awaiter$6(this, void 0, void 0, function* () {
            const n = yield resolveProperties(this.checkTransaction(e))
            n.to != null &&
                ((n.to = Promise.resolve(n.to).then((o) =>
                    __awaiter$6(this, void 0, void 0, function* () {
                        if (o == null) return null
                        const a = yield this.resolveName(o)
                        return a == null && logger$b.throwArgumentError("provided ENS name resolves to null", "tx.to", o), a
                    })
                )),
                n.to.catch((o) => {}))
            const i = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null
            if (
                (n.gasPrice != null && (n.type === 2 || i)
                    ? logger$b.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e)
                    : (n.type === 0 || n.type === 1) &&
                      i &&
                      logger$b.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e),
                (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null)
            )
                n.type = 2
            else if (n.type === 0 || n.type === 1) n.gasPrice == null && (n.gasPrice = this.getGasPrice())
            else {
                const o = yield this.getFeeData()
                if (n.type == null)
                    if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
                        if (((n.type = 2), n.gasPrice != null)) {
                            const a = n.gasPrice
                            delete n.gasPrice, (n.maxFeePerGas = a), (n.maxPriorityFeePerGas = a)
                        } else
                            n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas),
                                n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas)
                    else
                        o.gasPrice != null
                            ? (i &&
                                  logger$b.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                                      operation: "populateTransaction",
                                  }),
                              n.gasPrice == null && (n.gasPrice = o.gasPrice),
                              (n.type = 0))
                            : logger$b.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                                  operation: "signer.getFeeData",
                              })
                else
                    n.type === 2 &&
                        (n.maxFeePerGas == null && (n.maxFeePerGas = o.maxFeePerGas),
                        n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = o.maxPriorityFeePerGas))
            }
            return (
                n.nonce == null && (n.nonce = this.getTransactionCount("pending")),
                n.gasLimit == null &&
                    (n.gasLimit = this.estimateGas(n).catch((o) => {
                        if (forwardErrors.indexOf(o.code) >= 0) throw o
                        return logger$b.throwError(
                            "cannot estimate gas; transaction may fail or may require manual gas limit",
                            Logger.errors.UNPREDICTABLE_GAS_LIMIT,
                            { error: o, tx: n }
                        )
                    })),
                n.chainId == null
                    ? (n.chainId = this.getChainId())
                    : (n.chainId = Promise.all([Promise.resolve(n.chainId), this.getChainId()]).then(
                          (o) => (o[1] !== 0 && o[0] !== o[1] && logger$b.throwArgumentError("chainId address mismatch", "transaction", e), o[0])
                      )),
                yield resolveProperties(n)
            )
        })
    }
    _checkProvider(e) {
        this.provider || logger$b.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: e || "_checkProvider" })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class VoidSigner extends Signer {
    constructor(e, n) {
        super(), defineReadOnly(this, "address", e), defineReadOnly(this, "provider", n || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, n) {
        return Promise.resolve().then(() => {
            logger$b.throwError(e, Logger.errors.UNSUPPORTED_OPERATION, { operation: n })
        })
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, n, i) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new VoidSigner(this.address, e)
    }
}
var bn$1 = { exports: {} }
;(function (t) {
    ;(function (e, n) {
        function i(O, u) {
            if (!O) throw new Error(u || "Assertion failed")
        }
        function o(O, u) {
            O.super_ = u
            var E = function () {}
            ;(E.prototype = u.prototype), (O.prototype = new E()), (O.prototype.constructor = O)
        }
        function a(O, u, E) {
            if (a.isBN(O)) return O
            ;(this.negative = 0),
                (this.words = null),
                (this.length = 0),
                (this.red = null),
                O !== null && ((u === "le" || u === "be") && ((E = u), (u = 10)), this._init(O || 0, u || 10, E || "be"))
        }
        typeof e == "object" ? (e.exports = a) : (n.BN = a), (a.BN = a), (a.wordSize = 26)
        var l
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? (l = window.Buffer) : (l = require("buffer").Buffer)
        } catch {}
        ;(a.isBN = function (u) {
            return u instanceof a ? !0 : u !== null && typeof u == "object" && u.constructor.wordSize === a.wordSize && Array.isArray(u.words)
        }),
            (a.max = function (u, E) {
                return u.cmp(E) > 0 ? u : E
            }),
            (a.min = function (u, E) {
                return u.cmp(E) < 0 ? u : E
            }),
            (a.prototype._init = function (u, E, $) {
                if (typeof u == "number") return this._initNumber(u, E, $)
                if (typeof u == "object") return this._initArray(u, E, $)
                E === "hex" && (E = 16), i(E === (E | 0) && E >= 2 && E <= 36), (u = u.toString().replace(/\s+/g, ""))
                var N = 0
                u[0] === "-" && (N++, (this.negative = 1)),
                    N < u.length &&
                        (E === 16 ? this._parseHex(u, N, $) : (this._parseBase(u, E, N), $ === "le" && this._initArray(this.toArray(), E, $)))
            }),
            (a.prototype._initNumber = function (u, E, $) {
                u < 0 && ((this.negative = 1), (u = -u)),
                    u < 67108864
                        ? ((this.words = [u & 67108863]), (this.length = 1))
                        : u < 4503599627370496
                        ? ((this.words = [u & 67108863, (u / 67108864) & 67108863]), (this.length = 2))
                        : (i(u < 9007199254740992), (this.words = [u & 67108863, (u / 67108864) & 67108863, 1]), (this.length = 3)),
                    $ === "le" && this._initArray(this.toArray(), E, $)
            }),
            (a.prototype._initArray = function (u, E, $) {
                if ((i(typeof u.length == "number"), u.length <= 0)) return (this.words = [0]), (this.length = 1), this
                ;(this.length = Math.ceil(u.length / 3)), (this.words = new Array(this.length))
                for (var N = 0; N < this.length; N++) this.words[N] = 0
                var M,
                    R,
                    C = 0
                if ($ === "be")
                    for (N = u.length - 1, M = 0; N >= 0; N -= 3)
                        (R = u[N] | (u[N - 1] << 8) | (u[N - 2] << 16)),
                            (this.words[M] |= (R << C) & 67108863),
                            (this.words[M + 1] = (R >>> (26 - C)) & 67108863),
                            (C += 24),
                            C >= 26 && ((C -= 26), M++)
                else if ($ === "le")
                    for (N = 0, M = 0; N < u.length; N += 3)
                        (R = u[N] | (u[N + 1] << 8) | (u[N + 2] << 16)),
                            (this.words[M] |= (R << C) & 67108863),
                            (this.words[M + 1] = (R >>> (26 - C)) & 67108863),
                            (C += 24),
                            C >= 26 && ((C -= 26), M++)
                return this._strip()
            })
        function c(O, u) {
            var E = O.charCodeAt(u)
            if (E >= 48 && E <= 57) return E - 48
            if (E >= 65 && E <= 70) return E - 55
            if (E >= 97 && E <= 102) return E - 87
            i(!1, "Invalid character in " + O)
        }
        function g(O, u, E) {
            var $ = c(O, E)
            return E - 1 >= u && ($ |= c(O, E - 1) << 4), $
        }
        a.prototype._parseHex = function (u, E, $) {
            ;(this.length = Math.ceil((u.length - E) / 6)), (this.words = new Array(this.length))
            for (var N = 0; N < this.length; N++) this.words[N] = 0
            var M = 0,
                R = 0,
                C
            if ($ === "be")
                for (N = u.length - 1; N >= E; N -= 2)
                    (C = g(u, E, N) << M),
                        (this.words[R] |= C & 67108863),
                        M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= C >>> 26)) : (M += 8)
            else {
                var S = u.length - E
                for (N = S % 2 === 0 ? E + 1 : E; N < u.length; N += 2)
                    (C = g(u, E, N) << M),
                        (this.words[R] |= C & 67108863),
                        M >= 18 ? ((M -= 18), (R += 1), (this.words[R] |= C >>> 26)) : (M += 8)
            }
            this._strip()
        }
        function v(O, u, E, $) {
            for (var N = 0, M = 0, R = Math.min(O.length, E), C = u; C < R; C++) {
                var S = O.charCodeAt(C) - 48
                ;(N *= $), S >= 49 ? (M = S - 49 + 10) : S >= 17 ? (M = S - 17 + 10) : (M = S), i(S >= 0 && M < $, "Invalid character"), (N += M)
            }
            return N
        }
        ;(a.prototype._parseBase = function (u, E, $) {
            ;(this.words = [0]), (this.length = 1)
            for (var N = 0, M = 1; M <= 67108863; M *= E) N++
            N--, (M = (M / E) | 0)
            for (var R = u.length - $, C = R % N, S = Math.min(R, R - C) + $, b = 0, T = $; T < S; T += N)
                (b = v(u, T, T + N, E)), this.imuln(M), this.words[0] + b < 67108864 ? (this.words[0] += b) : this._iaddn(b)
            if (C !== 0) {
                var Q = 1
                for (b = v(u, T, u.length, E), T = 0; T < C; T++) Q *= E
                this.imuln(Q), this.words[0] + b < 67108864 ? (this.words[0] += b) : this._iaddn(b)
            }
            this._strip()
        }),
            (a.prototype.copy = function (u) {
                u.words = new Array(this.length)
                for (var E = 0; E < this.length; E++) u.words[E] = this.words[E]
                ;(u.length = this.length), (u.negative = this.negative), (u.red = this.red)
            })
        function _(O, u) {
            ;(O.words = u.words), (O.length = u.length), (O.negative = u.negative), (O.red = u.red)
        }
        if (
            ((a.prototype._move = function (u) {
                _(u, this)
            }),
            (a.prototype.clone = function () {
                var u = new a(null)
                return this.copy(u), u
            }),
            (a.prototype._expand = function (u) {
                for (; this.length < u; ) this.words[this.length++] = 0
                return this
            }),
            (a.prototype._strip = function () {
                for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                return this._normSign()
            }),
            (a.prototype._normSign = function () {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            typeof Symbol != "undefined" && typeof Symbol.for == "function")
        )
            try {
                a.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
            } catch {
                a.prototype.inspect = A
            }
        else a.prototype.inspect = A
        function A() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var B = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000",
            ],
            D = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            I = [
                0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
                11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
                17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ]
        ;(a.prototype.toString = function (u, E) {
            ;(u = u || 10), (E = E | 0 || 1)
            var $
            if (u === 16 || u === "hex") {
                $ = ""
                for (var N = 0, M = 0, R = 0; R < this.length; R++) {
                    var C = this.words[R],
                        S = (((C << N) | M) & 16777215).toString(16)
                    ;(M = (C >>> (24 - N)) & 16777215),
                        (N += 2),
                        N >= 26 && ((N -= 26), R--),
                        M !== 0 || R !== this.length - 1 ? ($ = B[6 - S.length] + S + $) : ($ = S + $)
                }
                for (M !== 0 && ($ = M.toString(16) + $); $.length % E !== 0; ) $ = "0" + $
                return this.negative !== 0 && ($ = "-" + $), $
            }
            if (u === (u | 0) && u >= 2 && u <= 36) {
                var b = D[u],
                    T = I[u]
                $ = ""
                var Q = this.clone()
                for (Q.negative = 0; !Q.isZero(); ) {
                    var k = Q.modrn(T).toString(u)
                    ;(Q = Q.idivn(T)), Q.isZero() ? ($ = k + $) : ($ = B[b - k.length] + k + $)
                }
                for (this.isZero() && ($ = "0" + $); $.length % E !== 0; ) $ = "0" + $
                return this.negative !== 0 && ($ = "-" + $), $
            }
            i(!1, "Base should be between 2 and 36")
        }),
            (a.prototype.toNumber = function () {
                var u = this.words[0]
                return (
                    this.length === 2
                        ? (u += this.words[1] * 67108864)
                        : this.length === 3 && this.words[2] === 1
                        ? (u += 4503599627370496 + this.words[1] * 67108864)
                        : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"),
                    this.negative !== 0 ? -u : u
                )
            }),
            (a.prototype.toJSON = function () {
                return this.toString(16, 2)
            }),
            l &&
                (a.prototype.toBuffer = function (u, E) {
                    return this.toArrayLike(l, u, E)
                }),
            (a.prototype.toArray = function (u, E) {
                return this.toArrayLike(Array, u, E)
            })
        var L = function (u, E) {
            return u.allocUnsafe ? u.allocUnsafe(E) : new u(E)
        }
        ;(a.prototype.toArrayLike = function (u, E, $) {
            this._strip()
            var N = this.byteLength(),
                M = $ || Math.max(1, N)
            i(N <= M, "byte array longer than desired length"), i(M > 0, "Requested array length <= 0")
            var R = L(u, M),
                C = E === "le" ? "LE" : "BE"
            return this["_toArrayLike" + C](R, N), R
        }),
            (a.prototype._toArrayLikeLE = function (u, E) {
                for (var $ = 0, N = 0, M = 0, R = 0; M < this.length; M++) {
                    var C = (this.words[M] << R) | N
                    ;(u[$++] = C & 255),
                        $ < u.length && (u[$++] = (C >> 8) & 255),
                        $ < u.length && (u[$++] = (C >> 16) & 255),
                        R === 6 ? ($ < u.length && (u[$++] = (C >> 24) & 255), (N = 0), (R = 0)) : ((N = C >>> 24), (R += 2))
                }
                if ($ < u.length) for (u[$++] = N; $ < u.length; ) u[$++] = 0
            }),
            (a.prototype._toArrayLikeBE = function (u, E) {
                for (var $ = u.length - 1, N = 0, M = 0, R = 0; M < this.length; M++) {
                    var C = (this.words[M] << R) | N
                    ;(u[$--] = C & 255),
                        $ >= 0 && (u[$--] = (C >> 8) & 255),
                        $ >= 0 && (u[$--] = (C >> 16) & 255),
                        R === 6 ? ($ >= 0 && (u[$--] = (C >> 24) & 255), (N = 0), (R = 0)) : ((N = C >>> 24), (R += 2))
                }
                if ($ >= 0) for (u[$--] = N; $ >= 0; ) u[$--] = 0
            }),
            Math.clz32
                ? (a.prototype._countBits = function (u) {
                      return 32 - Math.clz32(u)
                  })
                : (a.prototype._countBits = function (u) {
                      var E = u,
                          $ = 0
                      return (
                          E >= 4096 && (($ += 13), (E >>>= 13)),
                          E >= 64 && (($ += 7), (E >>>= 7)),
                          E >= 8 && (($ += 4), (E >>>= 4)),
                          E >= 2 && (($ += 2), (E >>>= 2)),
                          $ + E
                      )
                  }),
            (a.prototype._zeroBits = function (u) {
                if (u === 0) return 26
                var E = u,
                    $ = 0
                return (
                    (E & 8191) === 0 && (($ += 13), (E >>>= 13)),
                    (E & 127) === 0 && (($ += 7), (E >>>= 7)),
                    (E & 15) === 0 && (($ += 4), (E >>>= 4)),
                    (E & 3) === 0 && (($ += 2), (E >>>= 2)),
                    (E & 1) === 0 && $++,
                    $
                )
            }),
            (a.prototype.bitLength = function () {
                var u = this.words[this.length - 1],
                    E = this._countBits(u)
                return (this.length - 1) * 26 + E
            })
        function G(O) {
            for (var u = new Array(O.bitLength()), E = 0; E < u.length; E++) {
                var $ = (E / 26) | 0,
                    N = E % 26
                u[E] = (O.words[$] >>> N) & 1
            }
            return u
        }
        ;(a.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var u = 0, E = 0; E < this.length; E++) {
                var $ = this._zeroBits(this.words[E])
                if (((u += $), $ !== 26)) break
            }
            return u
        }),
            (a.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }),
            (a.prototype.toTwos = function (u) {
                return this.negative !== 0 ? this.abs().inotn(u).iaddn(1) : this.clone()
            }),
            (a.prototype.fromTwos = function (u) {
                return this.testn(u - 1) ? this.notn(u).iaddn(1).ineg() : this.clone()
            }),
            (a.prototype.isNeg = function () {
                return this.negative !== 0
            }),
            (a.prototype.neg = function () {
                return this.clone().ineg()
            }),
            (a.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }),
            (a.prototype.iuor = function (u) {
                for (; this.length < u.length; ) this.words[this.length++] = 0
                for (var E = 0; E < u.length; E++) this.words[E] = this.words[E] | u.words[E]
                return this._strip()
            }),
            (a.prototype.ior = function (u) {
                return i((this.negative | u.negative) === 0), this.iuor(u)
            }),
            (a.prototype.or = function (u) {
                return this.length > u.length ? this.clone().ior(u) : u.clone().ior(this)
            }),
            (a.prototype.uor = function (u) {
                return this.length > u.length ? this.clone().iuor(u) : u.clone().iuor(this)
            }),
            (a.prototype.iuand = function (u) {
                var E
                this.length > u.length ? (E = u) : (E = this)
                for (var $ = 0; $ < E.length; $++) this.words[$] = this.words[$] & u.words[$]
                return (this.length = E.length), this._strip()
            }),
            (a.prototype.iand = function (u) {
                return i((this.negative | u.negative) === 0), this.iuand(u)
            }),
            (a.prototype.and = function (u) {
                return this.length > u.length ? this.clone().iand(u) : u.clone().iand(this)
            }),
            (a.prototype.uand = function (u) {
                return this.length > u.length ? this.clone().iuand(u) : u.clone().iuand(this)
            }),
            (a.prototype.iuxor = function (u) {
                var E, $
                this.length > u.length ? ((E = this), ($ = u)) : ((E = u), ($ = this))
                for (var N = 0; N < $.length; N++) this.words[N] = E.words[N] ^ $.words[N]
                if (this !== E) for (; N < E.length; N++) this.words[N] = E.words[N]
                return (this.length = E.length), this._strip()
            }),
            (a.prototype.ixor = function (u) {
                return i((this.negative | u.negative) === 0), this.iuxor(u)
            }),
            (a.prototype.xor = function (u) {
                return this.length > u.length ? this.clone().ixor(u) : u.clone().ixor(this)
            }),
            (a.prototype.uxor = function (u) {
                return this.length > u.length ? this.clone().iuxor(u) : u.clone().iuxor(this)
            }),
            (a.prototype.inotn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = Math.ceil(u / 26) | 0,
                    $ = u % 26
                this._expand(E), $ > 0 && E--
                for (var N = 0; N < E; N++) this.words[N] = ~this.words[N] & 67108863
                return $ > 0 && (this.words[N] = ~this.words[N] & (67108863 >> (26 - $))), this._strip()
            }),
            (a.prototype.notn = function (u) {
                return this.clone().inotn(u)
            }),
            (a.prototype.setn = function (u, E) {
                i(typeof u == "number" && u >= 0)
                var $ = (u / 26) | 0,
                    N = u % 26
                return (
                    this._expand($ + 1),
                    E ? (this.words[$] = this.words[$] | (1 << N)) : (this.words[$] = this.words[$] & ~(1 << N)),
                    this._strip()
                )
            }),
            (a.prototype.iadd = function (u) {
                var E
                if (this.negative !== 0 && u.negative === 0)
                    return (this.negative = 0), (E = this.isub(u)), (this.negative ^= 1), this._normSign()
                if (this.negative === 0 && u.negative !== 0) return (u.negative = 0), (E = this.isub(u)), (u.negative = 1), E._normSign()
                var $, N
                this.length > u.length ? (($ = this), (N = u)) : (($ = u), (N = this))
                for (var M = 0, R = 0; R < N.length; R++)
                    (E = ($.words[R] | 0) + (N.words[R] | 0) + M), (this.words[R] = E & 67108863), (M = E >>> 26)
                for (; M !== 0 && R < $.length; R++) (E = ($.words[R] | 0) + M), (this.words[R] = E & 67108863), (M = E >>> 26)
                if (((this.length = $.length), M !== 0)) (this.words[this.length] = M), this.length++
                else if ($ !== this) for (; R < $.length; R++) this.words[R] = $.words[R]
                return this
            }),
            (a.prototype.add = function (u) {
                var E
                return u.negative !== 0 && this.negative === 0
                    ? ((u.negative = 0), (E = this.sub(u)), (u.negative ^= 1), E)
                    : u.negative === 0 && this.negative !== 0
                    ? ((this.negative = 0), (E = u.sub(this)), (this.negative = 1), E)
                    : this.length > u.length
                    ? this.clone().iadd(u)
                    : u.clone().iadd(this)
            }),
            (a.prototype.isub = function (u) {
                if (u.negative !== 0) {
                    u.negative = 0
                    var E = this.iadd(u)
                    return (u.negative = 1), E._normSign()
                } else if (this.negative !== 0) return (this.negative = 0), this.iadd(u), (this.negative = 1), this._normSign()
                var $ = this.cmp(u)
                if ($ === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
                var N, M
                $ > 0 ? ((N = this), (M = u)) : ((N = u), (M = this))
                for (var R = 0, C = 0; C < M.length; C++)
                    (E = (N.words[C] | 0) - (M.words[C] | 0) + R), (R = E >> 26), (this.words[C] = E & 67108863)
                for (; R !== 0 && C < N.length; C++) (E = (N.words[C] | 0) + R), (R = E >> 26), (this.words[C] = E & 67108863)
                if (R === 0 && C < N.length && N !== this) for (; C < N.length; C++) this.words[C] = N.words[C]
                return (this.length = Math.max(this.length, C)), N !== this && (this.negative = 1), this._strip()
            }),
            (a.prototype.sub = function (u) {
                return this.clone().isub(u)
            })
        function U(O, u, E) {
            E.negative = u.negative ^ O.negative
            var $ = (O.length + u.length) | 0
            ;(E.length = $), ($ = ($ - 1) | 0)
            var N = O.words[0] | 0,
                M = u.words[0] | 0,
                R = N * M,
                C = R & 67108863,
                S = (R / 67108864) | 0
            E.words[0] = C
            for (var b = 1; b < $; b++) {
                for (var T = S >>> 26, Q = S & 67108863, k = Math.min(b, u.length - 1), W = Math.max(0, b - O.length + 1); W <= k; W++) {
                    var J = (b - W) | 0
                    ;(N = O.words[J] | 0), (M = u.words[W] | 0), (R = N * M + Q), (T += (R / 67108864) | 0), (Q = R & 67108863)
                }
                ;(E.words[b] = Q | 0), (S = T | 0)
            }
            return S !== 0 ? (E.words[b] = S | 0) : E.length--, E._strip()
        }
        var F = function (u, E, $) {
            var N = u.words,
                M = E.words,
                R = $.words,
                C = 0,
                S,
                b,
                T,
                Q = N[0] | 0,
                k = Q & 8191,
                W = Q >>> 13,
                J = N[1] | 0,
                ee = J & 8191,
                ne = J >>> 13,
                xe = N[2] | 0,
                ce = xe & 8191,
                de = xe >>> 13,
                H = N[3] | 0,
                j = H & 8191,
                q = H >>> 13,
                ae = N[4] | 0,
                te = ae & 8191,
                fe = ae >>> 13,
                Se = N[5] | 0,
                ue = Se & 8191,
                me = Se >>> 13,
                _e = N[6] | 0,
                Ce = _e & 8191,
                ke = _e >>> 13,
                Re = N[7] | 0,
                Ne = Re & 8191,
                Me = Re >>> 13,
                He = N[8] | 0,
                Fe = He & 8191,
                Le = He >>> 13,
                $t = N[9] | 0,
                nt = $t & 8191,
                lt = $t >>> 13,
                Zr = M[0] | 0,
                kt = Zr & 8191,
                Ze = Zr >>> 13,
                Xr = M[1] | 0,
                dt = Xr & 8191,
                Bt = Xr >>> 13,
                Ya = M[2] | 0,
                Gt = Ya & 8191,
                Vt = Ya >>> 13,
                il = M[3] | 0,
                Er = il & 8191,
                Pr = il >>> 13,
                ol = M[4] | 0,
                Mr = ol & 8191,
                Dr = ol >>> 13,
                sl = M[5] | 0,
                Ur = sl & 8191,
                Hr = sl >>> 13,
                al = M[6] | 0,
                jr = al & 8191,
                qr = al >>> 13,
                fl = M[7] | 0,
                Kr = fl & 8191,
                Gr = fl >>> 13,
                cl = M[8] | 0,
                Wr = cl & 8191,
                Yr = cl >>> 13,
                ul = M[9] | 0,
                Jr = ul & 8191,
                Qr = ul >>> 13
            ;($.negative = u.negative ^ E.negative),
                ($.length = 19),
                (S = Math.imul(k, kt)),
                (b = Math.imul(k, Ze)),
                (b = (b + Math.imul(W, kt)) | 0),
                (T = Math.imul(W, Ze))
            var Qa = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (Qa >>> 26)) | 0),
                (Qa &= 67108863),
                (S = Math.imul(ee, kt)),
                (b = Math.imul(ee, Ze)),
                (b = (b + Math.imul(ne, kt)) | 0),
                (T = Math.imul(ne, Ze)),
                (S = (S + Math.imul(k, dt)) | 0),
                (b = (b + Math.imul(k, Bt)) | 0),
                (b = (b + Math.imul(W, dt)) | 0),
                (T = (T + Math.imul(W, Bt)) | 0)
            var Za = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (Za >>> 26)) | 0),
                (Za &= 67108863),
                (S = Math.imul(ce, kt)),
                (b = Math.imul(ce, Ze)),
                (b = (b + Math.imul(de, kt)) | 0),
                (T = Math.imul(de, Ze)),
                (S = (S + Math.imul(ee, dt)) | 0),
                (b = (b + Math.imul(ee, Bt)) | 0),
                (b = (b + Math.imul(ne, dt)) | 0),
                (T = (T + Math.imul(ne, Bt)) | 0),
                (S = (S + Math.imul(k, Gt)) | 0),
                (b = (b + Math.imul(k, Vt)) | 0),
                (b = (b + Math.imul(W, Gt)) | 0),
                (T = (T + Math.imul(W, Vt)) | 0)
            var el = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (el >>> 26)) | 0),
                (el &= 67108863),
                (S = Math.imul(j, kt)),
                (b = Math.imul(j, Ze)),
                (b = (b + Math.imul(q, kt)) | 0),
                (T = Math.imul(q, Ze)),
                (S = (S + Math.imul(ce, dt)) | 0),
                (b = (b + Math.imul(ce, Bt)) | 0),
                (b = (b + Math.imul(de, dt)) | 0),
                (T = (T + Math.imul(de, Bt)) | 0),
                (S = (S + Math.imul(ee, Gt)) | 0),
                (b = (b + Math.imul(ee, Vt)) | 0),
                (b = (b + Math.imul(ne, Gt)) | 0),
                (T = (T + Math.imul(ne, Vt)) | 0),
                (S = (S + Math.imul(k, Er)) | 0),
                (b = (b + Math.imul(k, Pr)) | 0),
                (b = (b + Math.imul(W, Er)) | 0),
                (T = (T + Math.imul(W, Pr)) | 0)
            var tl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (tl >>> 26)) | 0),
                (tl &= 67108863),
                (S = Math.imul(te, kt)),
                (b = Math.imul(te, Ze)),
                (b = (b + Math.imul(fe, kt)) | 0),
                (T = Math.imul(fe, Ze)),
                (S = (S + Math.imul(j, dt)) | 0),
                (b = (b + Math.imul(j, Bt)) | 0),
                (b = (b + Math.imul(q, dt)) | 0),
                (T = (T + Math.imul(q, Bt)) | 0),
                (S = (S + Math.imul(ce, Gt)) | 0),
                (b = (b + Math.imul(ce, Vt)) | 0),
                (b = (b + Math.imul(de, Gt)) | 0),
                (T = (T + Math.imul(de, Vt)) | 0),
                (S = (S + Math.imul(ee, Er)) | 0),
                (b = (b + Math.imul(ee, Pr)) | 0),
                (b = (b + Math.imul(ne, Er)) | 0),
                (T = (T + Math.imul(ne, Pr)) | 0),
                (S = (S + Math.imul(k, Mr)) | 0),
                (b = (b + Math.imul(k, Dr)) | 0),
                (b = (b + Math.imul(W, Mr)) | 0),
                (T = (T + Math.imul(W, Dr)) | 0)
            var rl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (rl >>> 26)) | 0),
                (rl &= 67108863),
                (S = Math.imul(ue, kt)),
                (b = Math.imul(ue, Ze)),
                (b = (b + Math.imul(me, kt)) | 0),
                (T = Math.imul(me, Ze)),
                (S = (S + Math.imul(te, dt)) | 0),
                (b = (b + Math.imul(te, Bt)) | 0),
                (b = (b + Math.imul(fe, dt)) | 0),
                (T = (T + Math.imul(fe, Bt)) | 0),
                (S = (S + Math.imul(j, Gt)) | 0),
                (b = (b + Math.imul(j, Vt)) | 0),
                (b = (b + Math.imul(q, Gt)) | 0),
                (T = (T + Math.imul(q, Vt)) | 0),
                (S = (S + Math.imul(ce, Er)) | 0),
                (b = (b + Math.imul(ce, Pr)) | 0),
                (b = (b + Math.imul(de, Er)) | 0),
                (T = (T + Math.imul(de, Pr)) | 0),
                (S = (S + Math.imul(ee, Mr)) | 0),
                (b = (b + Math.imul(ee, Dr)) | 0),
                (b = (b + Math.imul(ne, Mr)) | 0),
                (T = (T + Math.imul(ne, Dr)) | 0),
                (S = (S + Math.imul(k, Ur)) | 0),
                (b = (b + Math.imul(k, Hr)) | 0),
                (b = (b + Math.imul(W, Ur)) | 0),
                (T = (T + Math.imul(W, Hr)) | 0)
            var dl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (dl >>> 26)) | 0),
                (dl &= 67108863),
                (S = Math.imul(Ce, kt)),
                (b = Math.imul(Ce, Ze)),
                (b = (b + Math.imul(ke, kt)) | 0),
                (T = Math.imul(ke, Ze)),
                (S = (S + Math.imul(ue, dt)) | 0),
                (b = (b + Math.imul(ue, Bt)) | 0),
                (b = (b + Math.imul(me, dt)) | 0),
                (T = (T + Math.imul(me, Bt)) | 0),
                (S = (S + Math.imul(te, Gt)) | 0),
                (b = (b + Math.imul(te, Vt)) | 0),
                (b = (b + Math.imul(fe, Gt)) | 0),
                (T = (T + Math.imul(fe, Vt)) | 0),
                (S = (S + Math.imul(j, Er)) | 0),
                (b = (b + Math.imul(j, Pr)) | 0),
                (b = (b + Math.imul(q, Er)) | 0),
                (T = (T + Math.imul(q, Pr)) | 0),
                (S = (S + Math.imul(ce, Mr)) | 0),
                (b = (b + Math.imul(ce, Dr)) | 0),
                (b = (b + Math.imul(de, Mr)) | 0),
                (T = (T + Math.imul(de, Dr)) | 0),
                (S = (S + Math.imul(ee, Ur)) | 0),
                (b = (b + Math.imul(ee, Hr)) | 0),
                (b = (b + Math.imul(ne, Ur)) | 0),
                (T = (T + Math.imul(ne, Hr)) | 0),
                (S = (S + Math.imul(k, jr)) | 0),
                (b = (b + Math.imul(k, qr)) | 0),
                (b = (b + Math.imul(W, jr)) | 0),
                (T = (T + Math.imul(W, qr)) | 0)
            var hl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (hl >>> 26)) | 0),
                (hl &= 67108863),
                (S = Math.imul(Ne, kt)),
                (b = Math.imul(Ne, Ze)),
                (b = (b + Math.imul(Me, kt)) | 0),
                (T = Math.imul(Me, Ze)),
                (S = (S + Math.imul(Ce, dt)) | 0),
                (b = (b + Math.imul(Ce, Bt)) | 0),
                (b = (b + Math.imul(ke, dt)) | 0),
                (T = (T + Math.imul(ke, Bt)) | 0),
                (S = (S + Math.imul(ue, Gt)) | 0),
                (b = (b + Math.imul(ue, Vt)) | 0),
                (b = (b + Math.imul(me, Gt)) | 0),
                (T = (T + Math.imul(me, Vt)) | 0),
                (S = (S + Math.imul(te, Er)) | 0),
                (b = (b + Math.imul(te, Pr)) | 0),
                (b = (b + Math.imul(fe, Er)) | 0),
                (T = (T + Math.imul(fe, Pr)) | 0),
                (S = (S + Math.imul(j, Mr)) | 0),
                (b = (b + Math.imul(j, Dr)) | 0),
                (b = (b + Math.imul(q, Mr)) | 0),
                (T = (T + Math.imul(q, Dr)) | 0),
                (S = (S + Math.imul(ce, Ur)) | 0),
                (b = (b + Math.imul(ce, Hr)) | 0),
                (b = (b + Math.imul(de, Ur)) | 0),
                (T = (T + Math.imul(de, Hr)) | 0),
                (S = (S + Math.imul(ee, jr)) | 0),
                (b = (b + Math.imul(ee, qr)) | 0),
                (b = (b + Math.imul(ne, jr)) | 0),
                (T = (T + Math.imul(ne, qr)) | 0),
                (S = (S + Math.imul(k, Kr)) | 0),
                (b = (b + Math.imul(k, Gr)) | 0),
                (b = (b + Math.imul(W, Kr)) | 0),
                (T = (T + Math.imul(W, Gr)) | 0)
            var pl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (pl >>> 26)) | 0),
                (pl &= 67108863),
                (S = Math.imul(Fe, kt)),
                (b = Math.imul(Fe, Ze)),
                (b = (b + Math.imul(Le, kt)) | 0),
                (T = Math.imul(Le, Ze)),
                (S = (S + Math.imul(Ne, dt)) | 0),
                (b = (b + Math.imul(Ne, Bt)) | 0),
                (b = (b + Math.imul(Me, dt)) | 0),
                (T = (T + Math.imul(Me, Bt)) | 0),
                (S = (S + Math.imul(Ce, Gt)) | 0),
                (b = (b + Math.imul(Ce, Vt)) | 0),
                (b = (b + Math.imul(ke, Gt)) | 0),
                (T = (T + Math.imul(ke, Vt)) | 0),
                (S = (S + Math.imul(ue, Er)) | 0),
                (b = (b + Math.imul(ue, Pr)) | 0),
                (b = (b + Math.imul(me, Er)) | 0),
                (T = (T + Math.imul(me, Pr)) | 0),
                (S = (S + Math.imul(te, Mr)) | 0),
                (b = (b + Math.imul(te, Dr)) | 0),
                (b = (b + Math.imul(fe, Mr)) | 0),
                (T = (T + Math.imul(fe, Dr)) | 0),
                (S = (S + Math.imul(j, Ur)) | 0),
                (b = (b + Math.imul(j, Hr)) | 0),
                (b = (b + Math.imul(q, Ur)) | 0),
                (T = (T + Math.imul(q, Hr)) | 0),
                (S = (S + Math.imul(ce, jr)) | 0),
                (b = (b + Math.imul(ce, qr)) | 0),
                (b = (b + Math.imul(de, jr)) | 0),
                (T = (T + Math.imul(de, qr)) | 0),
                (S = (S + Math.imul(ee, Kr)) | 0),
                (b = (b + Math.imul(ee, Gr)) | 0),
                (b = (b + Math.imul(ne, Kr)) | 0),
                (T = (T + Math.imul(ne, Gr)) | 0),
                (S = (S + Math.imul(k, Wr)) | 0),
                (b = (b + Math.imul(k, Yr)) | 0),
                (b = (b + Math.imul(W, Wr)) | 0),
                (T = (T + Math.imul(W, Yr)) | 0)
            var gl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (gl >>> 26)) | 0),
                (gl &= 67108863),
                (S = Math.imul(nt, kt)),
                (b = Math.imul(nt, Ze)),
                (b = (b + Math.imul(lt, kt)) | 0),
                (T = Math.imul(lt, Ze)),
                (S = (S + Math.imul(Fe, dt)) | 0),
                (b = (b + Math.imul(Fe, Bt)) | 0),
                (b = (b + Math.imul(Le, dt)) | 0),
                (T = (T + Math.imul(Le, Bt)) | 0),
                (S = (S + Math.imul(Ne, Gt)) | 0),
                (b = (b + Math.imul(Ne, Vt)) | 0),
                (b = (b + Math.imul(Me, Gt)) | 0),
                (T = (T + Math.imul(Me, Vt)) | 0),
                (S = (S + Math.imul(Ce, Er)) | 0),
                (b = (b + Math.imul(Ce, Pr)) | 0),
                (b = (b + Math.imul(ke, Er)) | 0),
                (T = (T + Math.imul(ke, Pr)) | 0),
                (S = (S + Math.imul(ue, Mr)) | 0),
                (b = (b + Math.imul(ue, Dr)) | 0),
                (b = (b + Math.imul(me, Mr)) | 0),
                (T = (T + Math.imul(me, Dr)) | 0),
                (S = (S + Math.imul(te, Ur)) | 0),
                (b = (b + Math.imul(te, Hr)) | 0),
                (b = (b + Math.imul(fe, Ur)) | 0),
                (T = (T + Math.imul(fe, Hr)) | 0),
                (S = (S + Math.imul(j, jr)) | 0),
                (b = (b + Math.imul(j, qr)) | 0),
                (b = (b + Math.imul(q, jr)) | 0),
                (T = (T + Math.imul(q, qr)) | 0),
                (S = (S + Math.imul(ce, Kr)) | 0),
                (b = (b + Math.imul(ce, Gr)) | 0),
                (b = (b + Math.imul(de, Kr)) | 0),
                (T = (T + Math.imul(de, Gr)) | 0),
                (S = (S + Math.imul(ee, Wr)) | 0),
                (b = (b + Math.imul(ee, Yr)) | 0),
                (b = (b + Math.imul(ne, Wr)) | 0),
                (T = (T + Math.imul(ne, Yr)) | 0),
                (S = (S + Math.imul(k, Jr)) | 0),
                (b = (b + Math.imul(k, Qr)) | 0),
                (b = (b + Math.imul(W, Jr)) | 0),
                (T = (T + Math.imul(W, Qr)) | 0)
            var ml = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (ml >>> 26)) | 0),
                (ml &= 67108863),
                (S = Math.imul(nt, dt)),
                (b = Math.imul(nt, Bt)),
                (b = (b + Math.imul(lt, dt)) | 0),
                (T = Math.imul(lt, Bt)),
                (S = (S + Math.imul(Fe, Gt)) | 0),
                (b = (b + Math.imul(Fe, Vt)) | 0),
                (b = (b + Math.imul(Le, Gt)) | 0),
                (T = (T + Math.imul(Le, Vt)) | 0),
                (S = (S + Math.imul(Ne, Er)) | 0),
                (b = (b + Math.imul(Ne, Pr)) | 0),
                (b = (b + Math.imul(Me, Er)) | 0),
                (T = (T + Math.imul(Me, Pr)) | 0),
                (S = (S + Math.imul(Ce, Mr)) | 0),
                (b = (b + Math.imul(Ce, Dr)) | 0),
                (b = (b + Math.imul(ke, Mr)) | 0),
                (T = (T + Math.imul(ke, Dr)) | 0),
                (S = (S + Math.imul(ue, Ur)) | 0),
                (b = (b + Math.imul(ue, Hr)) | 0),
                (b = (b + Math.imul(me, Ur)) | 0),
                (T = (T + Math.imul(me, Hr)) | 0),
                (S = (S + Math.imul(te, jr)) | 0),
                (b = (b + Math.imul(te, qr)) | 0),
                (b = (b + Math.imul(fe, jr)) | 0),
                (T = (T + Math.imul(fe, qr)) | 0),
                (S = (S + Math.imul(j, Kr)) | 0),
                (b = (b + Math.imul(j, Gr)) | 0),
                (b = (b + Math.imul(q, Kr)) | 0),
                (T = (T + Math.imul(q, Gr)) | 0),
                (S = (S + Math.imul(ce, Wr)) | 0),
                (b = (b + Math.imul(ce, Yr)) | 0),
                (b = (b + Math.imul(de, Wr)) | 0),
                (T = (T + Math.imul(de, Yr)) | 0),
                (S = (S + Math.imul(ee, Jr)) | 0),
                (b = (b + Math.imul(ee, Qr)) | 0),
                (b = (b + Math.imul(ne, Jr)) | 0),
                (T = (T + Math.imul(ne, Qr)) | 0)
            var yl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (yl >>> 26)) | 0),
                (yl &= 67108863),
                (S = Math.imul(nt, Gt)),
                (b = Math.imul(nt, Vt)),
                (b = (b + Math.imul(lt, Gt)) | 0),
                (T = Math.imul(lt, Vt)),
                (S = (S + Math.imul(Fe, Er)) | 0),
                (b = (b + Math.imul(Fe, Pr)) | 0),
                (b = (b + Math.imul(Le, Er)) | 0),
                (T = (T + Math.imul(Le, Pr)) | 0),
                (S = (S + Math.imul(Ne, Mr)) | 0),
                (b = (b + Math.imul(Ne, Dr)) | 0),
                (b = (b + Math.imul(Me, Mr)) | 0),
                (T = (T + Math.imul(Me, Dr)) | 0),
                (S = (S + Math.imul(Ce, Ur)) | 0),
                (b = (b + Math.imul(Ce, Hr)) | 0),
                (b = (b + Math.imul(ke, Ur)) | 0),
                (T = (T + Math.imul(ke, Hr)) | 0),
                (S = (S + Math.imul(ue, jr)) | 0),
                (b = (b + Math.imul(ue, qr)) | 0),
                (b = (b + Math.imul(me, jr)) | 0),
                (T = (T + Math.imul(me, qr)) | 0),
                (S = (S + Math.imul(te, Kr)) | 0),
                (b = (b + Math.imul(te, Gr)) | 0),
                (b = (b + Math.imul(fe, Kr)) | 0),
                (T = (T + Math.imul(fe, Gr)) | 0),
                (S = (S + Math.imul(j, Wr)) | 0),
                (b = (b + Math.imul(j, Yr)) | 0),
                (b = (b + Math.imul(q, Wr)) | 0),
                (T = (T + Math.imul(q, Yr)) | 0),
                (S = (S + Math.imul(ce, Jr)) | 0),
                (b = (b + Math.imul(ce, Qr)) | 0),
                (b = (b + Math.imul(de, Jr)) | 0),
                (T = (T + Math.imul(de, Qr)) | 0)
            var bl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (bl >>> 26)) | 0),
                (bl &= 67108863),
                (S = Math.imul(nt, Er)),
                (b = Math.imul(nt, Pr)),
                (b = (b + Math.imul(lt, Er)) | 0),
                (T = Math.imul(lt, Pr)),
                (S = (S + Math.imul(Fe, Mr)) | 0),
                (b = (b + Math.imul(Fe, Dr)) | 0),
                (b = (b + Math.imul(Le, Mr)) | 0),
                (T = (T + Math.imul(Le, Dr)) | 0),
                (S = (S + Math.imul(Ne, Ur)) | 0),
                (b = (b + Math.imul(Ne, Hr)) | 0),
                (b = (b + Math.imul(Me, Ur)) | 0),
                (T = (T + Math.imul(Me, Hr)) | 0),
                (S = (S + Math.imul(Ce, jr)) | 0),
                (b = (b + Math.imul(Ce, qr)) | 0),
                (b = (b + Math.imul(ke, jr)) | 0),
                (T = (T + Math.imul(ke, qr)) | 0),
                (S = (S + Math.imul(ue, Kr)) | 0),
                (b = (b + Math.imul(ue, Gr)) | 0),
                (b = (b + Math.imul(me, Kr)) | 0),
                (T = (T + Math.imul(me, Gr)) | 0),
                (S = (S + Math.imul(te, Wr)) | 0),
                (b = (b + Math.imul(te, Yr)) | 0),
                (b = (b + Math.imul(fe, Wr)) | 0),
                (T = (T + Math.imul(fe, Yr)) | 0),
                (S = (S + Math.imul(j, Jr)) | 0),
                (b = (b + Math.imul(j, Qr)) | 0),
                (b = (b + Math.imul(q, Jr)) | 0),
                (T = (T + Math.imul(q, Qr)) | 0)
            var vl = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (vl >>> 26)) | 0),
                (vl &= 67108863),
                (S = Math.imul(nt, Mr)),
                (b = Math.imul(nt, Dr)),
                (b = (b + Math.imul(lt, Mr)) | 0),
                (T = Math.imul(lt, Dr)),
                (S = (S + Math.imul(Fe, Ur)) | 0),
                (b = (b + Math.imul(Fe, Hr)) | 0),
                (b = (b + Math.imul(Le, Ur)) | 0),
                (T = (T + Math.imul(Le, Hr)) | 0),
                (S = (S + Math.imul(Ne, jr)) | 0),
                (b = (b + Math.imul(Ne, qr)) | 0),
                (b = (b + Math.imul(Me, jr)) | 0),
                (T = (T + Math.imul(Me, qr)) | 0),
                (S = (S + Math.imul(Ce, Kr)) | 0),
                (b = (b + Math.imul(Ce, Gr)) | 0),
                (b = (b + Math.imul(ke, Kr)) | 0),
                (T = (T + Math.imul(ke, Gr)) | 0),
                (S = (S + Math.imul(ue, Wr)) | 0),
                (b = (b + Math.imul(ue, Yr)) | 0),
                (b = (b + Math.imul(me, Wr)) | 0),
                (T = (T + Math.imul(me, Yr)) | 0),
                (S = (S + Math.imul(te, Jr)) | 0),
                (b = (b + Math.imul(te, Qr)) | 0),
                (b = (b + Math.imul(fe, Jr)) | 0),
                (T = (T + Math.imul(fe, Qr)) | 0)
            var ef = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (ef >>> 26)) | 0),
                (ef &= 67108863),
                (S = Math.imul(nt, Ur)),
                (b = Math.imul(nt, Hr)),
                (b = (b + Math.imul(lt, Ur)) | 0),
                (T = Math.imul(lt, Hr)),
                (S = (S + Math.imul(Fe, jr)) | 0),
                (b = (b + Math.imul(Fe, qr)) | 0),
                (b = (b + Math.imul(Le, jr)) | 0),
                (T = (T + Math.imul(Le, qr)) | 0),
                (S = (S + Math.imul(Ne, Kr)) | 0),
                (b = (b + Math.imul(Ne, Gr)) | 0),
                (b = (b + Math.imul(Me, Kr)) | 0),
                (T = (T + Math.imul(Me, Gr)) | 0),
                (S = (S + Math.imul(Ce, Wr)) | 0),
                (b = (b + Math.imul(Ce, Yr)) | 0),
                (b = (b + Math.imul(ke, Wr)) | 0),
                (T = (T + Math.imul(ke, Yr)) | 0),
                (S = (S + Math.imul(ue, Jr)) | 0),
                (b = (b + Math.imul(ue, Qr)) | 0),
                (b = (b + Math.imul(me, Jr)) | 0),
                (T = (T + Math.imul(me, Qr)) | 0)
            var tf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (tf >>> 26)) | 0),
                (tf &= 67108863),
                (S = Math.imul(nt, jr)),
                (b = Math.imul(nt, qr)),
                (b = (b + Math.imul(lt, jr)) | 0),
                (T = Math.imul(lt, qr)),
                (S = (S + Math.imul(Fe, Kr)) | 0),
                (b = (b + Math.imul(Fe, Gr)) | 0),
                (b = (b + Math.imul(Le, Kr)) | 0),
                (T = (T + Math.imul(Le, Gr)) | 0),
                (S = (S + Math.imul(Ne, Wr)) | 0),
                (b = (b + Math.imul(Ne, Yr)) | 0),
                (b = (b + Math.imul(Me, Wr)) | 0),
                (T = (T + Math.imul(Me, Yr)) | 0),
                (S = (S + Math.imul(Ce, Jr)) | 0),
                (b = (b + Math.imul(Ce, Qr)) | 0),
                (b = (b + Math.imul(ke, Jr)) | 0),
                (T = (T + Math.imul(ke, Qr)) | 0)
            var rf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (rf >>> 26)) | 0),
                (rf &= 67108863),
                (S = Math.imul(nt, Kr)),
                (b = Math.imul(nt, Gr)),
                (b = (b + Math.imul(lt, Kr)) | 0),
                (T = Math.imul(lt, Gr)),
                (S = (S + Math.imul(Fe, Wr)) | 0),
                (b = (b + Math.imul(Fe, Yr)) | 0),
                (b = (b + Math.imul(Le, Wr)) | 0),
                (T = (T + Math.imul(Le, Yr)) | 0),
                (S = (S + Math.imul(Ne, Jr)) | 0),
                (b = (b + Math.imul(Ne, Qr)) | 0),
                (b = (b + Math.imul(Me, Jr)) | 0),
                (T = (T + Math.imul(Me, Qr)) | 0)
            var nf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (nf >>> 26)) | 0),
                (nf &= 67108863),
                (S = Math.imul(nt, Wr)),
                (b = Math.imul(nt, Yr)),
                (b = (b + Math.imul(lt, Wr)) | 0),
                (T = Math.imul(lt, Yr)),
                (S = (S + Math.imul(Fe, Jr)) | 0),
                (b = (b + Math.imul(Fe, Qr)) | 0),
                (b = (b + Math.imul(Le, Jr)) | 0),
                (T = (T + Math.imul(Le, Qr)) | 0)
            var of = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            ;(C = (((T + (b >>> 13)) | 0) + (of >>> 26)) | 0),
                (of &= 67108863),
                (S = Math.imul(nt, Jr)),
                (b = Math.imul(nt, Qr)),
                (b = (b + Math.imul(lt, Jr)) | 0),
                (T = Math.imul(lt, Qr))
            var sf = (((C + S) | 0) + ((b & 8191) << 13)) | 0
            return (
                (C = (((T + (b >>> 13)) | 0) + (sf >>> 26)) | 0),
                (sf &= 67108863),
                (R[0] = Qa),
                (R[1] = Za),
                (R[2] = el),
                (R[3] = tl),
                (R[4] = rl),
                (R[5] = dl),
                (R[6] = hl),
                (R[7] = pl),
                (R[8] = gl),
                (R[9] = ml),
                (R[10] = yl),
                (R[11] = bl),
                (R[12] = vl),
                (R[13] = ef),
                (R[14] = tf),
                (R[15] = rf),
                (R[16] = nf),
                (R[17] = of),
                (R[18] = sf),
                C !== 0 && ((R[19] = C), $.length++),
                $
            )
        }
        Math.imul || (F = U)
        function Z(O, u, E) {
            ;(E.negative = u.negative ^ O.negative), (E.length = O.length + u.length)
            for (var $ = 0, N = 0, M = 0; M < E.length - 1; M++) {
                var R = N
                N = 0
                for (var C = $ & 67108863, S = Math.min(M, u.length - 1), b = Math.max(0, M - O.length + 1); b <= S; b++) {
                    var T = M - b,
                        Q = O.words[T] | 0,
                        k = u.words[b] | 0,
                        W = Q * k,
                        J = W & 67108863
                    ;(R = (R + ((W / 67108864) | 0)) | 0),
                        (J = (J + C) | 0),
                        (C = J & 67108863),
                        (R = (R + (J >>> 26)) | 0),
                        (N += R >>> 26),
                        (R &= 67108863)
                }
                ;(E.words[M] = C), ($ = R), (R = N)
            }
            return $ !== 0 ? (E.words[M] = $) : E.length--, E._strip()
        }
        function Y(O, u, E) {
            return Z(O, u, E)
        }
        ;(a.prototype.mulTo = function (u, E) {
            var $,
                N = this.length + u.length
            return (
                this.length === 10 && u.length === 10
                    ? ($ = F(this, u, E))
                    : N < 63
                    ? ($ = U(this, u, E))
                    : N < 1024
                    ? ($ = Z(this, u, E))
                    : ($ = Y(this, u, E)),
                $
            )
        }),
            (a.prototype.mul = function (u) {
                var E = new a(null)
                return (E.words = new Array(this.length + u.length)), this.mulTo(u, E)
            }),
            (a.prototype.mulf = function (u) {
                var E = new a(null)
                return (E.words = new Array(this.length + u.length)), Y(this, u, E)
            }),
            (a.prototype.imul = function (u) {
                return this.clone().mulTo(u, this)
            }),
            (a.prototype.imuln = function (u) {
                var E = u < 0
                E && (u = -u), i(typeof u == "number"), i(u < 67108864)
                for (var $ = 0, N = 0; N < this.length; N++) {
                    var M = (this.words[N] | 0) * u,
                        R = (M & 67108863) + ($ & 67108863)
                    ;($ >>= 26), ($ += (M / 67108864) | 0), ($ += R >>> 26), (this.words[N] = R & 67108863)
                }
                return $ !== 0 && ((this.words[N] = $), this.length++), E ? this.ineg() : this
            }),
            (a.prototype.muln = function (u) {
                return this.clone().imuln(u)
            }),
            (a.prototype.sqr = function () {
                return this.mul(this)
            }),
            (a.prototype.isqr = function () {
                return this.imul(this.clone())
            }),
            (a.prototype.pow = function (u) {
                var E = G(u)
                if (E.length === 0) return new a(1)
                for (var $ = this, N = 0; N < E.length && E[N] === 0; N++, $ = $.sqr());
                if (++N < E.length) for (var M = $.sqr(); N < E.length; N++, M = M.sqr()) E[N] !== 0 && ($ = $.mul(M))
                return $
            }),
            (a.prototype.iushln = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = (67108863 >>> (26 - E)) << (26 - E),
                    M
                if (E !== 0) {
                    var R = 0
                    for (M = 0; M < this.length; M++) {
                        var C = this.words[M] & N,
                            S = ((this.words[M] | 0) - C) << E
                        ;(this.words[M] = S | R), (R = C >>> (26 - E))
                    }
                    R && ((this.words[M] = R), this.length++)
                }
                if ($ !== 0) {
                    for (M = this.length - 1; M >= 0; M--) this.words[M + $] = this.words[M]
                    for (M = 0; M < $; M++) this.words[M] = 0
                    this.length += $
                }
                return this._strip()
            }),
            (a.prototype.ishln = function (u) {
                return i(this.negative === 0), this.iushln(u)
            }),
            (a.prototype.iushrn = function (u, E, $) {
                i(typeof u == "number" && u >= 0)
                var N
                E ? (N = (E - (E % 26)) / 26) : (N = 0)
                var M = u % 26,
                    R = Math.min((u - M) / 26, this.length),
                    C = 67108863 ^ ((67108863 >>> M) << M),
                    S = $
                if (((N -= R), (N = Math.max(0, N)), S)) {
                    for (var b = 0; b < R; b++) S.words[b] = this.words[b]
                    S.length = R
                }
                if (R !== 0)
                    if (this.length > R) for (this.length -= R, b = 0; b < this.length; b++) this.words[b] = this.words[b + R]
                    else (this.words[0] = 0), (this.length = 1)
                var T = 0
                for (b = this.length - 1; b >= 0 && (T !== 0 || b >= N); b--) {
                    var Q = this.words[b] | 0
                    ;(this.words[b] = (T << (26 - M)) | (Q >>> M)), (T = Q & C)
                }
                return S && T !== 0 && (S.words[S.length++] = T), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip()
            }),
            (a.prototype.ishrn = function (u, E, $) {
                return i(this.negative === 0), this.iushrn(u, E, $)
            }),
            (a.prototype.shln = function (u) {
                return this.clone().ishln(u)
            }),
            (a.prototype.ushln = function (u) {
                return this.clone().iushln(u)
            }),
            (a.prototype.shrn = function (u) {
                return this.clone().ishrn(u)
            }),
            (a.prototype.ushrn = function (u) {
                return this.clone().iushrn(u)
            }),
            (a.prototype.testn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = 1 << E
                if (this.length <= $) return !1
                var M = this.words[$]
                return !!(M & N)
            }),
            (a.prototype.imaskn = function (u) {
                i(typeof u == "number" && u >= 0)
                var E = u % 26,
                    $ = (u - E) / 26
                if ((i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)) return this
                if ((E !== 0 && $++, (this.length = Math.min($, this.length)), E !== 0)) {
                    var N = 67108863 ^ ((67108863 >>> E) << E)
                    this.words[this.length - 1] &= N
                }
                return this._strip()
            }),
            (a.prototype.maskn = function (u) {
                return this.clone().imaskn(u)
            }),
            (a.prototype.iaddn = function (u) {
                return (
                    i(typeof u == "number"),
                    i(u < 67108864),
                    u < 0
                        ? this.isubn(-u)
                        : this.negative !== 0
                        ? this.length === 1 && (this.words[0] | 0) <= u
                            ? ((this.words[0] = u - (this.words[0] | 0)), (this.negative = 0), this)
                            : ((this.negative = 0), this.isubn(u), (this.negative = 1), this)
                        : this._iaddn(u)
                )
            }),
            (a.prototype._iaddn = function (u) {
                this.words[0] += u
                for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
                    (this.words[E] -= 67108864), E === this.length - 1 ? (this.words[E + 1] = 1) : this.words[E + 1]++
                return (this.length = Math.max(this.length, E + 1)), this
            }),
            (a.prototype.isubn = function (u) {
                if ((i(typeof u == "number"), i(u < 67108864), u < 0)) return this.iaddn(-u)
                if (this.negative !== 0) return (this.negative = 0), this.iaddn(u), (this.negative = 1), this
                if (((this.words[0] -= u), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1)
                else for (var E = 0; E < this.length && this.words[E] < 0; E++) (this.words[E] += 67108864), (this.words[E + 1] -= 1)
                return this._strip()
            }),
            (a.prototype.addn = function (u) {
                return this.clone().iaddn(u)
            }),
            (a.prototype.subn = function (u) {
                return this.clone().isubn(u)
            }),
            (a.prototype.iabs = function () {
                return (this.negative = 0), this
            }),
            (a.prototype.abs = function () {
                return this.clone().iabs()
            }),
            (a.prototype._ishlnsubmul = function (u, E, $) {
                var N = u.length + $,
                    M
                this._expand(N)
                var R,
                    C = 0
                for (M = 0; M < u.length; M++) {
                    R = (this.words[M + $] | 0) + C
                    var S = (u.words[M] | 0) * E
                    ;(R -= S & 67108863), (C = (R >> 26) - ((S / 67108864) | 0)), (this.words[M + $] = R & 67108863)
                }
                for (; M < this.length - $; M++) (R = (this.words[M + $] | 0) + C), (C = R >> 26), (this.words[M + $] = R & 67108863)
                if (C === 0) return this._strip()
                for (i(C === -1), C = 0, M = 0; M < this.length; M++)
                    (R = -(this.words[M] | 0) + C), (C = R >> 26), (this.words[M] = R & 67108863)
                return (this.negative = 1), this._strip()
            }),
            (a.prototype._wordDiv = function (u, E) {
                var $ = this.length - u.length,
                    N = this.clone(),
                    M = u,
                    R = M.words[M.length - 1] | 0,
                    C = this._countBits(R)
                ;($ = 26 - C), $ !== 0 && ((M = M.ushln($)), N.iushln($), (R = M.words[M.length - 1] | 0))
                var S = N.length - M.length,
                    b
                if (E !== "mod") {
                    ;(b = new a(null)), (b.length = S + 1), (b.words = new Array(b.length))
                    for (var T = 0; T < b.length; T++) b.words[T] = 0
                }
                var Q = N.clone()._ishlnsubmul(M, 1, S)
                Q.negative === 0 && ((N = Q), b && (b.words[S] = 1))
                for (var k = S - 1; k >= 0; k--) {
                    var W = (N.words[M.length + k] | 0) * 67108864 + (N.words[M.length + k - 1] | 0)
                    for (W = Math.min((W / R) | 0, 67108863), N._ishlnsubmul(M, W, k); N.negative !== 0; )
                        W--, (N.negative = 0), N._ishlnsubmul(M, 1, k), N.isZero() || (N.negative ^= 1)
                    b && (b.words[k] = W)
                }
                return b && b._strip(), N._strip(), E !== "div" && $ !== 0 && N.iushrn($), { div: b || null, mod: N }
            }),
            (a.prototype.divmod = function (u, E, $) {
                if ((i(!u.isZero()), this.isZero())) return { div: new a(0), mod: new a(0) }
                var N, M, R
                return this.negative !== 0 && u.negative === 0
                    ? ((R = this.neg().divmod(u, E)),
                      E !== "mod" && (N = R.div.neg()),
                      E !== "div" && ((M = R.mod.neg()), $ && M.negative !== 0 && M.iadd(u)),
                      { div: N, mod: M })
                    : this.negative === 0 && u.negative !== 0
                    ? ((R = this.divmod(u.neg(), E)), E !== "mod" && (N = R.div.neg()), { div: N, mod: R.mod })
                    : (this.negative & u.negative) !== 0
                    ? ((R = this.neg().divmod(u.neg(), E)),
                      E !== "div" && ((M = R.mod.neg()), $ && M.negative !== 0 && M.isub(u)),
                      { div: R.div, mod: M })
                    : u.length > this.length || this.cmp(u) < 0
                    ? { div: new a(0), mod: this }
                    : u.length === 1
                    ? E === "div"
                        ? { div: this.divn(u.words[0]), mod: null }
                        : E === "mod"
                        ? { div: null, mod: new a(this.modrn(u.words[0])) }
                        : { div: this.divn(u.words[0]), mod: new a(this.modrn(u.words[0])) }
                    : this._wordDiv(u, E)
            }),
            (a.prototype.div = function (u) {
                return this.divmod(u, "div", !1).div
            }),
            (a.prototype.mod = function (u) {
                return this.divmod(u, "mod", !1).mod
            }),
            (a.prototype.umod = function (u) {
                return this.divmod(u, "mod", !0).mod
            }),
            (a.prototype.divRound = function (u) {
                var E = this.divmod(u)
                if (E.mod.isZero()) return E.div
                var $ = E.div.negative !== 0 ? E.mod.isub(u) : E.mod,
                    N = u.ushrn(1),
                    M = u.andln(1),
                    R = $.cmp(N)
                return R < 0 || (M === 1 && R === 0) ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1)
            }),
            (a.prototype.modrn = function (u) {
                var E = u < 0
                E && (u = -u), i(u <= 67108863)
                for (var $ = (1 << 26) % u, N = 0, M = this.length - 1; M >= 0; M--) N = ($ * N + (this.words[M] | 0)) % u
                return E ? -N : N
            }),
            (a.prototype.modn = function (u) {
                return this.modrn(u)
            }),
            (a.prototype.idivn = function (u) {
                var E = u < 0
                E && (u = -u), i(u <= 67108863)
                for (var $ = 0, N = this.length - 1; N >= 0; N--) {
                    var M = (this.words[N] | 0) + $ * 67108864
                    ;(this.words[N] = (M / u) | 0), ($ = M % u)
                }
                return this._strip(), E ? this.ineg() : this
            }),
            (a.prototype.divn = function (u) {
                return this.clone().idivn(u)
            }),
            (a.prototype.egcd = function (u) {
                i(u.negative === 0), i(!u.isZero())
                var E = this,
                    $ = u.clone()
                E.negative !== 0 ? (E = E.umod(u)) : (E = E.clone())
                for (var N = new a(1), M = new a(0), R = new a(0), C = new a(1), S = 0; E.isEven() && $.isEven(); ) E.iushrn(1), $.iushrn(1), ++S
                for (var b = $.clone(), T = E.clone(); !E.isZero(); ) {
                    for (var Q = 0, k = 1; (E.words[0] & k) === 0 && Q < 26; ++Q, k <<= 1);
                    if (Q > 0) for (E.iushrn(Q); Q-- > 0; ) (N.isOdd() || M.isOdd()) && (N.iadd(b), M.isub(T)), N.iushrn(1), M.iushrn(1)
                    for (var W = 0, J = 1; ($.words[0] & J) === 0 && W < 26; ++W, J <<= 1);
                    if (W > 0) for ($.iushrn(W); W-- > 0; ) (R.isOdd() || C.isOdd()) && (R.iadd(b), C.isub(T)), R.iushrn(1), C.iushrn(1)
                    E.cmp($) >= 0 ? (E.isub($), N.isub(R), M.isub(C)) : ($.isub(E), R.isub(N), C.isub(M))
                }
                return { a: R, b: C, gcd: $.iushln(S) }
            }),
            (a.prototype._invmp = function (u) {
                i(u.negative === 0), i(!u.isZero())
                var E = this,
                    $ = u.clone()
                E.negative !== 0 ? (E = E.umod(u)) : (E = E.clone())
                for (var N = new a(1), M = new a(0), R = $.clone(); E.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
                    for (var C = 0, S = 1; (E.words[0] & S) === 0 && C < 26; ++C, S <<= 1);
                    if (C > 0) for (E.iushrn(C); C-- > 0; ) N.isOdd() && N.iadd(R), N.iushrn(1)
                    for (var b = 0, T = 1; ($.words[0] & T) === 0 && b < 26; ++b, T <<= 1);
                    if (b > 0) for ($.iushrn(b); b-- > 0; ) M.isOdd() && M.iadd(R), M.iushrn(1)
                    E.cmp($) >= 0 ? (E.isub($), N.isub(M)) : ($.isub(E), M.isub(N))
                }
                var Q
                return E.cmpn(1) === 0 ? (Q = N) : (Q = M), Q.cmpn(0) < 0 && Q.iadd(u), Q
            }),
            (a.prototype.gcd = function (u) {
                if (this.isZero()) return u.abs()
                if (u.isZero()) return this.abs()
                var E = this.clone(),
                    $ = u.clone()
                ;(E.negative = 0), ($.negative = 0)
                for (var N = 0; E.isEven() && $.isEven(); N++) E.iushrn(1), $.iushrn(1)
                do {
                    for (; E.isEven(); ) E.iushrn(1)
                    for (; $.isEven(); ) $.iushrn(1)
                    var M = E.cmp($)
                    if (M < 0) {
                        var R = E
                        ;(E = $), ($ = R)
                    } else if (M === 0 || $.cmpn(1) === 0) break
                    E.isub($)
                } while (!0)
                return $.iushln(N)
            }),
            (a.prototype.invm = function (u) {
                return this.egcd(u).a.umod(u)
            }),
            (a.prototype.isEven = function () {
                return (this.words[0] & 1) === 0
            }),
            (a.prototype.isOdd = function () {
                return (this.words[0] & 1) === 1
            }),
            (a.prototype.andln = function (u) {
                return this.words[0] & u
            }),
            (a.prototype.bincn = function (u) {
                i(typeof u == "number")
                var E = u % 26,
                    $ = (u - E) / 26,
                    N = 1 << E
                if (this.length <= $) return this._expand($ + 1), (this.words[$] |= N), this
                for (var M = N, R = $; M !== 0 && R < this.length; R++) {
                    var C = this.words[R] | 0
                    ;(C += M), (M = C >>> 26), (C &= 67108863), (this.words[R] = C)
                }
                return M !== 0 && ((this.words[R] = M), this.length++), this
            }),
            (a.prototype.isZero = function () {
                return this.length === 1 && this.words[0] === 0
            }),
            (a.prototype.cmpn = function (u) {
                var E = u < 0
                if (this.negative !== 0 && !E) return -1
                if (this.negative === 0 && E) return 1
                this._strip()
                var $
                if (this.length > 1) $ = 1
                else {
                    E && (u = -u), i(u <= 67108863, "Number is too big")
                    var N = this.words[0] | 0
                    $ = N === u ? 0 : N < u ? -1 : 1
                }
                return this.negative !== 0 ? -$ | 0 : $
            }),
            (a.prototype.cmp = function (u) {
                if (this.negative !== 0 && u.negative === 0) return -1
                if (this.negative === 0 && u.negative !== 0) return 1
                var E = this.ucmp(u)
                return this.negative !== 0 ? -E | 0 : E
            }),
            (a.prototype.ucmp = function (u) {
                if (this.length > u.length) return 1
                if (this.length < u.length) return -1
                for (var E = 0, $ = this.length - 1; $ >= 0; $--) {
                    var N = this.words[$] | 0,
                        M = u.words[$] | 0
                    if (N !== M) {
                        N < M ? (E = -1) : N > M && (E = 1)
                        break
                    }
                }
                return E
            }),
            (a.prototype.gtn = function (u) {
                return this.cmpn(u) === 1
            }),
            (a.prototype.gt = function (u) {
                return this.cmp(u) === 1
            }),
            (a.prototype.gten = function (u) {
                return this.cmpn(u) >= 0
            }),
            (a.prototype.gte = function (u) {
                return this.cmp(u) >= 0
            }),
            (a.prototype.ltn = function (u) {
                return this.cmpn(u) === -1
            }),
            (a.prototype.lt = function (u) {
                return this.cmp(u) === -1
            }),
            (a.prototype.lten = function (u) {
                return this.cmpn(u) <= 0
            }),
            (a.prototype.lte = function (u) {
                return this.cmp(u) <= 0
            }),
            (a.prototype.eqn = function (u) {
                return this.cmpn(u) === 0
            }),
            (a.prototype.eq = function (u) {
                return this.cmp(u) === 0
            }),
            (a.red = function (u) {
                return new ye(u)
            }),
            (a.prototype.toRed = function (u) {
                return (
                    i(!this.red, "Already a number in reduction context"),
                    i(this.negative === 0, "red works only with positives"),
                    u.convertTo(this)._forceRed(u)
                )
            }),
            (a.prototype.fromRed = function () {
                return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }),
            (a.prototype._forceRed = function (u) {
                return (this.red = u), this
            }),
            (a.prototype.forceRed = function (u) {
                return i(!this.red, "Already a number in reduction context"), this._forceRed(u)
            }),
            (a.prototype.redAdd = function (u) {
                return i(this.red, "redAdd works only with red numbers"), this.red.add(this, u)
            }),
            (a.prototype.redIAdd = function (u) {
                return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, u)
            }),
            (a.prototype.redSub = function (u) {
                return i(this.red, "redSub works only with red numbers"), this.red.sub(this, u)
            }),
            (a.prototype.redISub = function (u) {
                return i(this.red, "redISub works only with red numbers"), this.red.isub(this, u)
            }),
            (a.prototype.redShl = function (u) {
                return i(this.red, "redShl works only with red numbers"), this.red.shl(this, u)
            }),
            (a.prototype.redMul = function (u) {
                return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.mul(this, u)
            }),
            (a.prototype.redIMul = function (u) {
                return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, u), this.red.imul(this, u)
            }),
            (a.prototype.redSqr = function () {
                return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }),
            (a.prototype.redISqr = function () {
                return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }),
            (a.prototype.redSqrt = function () {
                return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }),
            (a.prototype.redInvm = function () {
                return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }),
            (a.prototype.redNeg = function () {
                return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }),
            (a.prototype.redPow = function (u) {
                return i(this.red && !u.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, u)
            })
        var X = { k256: null, p224: null, p192: null, p25519: null }
        function ie(O, u) {
            ;(this.name = O),
                (this.p = new a(u, 16)),
                (this.n = this.p.bitLength()),
                (this.k = new a(1).iushln(this.n).isub(this.p)),
                (this.tmp = this._tmp())
        }
        ;(ie.prototype._tmp = function () {
            var u = new a(null)
            return (u.words = new Array(Math.ceil(this.n / 13))), u
        }),
            (ie.prototype.ireduce = function (u) {
                var E = u,
                    $
                do this.split(E, this.tmp), (E = this.imulK(E)), (E = E.iadd(this.tmp)), ($ = E.bitLength())
                while ($ > this.n)
                var N = $ < this.n ? -1 : E.ucmp(this.p)
                return N === 0 ? ((E.words[0] = 0), (E.length = 1)) : N > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E
            }),
            (ie.prototype.split = function (u, E) {
                u.iushrn(this.n, 0, E)
            }),
            (ie.prototype.imulK = function (u) {
                return u.imul(this.k)
            })
        function he() {
            ie.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        o(he, ie),
            (he.prototype.split = function (u, E) {
                for (var $ = 4194303, N = Math.min(u.length, 9), M = 0; M < N; M++) E.words[M] = u.words[M]
                if (((E.length = N), u.length <= 9)) {
                    ;(u.words[0] = 0), (u.length = 1)
                    return
                }
                var R = u.words[9]
                for (E.words[E.length++] = R & $, M = 10; M < u.length; M++) {
                    var C = u.words[M] | 0
                    ;(u.words[M - 10] = ((C & $) << 4) | (R >>> 22)), (R = C)
                }
                ;(R >>>= 22), (u.words[M - 10] = R), R === 0 && u.length > 10 ? (u.length -= 10) : (u.length -= 9)
            }),
            (he.prototype.imulK = function (u) {
                ;(u.words[u.length] = 0), (u.words[u.length + 1] = 0), (u.length += 2)
                for (var E = 0, $ = 0; $ < u.length; $++) {
                    var N = u.words[$] | 0
                    ;(E += N * 977), (u.words[$] = E & 67108863), (E = N * 64 + ((E / 67108864) | 0))
                }
                return u.words[u.length - 1] === 0 && (u.length--, u.words[u.length - 1] === 0 && u.length--), u
            })
        function oe() {
            ie.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        o(oe, ie)
        function le() {
            ie.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        o(le, ie)
        function Te() {
            ie.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        o(Te, ie),
            (Te.prototype.imulK = function (u) {
                for (var E = 0, $ = 0; $ < u.length; $++) {
                    var N = (u.words[$] | 0) * 19 + E,
                        M = N & 67108863
                    ;(N >>>= 26), (u.words[$] = M), (E = N)
                }
                return E !== 0 && (u.words[u.length++] = E), u
            }),
            (a._prime = function (u) {
                if (X[u]) return X[u]
                var E
                if (u === "k256") E = new he()
                else if (u === "p224") E = new oe()
                else if (u === "p192") E = new le()
                else if (u === "p25519") E = new Te()
                else throw new Error("Unknown prime " + u)
                return (X[u] = E), E
            })
        function ye(O) {
            if (typeof O == "string") {
                var u = a._prime(O)
                ;(this.m = u.p), (this.prime = u)
            } else i(O.gtn(1), "modulus must be greater than 1"), (this.m = O), (this.prime = null)
        }
        ;(ye.prototype._verify1 = function (u) {
            i(u.negative === 0, "red works only with positives"), i(u.red, "red works only with red numbers")
        }),
            (ye.prototype._verify2 = function (u, E) {
                i((u.negative | E.negative) === 0, "red works only with positives"),
                    i(u.red && u.red === E.red, "red works only with red numbers")
            }),
            (ye.prototype.imod = function (u) {
                return this.prime ? this.prime.ireduce(u)._forceRed(this) : (_(u, u.umod(this.m)._forceRed(this)), u)
            }),
            (ye.prototype.neg = function (u) {
                return u.isZero() ? u.clone() : this.m.sub(u)._forceRed(this)
            }),
            (ye.prototype.add = function (u, E) {
                this._verify2(u, E)
                var $ = u.add(E)
                return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this)
            }),
            (ye.prototype.iadd = function (u, E) {
                this._verify2(u, E)
                var $ = u.iadd(E)
                return $.cmp(this.m) >= 0 && $.isub(this.m), $
            }),
            (ye.prototype.sub = function (u, E) {
                this._verify2(u, E)
                var $ = u.sub(E)
                return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this)
            }),
            (ye.prototype.isub = function (u, E) {
                this._verify2(u, E)
                var $ = u.isub(E)
                return $.cmpn(0) < 0 && $.iadd(this.m), $
            }),
            (ye.prototype.shl = function (u, E) {
                return this._verify1(u), this.imod(u.ushln(E))
            }),
            (ye.prototype.imul = function (u, E) {
                return this._verify2(u, E), this.imod(u.imul(E))
            }),
            (ye.prototype.mul = function (u, E) {
                return this._verify2(u, E), this.imod(u.mul(E))
            }),
            (ye.prototype.isqr = function (u) {
                return this.imul(u, u.clone())
            }),
            (ye.prototype.sqr = function (u) {
                return this.mul(u, u)
            }),
            (ye.prototype.sqrt = function (u) {
                if (u.isZero()) return u.clone()
                var E = this.m.andln(3)
                if ((i(E % 2 === 1), E === 3)) {
                    var $ = this.m.add(new a(1)).iushrn(2)
                    return this.pow(u, $)
                }
                for (var N = this.m.subn(1), M = 0; !N.isZero() && N.andln(1) === 0; ) M++, N.iushrn(1)
                i(!N.isZero())
                var R = new a(1).toRed(this),
                    C = R.redNeg(),
                    S = this.m.subn(1).iushrn(1),
                    b = this.m.bitLength()
                for (b = new a(2 * b * b).toRed(this); this.pow(b, S).cmp(C) !== 0; ) b.redIAdd(C)
                for (var T = this.pow(b, N), Q = this.pow(u, N.addn(1).iushrn(1)), k = this.pow(u, N), W = M; k.cmp(R) !== 0; ) {
                    for (var J = k, ee = 0; J.cmp(R) !== 0; ee++) J = J.redSqr()
                    i(ee < W)
                    var ne = this.pow(T, new a(1).iushln(W - ee - 1))
                    ;(Q = Q.redMul(ne)), (T = ne.redSqr()), (k = k.redMul(T)), (W = ee)
                }
                return Q
            }),
            (ye.prototype.invm = function (u) {
                var E = u._invmp(this.m)
                return E.negative !== 0 ? ((E.negative = 0), this.imod(E).redNeg()) : this.imod(E)
            }),
            (ye.prototype.pow = function (u, E) {
                if (E.isZero()) return new a(1).toRed(this)
                if (E.cmpn(1) === 0) return u.clone()
                var $ = 4,
                    N = new Array(1 << $)
                ;(N[0] = new a(1).toRed(this)), (N[1] = u)
                for (var M = 2; M < N.length; M++) N[M] = this.mul(N[M - 1], u)
                var R = N[0],
                    C = 0,
                    S = 0,
                    b = E.bitLength() % 26
                for (b === 0 && (b = 26), M = E.length - 1; M >= 0; M--) {
                    for (var T = E.words[M], Q = b - 1; Q >= 0; Q--) {
                        var k = (T >> Q) & 1
                        if ((R !== N[0] && (R = this.sqr(R)), k === 0 && C === 0)) {
                            S = 0
                            continue
                        }
                        ;(C <<= 1), (C |= k), S++, !(S !== $ && (M !== 0 || Q !== 0)) && ((R = this.mul(R, N[C])), (S = 0), (C = 0))
                    }
                    b = 26
                }
                return R
            }),
            (ye.prototype.convertTo = function (u) {
                var E = u.umod(this.m)
                return E === u ? E.clone() : E
            }),
            (ye.prototype.convertFrom = function (u) {
                var E = u.clone()
                return (E.red = null), E
            }),
            (a.mont = function (u) {
                return new Ae(u)
            })
        function Ae(O) {
            ye.call(this, O),
                (this.shift = this.m.bitLength()),
                this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
                (this.r = new a(1).iushln(this.shift)),
                (this.r2 = this.imod(this.r.sqr())),
                (this.rinv = this.r._invmp(this.m)),
                (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                (this.minv = this.minv.umod(this.r)),
                (this.minv = this.r.sub(this.minv))
        }
        o(Ae, ye),
            (Ae.prototype.convertTo = function (u) {
                return this.imod(u.ushln(this.shift))
            }),
            (Ae.prototype.convertFrom = function (u) {
                var E = this.imod(u.mul(this.rinv))
                return (E.red = null), E
            }),
            (Ae.prototype.imul = function (u, E) {
                if (u.isZero() || E.isZero()) return (u.words[0] = 0), (u.length = 1), u
                var $ = u.imul(E),
                    N = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    M = $.isub(N).iushrn(this.shift),
                    R = M
                return M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)), R._forceRed(this)
            }),
            (Ae.prototype.mul = function (u, E) {
                if (u.isZero() || E.isZero()) return new a(0)._forceRed(this)
                var $ = u.mul(E),
                    N = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    M = $.isub(N).iushrn(this.shift),
                    R = M
                return M.cmp(this.m) >= 0 ? (R = M.isub(this.m)) : M.cmpn(0) < 0 && (R = M.iadd(this.m)), R._forceRed(this)
            }),
            (Ae.prototype.invm = function (u) {
                var E = this.imod(u._invmp(this.m).mul(this.r2))
                return E._forceRed(this)
            })
    })(t, commonjsGlobal)
})(bn$1)
var BN = bn$1.exports,
    hash$3 = {},
    utils$9 = {},
    minimalisticAssert$1 = assert$b
function assert$b(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
assert$b.equal = function (e, n, i) {
    if (e != n) throw new Error(i || "Assertion failed: " + e + " != " + n)
}
var inherits_browser$1 = { exports: {} }
typeof Object.create == "function"
    ? (inherits_browser$1.exports = function (e, n) {
          n &&
              ((e.super_ = n),
              (e.prototype = Object.create(n.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })))
      })
    : (inherits_browser$1.exports = function (e, n) {
          if (n) {
              e.super_ = n
              var i = function () {}
              ;(i.prototype = n.prototype), (e.prototype = new i()), (e.prototype.constructor = e)
          }
      })
var assert$a = minimalisticAssert$1,
    inherits = inherits_browser$1.exports
utils$9.inherits = inherits
function isSurrogatePair(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320
}
function toArray(t, e) {
    if (Array.isArray(t)) return t.slice()
    if (!t) return []
    var n = []
    if (typeof t == "string")
        if (e) {
            if (e === "hex")
                for (t = t.replace(/[^a-z0-9]+/gi, ""), t.length % 2 !== 0 && (t = "0" + t), o = 0; o < t.length; o += 2)
                    n.push(parseInt(t[o] + t[o + 1], 16))
        } else
            for (var i = 0, o = 0; o < t.length; o++) {
                var a = t.charCodeAt(o)
                a < 128
                    ? (n[i++] = a)
                    : a < 2048
                    ? ((n[i++] = (a >> 6) | 192), (n[i++] = (a & 63) | 128))
                    : isSurrogatePair(t, o)
                    ? ((a = 65536 + ((a & 1023) << 10) + (t.charCodeAt(++o) & 1023)),
                      (n[i++] = (a >> 18) | 240),
                      (n[i++] = ((a >> 12) & 63) | 128),
                      (n[i++] = ((a >> 6) & 63) | 128),
                      (n[i++] = (a & 63) | 128))
                    : ((n[i++] = (a >> 12) | 224), (n[i++] = ((a >> 6) & 63) | 128), (n[i++] = (a & 63) | 128))
            }
    else for (o = 0; o < t.length; o++) n[o] = t[o] | 0
    return n
}
utils$9.toArray = toArray
function toHex(t) {
    for (var e = "", n = 0; n < t.length; n++) e += zero2(t[n].toString(16))
    return e
}
utils$9.toHex = toHex
function htonl(t) {
    var e = (t >>> 24) | ((t >>> 8) & 65280) | ((t << 8) & 16711680) | ((t & 255) << 24)
    return e >>> 0
}
utils$9.htonl = htonl
function toHex32(t, e) {
    for (var n = "", i = 0; i < t.length; i++) {
        var o = t[i]
        e === "little" && (o = htonl(o)), (n += zero8(o.toString(16)))
    }
    return n
}
utils$9.toHex32 = toHex32
function zero2(t) {
    return t.length === 1 ? "0" + t : t
}
utils$9.zero2 = zero2
function zero8(t) {
    return t.length === 7
        ? "0" + t
        : t.length === 6
        ? "00" + t
        : t.length === 5
        ? "000" + t
        : t.length === 4
        ? "0000" + t
        : t.length === 3
        ? "00000" + t
        : t.length === 2
        ? "000000" + t
        : t.length === 1
        ? "0000000" + t
        : t
}
utils$9.zero8 = zero8
function join32(t, e, n, i) {
    var o = n - e
    assert$a(o % 4 === 0)
    for (var a = new Array(o / 4), l = 0, c = e; l < a.length; l++, c += 4) {
        var g
        i === "big"
            ? (g = (t[c] << 24) | (t[c + 1] << 16) | (t[c + 2] << 8) | t[c + 3])
            : (g = (t[c + 3] << 24) | (t[c + 2] << 16) | (t[c + 1] << 8) | t[c]),
            (a[l] = g >>> 0)
    }
    return a
}
utils$9.join32 = join32
function split32(t, e) {
    for (var n = new Array(t.length * 4), i = 0, o = 0; i < t.length; i++, o += 4) {
        var a = t[i]
        e === "big"
            ? ((n[o] = a >>> 24), (n[o + 1] = (a >>> 16) & 255), (n[o + 2] = (a >>> 8) & 255), (n[o + 3] = a & 255))
            : ((n[o + 3] = a >>> 24), (n[o + 2] = (a >>> 16) & 255), (n[o + 1] = (a >>> 8) & 255), (n[o] = a & 255))
    }
    return n
}
utils$9.split32 = split32
function rotr32$1(t, e) {
    return (t >>> e) | (t << (32 - e))
}
utils$9.rotr32 = rotr32$1
function rotl32$2(t, e) {
    return (t << e) | (t >>> (32 - e))
}
utils$9.rotl32 = rotl32$2
function sum32$3(t, e) {
    return (t + e) >>> 0
}
utils$9.sum32 = sum32$3
function sum32_3$1(t, e, n) {
    return (t + e + n) >>> 0
}
utils$9.sum32_3 = sum32_3$1
function sum32_4$2(t, e, n, i) {
    return (t + e + n + i) >>> 0
}
utils$9.sum32_4 = sum32_4$2
function sum32_5$2(t, e, n, i, o) {
    return (t + e + n + i + o) >>> 0
}
utils$9.sum32_5 = sum32_5$2
function sum64$1(t, e, n, i) {
    var o = t[e],
        a = t[e + 1],
        l = (i + a) >>> 0,
        c = (l < i ? 1 : 0) + n + o
    ;(t[e] = c >>> 0), (t[e + 1] = l)
}
utils$9.sum64 = sum64$1
function sum64_hi$1(t, e, n, i) {
    var o = (e + i) >>> 0,
        a = (o < e ? 1 : 0) + t + n
    return a >>> 0
}
utils$9.sum64_hi = sum64_hi$1
function sum64_lo$1(t, e, n, i) {
    var o = e + i
    return o >>> 0
}
utils$9.sum64_lo = sum64_lo$1
function sum64_4_hi$1(t, e, n, i, o, a, l, c) {
    var g = 0,
        v = e
    ;(v = (v + i) >>> 0), (g += v < e ? 1 : 0), (v = (v + a) >>> 0), (g += v < a ? 1 : 0), (v = (v + c) >>> 0), (g += v < c ? 1 : 0)
    var _ = t + n + o + l + g
    return _ >>> 0
}
utils$9.sum64_4_hi = sum64_4_hi$1
function sum64_4_lo$1(t, e, n, i, o, a, l, c) {
    var g = e + i + a + c
    return g >>> 0
}
utils$9.sum64_4_lo = sum64_4_lo$1
function sum64_5_hi$1(t, e, n, i, o, a, l, c, g, v) {
    var _ = 0,
        A = e
    ;(A = (A + i) >>> 0),
        (_ += A < e ? 1 : 0),
        (A = (A + a) >>> 0),
        (_ += A < a ? 1 : 0),
        (A = (A + c) >>> 0),
        (_ += A < c ? 1 : 0),
        (A = (A + v) >>> 0),
        (_ += A < v ? 1 : 0)
    var B = t + n + o + l + g + _
    return B >>> 0
}
utils$9.sum64_5_hi = sum64_5_hi$1
function sum64_5_lo$1(t, e, n, i, o, a, l, c, g, v) {
    var _ = e + i + a + c + v
    return _ >>> 0
}
utils$9.sum64_5_lo = sum64_5_lo$1
function rotr64_hi$1(t, e, n) {
    var i = (e << (32 - n)) | (t >>> n)
    return i >>> 0
}
utils$9.rotr64_hi = rotr64_hi$1
function rotr64_lo$1(t, e, n) {
    var i = (t << (32 - n)) | (e >>> n)
    return i >>> 0
}
utils$9.rotr64_lo = rotr64_lo$1
function shr64_hi$1(t, e, n) {
    return t >>> n
}
utils$9.shr64_hi = shr64_hi$1
function shr64_lo$1(t, e, n) {
    var i = (t << (32 - n)) | (e >>> n)
    return i >>> 0
}
utils$9.shr64_lo = shr64_lo$1
var common$6 = {},
    utils$8 = utils$9,
    assert$9 = minimalisticAssert$1
function BlockHash$4() {
    ;(this.pending = null),
        (this.pendingTotal = 0),
        (this.blockSize = this.constructor.blockSize),
        (this.outSize = this.constructor.outSize),
        (this.hmacStrength = this.constructor.hmacStrength),
        (this.padLength = this.constructor.padLength / 8),
        (this.endian = "big"),
        (this._delta8 = this.blockSize / 8),
        (this._delta32 = this.blockSize / 32)
}
common$6.BlockHash = BlockHash$4
BlockHash$4.prototype.update = function (e, n) {
    if (
        ((e = utils$8.toArray(e, n)),
        this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e),
        (this.pendingTotal += e.length),
        this.pending.length >= this._delta8)
    ) {
        e = this.pending
        var i = e.length % this._delta8
        ;(this.pending = e.slice(e.length - i, e.length)),
            this.pending.length === 0 && (this.pending = null),
            (e = utils$8.join32(e, 0, e.length - i, this.endian))
        for (var o = 0; o < e.length; o += this._delta32) this._update(e, o, o + this._delta32)
    }
    return this
}
BlockHash$4.prototype.digest = function (e) {
    return this.update(this._pad()), assert$9(this.pending === null), this._digest(e)
}
BlockHash$4.prototype._pad = function () {
    var e = this.pendingTotal,
        n = this._delta8,
        i = n - ((e + this.padLength) % n),
        o = new Array(i + this.padLength)
    o[0] = 128
    for (var a = 1; a < i; a++) o[a] = 0
    if (((e <<= 3), this.endian === "big")) {
        for (var l = 8; l < this.padLength; l++) o[a++] = 0
        ;(o[a++] = 0),
            (o[a++] = 0),
            (o[a++] = 0),
            (o[a++] = 0),
            (o[a++] = (e >>> 24) & 255),
            (o[a++] = (e >>> 16) & 255),
            (o[a++] = (e >>> 8) & 255),
            (o[a++] = e & 255)
    } else
        for (
            o[a++] = e & 255,
                o[a++] = (e >>> 8) & 255,
                o[a++] = (e >>> 16) & 255,
                o[a++] = (e >>> 24) & 255,
                o[a++] = 0,
                o[a++] = 0,
                o[a++] = 0,
                o[a++] = 0,
                l = 8;
            l < this.padLength;
            l++
        )
            o[a++] = 0
    return o
}
var sha$1 = {},
    common$5 = {},
    utils$7 = utils$9,
    rotr32 = utils$7.rotr32
function ft_1$1(t, e, n, i) {
    if (t === 0) return ch32$1(e, n, i)
    if (t === 1 || t === 3) return p32(e, n, i)
    if (t === 2) return maj32$1(e, n, i)
}
common$5.ft_1 = ft_1$1
function ch32$1(t, e, n) {
    return (t & e) ^ (~t & n)
}
common$5.ch32 = ch32$1
function maj32$1(t, e, n) {
    return (t & e) ^ (t & n) ^ (e & n)
}
common$5.maj32 = maj32$1
function p32(t, e, n) {
    return t ^ e ^ n
}
common$5.p32 = p32
function s0_256$1(t) {
    return rotr32(t, 2) ^ rotr32(t, 13) ^ rotr32(t, 22)
}
common$5.s0_256 = s0_256$1
function s1_256$1(t) {
    return rotr32(t, 6) ^ rotr32(t, 11) ^ rotr32(t, 25)
}
common$5.s1_256 = s1_256$1
function g0_256$1(t) {
    return rotr32(t, 7) ^ rotr32(t, 18) ^ (t >>> 3)
}
common$5.g0_256 = g0_256$1
function g1_256$1(t) {
    return rotr32(t, 17) ^ rotr32(t, 19) ^ (t >>> 10)
}
common$5.g1_256 = g1_256$1
var utils$6 = utils$9,
    common$4 = common$6,
    shaCommon$1 = common$5,
    rotl32$1 = utils$6.rotl32,
    sum32$2 = utils$6.sum32,
    sum32_5$1 = utils$6.sum32_5,
    ft_1 = shaCommon$1.ft_1,
    BlockHash$3 = common$4.BlockHash,
    sha1_K = [1518500249, 1859775393, 2400959708, 3395469782]
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1()
    BlockHash$3.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80))
}
utils$6.inherits(SHA1, BlockHash$3)
var _1 = SHA1
SHA1.blockSize = 512
SHA1.outSize = 160
SHA1.hmacStrength = 80
SHA1.padLength = 64
SHA1.prototype._update = function (e, n) {
    for (var i = this.W, o = 0; o < 16; o++) i[o] = e[n + o]
    for (; o < i.length; o++) i[o] = rotl32$1(i[o - 3] ^ i[o - 8] ^ i[o - 14] ^ i[o - 16], 1)
    var a = this.h[0],
        l = this.h[1],
        c = this.h[2],
        g = this.h[3],
        v = this.h[4]
    for (o = 0; o < i.length; o++) {
        var _ = ~~(o / 20),
            A = sum32_5$1(rotl32$1(a, 5), ft_1(_, l, c, g), v, i[o], sha1_K[_])
        ;(v = g), (g = c), (c = rotl32$1(l, 30)), (l = a), (a = A)
    }
    ;(this.h[0] = sum32$2(this.h[0], a)),
        (this.h[1] = sum32$2(this.h[1], l)),
        (this.h[2] = sum32$2(this.h[2], c)),
        (this.h[3] = sum32$2(this.h[3], g)),
        (this.h[4] = sum32$2(this.h[4], v))
}
SHA1.prototype._digest = function (e) {
    return e === "hex" ? utils$6.toHex32(this.h, "big") : utils$6.split32(this.h, "big")
}
var utils$5 = utils$9,
    common$3 = common$6,
    shaCommon = common$5,
    assert$8 = minimalisticAssert$1,
    sum32$1 = utils$5.sum32,
    sum32_4$1 = utils$5.sum32_4,
    sum32_5 = utils$5.sum32_5,
    ch32 = shaCommon.ch32,
    maj32 = shaCommon.maj32,
    s0_256 = shaCommon.s0_256,
    s1_256 = shaCommon.s1_256,
    g0_256 = shaCommon.g0_256,
    g1_256 = shaCommon.g1_256,
    BlockHash$2 = common$3.BlockHash,
    sha256_K = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278,
        1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
        1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205,
        773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
    ]
function SHA256$1() {
    if (!(this instanceof SHA256$1)) return new SHA256$1()
    BlockHash$2.call(this),
        (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        (this.k = sha256_K),
        (this.W = new Array(64))
}
utils$5.inherits(SHA256$1, BlockHash$2)
var _256 = SHA256$1
SHA256$1.blockSize = 512
SHA256$1.outSize = 256
SHA256$1.hmacStrength = 192
SHA256$1.padLength = 64
SHA256$1.prototype._update = function (e, n) {
    for (var i = this.W, o = 0; o < 16; o++) i[o] = e[n + o]
    for (; o < i.length; o++) i[o] = sum32_4$1(g1_256(i[o - 2]), i[o - 7], g0_256(i[o - 15]), i[o - 16])
    var a = this.h[0],
        l = this.h[1],
        c = this.h[2],
        g = this.h[3],
        v = this.h[4],
        _ = this.h[5],
        A = this.h[6],
        B = this.h[7]
    for (assert$8(this.k.length === i.length), o = 0; o < i.length; o++) {
        var D = sum32_5(B, s1_256(v), ch32(v, _, A), this.k[o], i[o]),
            I = sum32$1(s0_256(a), maj32(a, l, c))
        ;(B = A), (A = _), (_ = v), (v = sum32$1(g, D)), (g = c), (c = l), (l = a), (a = sum32$1(D, I))
    }
    ;(this.h[0] = sum32$1(this.h[0], a)),
        (this.h[1] = sum32$1(this.h[1], l)),
        (this.h[2] = sum32$1(this.h[2], c)),
        (this.h[3] = sum32$1(this.h[3], g)),
        (this.h[4] = sum32$1(this.h[4], v)),
        (this.h[5] = sum32$1(this.h[5], _)),
        (this.h[6] = sum32$1(this.h[6], A)),
        (this.h[7] = sum32$1(this.h[7], B))
}
SHA256$1.prototype._digest = function (e) {
    return e === "hex" ? utils$5.toHex32(this.h, "big") : utils$5.split32(this.h, "big")
}
var utils$4 = utils$9,
    SHA256 = _256
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224()
    SHA256.call(this), (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
}
utils$4.inherits(SHA224, SHA256)
var _224 = SHA224
SHA224.blockSize = 512
SHA224.outSize = 224
SHA224.hmacStrength = 192
SHA224.padLength = 64
SHA224.prototype._digest = function (e) {
    return e === "hex" ? utils$4.toHex32(this.h.slice(0, 7), "big") : utils$4.split32(this.h.slice(0, 7), "big")
}
var utils$3 = utils$9,
    common$2 = common$6,
    assert$7 = minimalisticAssert$1,
    rotr64_hi = utils$3.rotr64_hi,
    rotr64_lo = utils$3.rotr64_lo,
    shr64_hi = utils$3.shr64_hi,
    shr64_lo = utils$3.shr64_lo,
    sum64 = utils$3.sum64,
    sum64_hi = utils$3.sum64_hi,
    sum64_lo = utils$3.sum64_lo,
    sum64_4_hi = utils$3.sum64_4_hi,
    sum64_4_lo = utils$3.sum64_4_lo,
    sum64_5_hi = utils$3.sum64_5_hi,
    sum64_5_lo = utils$3.sum64_5_lo,
    BlockHash$1 = common$2.BlockHash,
    sha512_K = [
        1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993,
        3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764,
        1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401,
        2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235,
        1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671,
        3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
        773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
        1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
        3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616,
        1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995,
        1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474,
        593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
        3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269,
        320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158,
        1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
    ]
function SHA512$1() {
    if (!(this instanceof SHA512$1)) return new SHA512$1()
    BlockHash$1.call(this),
        (this.h = [
            1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924,
            725511199, 528734635, 4215389547, 1541459225, 327033209,
        ]),
        (this.k = sha512_K),
        (this.W = new Array(160))
}
utils$3.inherits(SHA512$1, BlockHash$1)
var _512 = SHA512$1
SHA512$1.blockSize = 1024
SHA512$1.outSize = 512
SHA512$1.hmacStrength = 192
SHA512$1.padLength = 128
SHA512$1.prototype._prepareBlock = function (e, n) {
    for (var i = this.W, o = 0; o < 32; o++) i[o] = e[n + o]
    for (; o < i.length; o += 2) {
        var a = g1_512_hi(i[o - 4], i[o - 3]),
            l = g1_512_lo(i[o - 4], i[o - 3]),
            c = i[o - 14],
            g = i[o - 13],
            v = g0_512_hi(i[o - 30], i[o - 29]),
            _ = g0_512_lo(i[o - 30], i[o - 29]),
            A = i[o - 32],
            B = i[o - 31]
        ;(i[o] = sum64_4_hi(a, l, c, g, v, _, A, B)), (i[o + 1] = sum64_4_lo(a, l, c, g, v, _, A, B))
    }
}
SHA512$1.prototype._update = function (e, n) {
    this._prepareBlock(e, n)
    var i = this.W,
        o = this.h[0],
        a = this.h[1],
        l = this.h[2],
        c = this.h[3],
        g = this.h[4],
        v = this.h[5],
        _ = this.h[6],
        A = this.h[7],
        B = this.h[8],
        D = this.h[9],
        I = this.h[10],
        L = this.h[11],
        G = this.h[12],
        U = this.h[13],
        F = this.h[14],
        Z = this.h[15]
    assert$7(this.k.length === i.length)
    for (var Y = 0; Y < i.length; Y += 2) {
        var X = F,
            ie = Z,
            he = s1_512_hi(B, D),
            oe = s1_512_lo(B, D),
            le = ch64_hi(B, D, I, L, G),
            Te = ch64_lo(B, D, I, L, G, U),
            ye = this.k[Y],
            Ae = this.k[Y + 1],
            O = i[Y],
            u = i[Y + 1],
            E = sum64_5_hi(X, ie, he, oe, le, Te, ye, Ae, O, u),
            $ = sum64_5_lo(X, ie, he, oe, le, Te, ye, Ae, O, u)
        ;(X = s0_512_hi(o, a)), (ie = s0_512_lo(o, a)), (he = maj64_hi(o, a, l, c, g)), (oe = maj64_lo(o, a, l, c, g, v))
        var N = sum64_hi(X, ie, he, oe),
            M = sum64_lo(X, ie, he, oe)
        ;(F = G),
            (Z = U),
            (G = I),
            (U = L),
            (I = B),
            (L = D),
            (B = sum64_hi(_, A, E, $)),
            (D = sum64_lo(A, A, E, $)),
            (_ = g),
            (A = v),
            (g = l),
            (v = c),
            (l = o),
            (c = a),
            (o = sum64_hi(E, $, N, M)),
            (a = sum64_lo(E, $, N, M))
    }
    sum64(this.h, 0, o, a),
        sum64(this.h, 2, l, c),
        sum64(this.h, 4, g, v),
        sum64(this.h, 6, _, A),
        sum64(this.h, 8, B, D),
        sum64(this.h, 10, I, L),
        sum64(this.h, 12, G, U),
        sum64(this.h, 14, F, Z)
}
SHA512$1.prototype._digest = function (e) {
    return e === "hex" ? utils$3.toHex32(this.h, "big") : utils$3.split32(this.h, "big")
}
function ch64_hi(t, e, n, i, o) {
    var a = (t & n) ^ (~t & o)
    return a < 0 && (a += 4294967296), a
}
function ch64_lo(t, e, n, i, o, a) {
    var l = (e & i) ^ (~e & a)
    return l < 0 && (l += 4294967296), l
}
function maj64_hi(t, e, n, i, o) {
    var a = (t & n) ^ (t & o) ^ (n & o)
    return a < 0 && (a += 4294967296), a
}
function maj64_lo(t, e, n, i, o, a) {
    var l = (e & i) ^ (e & a) ^ (i & a)
    return l < 0 && (l += 4294967296), l
}
function s0_512_hi(t, e) {
    var n = rotr64_hi(t, e, 28),
        i = rotr64_hi(e, t, 2),
        o = rotr64_hi(e, t, 7),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function s0_512_lo(t, e) {
    var n = rotr64_lo(t, e, 28),
        i = rotr64_lo(e, t, 2),
        o = rotr64_lo(e, t, 7),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function s1_512_hi(t, e) {
    var n = rotr64_hi(t, e, 14),
        i = rotr64_hi(t, e, 18),
        o = rotr64_hi(e, t, 9),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function s1_512_lo(t, e) {
    var n = rotr64_lo(t, e, 14),
        i = rotr64_lo(t, e, 18),
        o = rotr64_lo(e, t, 9),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function g0_512_hi(t, e) {
    var n = rotr64_hi(t, e, 1),
        i = rotr64_hi(t, e, 8),
        o = shr64_hi(t, e, 7),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function g0_512_lo(t, e) {
    var n = rotr64_lo(t, e, 1),
        i = rotr64_lo(t, e, 8),
        o = shr64_lo(t, e, 7),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function g1_512_hi(t, e) {
    var n = rotr64_hi(t, e, 19),
        i = rotr64_hi(e, t, 29),
        o = shr64_hi(t, e, 6),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
function g1_512_lo(t, e) {
    var n = rotr64_lo(t, e, 19),
        i = rotr64_lo(e, t, 29),
        o = shr64_lo(t, e, 6),
        a = n ^ i ^ o
    return a < 0 && (a += 4294967296), a
}
var utils$2 = utils$9,
    SHA512 = _512
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384()
    SHA512.call(this),
        (this.h = [
            3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231,
            1750603025, 3675008525, 1694076839, 1203062813, 3204075428,
        ])
}
utils$2.inherits(SHA384, SHA512)
var _384 = SHA384
SHA384.blockSize = 1024
SHA384.outSize = 384
SHA384.hmacStrength = 192
SHA384.padLength = 128
SHA384.prototype._digest = function (e) {
    return e === "hex" ? utils$2.toHex32(this.h.slice(0, 12), "big") : utils$2.split32(this.h.slice(0, 12), "big")
}
sha$1.sha1 = _1
sha$1.sha224 = _224
sha$1.sha256 = _256
sha$1.sha384 = _384
sha$1.sha512 = _512
var ripemd = {},
    utils$1 = utils$9,
    common$1 = common$6,
    rotl32 = utils$1.rotl32,
    sum32 = utils$1.sum32,
    sum32_3 = utils$1.sum32_3,
    sum32_4 = utils$1.sum32_4,
    BlockHash = common$1.BlockHash
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160()
    BlockHash.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = "little")
}
utils$1.inherits(RIPEMD160, BlockHash)
ripemd.ripemd160 = RIPEMD160
RIPEMD160.blockSize = 512
RIPEMD160.outSize = 160
RIPEMD160.hmacStrength = 192
RIPEMD160.padLength = 64
RIPEMD160.prototype._update = function (e, n) {
    for (var i = this.h[0], o = this.h[1], a = this.h[2], l = this.h[3], c = this.h[4], g = i, v = o, _ = a, A = l, B = c, D = 0; D < 80; D++) {
        var I = sum32(rotl32(sum32_4(i, f(D, o, a, l), e[r[D] + n], K(D)), s$2[D]), c)
        ;(i = c),
            (c = l),
            (l = rotl32(a, 10)),
            (a = o),
            (o = I),
            (I = sum32(rotl32(sum32_4(g, f(79 - D, v, _, A), e[rh[D] + n], Kh(D)), sh[D]), B)),
            (g = B),
            (B = A),
            (A = rotl32(_, 10)),
            (_ = v),
            (v = I)
    }
    ;(I = sum32_3(this.h[1], a, A)),
        (this.h[1] = sum32_3(this.h[2], l, B)),
        (this.h[2] = sum32_3(this.h[3], c, g)),
        (this.h[3] = sum32_3(this.h[4], i, v)),
        (this.h[4] = sum32_3(this.h[0], o, _)),
        (this.h[0] = I)
}
RIPEMD160.prototype._digest = function (e) {
    return e === "hex" ? utils$1.toHex32(this.h, "little") : utils$1.split32(this.h, "little")
}
function f(t, e, n, i) {
    return t <= 15 ? e ^ n ^ i : t <= 31 ? (e & n) | (~e & i) : t <= 47 ? (e | ~n) ^ i : t <= 63 ? (e & i) | (n & ~i) : e ^ (n | ~i)
}
function K(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}
function Kh(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}
var r = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2,
        7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
    ],
    rh = [
        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11,
        8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
    ],
    s$2 = [
        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
        15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8,
        5, 6,
    ],
    sh = [
        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
        14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
        11, 11,
    ],
    utils = utils$9,
    assert$6 = minimalisticAssert$1
function Hmac(t, e, n) {
    if (!(this instanceof Hmac)) return new Hmac(t, e, n)
    ;(this.Hash = t),
        (this.blockSize = t.blockSize / 8),
        (this.outSize = t.outSize / 8),
        (this.inner = null),
        (this.outer = null),
        this._init(utils.toArray(e, n))
}
var hmac = Hmac
Hmac.prototype._init = function (e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), assert$6(e.length <= this.blockSize)
    for (var n = e.length; n < this.blockSize; n++) e.push(0)
    for (n = 0; n < e.length; n++) e[n] ^= 54
    for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++) e[n] ^= 106
    this.outer = new this.Hash().update(e)
}
Hmac.prototype.update = function (e, n) {
    return this.inner.update(e, n), this
}
Hmac.prototype.digest = function (e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
}
;(function (t) {
    var e = t
    ;(e.utils = utils$9),
        (e.common = common$6),
        (e.sha = sha$1),
        (e.ripemd = ripemd),
        (e.hmac = hmac),
        (e.sha1 = e.sha.sha1),
        (e.sha256 = e.sha.sha256),
        (e.sha224 = e.sha.sha224),
        (e.sha384 = e.sha.sha384),
        (e.sha512 = e.sha.sha512),
        (e.ripemd160 = e.ripemd.ripemd160)
})(hash$3)
var hash$2 = hash$3
function createCommonjsModule(t, e, n) {
    return (
        (n = {
            path: e,
            exports: {},
            require: function (i, o) {
                return commonjsRequire(i, o == null ? n.path : o)
            },
        }),
        t(n, n.exports),
        n.exports
    )
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var minimalisticAssert = assert
function assert(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
assert.equal = function (e, n, i) {
    if (e != n) throw new Error(i || "Assertion failed: " + e + " != " + n)
}
var utils_1 = createCommonjsModule(function (t, e) {
        var n = e
        function i(l, c) {
            if (Array.isArray(l)) return l.slice()
            if (!l) return []
            var g = []
            if (typeof l != "string") {
                for (var v = 0; v < l.length; v++) g[v] = l[v] | 0
                return g
            }
            if (c === "hex") {
                ;(l = l.replace(/[^a-z0-9]+/gi, "")), l.length % 2 !== 0 && (l = "0" + l)
                for (var v = 0; v < l.length; v += 2) g.push(parseInt(l[v] + l[v + 1], 16))
            } else
                for (var v = 0; v < l.length; v++) {
                    var _ = l.charCodeAt(v),
                        A = _ >> 8,
                        B = _ & 255
                    A ? g.push(A, B) : g.push(B)
                }
            return g
        }
        n.toArray = i
        function o(l) {
            return l.length === 1 ? "0" + l : l
        }
        n.zero2 = o
        function a(l) {
            for (var c = "", g = 0; g < l.length; g++) c += o(l[g].toString(16))
            return c
        }
        ;(n.toHex = a),
            (n.encode = function (c, g) {
                return g === "hex" ? a(c) : c
            })
    }),
    utils_1$1 = createCommonjsModule(function (t, e) {
        var n = e
        ;(n.assert = minimalisticAssert),
            (n.toArray = utils_1.toArray),
            (n.zero2 = utils_1.zero2),
            (n.toHex = utils_1.toHex),
            (n.encode = utils_1.encode)
        function i(g, v, _) {
            var A = new Array(Math.max(g.bitLength(), _) + 1)
            A.fill(0)
            for (var B = 1 << (v + 1), D = g.clone(), I = 0; I < A.length; I++) {
                var L,
                    G = D.andln(B - 1)
                D.isOdd() ? (G > (B >> 1) - 1 ? (L = (B >> 1) - G) : (L = G), D.isubn(L)) : (L = 0), (A[I] = L), D.iushrn(1)
            }
            return A
        }
        n.getNAF = i
        function o(g, v) {
            var _ = [[], []]
            ;(g = g.clone()), (v = v.clone())
            for (var A = 0, B = 0, D; g.cmpn(-A) > 0 || v.cmpn(-B) > 0; ) {
                var I = (g.andln(3) + A) & 3,
                    L = (v.andln(3) + B) & 3
                I === 3 && (I = -1), L === 3 && (L = -1)
                var G
                ;(I & 1) === 0 ? (G = 0) : ((D = (g.andln(7) + A) & 7), (D === 3 || D === 5) && L === 2 ? (G = -I) : (G = I)), _[0].push(G)
                var U
                ;(L & 1) === 0 ? (U = 0) : ((D = (v.andln(7) + B) & 7), (D === 3 || D === 5) && I === 2 ? (U = -L) : (U = L)),
                    _[1].push(U),
                    2 * A === G + 1 && (A = 1 - A),
                    2 * B === U + 1 && (B = 1 - B),
                    g.iushrn(1),
                    v.iushrn(1)
            }
            return _
        }
        n.getJSF = o
        function a(g, v, _) {
            var A = "_" + v
            g.prototype[v] = function () {
                return this[A] !== void 0 ? this[A] : (this[A] = _.call(this))
            }
        }
        n.cachedProperty = a
        function l(g) {
            return typeof g == "string" ? n.toArray(g, "hex") : g
        }
        n.parseBytes = l
        function c(g) {
            return new BN(g, "hex", "le")
        }
        n.intFromLE = c
    }),
    getNAF = utils_1$1.getNAF,
    getJSF = utils_1$1.getJSF,
    assert$1 = utils_1$1.assert
function BaseCurve(t, e) {
    ;(this.type = t),
        (this.p = new BN(e.p, 16)),
        (this.red = e.prime ? BN.red(e.prime) : BN.mont(this.p)),
        (this.zero = new BN(0).toRed(this.red)),
        (this.one = new BN(1).toRed(this.red)),
        (this.two = new BN(2).toRed(this.red)),
        (this.n = e.n && new BN(e.n, 16)),
        (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
        (this._wnafT1 = new Array(4)),
        (this._wnafT2 = new Array(4)),
        (this._wnafT3 = new Array(4)),
        (this._wnafT4 = new Array(4)),
        (this._bitLength = this.n ? this.n.bitLength() : 0)
    var n = this.n && this.p.div(this.n)
    !n || n.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
}
var base$1 = BaseCurve
BaseCurve.prototype.point = function () {
    throw new Error("Not implemented")
}
BaseCurve.prototype.validate = function () {
    throw new Error("Not implemented")
}
BaseCurve.prototype._fixedNafMul = function (e, n) {
    assert$1(e.precomputed)
    var i = e._getDoubles(),
        o = getNAF(n, 1, this._bitLength),
        a = (1 << (i.step + 1)) - (i.step % 2 === 0 ? 2 : 1)
    a /= 3
    var l = [],
        c,
        g
    for (c = 0; c < o.length; c += i.step) {
        g = 0
        for (var v = c + i.step - 1; v >= c; v--) g = (g << 1) + o[v]
        l.push(g)
    }
    for (var _ = this.jpoint(null, null, null), A = this.jpoint(null, null, null), B = a; B > 0; B--) {
        for (c = 0; c < l.length; c++) (g = l[c]), g === B ? (A = A.mixedAdd(i.points[c])) : g === -B && (A = A.mixedAdd(i.points[c].neg()))
        _ = _.add(A)
    }
    return _.toP()
}
BaseCurve.prototype._wnafMul = function (e, n) {
    var i = 4,
        o = e._getNAFPoints(i)
    i = o.wnd
    for (var a = o.points, l = getNAF(n, i, this._bitLength), c = this.jpoint(null, null, null), g = l.length - 1; g >= 0; g--) {
        for (var v = 0; g >= 0 && l[g] === 0; g--) v++
        if ((g >= 0 && v++, (c = c.dblp(v)), g < 0)) break
        var _ = l[g]
        assert$1(_ !== 0),
            e.type === "affine"
                ? _ > 0
                    ? (c = c.mixedAdd(a[(_ - 1) >> 1]))
                    : (c = c.mixedAdd(a[(-_ - 1) >> 1].neg()))
                : _ > 0
                ? (c = c.add(a[(_ - 1) >> 1]))
                : (c = c.add(a[(-_ - 1) >> 1].neg()))
    }
    return e.type === "affine" ? c.toP() : c
}
BaseCurve.prototype._wnafMulAdd = function (e, n, i, o, a) {
    var l = this._wnafT1,
        c = this._wnafT2,
        g = this._wnafT3,
        v = 0,
        _,
        A,
        B
    for (_ = 0; _ < o; _++) {
        B = n[_]
        var D = B._getNAFPoints(e)
        ;(l[_] = D.wnd), (c[_] = D.points)
    }
    for (_ = o - 1; _ >= 1; _ -= 2) {
        var I = _ - 1,
            L = _
        if (l[I] !== 1 || l[L] !== 1) {
            ;(g[I] = getNAF(i[I], l[I], this._bitLength)),
                (g[L] = getNAF(i[L], l[L], this._bitLength)),
                (v = Math.max(g[I].length, v)),
                (v = Math.max(g[L].length, v))
            continue
        }
        var G = [n[I], null, null, n[L]]
        n[I].y.cmp(n[L].y) === 0
            ? ((G[1] = n[I].add(n[L])), (G[2] = n[I].toJ().mixedAdd(n[L].neg())))
            : n[I].y.cmp(n[L].y.redNeg()) === 0
            ? ((G[1] = n[I].toJ().mixedAdd(n[L])), (G[2] = n[I].add(n[L].neg())))
            : ((G[1] = n[I].toJ().mixedAdd(n[L])), (G[2] = n[I].toJ().mixedAdd(n[L].neg())))
        var U = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            F = getJSF(i[I], i[L])
        for (v = Math.max(F[0].length, v), g[I] = new Array(v), g[L] = new Array(v), A = 0; A < v; A++) {
            var Z = F[0][A] | 0,
                Y = F[1][A] | 0
            ;(g[I][A] = U[(Z + 1) * 3 + (Y + 1)]), (g[L][A] = 0), (c[I] = G)
        }
    }
    var X = this.jpoint(null, null, null),
        ie = this._wnafT4
    for (_ = v; _ >= 0; _--) {
        for (var he = 0; _ >= 0; ) {
            var oe = !0
            for (A = 0; A < o; A++) (ie[A] = g[A][_] | 0), ie[A] !== 0 && (oe = !1)
            if (!oe) break
            he++, _--
        }
        if ((_ >= 0 && he++, (X = X.dblp(he)), _ < 0)) break
        for (A = 0; A < o; A++) {
            var le = ie[A]
            le !== 0 &&
                (le > 0 ? (B = c[A][(le - 1) >> 1]) : le < 0 && (B = c[A][(-le - 1) >> 1].neg()),
                B.type === "affine" ? (X = X.mixedAdd(B)) : (X = X.add(B)))
        }
    }
    for (_ = 0; _ < o; _++) c[_] = null
    return a ? X : X.toP()
}
function BasePoint(t, e) {
    ;(this.curve = t), (this.type = e), (this.precomputed = null)
}
BaseCurve.BasePoint = BasePoint
BasePoint.prototype.eq = function () {
    throw new Error("Not implemented")
}
BasePoint.prototype.validate = function () {
    return this.curve.validate(this)
}
BaseCurve.prototype.decodePoint = function (e, n) {
    e = utils_1$1.toArray(e, n)
    var i = this.p.byteLength()
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {
        e[0] === 6 ? assert$1(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$1(e[e.length - 1] % 2 === 1)
        var o = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i))
        return o
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i) return this.pointFromX(e.slice(1, 1 + i), e[0] === 3)
    throw new Error("Unknown point format")
}
BasePoint.prototype.encodeCompressed = function (e) {
    return this.encode(e, !0)
}
BasePoint.prototype._encode = function (e) {
    var n = this.curve.p.byteLength(),
        i = this.getX().toArray("be", n)
    return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", n))
}
BasePoint.prototype.encode = function (e, n) {
    return utils_1$1.encode(this._encode(n), e)
}
BasePoint.prototype.precompute = function (e) {
    if (this.precomputed) return this
    var n = { doubles: null, naf: null, beta: null }
    return (n.naf = this._getNAFPoints(8)), (n.doubles = this._getDoubles(4, e)), (n.beta = this._getBeta()), (this.precomputed = n), this
}
BasePoint.prototype._hasDoubles = function (e) {
    if (!this.precomputed) return !1
    var n = this.precomputed.doubles
    return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : !1
}
BasePoint.prototype._getDoubles = function (e, n) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
    for (var i = [this], o = this, a = 0; a < n; a += e) {
        for (var l = 0; l < e; l++) o = o.dbl()
        i.push(o)
    }
    return { step: e, points: i }
}
BasePoint.prototype._getNAFPoints = function (e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
    for (var n = [this], i = (1 << e) - 1, o = i === 1 ? null : this.dbl(), a = 1; a < i; a++) n[a] = n[a - 1].add(o)
    return { wnd: e, points: n }
}
BasePoint.prototype._getBeta = function () {
    return null
}
BasePoint.prototype.dblp = function (e) {
    for (var n = this, i = 0; i < e; i++) n = n.dbl()
    return n
}
var inherits_browser = createCommonjsModule(function (t) {
        typeof Object.create == "function"
            ? (t.exports = function (n, i) {
                  i &&
                      ((n.super_ = i),
                      (n.prototype = Object.create(i.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } })))
              })
            : (t.exports = function (n, i) {
                  if (i) {
                      n.super_ = i
                      var o = function () {}
                      ;(o.prototype = i.prototype), (n.prototype = new o()), (n.prototype.constructor = n)
                  }
              })
    }),
    assert$2 = utils_1$1.assert
function ShortCurve(t) {
    base$1.call(this, "short", t),
        (this.a = new BN(t.a, 16).toRed(this.red)),
        (this.b = new BN(t.b, 16).toRed(this.red)),
        (this.tinv = this.two.redInvm()),
        (this.zeroA = this.a.fromRed().cmpn(0) === 0),
        (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
        (this.endo = this._getEndomorphism(t)),
        (this._endoWnafT1 = new Array(4)),
        (this._endoWnafT2 = new Array(4))
}
inherits_browser(ShortCurve, base$1)
var short_1 = ShortCurve
ShortCurve.prototype._getEndomorphism = function (e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var n, i
        if (e.beta) n = new BN(e.beta, 16).toRed(this.red)
        else {
            var o = this._getEndoRoots(this.p)
            ;(n = o[0].cmp(o[1]) < 0 ? o[0] : o[1]), (n = n.toRed(this.red))
        }
        if (e.lambda) i = new BN(e.lambda, 16)
        else {
            var a = this._getEndoRoots(this.n)
            this.g.mul(a[0]).x.cmp(this.g.x.redMul(n)) === 0 ? (i = a[0]) : ((i = a[1]), assert$2(this.g.mul(i).x.cmp(this.g.x.redMul(n)) === 0))
        }
        var l
        return (
            e.basis
                ? (l = e.basis.map(function (c) {
                      return { a: new BN(c.a, 16), b: new BN(c.b, 16) }
                  }))
                : (l = this._getEndoBasis(i)),
            { beta: n, lambda: i, basis: l }
        )
    }
}
ShortCurve.prototype._getEndoRoots = function (e) {
    var n = e === this.p ? this.red : BN.mont(e),
        i = new BN(2).toRed(n).redInvm(),
        o = i.redNeg(),
        a = new BN(3).toRed(n).redNeg().redSqrt().redMul(i),
        l = o.redAdd(a).fromRed(),
        c = o.redSub(a).fromRed()
    return [l, c]
}
ShortCurve.prototype._getEndoBasis = function (e) {
    for (
        var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
            i = e,
            o = this.n.clone(),
            a = new BN(1),
            l = new BN(0),
            c = new BN(0),
            g = new BN(1),
            v,
            _,
            A,
            B,
            D,
            I,
            L,
            G = 0,
            U,
            F;
        i.cmpn(0) !== 0;

    ) {
        var Z = o.div(i)
        ;(U = o.sub(Z.mul(i))), (F = c.sub(Z.mul(a)))
        var Y = g.sub(Z.mul(l))
        if (!A && U.cmp(n) < 0) (v = L.neg()), (_ = a), (A = U.neg()), (B = F)
        else if (A && ++G === 2) break
        ;(L = U), (o = i), (i = U), (c = a), (a = F), (g = l), (l = Y)
    }
    ;(D = U.neg()), (I = F)
    var X = A.sqr().add(B.sqr()),
        ie = D.sqr().add(I.sqr())
    return (
        ie.cmp(X) >= 0 && ((D = v), (I = _)),
        A.negative && ((A = A.neg()), (B = B.neg())),
        D.negative && ((D = D.neg()), (I = I.neg())),
        [
            { a: A, b: B },
            { a: D, b: I },
        ]
    )
}
ShortCurve.prototype._endoSplit = function (e) {
    var n = this.endo.basis,
        i = n[0],
        o = n[1],
        a = o.b.mul(e).divRound(this.n),
        l = i.b.neg().mul(e).divRound(this.n),
        c = a.mul(i.a),
        g = l.mul(o.a),
        v = a.mul(i.b),
        _ = l.mul(o.b),
        A = e.sub(c).sub(g),
        B = v.add(_).neg()
    return { k1: A, k2: B }
}
ShortCurve.prototype.pointFromX = function (e, n) {
    ;(e = new BN(e, 16)), e.red || (e = e.toRed(this.red))
    var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        o = i.redSqrt()
    if (o.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error("invalid point")
    var a = o.fromRed().isOdd()
    return ((n && !a) || (!n && a)) && (o = o.redNeg()), this.point(e, o)
}
ShortCurve.prototype.validate = function (e) {
    if (e.inf) return !0
    var n = e.x,
        i = e.y,
        o = this.a.redMul(n),
        a = n.redSqr().redMul(n).redIAdd(o).redIAdd(this.b)
    return i.redSqr().redISub(a).cmpn(0) === 0
}
ShortCurve.prototype._endoWnafMulAdd = function (e, n, i) {
    for (var o = this._endoWnafT1, a = this._endoWnafT2, l = 0; l < e.length; l++) {
        var c = this._endoSplit(n[l]),
            g = e[l],
            v = g._getBeta()
        c.k1.negative && (c.k1.ineg(), (g = g.neg(!0))),
            c.k2.negative && (c.k2.ineg(), (v = v.neg(!0))),
            (o[l * 2] = g),
            (o[l * 2 + 1] = v),
            (a[l * 2] = c.k1),
            (a[l * 2 + 1] = c.k2)
    }
    for (var _ = this._wnafMulAdd(1, o, a, l * 2, i), A = 0; A < l * 2; A++) (o[A] = null), (a[A] = null)
    return _
}
function Point(t, e, n, i) {
    base$1.BasePoint.call(this, t, "affine"),
        e === null && n === null
            ? ((this.x = null), (this.y = null), (this.inf = !0))
            : ((this.x = new BN(e, 16)),
              (this.y = new BN(n, 16)),
              i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1))
}
inherits_browser(Point, base$1.BasePoint)
ShortCurve.prototype.point = function (e, n, i) {
    return new Point(this, e, n, i)
}
ShortCurve.prototype.pointFromJSON = function (e, n) {
    return Point.fromJSON(this, e, n)
}
Point.prototype._getBeta = function () {
    if (!!this.curve.endo) {
        var e = this.precomputed
        if (e && e.beta) return e.beta
        var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
        if (e) {
            var i = this.curve,
                o = function (a) {
                    return i.point(a.x.redMul(i.endo.beta), a.y)
                }
            ;(e.beta = n),
                (n.precomputed = {
                    beta: null,
                    naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(o) },
                    doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(o) },
                })
        }
        return n
    }
}
Point.prototype.toJSON = function () {
    return this.precomputed
        ? [
              this.x,
              this.y,
              this.precomputed && {
                  doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) },
                  naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) },
              },
          ]
        : [this.x, this.y]
}
Point.fromJSON = function (e, n, i) {
    typeof n == "string" && (n = JSON.parse(n))
    var o = e.point(n[0], n[1], i)
    if (!n[2]) return o
    function a(c) {
        return e.point(c[0], c[1], i)
    }
    var l = n[2]
    return (
        (o.precomputed = {
            beta: null,
            doubles: l.doubles && { step: l.doubles.step, points: [o].concat(l.doubles.points.map(a)) },
            naf: l.naf && { wnd: l.naf.wnd, points: [o].concat(l.naf.points.map(a)) },
        }),
        o
    )
}
Point.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC Point Infinity>"
        : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
}
Point.prototype.isInfinity = function () {
    return this.inf
}
Point.prototype.add = function (e) {
    if (this.inf) return e
    if (e.inf) return this
    if (this.eq(e)) return this.dbl()
    if (this.neg().eq(e)) return this.curve.point(null, null)
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null)
    var n = this.y.redSub(e.y)
    n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()))
    var i = n.redSqr().redISub(this.x).redISub(e.x),
        o = n.redMul(this.x.redSub(i)).redISub(this.y)
    return this.curve.point(i, o)
}
Point.prototype.dbl = function () {
    if (this.inf) return this
    var e = this.y.redAdd(this.y)
    if (e.cmpn(0) === 0) return this.curve.point(null, null)
    var n = this.curve.a,
        i = this.x.redSqr(),
        o = e.redInvm(),
        a = i.redAdd(i).redIAdd(i).redIAdd(n).redMul(o),
        l = a.redSqr().redISub(this.x.redAdd(this.x)),
        c = a.redMul(this.x.redSub(l)).redISub(this.y)
    return this.curve.point(l, c)
}
Point.prototype.getX = function () {
    return this.x.fromRed()
}
Point.prototype.getY = function () {
    return this.y.fromRed()
}
Point.prototype.mul = function (e) {
    return (
        (e = new BN(e, 16)),
        this.isInfinity()
            ? this
            : this._hasDoubles(e)
            ? this.curve._fixedNafMul(this, e)
            : this.curve.endo
            ? this.curve._endoWnafMulAdd([this], [e])
            : this.curve._wnafMul(this, e)
    )
}
Point.prototype.mulAdd = function (e, n, i) {
    var o = [this, n],
        a = [e, i]
    return this.curve.endo ? this.curve._endoWnafMulAdd(o, a) : this.curve._wnafMulAdd(1, o, a, 2)
}
Point.prototype.jmulAdd = function (e, n, i) {
    var o = [this, n],
        a = [e, i]
    return this.curve.endo ? this.curve._endoWnafMulAdd(o, a, !0) : this.curve._wnafMulAdd(1, o, a, 2, !0)
}
Point.prototype.eq = function (e) {
    return this === e || (this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)))
}
Point.prototype.neg = function (e) {
    if (this.inf) return this
    var n = this.curve.point(this.x, this.y.redNeg())
    if (e && this.precomputed) {
        var i = this.precomputed,
            o = function (a) {
                return a.neg()
            }
        n.precomputed = {
            naf: i.naf && { wnd: i.naf.wnd, points: i.naf.points.map(o) },
            doubles: i.doubles && { step: i.doubles.step, points: i.doubles.points.map(o) },
        }
    }
    return n
}
Point.prototype.toJ = function () {
    if (this.inf) return this.curve.jpoint(null, null, null)
    var e = this.curve.jpoint(this.x, this.y, this.curve.one)
    return e
}
function JPoint(t, e, n, i) {
    base$1.BasePoint.call(this, t, "jacobian"),
        e === null && n === null && i === null
            ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new BN(0)))
            : ((this.x = new BN(e, 16)), (this.y = new BN(n, 16)), (this.z = new BN(i, 16))),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        (this.zOne = this.z === this.curve.one)
}
inherits_browser(JPoint, base$1.BasePoint)
ShortCurve.prototype.jpoint = function (e, n, i) {
    return new JPoint(this, e, n, i)
}
JPoint.prototype.toP = function () {
    if (this.isInfinity()) return this.curve.point(null, null)
    var e = this.z.redInvm(),
        n = e.redSqr(),
        i = this.x.redMul(n),
        o = this.y.redMul(n).redMul(e)
    return this.curve.point(i, o)
}
JPoint.prototype.neg = function () {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
}
JPoint.prototype.add = function (e) {
    if (this.isInfinity()) return e
    if (e.isInfinity()) return this
    var n = e.z.redSqr(),
        i = this.z.redSqr(),
        o = this.x.redMul(n),
        a = e.x.redMul(i),
        l = this.y.redMul(n.redMul(e.z)),
        c = e.y.redMul(i.redMul(this.z)),
        g = o.redSub(a),
        v = l.redSub(c)
    if (g.cmpn(0) === 0) return v.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var _ = g.redSqr(),
        A = _.redMul(g),
        B = o.redMul(_),
        D = v.redSqr().redIAdd(A).redISub(B).redISub(B),
        I = v.redMul(B.redISub(D)).redISub(l.redMul(A)),
        L = this.z.redMul(e.z).redMul(g)
    return this.curve.jpoint(D, I, L)
}
JPoint.prototype.mixedAdd = function (e) {
    if (this.isInfinity()) return e.toJ()
    if (e.isInfinity()) return this
    var n = this.z.redSqr(),
        i = this.x,
        o = e.x.redMul(n),
        a = this.y,
        l = e.y.redMul(n).redMul(this.z),
        c = i.redSub(o),
        g = a.redSub(l)
    if (c.cmpn(0) === 0) return g.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var v = c.redSqr(),
        _ = v.redMul(c),
        A = i.redMul(v),
        B = g.redSqr().redIAdd(_).redISub(A).redISub(A),
        D = g.redMul(A.redISub(B)).redISub(a.redMul(_)),
        I = this.z.redMul(c)
    return this.curve.jpoint(B, D, I)
}
JPoint.prototype.dblp = function (e) {
    if (e === 0) return this
    if (this.isInfinity()) return this
    if (!e) return this.dbl()
    var n
    if (this.curve.zeroA || this.curve.threeA) {
        var i = this
        for (n = 0; n < e; n++) i = i.dbl()
        return i
    }
    var o = this.curve.a,
        a = this.curve.tinv,
        l = this.x,
        c = this.y,
        g = this.z,
        v = g.redSqr().redSqr(),
        _ = c.redAdd(c)
    for (n = 0; n < e; n++) {
        var A = l.redSqr(),
            B = _.redSqr(),
            D = B.redSqr(),
            I = A.redAdd(A).redIAdd(A).redIAdd(o.redMul(v)),
            L = l.redMul(B),
            G = I.redSqr().redISub(L.redAdd(L)),
            U = L.redISub(G),
            F = I.redMul(U)
        F = F.redIAdd(F).redISub(D)
        var Z = _.redMul(g)
        n + 1 < e && (v = v.redMul(D)), (l = G), (g = Z), (_ = F)
    }
    return this.curve.jpoint(l, _.redMul(a), g)
}
JPoint.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
}
JPoint.prototype._zeroDbl = function () {
    var e, n, i
    if (this.zOne) {
        var o = this.x.redSqr(),
            a = this.y.redSqr(),
            l = a.redSqr(),
            c = this.x.redAdd(a).redSqr().redISub(o).redISub(l)
        c = c.redIAdd(c)
        var g = o.redAdd(o).redIAdd(o),
            v = g.redSqr().redISub(c).redISub(c),
            _ = l.redIAdd(l)
        ;(_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (e = v), (n = g.redMul(c.redISub(v)).redISub(_)), (i = this.y.redAdd(this.y))
    } else {
        var A = this.x.redSqr(),
            B = this.y.redSqr(),
            D = B.redSqr(),
            I = this.x.redAdd(B).redSqr().redISub(A).redISub(D)
        I = I.redIAdd(I)
        var L = A.redAdd(A).redIAdd(A),
            G = L.redSqr(),
            U = D.redIAdd(D)
        ;(U = U.redIAdd(U)),
            (U = U.redIAdd(U)),
            (e = G.redISub(I).redISub(I)),
            (n = L.redMul(I.redISub(e)).redISub(U)),
            (i = this.y.redMul(this.z)),
            (i = i.redIAdd(i))
    }
    return this.curve.jpoint(e, n, i)
}
JPoint.prototype._threeDbl = function () {
    var e, n, i
    if (this.zOne) {
        var o = this.x.redSqr(),
            a = this.y.redSqr(),
            l = a.redSqr(),
            c = this.x.redAdd(a).redSqr().redISub(o).redISub(l)
        c = c.redIAdd(c)
        var g = o.redAdd(o).redIAdd(o).redIAdd(this.curve.a),
            v = g.redSqr().redISub(c).redISub(c)
        e = v
        var _ = l.redIAdd(l)
        ;(_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (n = g.redMul(c.redISub(v)).redISub(_)), (i = this.y.redAdd(this.y))
    } else {
        var A = this.z.redSqr(),
            B = this.y.redSqr(),
            D = this.x.redMul(B),
            I = this.x.redSub(A).redMul(this.x.redAdd(A))
        I = I.redAdd(I).redIAdd(I)
        var L = D.redIAdd(D)
        L = L.redIAdd(L)
        var G = L.redAdd(L)
        ;(e = I.redSqr().redISub(G)), (i = this.y.redAdd(this.z).redSqr().redISub(B).redISub(A))
        var U = B.redSqr()
        ;(U = U.redIAdd(U)), (U = U.redIAdd(U)), (U = U.redIAdd(U)), (n = I.redMul(L.redISub(e)).redISub(U))
    }
    return this.curve.jpoint(e, n, i)
}
JPoint.prototype._dbl = function () {
    var e = this.curve.a,
        n = this.x,
        i = this.y,
        o = this.z,
        a = o.redSqr().redSqr(),
        l = n.redSqr(),
        c = i.redSqr(),
        g = l.redAdd(l).redIAdd(l).redIAdd(e.redMul(a)),
        v = n.redAdd(n)
    v = v.redIAdd(v)
    var _ = v.redMul(c),
        A = g.redSqr().redISub(_.redAdd(_)),
        B = _.redISub(A),
        D = c.redSqr()
    ;(D = D.redIAdd(D)), (D = D.redIAdd(D)), (D = D.redIAdd(D))
    var I = g.redMul(B).redISub(D),
        L = i.redAdd(i).redMul(o)
    return this.curve.jpoint(A, I, L)
}
JPoint.prototype.trpl = function () {
    if (!this.curve.zeroA) return this.dbl().add(this)
    var e = this.x.redSqr(),
        n = this.y.redSqr(),
        i = this.z.redSqr(),
        o = n.redSqr(),
        a = e.redAdd(e).redIAdd(e),
        l = a.redSqr(),
        c = this.x.redAdd(n).redSqr().redISub(e).redISub(o)
    ;(c = c.redIAdd(c)), (c = c.redAdd(c).redIAdd(c)), (c = c.redISub(l))
    var g = c.redSqr(),
        v = o.redIAdd(o)
    ;(v = v.redIAdd(v)), (v = v.redIAdd(v)), (v = v.redIAdd(v))
    var _ = a.redIAdd(c).redSqr().redISub(l).redISub(g).redISub(v),
        A = n.redMul(_)
    ;(A = A.redIAdd(A)), (A = A.redIAdd(A))
    var B = this.x.redMul(g).redISub(A)
    ;(B = B.redIAdd(B)), (B = B.redIAdd(B))
    var D = this.y.redMul(_.redMul(v.redISub(_)).redISub(c.redMul(g)))
    ;(D = D.redIAdd(D)), (D = D.redIAdd(D)), (D = D.redIAdd(D))
    var I = this.z.redAdd(c).redSqr().redISub(i).redISub(g)
    return this.curve.jpoint(B, D, I)
}
JPoint.prototype.mul = function (e, n) {
    return (e = new BN(e, n)), this.curve._wnafMul(this, e)
}
JPoint.prototype.eq = function (e) {
    if (e.type === "affine") return this.eq(e.toJ())
    if (this === e) return !0
    var n = this.z.redSqr(),
        i = e.z.redSqr()
    if (this.x.redMul(i).redISub(e.x.redMul(n)).cmpn(0) !== 0) return !1
    var o = n.redMul(this.z),
        a = i.redMul(e.z)
    return this.y.redMul(a).redISub(e.y.redMul(o)).cmpn(0) === 0
}
JPoint.prototype.eqXToP = function (e) {
    var n = this.z.redSqr(),
        i = e.toRed(this.curve.red).redMul(n)
    if (this.x.cmp(i) === 0) return !0
    for (var o = e.clone(), a = this.curve.redN.redMul(n); ; ) {
        if ((o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)) return !1
        if ((i.redIAdd(a), this.x.cmp(i) === 0)) return !0
    }
}
JPoint.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC JPoint Infinity>"
        : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
}
JPoint.prototype.isInfinity = function () {
    return this.z.cmpn(0) === 0
}
var curve_1 = createCommonjsModule(function (t, e) {
        var n = e
        ;(n.base = base$1), (n.short = short_1), (n.mont = null), (n.edwards = null)
    }),
    curves_1 = createCommonjsModule(function (t, e) {
        var n = e,
            i = utils_1$1.assert
        function o(c) {
            c.type === "short"
                ? (this.curve = new curve_1.short(c))
                : c.type === "edwards"
                ? (this.curve = new curve_1.edwards(c))
                : (this.curve = new curve_1.mont(c)),
                (this.g = this.curve.g),
                (this.n = this.curve.n),
                (this.hash = c.hash),
                i(this.g.validate(), "Invalid curve"),
                i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        n.PresetCurve = o
        function a(c, g) {
            Object.defineProperty(n, c, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                    var v = new o(g)
                    return Object.defineProperty(n, c, { configurable: !0, enumerable: !0, value: v }), v
                },
            })
        }
        a("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: hash$2.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"],
        }),
            a("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: hash$2.sha256,
                gRed: !1,
                g: [
                    "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                    "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
                ],
            }),
            a("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: hash$2.sha256,
                gRed: !1,
                g: [
                    "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                    "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
                ],
            }),
            a("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: hash$2.sha384,
                gRed: !1,
                g: [
                    "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                    "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
                ],
            }),
            a("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: hash$2.sha512,
                gRed: !1,
                g: [
                    "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                    "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
                ],
            }),
            a("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hash$2.sha256,
                gRed: !1,
                g: ["9"],
            }),
            a("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: hash$2.sha256,
                gRed: !1,
                g: [
                    "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                    "6666666666666666666666666666666666666666666666666666666666666658",
                ],
            })
        var l
        try {
            l = null.crash()
        } catch {
            l = void 0
        }
        a("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: hash$2.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                { a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" },
                { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" },
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                l,
            ],
        })
    })
function HmacDRBG(t) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(t)
    ;(this.hash = t.hash),
        (this.predResist = !!t.predResist),
        (this.outLen = this.hash.outSize),
        (this.minEntropy = t.minEntropy || this.hash.hmacStrength),
        (this._reseed = null),
        (this.reseedInterval = null),
        (this.K = null),
        (this.V = null)
    var e = utils_1.toArray(t.entropy, t.entropyEnc || "hex"),
        n = utils_1.toArray(t.nonce, t.nonceEnc || "hex"),
        i = utils_1.toArray(t.pers, t.persEnc || "hex")
    minimalisticAssert(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, n, i)
}
var hmacDrbg = HmacDRBG
HmacDRBG.prototype._init = function (e, n, i) {
    var o = e.concat(n).concat(i)
    ;(this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8))
    for (var a = 0; a < this.V.length; a++) (this.K[a] = 0), (this.V[a] = 1)
    this._update(o), (this._reseed = 1), (this.reseedInterval = 281474976710656)
}
HmacDRBG.prototype._hmac = function () {
    return new hash$2.hmac(this.hash, this.K)
}
HmacDRBG.prototype._update = function (e) {
    var n = this._hmac().update(this.V).update([0])
    e && (n = n.update(e)),
        (this.K = n.digest()),
        (this.V = this._hmac().update(this.V).digest()),
        e && ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()), (this.V = this._hmac().update(this.V).digest()))
}
HmacDRBG.prototype.reseed = function (e, n, i, o) {
    typeof n != "string" && ((o = i), (i = n), (n = null)),
        (e = utils_1.toArray(e, n)),
        (i = utils_1.toArray(i, o)),
        minimalisticAssert(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update(e.concat(i || [])),
        (this._reseed = 1)
}
HmacDRBG.prototype.generate = function (e, n, i, o) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required")
    typeof n != "string" && ((o = i), (i = n), (n = null)), i && ((i = utils_1.toArray(i, o || "hex")), this._update(i))
    for (var a = []; a.length < e; ) (this.V = this._hmac().update(this.V).digest()), (a = a.concat(this.V))
    var l = a.slice(0, e)
    return this._update(i), this._reseed++, utils_1.encode(l, n)
}
var assert$3 = utils_1$1.assert
function KeyPair(t, e) {
    ;(this.ec = t),
        (this.priv = null),
        (this.pub = null),
        e.priv && this._importPrivate(e.priv, e.privEnc),
        e.pub && this._importPublic(e.pub, e.pubEnc)
}
var key = KeyPair
KeyPair.fromPublic = function (e, n, i) {
    return n instanceof KeyPair ? n : new KeyPair(e, { pub: n, pubEnc: i })
}
KeyPair.fromPrivate = function (e, n, i) {
    return n instanceof KeyPair ? n : new KeyPair(e, { priv: n, privEnc: i })
}
KeyPair.prototype.validate = function () {
    var e = this.getPublic()
    return e.isInfinity()
        ? { result: !1, reason: "Invalid public key" }
        : e.validate()
        ? e.mul(this.ec.curve.n).isInfinity()
            ? { result: !0, reason: null }
            : { result: !1, reason: "Public key * N != O" }
        : { result: !1, reason: "Public key is not a point" }
}
KeyPair.prototype.getPublic = function (e, n) {
    return typeof e == "string" && ((n = e), (e = null)), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, e) : this.pub
}
KeyPair.prototype.getPrivate = function (e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
}
KeyPair.prototype._importPrivate = function (e, n) {
    ;(this.priv = new BN(e, n || 16)), (this.priv = this.priv.umod(this.ec.curve.n))
}
KeyPair.prototype._importPublic = function (e, n) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont"
            ? assert$3(e.x, "Need x coordinate")
            : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3(e.x && e.y, "Need both x and y coordinate"),
            (this.pub = this.ec.curve.point(e.x, e.y))
        return
    }
    this.pub = this.ec.curve.decodePoint(e, n)
}
KeyPair.prototype.derive = function (e) {
    return e.validate() || assert$3(e.validate(), "public point not validated"), e.mul(this.priv).getX()
}
KeyPair.prototype.sign = function (e, n, i) {
    return this.ec.sign(e, this, n, i)
}
KeyPair.prototype.verify = function (e, n) {
    return this.ec.verify(e, n, this)
}
KeyPair.prototype.inspect = function () {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
}
var assert$4 = utils_1$1.assert
function Signature(t, e) {
    if (t instanceof Signature) return t
    this._importDER(t, e) ||
        (assert$4(t.r && t.s, "Signature without r or s"),
        (this.r = new BN(t.r, 16)),
        (this.s = new BN(t.s, 16)),
        t.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = t.recoveryParam))
}
var signature = Signature
function Position() {
    this.place = 0
}
function getLength(t, e) {
    var n = t[e.place++]
    if (!(n & 128)) return n
    var i = n & 15
    if (i === 0 || i > 4) return !1
    for (var o = 0, a = 0, l = e.place; a < i; a++, l++) (o <<= 8), (o |= t[l]), (o >>>= 0)
    return o <= 127 ? !1 : ((e.place = l), o)
}
function rmPadding(t) {
    for (var e = 0, n = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < n; ) e++
    return e === 0 ? t : t.slice(e)
}
Signature.prototype._importDER = function (e, n) {
    e = utils_1$1.toArray(e, n)
    var i = new Position()
    if (e[i.place++] !== 48) return !1
    var o = getLength(e, i)
    if (o === !1 || o + i.place !== e.length || e[i.place++] !== 2) return !1
    var a = getLength(e, i)
    if (a === !1) return !1
    var l = e.slice(i.place, a + i.place)
    if (((i.place += a), e[i.place++] !== 2)) return !1
    var c = getLength(e, i)
    if (c === !1 || e.length !== c + i.place) return !1
    var g = e.slice(i.place, c + i.place)
    if (l[0] === 0)
        if (l[1] & 128) l = l.slice(1)
        else return !1
    if (g[0] === 0)
        if (g[1] & 128) g = g.slice(1)
        else return !1
    return (this.r = new BN(l)), (this.s = new BN(g)), (this.recoveryParam = null), !0
}
function constructLength(t, e) {
    if (e < 128) {
        t.push(e)
        return
    }
    var n = 1 + ((Math.log(e) / Math.LN2) >>> 3)
    for (t.push(n | 128); --n; ) t.push((e >>> (n << 3)) & 255)
    t.push(e)
}
Signature.prototype.toDER = function (e) {
    var n = this.r.toArray(),
        i = this.s.toArray()
    for (n[0] & 128 && (n = [0].concat(n)), i[0] & 128 && (i = [0].concat(i)), n = rmPadding(n), i = rmPadding(i); !i[0] && !(i[1] & 128); )
        i = i.slice(1)
    var o = [2]
    constructLength(o, n.length), (o = o.concat(n)), o.push(2), constructLength(o, i.length)
    var a = o.concat(i),
        l = [48]
    return constructLength(l, a.length), (l = l.concat(a)), utils_1$1.encode(l, e)
}
var rand = function () {
        throw new Error("unsupported")
    },
    assert$5 = utils_1$1.assert
function EC(t) {
    if (!(this instanceof EC)) return new EC(t)
    typeof t == "string" && (assert$5(Object.prototype.hasOwnProperty.call(curves_1, t), "Unknown curve " + t), (t = curves_1[t])),
        t instanceof curves_1.PresetCurve && (t = { curve: t }),
        (this.curve = t.curve.curve),
        (this.n = this.curve.n),
        (this.nh = this.n.ushrn(1)),
        (this.g = this.curve.g),
        (this.g = t.curve.g),
        this.g.precompute(t.curve.n.bitLength() + 1),
        (this.hash = t.hash || t.curve.hash)
}
var ec = EC
EC.prototype.keyPair = function (e) {
    return new key(this, e)
}
EC.prototype.keyFromPrivate = function (e, n) {
    return key.fromPrivate(this, e, n)
}
EC.prototype.keyFromPublic = function (e, n) {
    return key.fromPublic(this, e, n)
}
EC.prototype.genKeyPair = function (e) {
    e || (e = {})
    for (
        var n = new hmacDrbg({
                hash: this.hash,
                pers: e.pers,
                persEnc: e.persEnc || "utf8",
                entropy: e.entropy || rand(this.hash.hmacStrength),
                entropyEnc: (e.entropy && e.entropyEnc) || "utf8",
                nonce: this.n.toArray(),
            }),
            i = this.n.byteLength(),
            o = this.n.sub(new BN(2));
        ;

    ) {
        var a = new BN(n.generate(i))
        if (!(a.cmp(o) > 0)) return a.iaddn(1), this.keyFromPrivate(a)
    }
}
EC.prototype._truncateToN = function (e, n) {
    var i = e.byteLength() * 8 - this.n.bitLength()
    return i > 0 && (e = e.ushrn(i)), !n && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
}
EC.prototype.sign = function (e, n, i, o) {
    typeof i == "object" && ((o = i), (i = null)), o || (o = {}), (n = this.keyFromPrivate(n, i)), (e = this._truncateToN(new BN(e, 16)))
    for (
        var a = this.n.byteLength(),
            l = n.getPrivate().toArray("be", a),
            c = e.toArray("be", a),
            g = new hmacDrbg({ hash: this.hash, entropy: l, nonce: c, pers: o.pers, persEnc: o.persEnc || "utf8" }),
            v = this.n.sub(new BN(1)),
            _ = 0;
        ;
        _++
    ) {
        var A = o.k ? o.k(_) : new BN(g.generate(this.n.byteLength()))
        if (((A = this._truncateToN(A, !0)), !(A.cmpn(1) <= 0 || A.cmp(v) >= 0))) {
            var B = this.g.mul(A)
            if (!B.isInfinity()) {
                var D = B.getX(),
                    I = D.umod(this.n)
                if (I.cmpn(0) !== 0) {
                    var L = A.invm(this.n).mul(I.mul(n.getPrivate()).iadd(e))
                    if (((L = L.umod(this.n)), L.cmpn(0) !== 0)) {
                        var G = (B.getY().isOdd() ? 1 : 0) | (D.cmp(I) !== 0 ? 2 : 0)
                        return (
                            o.canonical && L.cmp(this.nh) > 0 && ((L = this.n.sub(L)), (G ^= 1)), new signature({ r: I, s: L, recoveryParam: G })
                        )
                    }
                }
            }
        }
    }
}
EC.prototype.verify = function (e, n, i, o) {
    ;(e = this._truncateToN(new BN(e, 16))), (i = this.keyFromPublic(i, o)), (n = new signature(n, "hex"))
    var a = n.r,
        l = n.s
    if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0 || l.cmpn(1) < 0 || l.cmp(this.n) >= 0) return !1
    var c = l.invm(this.n),
        g = c.mul(e).umod(this.n),
        v = c.mul(a).umod(this.n),
        _
    return this.curve._maxwellTrick
        ? ((_ = this.g.jmulAdd(g, i.getPublic(), v)), _.isInfinity() ? !1 : _.eqXToP(a))
        : ((_ = this.g.mulAdd(g, i.getPublic(), v)), _.isInfinity() ? !1 : _.getX().umod(this.n).cmp(a) === 0)
}
EC.prototype.recoverPubKey = function (t, e, n, i) {
    assert$5((3 & n) === n, "The recovery param is more than two bits"), (e = new signature(e, i))
    var o = this.n,
        a = new BN(t),
        l = e.r,
        c = e.s,
        g = n & 1,
        v = n >> 1
    if (l.cmp(this.curve.p.umod(this.curve.n)) >= 0 && v) throw new Error("Unable to find sencond key candinate")
    v ? (l = this.curve.pointFromX(l.add(this.curve.n), g)) : (l = this.curve.pointFromX(l, g))
    var _ = e.r.invm(o),
        A = o.sub(a).mul(_).umod(o),
        B = c.mul(_).umod(o)
    return this.g.mulAdd(A, l, B)
}
EC.prototype.getKeyRecoveryParam = function (t, e, n, i) {
    if (((e = new signature(e, i)), e.recoveryParam !== null)) return e.recoveryParam
    for (var o = 0; o < 4; o++) {
        var a
        try {
            a = this.recoverPubKey(t, e, o)
        } catch {
            continue
        }
        if (a.eq(n)) return o
    }
    throw new Error("Unable to find valid recovery factor")
}
var elliptic_1 = createCommonjsModule(function (t, e) {
        var n = e
        ;(n.version = "6.5.4"),
            (n.utils = utils_1$1),
            (n.rand = function () {
                throw new Error("unsupported")
            }),
            (n.curve = curve_1),
            (n.curves = curves_1),
            (n.ec = ec),
            (n.eddsa = null)
    }),
    EC$1 = elliptic_1.ec
const version$8 = "signing-key/5.7.0",
    logger$a = new Logger(version$8)
let _curve = null
function getCurve() {
    return _curve || (_curve = new EC$1("secp256k1")), _curve
}
class SigningKey {
    constructor(e) {
        defineReadOnly(this, "curve", "secp256k1"),
            defineReadOnly(this, "privateKey", hexlify(e)),
            hexDataLength(this.privateKey) !== 32 && logger$a.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]")
        const n = getCurve().keyFromPrivate(arrayify(this.privateKey))
        defineReadOnly(this, "publicKey", "0x" + n.getPublic(!1, "hex")),
            defineReadOnly(this, "compressedPublicKey", "0x" + n.getPublic(!0, "hex")),
            defineReadOnly(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const n = getCurve().keyFromPublic(arrayify(this.publicKey)),
            i = getCurve().keyFromPublic(arrayify(e))
        return "0x" + n.pub.add(i.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const n = getCurve().keyFromPrivate(arrayify(this.privateKey)),
            i = arrayify(e)
        i.length !== 32 && logger$a.throwArgumentError("bad digest length", "digest", e)
        const o = n.sign(i, { canonical: !0 })
        return splitSignature({
            recoveryParam: o.recoveryParam,
            r: hexZeroPad("0x" + o.r.toString(16), 32),
            s: hexZeroPad("0x" + o.s.toString(16), 32),
        })
    }
    computeSharedSecret(e) {
        const n = getCurve().keyFromPrivate(arrayify(this.privateKey)),
            i = getCurve().keyFromPublic(arrayify(computePublicKey(e)))
        return hexZeroPad("0x" + n.derive(i.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}
function recoverPublicKey(t, e) {
    const n = splitSignature(e),
        i = { r: arrayify(n.r), s: arrayify(n.s) }
    return "0x" + getCurve().recoverPubKey(arrayify(t), i, n.recoveryParam).encode("hex", !1)
}
function computePublicKey(t, e) {
    const n = arrayify(t)
    if (n.length === 32) {
        const i = new SigningKey(n)
        return e ? "0x" + getCurve().keyFromPrivate(n).getPublic(!0, "hex") : i.publicKey
    } else {
        if (n.length === 33) return e ? hexlify(n) : "0x" + getCurve().keyFromPublic(n).getPublic(!1, "hex")
        if (n.length === 65) return e ? "0x" + getCurve().keyFromPublic(n).getPublic(!0, "hex") : hexlify(n)
    }
    return logger$a.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const version$7 = "transactions/5.7.0",
    logger$9 = new Logger(version$7)
var TransactionTypes
;(function (t) {
    ;(t[(t.legacy = 0)] = "legacy"), (t[(t.eip2930 = 1)] = "eip2930"), (t[(t.eip1559 = 2)] = "eip1559")
})(TransactionTypes || (TransactionTypes = {}))
function handleAddress(t) {
    return t === "0x" ? null : getAddress(t)
}
function handleNumber(t) {
    return t === "0x" ? Zero$1 : BigNumber.from(t)
}
function computeAddress(t) {
    const e = computePublicKey(t)
    return getAddress(hexDataSlice(keccak256(hexDataSlice(e, 1)), 12))
}
function recoverAddress(t, e) {
    return computeAddress(recoverPublicKey(arrayify(t), e))
}
function formatNumber(t, e) {
    const n = stripZeros(BigNumber.from(t).toHexString())
    return n.length > 32 && logger$9.throwArgumentError("invalid length for " + e, "transaction:" + e, t), n
}
function accessSetify(t, e) {
    return {
        address: getAddress(t),
        storageKeys: (e || []).map(
            (n, i) => (
                hexDataLength(n) !== 32 && logger$9.throwArgumentError("invalid access list storageKey", `accessList[${t}:${i}]`, n),
                n.toLowerCase()
            )
        ),
    }
}
function accessListify(t) {
    if (Array.isArray(t))
        return t.map((n, i) =>
            Array.isArray(n)
                ? (n.length > 2 && logger$9.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${i}]`, n),
                  accessSetify(n[0], n[1]))
                : accessSetify(n.address, n.storageKeys)
        )
    const e = Object.keys(t).map((n) => {
        const i = t[n].reduce((o, a) => ((o[a] = !0), o), {})
        return accessSetify(n, Object.keys(i).sort())
    })
    return e.sort((n, i) => n.address.localeCompare(i.address)), e
}
function formatAccessList(t) {
    return accessListify(t).map((e) => [e.address, e.storageKeys])
}
function _serializeEip1559(t, e) {
    if (t.gasPrice != null) {
        const i = BigNumber.from(t.gasPrice),
            o = BigNumber.from(t.maxFeePerGas || 0)
        i.eq(o) || logger$9.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", { gasPrice: i, maxFeePerGas: o })
    }
    const n = [
        formatNumber(t.chainId || 0, "chainId"),
        formatNumber(t.nonce || 0, "nonce"),
        formatNumber(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(t.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(t.gasLimit || 0, "gasLimit"),
        t.to != null ? getAddress(t.to) : "0x",
        formatNumber(t.value || 0, "value"),
        t.data || "0x",
        formatAccessList(t.accessList || []),
    ]
    if (e) {
        const i = splitSignature(e)
        n.push(formatNumber(i.recoveryParam, "recoveryParam")), n.push(stripZeros(i.r)), n.push(stripZeros(i.s))
    }
    return hexConcat(["0x02", encode$h(n)])
}
function _serializeEip2930(t, e) {
    const n = [
        formatNumber(t.chainId || 0, "chainId"),
        formatNumber(t.nonce || 0, "nonce"),
        formatNumber(t.gasPrice || 0, "gasPrice"),
        formatNumber(t.gasLimit || 0, "gasLimit"),
        t.to != null ? getAddress(t.to) : "0x",
        formatNumber(t.value || 0, "value"),
        t.data || "0x",
        formatAccessList(t.accessList || []),
    ]
    if (e) {
        const i = splitSignature(e)
        n.push(formatNumber(i.recoveryParam, "recoveryParam")), n.push(stripZeros(i.r)), n.push(stripZeros(i.s))
    }
    return hexConcat(["0x01", encode$h(n)])
}
function _parseEipSignature(t, e, n) {
    try {
        const i = handleNumber(e[0]).toNumber()
        if (i !== 0 && i !== 1) throw new Error("bad recid")
        t.v = i
    } catch {
        logger$9.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
    }
    ;(t.r = hexZeroPad(e[1], 32)), (t.s = hexZeroPad(e[2], 32))
    try {
        const i = keccak256(n(t))
        t.from = recoverAddress(i, { r: t.r, s: t.s, recoveryParam: t.v })
    } catch {}
}
function _parseEip1559(t) {
    const e = decode$i(t.slice(1))
    e.length !== 9 && e.length !== 12 && logger$9.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(t))
    const n = handleNumber(e[2]),
        i = handleNumber(e[3]),
        o = {
            type: 2,
            chainId: handleNumber(e[0]).toNumber(),
            nonce: handleNumber(e[1]).toNumber(),
            maxPriorityFeePerGas: n,
            maxFeePerGas: i,
            gasPrice: null,
            gasLimit: handleNumber(e[4]),
            to: handleAddress(e[5]),
            value: handleNumber(e[6]),
            data: e[7],
            accessList: accessListify(e[8]),
        }
    return e.length === 9 || ((o.hash = keccak256(t)), _parseEipSignature(o, e.slice(9), _serializeEip1559)), o
}
function _parseEip2930(t) {
    const e = decode$i(t.slice(1))
    e.length !== 8 && e.length !== 11 && logger$9.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(t))
    const n = {
        type: 1,
        chainId: handleNumber(e[0]).toNumber(),
        nonce: handleNumber(e[1]).toNumber(),
        gasPrice: handleNumber(e[2]),
        gasLimit: handleNumber(e[3]),
        to: handleAddress(e[4]),
        value: handleNumber(e[5]),
        data: e[6],
        accessList: accessListify(e[7]),
    }
    return e.length === 8 || ((n.hash = keccak256(t)), _parseEipSignature(n, e.slice(8), _serializeEip2930)), n
}
function _parse(t) {
    const e = decode$i(t)
    e.length !== 9 && e.length !== 6 && logger$9.throwArgumentError("invalid raw transaction", "rawTransaction", t)
    const n = {
        nonce: handleNumber(e[0]).toNumber(),
        gasPrice: handleNumber(e[1]),
        gasLimit: handleNumber(e[2]),
        to: handleAddress(e[3]),
        value: handleNumber(e[4]),
        data: e[5],
        chainId: 0,
    }
    if (e.length === 6) return n
    try {
        n.v = BigNumber.from(e[6]).toNumber()
    } catch {
        return n
    }
    if (((n.r = hexZeroPad(e[7], 32)), (n.s = hexZeroPad(e[8], 32)), BigNumber.from(n.r).isZero() && BigNumber.from(n.s).isZero()))
        (n.chainId = n.v), (n.v = 0)
    else {
        ;(n.chainId = Math.floor((n.v - 35) / 2)), n.chainId < 0 && (n.chainId = 0)
        let i = n.v - 27
        const o = e.slice(0, 6)
        n.chainId !== 0 && (o.push(hexlify(n.chainId)), o.push("0x"), o.push("0x"), (i -= n.chainId * 2 + 8))
        const a = keccak256(encode$h(o))
        try {
            n.from = recoverAddress(a, { r: hexlify(n.r), s: hexlify(n.s), recoveryParam: i })
        } catch {}
        n.hash = keccak256(t)
    }
    return (n.type = null), n
}
function parse$2(t) {
    const e = arrayify(t)
    if (e[0] > 127) return _parse(e)
    switch (e[0]) {
        case 1:
            return _parseEip2930(e)
        case 2:
            return _parseEip1559(e)
    }
    return logger$9.throwError(`unsupported transaction type: ${e[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: e[0],
    })
}
const version$6 = "contracts/5.7.0"
var __awaiter$5 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$8 = new Logger(version$6),
    allowedTransactionKeys$1 = {
        chainId: !0,
        data: !0,
        from: !0,
        gasLimit: !0,
        gasPrice: !0,
        nonce: !0,
        to: !0,
        value: !0,
        type: !0,
        accessList: !0,
        maxFeePerGas: !0,
        maxPriorityFeePerGas: !0,
        customData: !0,
        ccipReadEnabled: !0,
    }
function resolveName(t, e) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const n = yield e
        typeof n != "string" && logger$8.throwArgumentError("invalid address or ENS name", "name", n)
        try {
            return getAddress(n)
        } catch {}
        t ||
            logger$8.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
            })
        const i = yield t.resolveName(n)
        return i == null && logger$8.throwArgumentError("resolver or addr is not configured for ENS name", "name", n), i
    })
}
function resolveAddresses(t, e, n) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return Array.isArray(n)
            ? yield Promise.all(n.map((i, o) => resolveAddresses(t, Array.isArray(e) ? e[o] : e[i.name], i)))
            : n.type === "address"
            ? yield resolveName(t, e)
            : n.type === "tuple"
            ? yield resolveAddresses(t, e, n.components)
            : n.baseType === "array"
            ? Array.isArray(e)
                ? yield Promise.all(e.map((i) => resolveAddresses(t, i, n.arrayChildren)))
                : Promise.reject(logger$8.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, { argument: "value", value: e }))
            : e
    })
}
function populateTransaction(t, e, n) {
    return __awaiter$5(this, void 0, void 0, function* () {
        let i = {}
        n.length === e.inputs.length + 1 && typeof n[n.length - 1] == "object" && (i = shallowCopy(n.pop())),
            logger$8.checkArgumentCount(n.length, e.inputs.length, "passed to contract"),
            t.signer
                ? i.from
                    ? (i.from = resolveProperties({ override: resolveName(t.signer, i.from), signer: t.signer.getAddress() }).then((v) =>
                          __awaiter$5(this, void 0, void 0, function* () {
                              return (
                                  getAddress(v.signer) !== v.override &&
                                      logger$8.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                                          operation: "overrides.from",
                                      }),
                                  v.override
                              )
                          })
                      ))
                    : (i.from = t.signer.getAddress())
                : i.from && (i.from = resolveName(t.provider, i.from))
        const o = yield resolveProperties({
                args: resolveAddresses(t.signer || t.provider, n, e.inputs),
                address: t.resolvedAddress,
                overrides: resolveProperties(i) || {},
            }),
            a = t.interface.encodeFunctionData(e, o.args),
            l = { data: a, to: o.address },
            c = o.overrides
        if (
            (c.nonce != null && (l.nonce = BigNumber.from(c.nonce).toNumber()),
            c.gasLimit != null && (l.gasLimit = BigNumber.from(c.gasLimit)),
            c.gasPrice != null && (l.gasPrice = BigNumber.from(c.gasPrice)),
            c.maxFeePerGas != null && (l.maxFeePerGas = BigNumber.from(c.maxFeePerGas)),
            c.maxPriorityFeePerGas != null && (l.maxPriorityFeePerGas = BigNumber.from(c.maxPriorityFeePerGas)),
            c.from != null && (l.from = c.from),
            c.type != null && (l.type = c.type),
            c.accessList != null && (l.accessList = accessListify(c.accessList)),
            l.gasLimit == null && e.gas != null)
        ) {
            let v = 21e3
            const _ = arrayify(a)
            for (let A = 0; A < _.length; A++) (v += 4), _[A] && (v += 64)
            l.gasLimit = BigNumber.from(e.gas).add(v)
        }
        if (c.value) {
            const v = BigNumber.from(c.value)
            !v.isZero() &&
                !e.payable &&
                logger$8.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: i.value,
                }),
                (l.value = v)
        }
        c.customData && (l.customData = shallowCopy(c.customData)),
            c.ccipReadEnabled && (l.ccipReadEnabled = !!c.ccipReadEnabled),
            delete i.nonce,
            delete i.gasLimit,
            delete i.gasPrice,
            delete i.from,
            delete i.value,
            delete i.type,
            delete i.accessList,
            delete i.maxFeePerGas,
            delete i.maxPriorityFeePerGas,
            delete i.customData,
            delete i.ccipReadEnabled
        const g = Object.keys(i).filter((v) => i[v] != null)
        return (
            g.length &&
                logger$8.throwError(`cannot override ${g.map((v) => JSON.stringify(v)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides",
                    overrides: g,
                }),
            l
        )
    })
}
function buildPopulate(t, e) {
    return function (...n) {
        return populateTransaction(t, e, n)
    }
}
function buildEstimate(t, e) {
    const n = t.signer || t.provider
    return function (...i) {
        return __awaiter$5(this, void 0, void 0, function* () {
            n || logger$8.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "estimateGas" })
            const o = yield populateTransaction(t, e, i)
            return yield n.estimateGas(o)
        })
    }
}
function addContractWait(t, e) {
    const n = e.wait.bind(e)
    e.wait = (i) =>
        n(i).then(
            (o) => (
                (o.events = o.logs.map((a) => {
                    let l = deepCopy(a),
                        c = null
                    try {
                        c = t.interface.parseLog(a)
                    } catch {}
                    return (
                        c &&
                            ((l.args = c.args),
                            (l.decode = (g, v) => t.interface.decodeEventLog(c.eventFragment, g, v)),
                            (l.event = c.name),
                            (l.eventSignature = c.signature)),
                        (l.removeListener = () => t.provider),
                        (l.getBlock = () => t.provider.getBlock(o.blockHash)),
                        (l.getTransaction = () => t.provider.getTransaction(o.transactionHash)),
                        (l.getTransactionReceipt = () => Promise.resolve(o)),
                        l
                    )
                })),
                o
            )
        )
}
function buildCall(t, e, n) {
    const i = t.signer || t.provider
    return function (...o) {
        return __awaiter$5(this, void 0, void 0, function* () {
            let a
            if (o.length === e.inputs.length + 1 && typeof o[o.length - 1] == "object") {
                const g = shallowCopy(o.pop())
                g.blockTag != null && (a = yield g.blockTag), delete g.blockTag, o.push(g)
            }
            t.deployTransaction != null && (yield t._deployed(a))
            const l = yield populateTransaction(t, e, o),
                c = yield i.call(l, a)
            try {
                let g = t.interface.decodeFunctionResult(e, c)
                return n && e.outputs.length === 1 && (g = g[0]), g
            } catch (g) {
                throw (g.code === Logger.errors.CALL_EXCEPTION && ((g.address = t.address), (g.args = o), (g.transaction = l)), g)
            }
        })
    }
}
function buildSend(t, e) {
    return function (...n) {
        return __awaiter$5(this, void 0, void 0, function* () {
            t.signer ||
                logger$8.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction",
                }),
                t.deployTransaction != null && (yield t._deployed())
            const i = yield populateTransaction(t, e, n),
                o = yield t.signer.sendTransaction(i)
            return addContractWait(t, o), o
        })
    }
}
function buildDefault(t, e, n) {
    return e.constant ? buildCall(t, e, n) : buildSend(t, e)
}
function getEventTag$1(t) {
    return t.address && (t.topics == null || t.topics.length === 0)
        ? "*"
        : (t.address || "*") + "@" + (t.topics ? t.topics.map((e) => (Array.isArray(e) ? e.join("|") : e)).join(":") : "")
}
class RunningEvent {
    constructor(e, n) {
        defineReadOnly(this, "tag", e), defineReadOnly(this, "filter", n), (this._listeners = [])
    }
    addListener(e, n) {
        this._listeners.push({ listener: e, once: n })
    }
    removeListener(e) {
        let n = !1
        this._listeners = this._listeners.filter((i) => (n || i.listener !== e ? !0 : ((n = !0), !1)))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map((e) => e.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(e) {
        const n = this.listenerCount()
        return (
            (this._listeners = this._listeners.filter((i) => {
                const o = e.slice()
                return (
                    setTimeout(() => {
                        i.listener.apply(this, o)
                    }, 0),
                    !i.once
                )
            })),
            n
        )
    }
    prepareEvent(e) {}
    getEmit(e) {
        return [e]
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor() {
        super("error", null)
    }
}
class FragmentRunningEvent extends RunningEvent {
    constructor(e, n, i, o) {
        const a = { address: e }
        let l = n.getEventTopic(i)
        o ? (l !== o[0] && logger$8.throwArgumentError("topic mismatch", "topics", o), (a.topics = o.slice())) : (a.topics = [l]),
            super(getEventTag$1(a), a),
            defineReadOnly(this, "address", e),
            defineReadOnly(this, "interface", n),
            defineReadOnly(this, "fragment", i)
    }
    prepareEvent(e) {
        super.prepareEvent(e),
            (e.event = this.fragment.name),
            (e.eventSignature = this.fragment.format()),
            (e.decode = (n, i) => this.interface.decodeEventLog(this.fragment, n, i))
        try {
            e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
        } catch (n) {
            ;(e.args = null), (e.decodeError = n)
        }
    }
    getEmit(e) {
        const n = checkResultErrors(e.args)
        if (n.length) throw n[0].error
        const i = (e.args || []).slice()
        return i.push(e), i
    }
}
class WildcardRunningEvent extends RunningEvent {
    constructor(e, n) {
        super("*", { address: e }), defineReadOnly(this, "address", e), defineReadOnly(this, "interface", n)
    }
    prepareEvent(e) {
        super.prepareEvent(e)
        try {
            const n = this.interface.parseLog(e)
            ;(e.event = n.name),
                (e.eventSignature = n.signature),
                (e.decode = (i, o) => this.interface.decodeEventLog(n.eventFragment, i, o)),
                (e.args = n.args)
        } catch {}
    }
}
class BaseContract {
    constructor(e, n, i) {
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(n)),
            i == null
                ? (defineReadOnly(this, "provider", null), defineReadOnly(this, "signer", null))
                : Signer.isSigner(i)
                ? (defineReadOnly(this, "provider", i.provider || null), defineReadOnly(this, "signer", i))
                : Provider$1.isProvider(i)
                ? (defineReadOnly(this, "provider", i), defineReadOnly(this, "signer", null))
                : logger$8.throwArgumentError("invalid signer or provider", "signerOrProvider", i),
            defineReadOnly(this, "callStatic", {}),
            defineReadOnly(this, "estimateGas", {}),
            defineReadOnly(this, "functions", {}),
            defineReadOnly(this, "populateTransaction", {}),
            defineReadOnly(this, "filters", {})
        {
            const l = {}
            Object.keys(this.interface.events).forEach((c) => {
                const g = this.interface.events[c]
                defineReadOnly(this.filters, c, (...v) => ({ address: this.address, topics: this.interface.encodeFilterTopics(g, v) })),
                    l[g.name] || (l[g.name] = []),
                    l[g.name].push(c)
            }),
                Object.keys(l).forEach((c) => {
                    const g = l[c]
                    g.length === 1
                        ? defineReadOnly(this.filters, c, this.filters[g[0]])
                        : logger$8.warn(`Duplicate definition of ${c} (${g.join(", ")})`)
                })
        }
        if (
            (defineReadOnly(this, "_runningEvents", {}),
            defineReadOnly(this, "_wrappedEmits", {}),
            e == null && logger$8.throwArgumentError("invalid contract address or ENS name", "addressOrName", e),
            defineReadOnly(this, "address", e),
            this.provider)
        )
            defineReadOnly(this, "resolvedAddress", resolveName(this.provider, e))
        else
            try {
                defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(e)))
            } catch {
                logger$8.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract",
                })
            }
        this.resolvedAddress.catch((l) => {})
        const o = {},
            a = {}
        Object.keys(this.interface.functions).forEach((l) => {
            const c = this.interface.functions[l]
            if (a[l]) {
                logger$8.warn(`Duplicate ABI entry for ${JSON.stringify(l)}`)
                return
            }
            a[l] = !0
            {
                const g = c.name
                o[`%${g}`] || (o[`%${g}`] = []), o[`%${g}`].push(l)
            }
            this[l] == null && defineReadOnly(this, l, buildDefault(this, c, !0)),
                this.functions[l] == null && defineReadOnly(this.functions, l, buildDefault(this, c, !1)),
                this.callStatic[l] == null && defineReadOnly(this.callStatic, l, buildCall(this, c, !0)),
                this.populateTransaction[l] == null && defineReadOnly(this.populateTransaction, l, buildPopulate(this, c)),
                this.estimateGas[l] == null && defineReadOnly(this.estimateGas, l, buildEstimate(this, c))
        }),
            Object.keys(o).forEach((l) => {
                const c = o[l]
                if (c.length > 1) return
                l = l.substring(1)
                const g = c[0]
                try {
                    this[l] == null && defineReadOnly(this, l, this[g])
                } catch {}
                this.functions[l] == null && defineReadOnly(this.functions, l, this.functions[g]),
                    this.callStatic[l] == null && defineReadOnly(this.callStatic, l, this.callStatic[g]),
                    this.populateTransaction[l] == null && defineReadOnly(this.populateTransaction, l, this.populateTransaction[g]),
                    this.estimateGas[l] == null && defineReadOnly(this.estimateGas, l, this.estimateGas[g])
            })
    }
    static getContractAddress(e) {
        return getContractAddress(e)
    }
    static getInterface(e) {
        return Interface.isInterface(e) ? e : new Interface(e)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(e) {
        return (
            this._deployedPromise ||
                (this.deployTransaction
                    ? (this._deployedPromise = this.deployTransaction.wait().then(() => this))
                    : (this._deployedPromise = this.provider
                          .getCode(this.address, e)
                          .then(
                              (n) => (
                                  n === "0x" &&
                                      logger$8.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                                          contractAddress: this.address,
                                          operation: "getDeployed",
                                      }),
                                  this
                              )
                          ))),
            this._deployedPromise
        )
    }
    fallback(e) {
        this.signer ||
            logger$8.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction(fallback)",
            })
        const n = shallowCopy(e || {})
        return (
            ["from", "to"].forEach(function (i) {
                n[i] != null && logger$8.throwError("cannot override " + i, Logger.errors.UNSUPPORTED_OPERATION, { operation: i })
            }),
            (n.to = this.resolvedAddress),
            this.deployed().then(() => this.signer.sendTransaction(n))
        )
    }
    connect(e) {
        typeof e == "string" && (e = new VoidSigner(e, this.provider))
        const n = new this.constructor(this.address, this.interface, e)
        return this.deployTransaction && defineReadOnly(n, "deployTransaction", this.deployTransaction), n
    }
    attach(e) {
        return new this.constructor(e, this.interface, this.signer || this.provider)
    }
    static isIndexed(e) {
        return Indexed.isIndexed(e)
    }
    _normalizeRunningEvent(e) {
        return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
    }
    _getRunningEvent(e) {
        if (typeof e == "string") {
            if (e === "error") return this._normalizeRunningEvent(new ErrorRunningEvent())
            if (e === "event") return this._normalizeRunningEvent(new RunningEvent("event", null))
            if (e === "*") return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface))
            const n = this.interface.getEvent(e)
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, n))
        }
        if (e.topics && e.topics.length > 0) {
            try {
                const i = e.topics[0]
                if (typeof i != "string") throw new Error("invalid topic")
                const o = this.interface.getEvent(i)
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, o, e.topics))
            } catch {}
            const n = { address: this.address, topics: e.topics }
            return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(n), n))
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface))
    }
    _checkRunningEvents(e) {
        if (e.listenerCount() === 0) {
            delete this._runningEvents[e.tag]
            const n = this._wrappedEmits[e.tag]
            n && e.filter && (this.provider.off(e.filter, n), delete this._wrappedEmits[e.tag])
        }
    }
    _wrapEvent(e, n, i) {
        const o = deepCopy(n)
        return (
            (o.removeListener = () => {
                !i || (e.removeListener(i), this._checkRunningEvents(e))
            }),
            (o.getBlock = () => this.provider.getBlock(n.blockHash)),
            (o.getTransaction = () => this.provider.getTransaction(n.transactionHash)),
            (o.getTransactionReceipt = () => this.provider.getTransactionReceipt(n.transactionHash)),
            e.prepareEvent(o),
            o
        )
    }
    _addEventListener(e, n, i) {
        if (
            (this.provider ||
                logger$8.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "once",
                }),
            e.addListener(n, i),
            (this._runningEvents[e.tag] = e),
            !this._wrappedEmits[e.tag])
        ) {
            const o = (a) => {
                let l = this._wrapEvent(e, a, n)
                if (l.decodeError == null)
                    try {
                        const c = e.getEmit(l)
                        this.emit(e.filter, ...c)
                    } catch (c) {
                        l.decodeError = c.error
                    }
                e.filter != null && this.emit("event", l), l.decodeError != null && this.emit("error", l.decodeError, l)
            }
            ;(this._wrappedEmits[e.tag] = o), e.filter != null && this.provider.on(e.filter, o)
        }
    }
    queryFilter(e, n, i) {
        const o = this._getRunningEvent(e),
            a = shallowCopy(o.filter)
        return (
            typeof n == "string" && isHexString(n, 32)
                ? (i != null && logger$8.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", i), (a.blockHash = n))
                : ((a.fromBlock = n != null ? n : 0), (a.toBlock = i != null ? i : "latest")),
            this.provider.getLogs(a).then((l) => l.map((c) => this._wrapEvent(o, c, null)))
        )
    }
    on(e, n) {
        return this._addEventListener(this._getRunningEvent(e), n, !1), this
    }
    once(e, n) {
        return this._addEventListener(this._getRunningEvent(e), n, !0), this
    }
    emit(e, ...n) {
        if (!this.provider) return !1
        const i = this._getRunningEvent(e),
            o = i.run(n) > 0
        return this._checkRunningEvents(i), o
    }
    listenerCount(e) {
        return this.provider
            ? e == null
                ? Object.keys(this._runningEvents).reduce((n, i) => n + this._runningEvents[i].listenerCount(), 0)
                : this._getRunningEvent(e).listenerCount()
            : 0
    }
    listeners(e) {
        if (!this.provider) return []
        if (e == null) {
            const n = []
            for (let i in this._runningEvents)
                this._runningEvents[i].listeners().forEach((o) => {
                    n.push(o)
                })
            return n
        }
        return this._getRunningEvent(e).listeners()
    }
    removeAllListeners(e) {
        if (!this.provider) return this
        if (e == null) {
            for (const i in this._runningEvents) {
                const o = this._runningEvents[i]
                o.removeAllListeners(), this._checkRunningEvents(o)
            }
            return this
        }
        const n = this._getRunningEvent(e)
        return n.removeAllListeners(), this._checkRunningEvents(n), this
    }
    off(e, n) {
        if (!this.provider) return this
        const i = this._getRunningEvent(e)
        return i.removeListener(n), this._checkRunningEvents(i), this
    }
    removeListener(e, n) {
        return this.off(e, n)
    }
}
class Contract extends BaseContract {}
class ContractFactory {
    constructor(e, n, i) {
        let o = null
        typeof n == "string" ? (o = n) : isBytes$1(n) ? (o = hexlify(n)) : n && typeof n.object == "string" ? (o = n.object) : (o = "!"),
            o.substring(0, 2) !== "0x" && (o = "0x" + o),
            (!isHexString(o) || o.length % 2) && logger$8.throwArgumentError("invalid bytecode", "bytecode", n),
            i && !Signer.isSigner(i) && logger$8.throwArgumentError("invalid signer", "signer", i),
            defineReadOnly(this, "bytecode", o),
            defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(e)),
            defineReadOnly(this, "signer", i || null)
    }
    getDeployTransaction(...e) {
        let n = {}
        if (e.length === this.interface.deploy.inputs.length + 1 && typeof e[e.length - 1] == "object") {
            n = shallowCopy(e.pop())
            for (const i in n) if (!allowedTransactionKeys$1[i]) throw new Error("unknown transaction override " + i)
        }
        return (
            ["data", "from", "to"].forEach((i) => {
                n[i] != null && logger$8.throwError("cannot override " + i, Logger.errors.UNSUPPORTED_OPERATION, { operation: i })
            }),
            n.value &&
                !BigNumber.from(n.value).isZero() &&
                !this.interface.deploy.payable &&
                logger$8.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: n.value,
                }),
            logger$8.checkArgumentCount(e.length, this.interface.deploy.inputs.length, " in Contract constructor"),
            (n.data = hexlify(concat$2([this.bytecode, this.interface.encodeDeploy(e)]))),
            n
        )
    }
    deploy(...e) {
        return __awaiter$5(this, void 0, void 0, function* () {
            let n = {}
            e.length === this.interface.deploy.inputs.length + 1 && (n = e.pop()),
                logger$8.checkArgumentCount(e.length, this.interface.deploy.inputs.length, " in Contract constructor")
            const i = yield resolveAddresses(this.signer, e, this.interface.deploy.inputs)
            i.push(n)
            const o = this.getDeployTransaction(...i),
                a = yield this.signer.sendTransaction(o),
                l = getStatic(this.constructor, "getContractAddress")(a),
                c = getStatic(this.constructor, "getContract")(l, this.interface, this.signer)
            return addContractWait(c, a), defineReadOnly(c, "deployTransaction", a), c
        })
    }
    attach(e) {
        return this.constructor.getContract(e, this.interface, this.signer)
    }
    connect(e) {
        return new this.constructor(this.interface, this.bytecode, e)
    }
    static fromSolidity(e, n) {
        e == null && logger$8.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" }),
            typeof e == "string" && (e = JSON.parse(e))
        const i = e.abi
        let o = null
        return e.bytecode ? (o = e.bytecode) : e.evm && e.evm.bytecode && (o = e.evm.bytecode), new this(i, o, n)
    }
    static getInterface(e) {
        return Contract.getInterface(e)
    }
    static getContractAddress(e) {
        return getContractAddress(e)
    }
    static getContract(e, n, i) {
        return new Contract(e, n, i)
    }
}
class BaseX {
    constructor(e) {
        defineReadOnly(this, "alphabet", e),
            defineReadOnly(this, "base", e.length),
            defineReadOnly(this, "_alphabetMap", {}),
            defineReadOnly(this, "_leader", e.charAt(0))
        for (let n = 0; n < e.length; n++) this._alphabetMap[e.charAt(n)] = n
    }
    encode(e) {
        let n = arrayify(e)
        if (n.length === 0) return ""
        let i = [0]
        for (let a = 0; a < n.length; ++a) {
            let l = n[a]
            for (let c = 0; c < i.length; ++c) (l += i[c] << 8), (i[c] = l % this.base), (l = (l / this.base) | 0)
            for (; l > 0; ) i.push(l % this.base), (l = (l / this.base) | 0)
        }
        let o = ""
        for (let a = 0; n[a] === 0 && a < n.length - 1; ++a) o += this._leader
        for (let a = i.length - 1; a >= 0; --a) o += this.alphabet[i[a]]
        return o
    }
    decode(e) {
        if (typeof e != "string") throw new TypeError("Expected String")
        let n = []
        if (e.length === 0) return new Uint8Array(n)
        n.push(0)
        for (let i = 0; i < e.length; i++) {
            let o = this._alphabetMap[e[i]]
            if (o === void 0) throw new Error("Non-base" + this.base + " character")
            let a = o
            for (let l = 0; l < n.length; ++l) (a += n[l] * this.base), (n[l] = a & 255), (a >>= 8)
            for (; a > 0; ) n.push(a & 255), (a >>= 8)
        }
        for (let i = 0; e[i] === this._leader && i < e.length - 1; ++i) n.push(0)
        return arrayify(new Uint8Array(n.reverse()))
    }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567")
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    version$5 = "sha2/5.7.0"
new Logger(version$5)
function sha256$1(t) {
    return "0x" + hash$2.sha256().update(arrayify(t)).digest("hex")
}
const version$4 = "networks/5.7.0",
    logger$7 = new Logger(version$4)
function isRenetworkable(t) {
    return t && typeof t.renetwork == "function"
}
function ethDefaultProvider(t) {
    const e = function (n, i) {
        i == null && (i = {})
        const o = []
        if (n.InfuraProvider && i.infura !== "-")
            try {
                o.push(new n.InfuraProvider(t, i.infura))
            } catch {}
        if (n.EtherscanProvider && i.etherscan !== "-")
            try {
                o.push(new n.EtherscanProvider(t, i.etherscan))
            } catch {}
        if (n.AlchemyProvider && i.alchemy !== "-")
            try {
                o.push(new n.AlchemyProvider(t, i.alchemy))
            } catch {}
        if (n.PocketProvider && i.pocket !== "-") {
            const a = ["goerli", "ropsten", "rinkeby"]
            try {
                const l = new n.PocketProvider(t, i.pocket)
                l.network && a.indexOf(l.network.name) === -1 && o.push(l)
            } catch {}
        }
        if (n.CloudflareProvider && i.cloudflare !== "-")
            try {
                o.push(new n.CloudflareProvider(t))
            } catch {}
        if (n.AnkrProvider && i.ankr !== "-")
            try {
                const a = ["ropsten"],
                    l = new n.AnkrProvider(t, i.ankr)
                l.network && a.indexOf(l.network.name) === -1 && o.push(l)
            } catch {}
        if (o.length === 0) return null
        if (n.FallbackProvider) {
            let a = 1
            return i.quorum != null ? (a = i.quorum) : t === "homestead" && (a = 2), new n.FallbackProvider(o, a)
        }
        return o[0]
    }
    return (
        (e.renetwork = function (n) {
            return ethDefaultProvider(n)
        }),
        e
    )
}
function etcDefaultProvider(t, e) {
    const n = function (i, o) {
        return i.JsonRpcProvider ? new i.JsonRpcProvider(t, e) : null
    }
    return (
        (n.renetwork = function (i) {
            return etcDefaultProvider(t, i)
        }),
        n
    )
}
const homestead = {
        chainId: 1,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "homestead",
        _defaultProvider: ethDefaultProvider("homestead"),
    },
    ropsten = {
        chainId: 3,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "ropsten",
        _defaultProvider: ethDefaultProvider("ropsten"),
    },
    classicMordor = {
        chainId: 63,
        name: "classicMordor",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor"),
    },
    networks = {
        unspecified: { chainId: 0, name: "unspecified" },
        homestead,
        mainnet: homestead,
        morden: { chainId: 2, name: "morden" },
        ropsten,
        testnet: ropsten,
        rinkeby: {
            chainId: 4,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "rinkeby",
            _defaultProvider: ethDefaultProvider("rinkeby"),
        },
        kovan: { chainId: 42, name: "kovan", _defaultProvider: ethDefaultProvider("kovan") },
        goerli: {
            chainId: 5,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "goerli",
            _defaultProvider: ethDefaultProvider("goerli"),
        },
        kintsugi: { chainId: 1337702, name: "kintsugi" },
        classic: { chainId: 61, name: "classic", _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic") },
        classicMorden: { chainId: 62, name: "classicMorden" },
        classicMordor,
        classicTestnet: classicMordor,
        classicKotti: {
            chainId: 6,
            name: "classicKotti",
            _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti"),
        },
        xdai: { chainId: 100, name: "xdai" },
        matic: { chainId: 137, name: "matic", _defaultProvider: ethDefaultProvider("matic") },
        maticmum: { chainId: 80001, name: "maticmum" },
        optimism: { chainId: 10, name: "optimism", _defaultProvider: ethDefaultProvider("optimism") },
        "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
        "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
        arbitrum: { chainId: 42161, name: "arbitrum" },
        "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
        "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
        bnb: { chainId: 56, name: "bnb" },
        bnbt: { chainId: 97, name: "bnbt" },
    }
function getNetwork(t) {
    if (t == null) return null
    if (typeof t == "number") {
        for (const i in networks) {
            const o = networks[i]
            if (o.chainId === t)
                return { name: o.name, chainId: o.chainId, ensAddress: o.ensAddress || null, _defaultProvider: o._defaultProvider || null }
        }
        return { chainId: t, name: "unknown" }
    }
    if (typeof t == "string") {
        const i = networks[t]
        return i == null ? null : { name: i.name, chainId: i.chainId, ensAddress: i.ensAddress, _defaultProvider: i._defaultProvider || null }
    }
    const e = networks[t.name]
    if (!e) return typeof t.chainId != "number" && logger$7.throwArgumentError("invalid network chainId", "network", t), t
    t.chainId !== 0 && t.chainId !== e.chainId && logger$7.throwArgumentError("network chainId mismatch", "network", t)
    let n = t._defaultProvider || null
    return (
        n == null &&
            e._defaultProvider &&
            (isRenetworkable(e._defaultProvider) ? (n = e._defaultProvider.renetwork(t)) : (n = e._defaultProvider)),
        { name: t.name, chainId: e.chainId, ensAddress: t.ensAddress || e.ensAddress || null, _defaultProvider: n }
    )
}
const version$3 = "web/5.7.0"
var __awaiter$4 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
function getUrl(t, e) {
    return __awaiter$4(this, void 0, void 0, function* () {
        e == null && (e = {})
        const n = { method: e.method || "GET", headers: e.headers || {}, body: e.body || void 0 }
        if (
            (e.skipFetchSetup !== !0 &&
                ((n.mode = "cors"), (n.cache = "no-cache"), (n.credentials = "same-origin"), (n.redirect = "follow"), (n.referrer = "client")),
            e.fetchOptions != null)
        ) {
            const l = e.fetchOptions
            l.mode && (n.mode = l.mode),
                l.cache && (n.cache = l.cache),
                l.credentials && (n.credentials = l.credentials),
                l.redirect && (n.redirect = l.redirect),
                l.referrer && (n.referrer = l.referrer)
        }
        const i = yield fetch(t, n),
            o = yield i.arrayBuffer(),
            a = {}
        return (
            i.headers.forEach
                ? i.headers.forEach((l, c) => {
                      a[c.toLowerCase()] = l
                  })
                : i.headers.keys().forEach((l) => {
                      a[l.toLowerCase()] = i.headers.get(l)
                  }),
            { headers: a, statusCode: i.status, statusMessage: i.statusText, body: arrayify(new Uint8Array(o)) }
        )
    })
}
var __awaiter$3 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$6 = new Logger(version$3)
function staller(t) {
    return new Promise((e) => {
        setTimeout(e, t)
    })
}
function bodyify(t, e) {
    if (t == null) return null
    if (typeof t == "string") return t
    if (isBytesLike(t)) {
        if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
            try {
                return toUtf8String(t)
            } catch {}
        return hexlify(t)
    }
    return t
}
function _fetchData(t, e, n) {
    const i = typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12
    logger$6.assertArgument(i > 0 && i % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", i)
    const o = typeof t == "object" ? t.throttleCallback : null,
        a = typeof t == "object" && typeof t.throttleSlotInterval == "number" ? t.throttleSlotInterval : 100
    logger$6.assertArgument(a > 0 && a % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", a)
    const l = typeof t == "object" ? !!t.errorPassThrough : !1,
        c = {}
    let g = null
    const v = { method: "GET" }
    let _ = !1,
        A = 2 * 60 * 1e3
    if (typeof t == "string") g = t
    else if (typeof t == "object") {
        if (
            ((t == null || t.url == null) && logger$6.throwArgumentError("missing URL", "connection.url", t),
            (g = t.url),
            typeof t.timeout == "number" && t.timeout > 0 && (A = t.timeout),
            t.headers)
        )
            for (const U in t.headers)
                (c[U.toLowerCase()] = { key: U, value: String(t.headers[U]) }),
                    ["if-none-match", "if-modified-since"].indexOf(U.toLowerCase()) >= 0 && (_ = !0)
        if (((v.allowGzip = !!t.allowGzip), t.user != null && t.password != null)) {
            g.substring(0, 6) !== "https:" &&
                t.allowInsecureAuthentication !== !0 &&
                logger$6.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, {
                    argument: "url",
                    url: g,
                    user: t.user,
                    password: "[REDACTED]",
                })
            const U = t.user + ":" + t.password
            c.authorization = { key: "Authorization", value: "Basic " + encode$g(toUtf8Bytes(U)) }
        }
        t.skipFetchSetup != null && (v.skipFetchSetup = !!t.skipFetchSetup),
            t.fetchOptions != null && (v.fetchOptions = shallowCopy(t.fetchOptions))
    }
    const B = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
        D = g ? g.match(B) : null
    if (D)
        try {
            const U = { statusCode: 200, statusMessage: "OK", headers: { "content-type": D[1] }, body: decode$h(D[2]) }
            let F = U.body
            return n && (F = n(U.body, U)), Promise.resolve(F)
        } catch (U) {
            logger$6.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                body: bodyify(D[1], D[2]),
                error: U,
                requestBody: null,
                requestMethod: "GET",
                url: g,
            })
        }
    e &&
        ((v.method = "POST"),
        (v.body = e),
        c["content-type"] == null && (c["content-type"] = { key: "Content-Type", value: "application/octet-stream" }),
        c["content-length"] == null && (c["content-length"] = { key: "Content-Length", value: String(e.length) }))
    const I = {}
    Object.keys(c).forEach((U) => {
        const F = c[U]
        I[F.key] = F.value
    }),
        (v.headers = I)
    const L = (function () {
            let U = null
            return {
                promise: new Promise(function (Y, X) {
                    A &&
                        (U = setTimeout(() => {
                            U != null &&
                                ((U = null),
                                X(
                                    logger$6.makeError("timeout", Logger.errors.TIMEOUT, {
                                        requestBody: bodyify(v.body, I["content-type"]),
                                        requestMethod: v.method,
                                        timeout: A,
                                        url: g,
                                    })
                                ))
                        }, A))
                }),
                cancel: function () {
                    U != null && (clearTimeout(U), (U = null))
                },
            }
        })(),
        G = (function () {
            return __awaiter$3(this, void 0, void 0, function* () {
                for (let U = 0; U < i; U++) {
                    let F = null
                    try {
                        if (((F = yield getUrl(g, v)), U < i)) {
                            if (F.statusCode === 301 || F.statusCode === 302) {
                                const Y = F.headers.location || ""
                                if (v.method === "GET" && Y.match(/^https:/)) {
                                    g = F.headers.location
                                    continue
                                }
                            } else if (F.statusCode === 429) {
                                let Y = !0
                                if ((o && (Y = yield o(U, g)), Y)) {
                                    let X = 0
                                    const ie = F.headers["retry-after"]
                                    typeof ie == "string" && ie.match(/^[1-9][0-9]*$/)
                                        ? (X = parseInt(ie) * 1e3)
                                        : (X = a * parseInt(String(Math.random() * Math.pow(2, U)))),
                                        yield staller(X)
                                    continue
                                }
                            }
                        }
                    } catch (Y) {
                        ;(F = Y.response),
                            F == null &&
                                (L.cancel(),
                                logger$6.throwError("missing response", Logger.errors.SERVER_ERROR, {
                                    requestBody: bodyify(v.body, I["content-type"]),
                                    requestMethod: v.method,
                                    serverError: Y,
                                    url: g,
                                }))
                    }
                    let Z = F.body
                    if (
                        (_ && F.statusCode === 304
                            ? (Z = null)
                            : !l &&
                              (F.statusCode < 200 || F.statusCode >= 300) &&
                              (L.cancel(),
                              logger$6.throwError("bad response", Logger.errors.SERVER_ERROR, {
                                  status: F.statusCode,
                                  headers: F.headers,
                                  body: bodyify(Z, F.headers ? F.headers["content-type"] : null),
                                  requestBody: bodyify(v.body, I["content-type"]),
                                  requestMethod: v.method,
                                  url: g,
                              })),
                        n)
                    )
                        try {
                            const Y = yield n(Z, F)
                            return L.cancel(), Y
                        } catch (Y) {
                            if (Y.throttleRetry && U < i) {
                                let X = !0
                                if ((o && (X = yield o(U, g)), X)) {
                                    const ie = a * parseInt(String(Math.random() * Math.pow(2, U)))
                                    yield staller(ie)
                                    continue
                                }
                            }
                            L.cancel(),
                                logger$6.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                                    body: bodyify(Z, F.headers ? F.headers["content-type"] : null),
                                    error: Y,
                                    requestBody: bodyify(v.body, I["content-type"]),
                                    requestMethod: v.method,
                                    url: g,
                                })
                        }
                    return L.cancel(), Z
                }
                return logger$6.throwError("failed response", Logger.errors.SERVER_ERROR, {
                    requestBody: bodyify(v.body, I["content-type"]),
                    requestMethod: v.method,
                    url: g,
                })
            })
        })()
    return Promise.race([L.promise, G])
}
function fetchJson(t, e, n) {
    let i = (a, l) => {
            let c = null
            if (a != null)
                try {
                    c = JSON.parse(toUtf8String(a))
                } catch (g) {
                    logger$6.throwError("invalid JSON", Logger.errors.SERVER_ERROR, { body: a, error: g })
                }
            return n && (c = n(c, l)), c
        },
        o = null
    if (e != null) {
        o = toUtf8Bytes(e)
        const a = typeof t == "string" ? { url: t } : shallowCopy(t)
        a.headers
            ? Object.keys(a.headers).filter((c) => c.toLowerCase() === "content-type").length !== 0 ||
              ((a.headers = shallowCopy(a.headers)), (a.headers["content-type"] = "application/json"))
            : (a.headers = { "content-type": "application/json" }),
            (t = a)
    }
    return _fetchData(t, o, i)
}
function poll(t, e) {
    return (
        e || (e = {}),
        (e = shallowCopy(e)),
        e.floor == null && (e.floor = 0),
        e.ceiling == null && (e.ceiling = 1e4),
        e.interval == null && (e.interval = 250),
        new Promise(function (n, i) {
            let o = null,
                a = !1
            const l = () => (a ? !1 : ((a = !0), o && clearTimeout(o), !0))
            e.timeout &&
                (o = setTimeout(() => {
                    l() && i(new Error("timeout"))
                }, e.timeout))
            const c = e.retryLimit
            let g = 0
            function v() {
                return t().then(
                    function (_) {
                        if (_ !== void 0) l() && n(_)
                        else if (e.oncePoll) e.oncePoll.once("poll", v)
                        else if (e.onceBlock) e.onceBlock.once("block", v)
                        else if (!a) {
                            if ((g++, g > c)) {
                                l() && i(new Error("retry limit reached"))
                                return
                            }
                            let A = e.interval * parseInt(String(Math.random() * Math.pow(2, g)))
                            A < e.floor && (A = e.floor), A > e.ceiling && (A = e.ceiling), setTimeout(v, A)
                        }
                        return null
                    },
                    function (_) {
                        l() && i(_)
                    }
                )
            }
            v()
        })
    )
}
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
    ALPHABET_MAP = {}
for (var z = 0; z < ALPHABET.length; z++) {
    var x = ALPHABET.charAt(z)
    if (ALPHABET_MAP[x] !== void 0) throw new TypeError(x + " is ambiguous")
    ALPHABET_MAP[x] = z
}
function polymodStep(t) {
    var e = t >> 25
    return (
        ((t & 33554431) << 5) ^
        (-((e >> 0) & 1) & 996825010) ^
        (-((e >> 1) & 1) & 642813549) ^
        (-((e >> 2) & 1) & 513874426) ^
        (-((e >> 3) & 1) & 1027748829) ^
        (-((e >> 4) & 1) & 705979059)
    )
}
function prefixChk(t) {
    for (var e = 1, n = 0; n < t.length; ++n) {
        var i = t.charCodeAt(n)
        if (i < 33 || i > 126) return "Invalid prefix (" + t + ")"
        e = polymodStep(e) ^ (i >> 5)
    }
    for (e = polymodStep(e), n = 0; n < t.length; ++n) {
        var o = t.charCodeAt(n)
        e = polymodStep(e) ^ (o & 31)
    }
    return e
}
function encode$f(t, e, n) {
    if (((n = n || 90), t.length + 7 + e.length > n)) throw new TypeError("Exceeds length limit")
    t = t.toLowerCase()
    var i = prefixChk(t)
    if (typeof i == "string") throw new Error(i)
    for (var o = t + "1", a = 0; a < e.length; ++a) {
        var l = e[a]
        if (l >> 5 !== 0) throw new Error("Non 5-bit word")
        ;(i = polymodStep(i) ^ l), (o += ALPHABET.charAt(l))
    }
    for (a = 0; a < 6; ++a) i = polymodStep(i)
    for (i ^= 1, a = 0; a < 6; ++a) {
        var c = (i >> ((5 - a) * 5)) & 31
        o += ALPHABET.charAt(c)
    }
    return o
}
function __decode(t, e) {
    if (((e = e || 90), t.length < 8)) return t + " too short"
    if (t.length > e) return "Exceeds length limit"
    var n = t.toLowerCase(),
        i = t.toUpperCase()
    if (t !== n && t !== i) return "Mixed-case string " + t
    t = n
    var o = t.lastIndexOf("1")
    if (o === -1) return "No separator character for " + t
    if (o === 0) return "Missing prefix for " + t
    var a = t.slice(0, o),
        l = t.slice(o + 1)
    if (l.length < 6) return "Data too short"
    var c = prefixChk(a)
    if (typeof c == "string") return c
    for (var g = [], v = 0; v < l.length; ++v) {
        var _ = l.charAt(v),
            A = ALPHABET_MAP[_]
        if (A === void 0) return "Unknown character " + _
        ;(c = polymodStep(c) ^ A), !(v + 6 >= l.length) && g.push(A)
    }
    return c !== 1 ? "Invalid checksum for " + t : { prefix: a, words: g }
}
function decodeUnsafe() {
    var t = __decode.apply(null, arguments)
    if (typeof t == "object") return t
}
function decode$g(t) {
    var e = __decode.apply(null, arguments)
    if (typeof e == "object") return e
    throw new Error(e)
}
function convert(t, e, n, i) {
    for (var o = 0, a = 0, l = (1 << n) - 1, c = [], g = 0; g < t.length; ++g)
        for (o = (o << e) | t[g], a += e; a >= n; ) (a -= n), c.push((o >> a) & l)
    if (i) a > 0 && c.push((o << (n - a)) & l)
    else {
        if (a >= e) return "Excess padding"
        if ((o << (n - a)) & l) return "Non-zero padding"
    }
    return c
}
function toWordsUnsafe(t) {
    var e = convert(t, 8, 5, !0)
    if (Array.isArray(e)) return e
}
function toWords(t) {
    var e = convert(t, 8, 5, !0)
    if (Array.isArray(e)) return e
    throw new Error(e)
}
function fromWordsUnsafe(t) {
    var e = convert(t, 5, 8, !1)
    if (Array.isArray(e)) return e
}
function fromWords(t) {
    var e = convert(t, 5, 8, !1)
    if (Array.isArray(e)) return e
    throw new Error(e)
}
var bech32 = { decodeUnsafe, decode: decode$g, encode: encode$f, toWordsUnsafe, toWords, fromWordsUnsafe, fromWords }
const version$2 = "providers/5.7.0",
    logger$5 = new Logger(version$2)
class Formatter {
    constructor() {
        this.formats = this.getDefaultFormats()
    }
    getDefaultFormats() {
        const e = {},
            n = this.address.bind(this),
            i = this.bigNumber.bind(this),
            o = this.blockTag.bind(this),
            a = this.data.bind(this),
            l = this.hash.bind(this),
            c = this.hex.bind(this),
            g = this.number.bind(this),
            v = this.type.bind(this),
            _ = (A) => this.data(A, !0)
        return (
            (e.transaction = {
                hash: l,
                type: v,
                accessList: Formatter.allowNull(this.accessList.bind(this), null),
                blockHash: Formatter.allowNull(l, null),
                blockNumber: Formatter.allowNull(g, null),
                transactionIndex: Formatter.allowNull(g, null),
                confirmations: Formatter.allowNull(g, null),
                from: n,
                gasPrice: Formatter.allowNull(i),
                maxPriorityFeePerGas: Formatter.allowNull(i),
                maxFeePerGas: Formatter.allowNull(i),
                gasLimit: i,
                to: Formatter.allowNull(n, null),
                value: i,
                nonce: g,
                data: a,
                r: Formatter.allowNull(this.uint256),
                s: Formatter.allowNull(this.uint256),
                v: Formatter.allowNull(g),
                creates: Formatter.allowNull(n, null),
                raw: Formatter.allowNull(a),
            }),
            (e.transactionRequest = {
                from: Formatter.allowNull(n),
                nonce: Formatter.allowNull(g),
                gasLimit: Formatter.allowNull(i),
                gasPrice: Formatter.allowNull(i),
                maxPriorityFeePerGas: Formatter.allowNull(i),
                maxFeePerGas: Formatter.allowNull(i),
                to: Formatter.allowNull(n),
                value: Formatter.allowNull(i),
                data: Formatter.allowNull(_),
                type: Formatter.allowNull(g),
                accessList: Formatter.allowNull(this.accessList.bind(this), null),
            }),
            (e.receiptLog = {
                transactionIndex: g,
                blockNumber: g,
                transactionHash: l,
                address: n,
                topics: Formatter.arrayOf(l),
                data: a,
                logIndex: g,
                blockHash: l,
            }),
            (e.receipt = {
                to: Formatter.allowNull(this.address, null),
                from: Formatter.allowNull(this.address, null),
                contractAddress: Formatter.allowNull(n, null),
                transactionIndex: g,
                root: Formatter.allowNull(c),
                gasUsed: i,
                logsBloom: Formatter.allowNull(a),
                blockHash: l,
                transactionHash: l,
                logs: Formatter.arrayOf(this.receiptLog.bind(this)),
                blockNumber: g,
                confirmations: Formatter.allowNull(g, null),
                cumulativeGasUsed: i,
                effectiveGasPrice: Formatter.allowNull(i),
                status: Formatter.allowNull(g),
                type: v,
            }),
            (e.block = {
                hash: Formatter.allowNull(l),
                parentHash: l,
                number: g,
                timestamp: g,
                nonce: Formatter.allowNull(c),
                difficulty: this.difficulty.bind(this),
                gasLimit: i,
                gasUsed: i,
                miner: Formatter.allowNull(n),
                extraData: a,
                transactions: Formatter.allowNull(Formatter.arrayOf(l)),
                baseFeePerGas: Formatter.allowNull(i),
            }),
            (e.blockWithTransactions = shallowCopy(e.block)),
            (e.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)))),
            (e.filter = {
                fromBlock: Formatter.allowNull(o, void 0),
                toBlock: Formatter.allowNull(o, void 0),
                blockHash: Formatter.allowNull(l, void 0),
                address: Formatter.allowNull(n, void 0),
                topics: Formatter.allowNull(this.topics.bind(this), void 0),
            }),
            (e.filterLog = {
                blockNumber: Formatter.allowNull(g),
                blockHash: Formatter.allowNull(l),
                transactionIndex: g,
                removed: Formatter.allowNull(this.boolean.bind(this)),
                address: n,
                data: Formatter.allowFalsish(a, "0x"),
                topics: Formatter.arrayOf(l),
                transactionHash: l,
                logIndex: g,
            }),
            e
        )
    }
    accessList(e) {
        return accessListify(e || [])
    }
    number(e) {
        return e === "0x" ? 0 : BigNumber.from(e).toNumber()
    }
    type(e) {
        return e === "0x" || e == null ? 0 : BigNumber.from(e).toNumber()
    }
    bigNumber(e) {
        return BigNumber.from(e)
    }
    boolean(e) {
        if (typeof e == "boolean") return e
        if (typeof e == "string") {
            if (((e = e.toLowerCase()), e === "true")) return !0
            if (e === "false") return !1
        }
        throw new Error("invalid boolean - " + e)
    }
    hex(e, n) {
        return typeof e == "string" && (!n && e.substring(0, 2) !== "0x" && (e = "0x" + e), isHexString(e))
            ? e.toLowerCase()
            : logger$5.throwArgumentError("invalid hash", "value", e)
    }
    data(e, n) {
        const i = this.hex(e, n)
        if (i.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e)
        return i
    }
    address(e) {
        return getAddress(e)
    }
    callAddress(e) {
        if (!isHexString(e, 32)) return null
        const n = getAddress(hexDataSlice(e, 12))
        return n === AddressZero ? null : n
    }
    contractAddress(e) {
        return getContractAddress(e)
    }
    blockTag(e) {
        if (e == null) return "latest"
        if (e === "earliest") return "0x0"
        switch (e) {
            case "earliest":
                return "0x0"
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return e
        }
        if (typeof e == "number" || isHexString(e)) return hexValue(e)
        throw new Error("invalid blockTag")
    }
    hash(e, n) {
        const i = this.hex(e, n)
        return hexDataLength(i) !== 32 ? logger$5.throwArgumentError("invalid hash", "value", e) : i
    }
    difficulty(e) {
        if (e == null) return null
        const n = BigNumber.from(e)
        try {
            return n.toNumber()
        } catch {}
        return null
    }
    uint256(e) {
        if (!isHexString(e)) throw new Error("invalid uint256")
        return hexZeroPad(e, 32)
    }
    _block(e, n) {
        e.author != null && e.miner == null && (e.miner = e.author)
        const i = e._difficulty != null ? e._difficulty : e.difficulty,
            o = Formatter.check(n, e)
        return (o._difficulty = i == null ? null : BigNumber.from(i)), o
    }
    block(e) {
        return this._block(e, this.formats.block)
    }
    blockWithTransactions(e) {
        return this._block(e, this.formats.blockWithTransactions)
    }
    transactionRequest(e) {
        return Formatter.check(this.formats.transactionRequest, e)
    }
    transactionResponse(e) {
        e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
            e.to && BigNumber.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"),
            e.input != null && e.data == null && (e.data = e.input),
            e.to == null && e.creates == null && (e.creates = this.contractAddress(e)),
            (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = [])
        const n = Formatter.check(this.formats.transaction, e)
        if (e.chainId != null) {
            let i = e.chainId
            isHexString(i) && (i = BigNumber.from(i).toNumber()), (n.chainId = i)
        } else {
            let i = e.networkId
            i == null && n.v == null && (i = e.chainId),
                isHexString(i) && (i = BigNumber.from(i).toNumber()),
                typeof i != "number" && n.v != null && ((i = (n.v - 35) / 2), i < 0 && (i = 0), (i = parseInt(i))),
                typeof i != "number" && (i = 0),
                (n.chainId = i)
        }
        return n.blockHash && n.blockHash.replace(/0/g, "") === "x" && (n.blockHash = null), n
    }
    transaction(e) {
        return parse$2(e)
    }
    receiptLog(e) {
        return Formatter.check(this.formats.receiptLog, e)
    }
    receipt(e) {
        const n = Formatter.check(this.formats.receipt, e)
        if (n.root != null)
            if (n.root.length <= 4) {
                const i = BigNumber.from(n.root).toNumber()
                i === 0 || i === 1
                    ? (n.status != null &&
                          n.status !== i &&
                          logger$5.throwArgumentError("alt-root-status/status mismatch", "value", { root: n.root, status: n.status }),
                      (n.status = i),
                      delete n.root)
                    : logger$5.throwArgumentError("invalid alt-root-status", "value.root", n.root)
            } else n.root.length !== 66 && logger$5.throwArgumentError("invalid root hash", "value.root", n.root)
        return n.status != null && (n.byzantium = !0), n
    }
    topics(e) {
        return Array.isArray(e) ? e.map((n) => this.topics(n)) : e != null ? this.hash(e, !0) : null
    }
    filter(e) {
        return Formatter.check(this.formats.filter, e)
    }
    filterLog(e) {
        return Formatter.check(this.formats.filterLog, e)
    }
    static check(e, n) {
        const i = {}
        for (const o in e)
            try {
                const a = e[o](n[o])
                a !== void 0 && (i[o] = a)
            } catch (a) {
                throw ((a.checkKey = o), (a.checkValue = n[o]), a)
            }
        return i
    }
    static allowNull(e, n) {
        return function (i) {
            return i == null ? n : e(i)
        }
    }
    static allowFalsish(e, n) {
        return function (i) {
            return i ? e(i) : n
        }
    }
    static arrayOf(e) {
        return function (n) {
            if (!Array.isArray(n)) throw new Error("not an array")
            const i = []
            return (
                n.forEach(function (o) {
                    i.push(e(o))
                }),
                i
            )
        }
    }
}
var __awaiter$2 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$4 = new Logger(version$2),
    MAX_CCIP_REDIRECTS = 10
function checkTopic(t) {
    return t == null ? "null" : (hexDataLength(t) !== 32 && logger$4.throwArgumentError("invalid topic", "topic", t), t.toLowerCase())
}
function serializeTopics(t) {
    for (t = t.slice(); t.length > 0 && t[t.length - 1] == null; ) t.pop()
    return t
        .map((e) => {
            if (Array.isArray(e)) {
                const n = {}
                e.forEach((o) => {
                    n[checkTopic(o)] = !0
                })
                const i = Object.keys(n)
                return i.sort(), i.join("|")
            } else return checkTopic(e)
        })
        .join("&")
}
function deserializeTopics(t) {
    return t === ""
        ? []
        : t.split(/&/g).map((e) => {
              if (e === "") return []
              const n = e.split("|").map((i) => (i === "null" ? null : i))
              return n.length === 1 ? n[0] : n
          })
}
function getEventTag(t) {
    if (typeof t == "string") {
        if (((t = t.toLowerCase()), hexDataLength(t) === 32)) return "tx:" + t
        if (t.indexOf(":") === -1) return t
    } else {
        if (Array.isArray(t)) return "filter:*:" + serializeTopics(t)
        if (ForkEvent.isForkEvent(t)) throw (logger$4.warn("not implemented"), new Error("not implemented"))
        if (t && typeof t == "object") return "filter:" + (t.address || "*") + ":" + serializeTopics(t.topics || [])
    }
    throw new Error("invalid event - " + t)
}
function getTime() {
    return new Date().getTime()
}
function stall(t) {
    return new Promise((e) => {
        setTimeout(e, t)
    })
}
const PollableEvents = ["block", "network", "pending", "poll"]
class Event$1 {
    constructor(e, n, i) {
        defineReadOnly(this, "tag", e),
            defineReadOnly(this, "listener", n),
            defineReadOnly(this, "once", i),
            (this._lastBlockNumber = -2),
            (this._inflight = !1)
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash
            case "filter":
                return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const e = this.tag.split(":")
        return e[0] !== "tx" ? null : e[1]
    }
    get filter() {
        const e = this.tag.split(":")
        if (e[0] !== "filter") return null
        const n = e[1],
            i = deserializeTopics(e[2]),
            o = {}
        return i.length > 0 && (o.topics = i), n && n !== "*" && (o.address = n), o
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0
    }
}
const coinInfos = {
    0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
    60: { symbol: "eth", ilk: "eth" },
    61: { symbol: "etc", ilk: "eth" },
    700: { symbol: "xdai", ilk: "eth" },
}
function bytes32ify(t) {
    return hexZeroPad(BigNumber.from(t).toHexString(), 32)
}
function base58Encode(t) {
    return Base58.encode(concat$2([t, hexDataSlice(sha256$1(sha256$1(t)), 0, 4)]))
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i"),
    matchers = [
        new RegExp("^(https)://(.*)$", "i"),
        new RegExp("^(data):(.*)$", "i"),
        matcherIpfs,
        new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
    ]
function _parseString(t, e) {
    try {
        return toUtf8String(_parseBytes(t, e))
    } catch {}
    return null
}
function _parseBytes(t, e) {
    if (t === "0x") return null
    const n = BigNumber.from(hexDataSlice(t, e, e + 32)).toNumber(),
        i = BigNumber.from(hexDataSlice(t, n, n + 32)).toNumber()
    return hexDataSlice(t, n + 32, n + 32 + i)
}
function getIpfsLink(t) {
    return (
        t.match(/^ipfs:\/\/ipfs\//i)
            ? (t = t.substring(12))
            : t.match(/^ipfs:\/\//i)
            ? (t = t.substring(7))
            : logger$4.throwArgumentError("unsupported IPFS format", "link", t),
        `https://gateway.ipfs.io/ipfs/${t}`
    )
}
function numPad(t) {
    const e = arrayify(t)
    if (e.length > 32) throw new Error("internal; should not happen")
    const n = new Uint8Array(32)
    return n.set(e, 32 - e.length), n
}
function bytesPad(t) {
    if (t.length % 32 === 0) return t
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32)
    return e.set(t), e
}
function encodeBytes$1(t) {
    const e = []
    let n = 0
    for (let i = 0; i < t.length; i++) e.push(null), (n += 32)
    for (let i = 0; i < t.length; i++) {
        const o = arrayify(t[i])
        ;(e[i] = numPad(n)), e.push(numPad(o.length)), e.push(bytesPad(o)), (n += 32 + Math.ceil(o.length / 32) * 32)
    }
    return hexConcat(e)
}
class Resolver {
    constructor(e, n, i, o) {
        defineReadOnly(this, "provider", e),
            defineReadOnly(this, "name", i),
            defineReadOnly(this, "address", e.formatter.address(n)),
            defineReadOnly(this, "_resolvedAddress", o)
    }
    supportsWildcard() {
        return (
            this._supportsEip2544 ||
                (this._supportsEip2544 = this.provider
                    .call({ to: this.address, data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000" })
                    .then((e) => BigNumber.from(e).eq(1))
                    .catch((e) => {
                        if (e.code === Logger.errors.CALL_EXCEPTION) return !1
                        throw ((this._supportsEip2544 = null), e)
                    })),
            this._supportsEip2544
        )
    }
    _fetch(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            const i = { to: this.address, ccipReadEnabled: !0, data: hexConcat([e, namehash(this.name), n || "0x"]) }
            let o = !1
            ;(yield this.supportsWildcard()) && ((o = !0), (i.data = hexConcat(["0x9061b923", encodeBytes$1([dnsEncode(this.name), i.data])])))
            try {
                let a = yield this.provider.call(i)
                return (
                    arrayify(a).length % 32 === 4 &&
                        logger$4.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, { transaction: i, data: a }),
                    o && (a = _parseBytes(a, 0)),
                    a
                )
            } catch (a) {
                if (a.code === Logger.errors.CALL_EXCEPTION) return null
                throw a
            }
        })
    }
    _fetchBytes(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            const i = yield this._fetch(e, n)
            return i != null ? _parseBytes(i, 0) : null
        })
    }
    _getAddress(e, n) {
        const i = coinInfos[String(e)]
        if (
            (i == null &&
                logger$4.throwError(`unsupported coin type: ${e}`, Logger.errors.UNSUPPORTED_OPERATION, { operation: `getAddress(${e})` }),
            i.ilk === "eth")
        )
            return this.provider.formatter.address(n)
        const o = arrayify(n)
        if (i.p2pkh != null) {
            const a = n.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/)
            if (a) {
                const l = parseInt(a[1], 16)
                if (a[2].length === l * 2 && l >= 1 && l <= 75) return base58Encode(concat$2([[i.p2pkh], "0x" + a[2]]))
            }
        }
        if (i.p2sh != null) {
            const a = n.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/)
            if (a) {
                const l = parseInt(a[1], 16)
                if (a[2].length === l * 2 && l >= 1 && l <= 75) return base58Encode(concat$2([[i.p2sh], "0x" + a[2]]))
            }
        }
        if (i.prefix != null) {
            const a = o[1]
            let l = o[0]
            if ((l === 0 ? a !== 20 && a !== 32 && (l = -1) : (l = -1), l >= 0 && o.length === 2 + a && a >= 1 && a <= 75)) {
                const c = bech32.toWords(o.slice(2))
                return c.unshift(l), bech32.encode(i.prefix, c)
            }
        }
        return null
    }
    getAddress(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if ((e == null && (e = 60), e === 60))
                try {
                    const o = yield this._fetch("0x3b3b57de")
                    return o === "0x" || o === HashZero ? null : this.provider.formatter.callAddress(o)
                } catch (o) {
                    if (o.code === Logger.errors.CALL_EXCEPTION) return null
                    throw o
                }
            const n = yield this._fetchBytes("0xf1cb7e06", bytes32ify(e))
            if (n == null || n === "0x") return null
            const i = this._getAddress(e, n)
            return (
                i == null &&
                    logger$4.throwError("invalid or unsupported coin data", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${e})`,
                        coinType: e,
                        data: n,
                    }),
                i
            )
        })
    }
    getAvatar() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const e = [{ type: "name", content: this.name }]
            try {
                const n = yield this.getText("avatar")
                if (n == null) return null
                for (let i = 0; i < matchers.length; i++) {
                    const o = n.match(matchers[i])
                    if (o == null) continue
                    const a = o[1].toLowerCase()
                    switch (a) {
                        case "https":
                            return e.push({ type: "url", content: n }), { linkage: e, url: n }
                        case "data":
                            return e.push({ type: "data", content: n }), { linkage: e, url: n }
                        case "ipfs":
                            return e.push({ type: "ipfs", content: n }), { linkage: e, url: getIpfsLink(n) }
                        case "erc721":
                        case "erc1155": {
                            const l = a === "erc721" ? "0xc87b56dd" : "0x0e89341c"
                            e.push({ type: a, content: n })
                            const c = this._resolvedAddress || (yield this.getAddress()),
                                g = (o[2] || "").split("/")
                            if (g.length !== 2) return null
                            const v = yield this.provider.formatter.address(g[0]),
                                _ = hexZeroPad(BigNumber.from(g[1]).toHexString(), 32)
                            if (a === "erc721") {
                                const L = this.provider.formatter.callAddress(
                                    yield this.provider.call({ to: v, data: hexConcat(["0x6352211e", _]) })
                                )
                                if (c !== L) return null
                                e.push({ type: "owner", content: L })
                            } else if (a === "erc1155") {
                                const L = BigNumber.from(
                                    yield this.provider.call({ to: v, data: hexConcat(["0x00fdd58e", hexZeroPad(c, 32), _]) })
                                )
                                if (L.isZero()) return null
                                e.push({ type: "balance", content: L.toString() })
                            }
                            const A = { to: this.provider.formatter.address(g[0]), data: hexConcat([l, _]) }
                            let B = _parseString(yield this.provider.call(A), 0)
                            if (B == null) return null
                            e.push({ type: "metadata-url-base", content: B }),
                                a === "erc1155" &&
                                    ((B = B.replace("{id}", _.substring(2))), e.push({ type: "metadata-url-expanded", content: B })),
                                B.match(/^ipfs:/i) && (B = getIpfsLink(B)),
                                e.push({ type: "metadata-url", content: B })
                            const D = yield fetchJson(B)
                            if (!D) return null
                            e.push({ type: "metadata", content: JSON.stringify(D) })
                            let I = D.image
                            if (typeof I != "string") return null
                            if (!I.match(/^(https:\/\/|data:)/i)) {
                                if (I.match(matcherIpfs) == null) return null
                                e.push({ type: "url-ipfs", content: I }), (I = getIpfsLink(I))
                            }
                            return e.push({ type: "url", content: I }), { linkage: e, url: I }
                        }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const e = yield this._fetchBytes("0xbc1c58d1")
            if (e == null || e === "0x") return null
            const n = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/)
            if (n) {
                const l = parseInt(n[3], 16)
                if (n[4].length === l * 2) return "ipfs://" + Base58.encode("0x" + n[1])
            }
            const i = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/)
            if (i) {
                const l = parseInt(i[3], 16)
                if (i[4].length === l * 2) return "ipns://" + Base58.encode("0x" + i[1])
            }
            const o = e.match(/^0xe40101fa011b20([0-9a-f]*)$/)
            if (o && o[1].length === 32 * 2) return "bzz://" + o[1]
            const a = e.match(/^0x90b2c605([0-9a-f]*)$/)
            if (a && a[1].length === 34 * 2) {
                const l = { "=": "", "+": "-", "/": "_" },
                    c = encode$g("0x" + a[1]).replace(/[=+\/]/g, (g) => l[g])
                return "sia://" + c
            }
            return logger$4.throwError("invalid or unsupported content hash data", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: e,
            })
        })
    }
    getText(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            let n = toUtf8Bytes(e)
            ;(n = concat$2([bytes32ify(64), bytes32ify(n.length), n])),
                n.length % 32 !== 0 && (n = concat$2([n, hexZeroPad("0x", 32 - (e.length % 32))]))
            const i = yield this._fetchBytes("0x59d1d43c", hexlify(n))
            return i == null || i === "0x" ? null : toUtf8String(i)
        })
    }
}
let defaultFormatter = null,
    nextPollId = 1
class BaseProvider extends Provider$1 {
    constructor(e) {
        if (
            (super(),
            (this._events = []),
            (this._emitted = { block: -2 }),
            (this.disableCcipRead = !1),
            (this.formatter = new.target.getFormatter()),
            defineReadOnly(this, "anyNetwork", e === "any"),
            this.anyNetwork && (e = this.detectNetwork()),
            e instanceof Promise)
        )
            (this._networkPromise = e), e.catch((n) => {}), this._ready().catch((n) => {})
        else {
            const n = getStatic(new.target, "getNetwork")(e)
            n
                ? (defineReadOnly(this, "_network", n), this.emit("network", n, null))
                : logger$4.throwArgumentError("invalid network", "network", e)
        }
        ;(this._maxInternalBlockNumber = -1024),
            (this._lastBlockNumber = -2),
            (this._maxFilterBlockRange = 10),
            (this._pollingInterval = 4e3),
            (this._fastQueryDate = 0)
    }
    _ready() {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (this._network == null) {
                let e = null
                if (this._networkPromise)
                    try {
                        e = yield this._networkPromise
                    } catch {}
                e == null && (e = yield this.detectNetwork()),
                    e || logger$4.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {}),
                    this._network == null &&
                        (this.anyNetwork ? (this._network = e) : defineReadOnly(this, "_network", e), this.emit("network", e, null))
            }
            return this._network
        })
    }
    get ready() {
        return poll(() =>
            this._ready().then(
                (e) => e,
                (e) => {
                    if (!(e.code === Logger.errors.NETWORK_ERROR && e.event === "noNetwork")) throw e
                }
            )
        )
    }
    static getFormatter() {
        return defaultFormatter == null && (defaultFormatter = new Formatter()), defaultFormatter
    }
    static getNetwork(e) {
        return getNetwork(e == null ? "homestead" : e)
    }
    ccipReadFetch(e, n, i) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (this.disableCcipRead || i.length === 0) return null
            const o = e.to.toLowerCase(),
                a = n.toLowerCase(),
                l = []
            for (let c = 0; c < i.length; c++) {
                const g = i[c],
                    v = g.replace("{sender}", o).replace("{data}", a),
                    _ = g.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: a, sender: o }),
                    A = yield fetchJson({ url: v, errorPassThrough: !0 }, _, (D, I) => ((D.status = I.statusCode), D))
                if (A.data) return A.data
                const B = A.message || "unknown error"
                if (A.status >= 400 && A.status < 500)
                    return logger$4.throwError(`response not found during CCIP fetch: ${B}`, Logger.errors.SERVER_ERROR, {
                        url: g,
                        errorMessage: B,
                    })
                l.push(B)
            }
            return logger$4.throwError(
                `error encountered during CCIP fetch: ${l.map((c) => JSON.stringify(c)).join(", ")}`,
                Logger.errors.SERVER_ERROR,
                { urls: i, errorMessages: l }
            )
        })
    }
    _getInternalBlockNumber(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if ((yield this._ready(), e > 0))
                for (; this._internalBlockNumber; ) {
                    const o = this._internalBlockNumber
                    try {
                        const a = yield o
                        if (getTime() - a.respTime <= e) return a.blockNumber
                        break
                    } catch {
                        if (this._internalBlockNumber === o) break
                    }
                }
            const n = getTime(),
                i = resolveProperties({
                    blockNumber: this.perform("getBlockNumber", {}),
                    networkError: this.getNetwork().then(
                        (o) => null,
                        (o) => o
                    ),
                }).then(({ blockNumber: o, networkError: a }) => {
                    if (a) throw (this._internalBlockNumber === i && (this._internalBlockNumber = null), a)
                    const l = getTime()
                    return (
                        (o = BigNumber.from(o).toNumber()),
                        o < this._maxInternalBlockNumber && (o = this._maxInternalBlockNumber),
                        (this._maxInternalBlockNumber = o),
                        this._setFastBlockNumber(o),
                        { blockNumber: o, reqTime: n, respTime: l }
                    )
                })
            return (
                (this._internalBlockNumber = i),
                i.catch((o) => {
                    this._internalBlockNumber === i && (this._internalBlockNumber = null)
                }),
                (yield i).blockNumber
            )
        })
    }
    poll() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const e = nextPollId++,
                n = []
            let i = null
            try {
                i = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (o) {
                this.emit("error", o)
                return
            }
            if ((this._setFastBlockNumber(i), this.emit("poll", e, i), i === this._lastBlockNumber)) {
                this.emit("didPoll", e)
                return
            }
            if ((this._emitted.block === -2 && (this._emitted.block = i - 1), Math.abs(this._emitted.block - i) > 1e3))
                logger$4.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${i})`),
                    this.emit(
                        "error",
                        logger$4.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
                            blockNumber: i,
                            event: "blockSkew",
                            previousBlockNumber: this._emitted.block,
                        })
                    ),
                    this.emit("block", i)
            else for (let o = this._emitted.block + 1; o <= i; o++) this.emit("block", o)
            this._emitted.block !== i &&
                ((this._emitted.block = i),
                Object.keys(this._emitted).forEach((o) => {
                    if (o === "block") return
                    const a = this._emitted[o]
                    a !== "pending" && i - a > 12 && delete this._emitted[o]
                })),
                this._lastBlockNumber === -2 && (this._lastBlockNumber = i - 1),
                this._events.forEach((o) => {
                    switch (o.type) {
                        case "tx": {
                            const a = o.hash
                            let l = this.getTransactionReceipt(a)
                                .then((c) => (!c || c.blockNumber == null || ((this._emitted["t:" + a] = c.blockNumber), this.emit(a, c)), null))
                                .catch((c) => {
                                    this.emit("error", c)
                                })
                            n.push(l)
                            break
                        }
                        case "filter": {
                            if (!o._inflight) {
                                ;(o._inflight = !0), o._lastBlockNumber === -2 && (o._lastBlockNumber = i - 1)
                                const a = o.filter
                                ;(a.fromBlock = o._lastBlockNumber + 1), (a.toBlock = i)
                                const l = a.toBlock - this._maxFilterBlockRange
                                l > a.fromBlock && (a.fromBlock = l), a.fromBlock < 0 && (a.fromBlock = 0)
                                const c = this.getLogs(a)
                                    .then((g) => {
                                        ;(o._inflight = !1),
                                            g.length !== 0 &&
                                                g.forEach((v) => {
                                                    v.blockNumber > o._lastBlockNumber && (o._lastBlockNumber = v.blockNumber),
                                                        (this._emitted["b:" + v.blockHash] = v.blockNumber),
                                                        (this._emitted["t:" + v.transactionHash] = v.blockNumber),
                                                        this.emit(a, v)
                                                })
                                    })
                                    .catch((g) => {
                                        this.emit("error", g), (o._inflight = !1)
                                    })
                                n.push(c)
                            }
                            break
                        }
                    }
                }),
                (this._lastBlockNumber = i),
                Promise.all(n)
                    .then(() => {
                        this.emit("didPoll", e)
                    })
                    .catch((o) => {
                        this.emit("error", o)
                    })
        })
    }
    resetEventsBlock(e) {
        ;(this._lastBlockNumber = e - 1), this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return logger$4.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork",
            })
        })
    }
    getNetwork() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const e = yield this._ready(),
                n = yield this.detectNetwork()
            if (e.chainId !== n.chainId) {
                if (this.anyNetwork)
                    return (
                        (this._network = n),
                        (this._lastBlockNumber = -2),
                        (this._fastBlockNumber = null),
                        (this._fastBlockNumberPromise = null),
                        (this._fastQueryDate = 0),
                        (this._emitted.block = -2),
                        (this._maxInternalBlockNumber = -1024),
                        (this._internalBlockNumber = null),
                        this.emit("network", n, e),
                        yield stall(0),
                        this._network
                    )
                const i = logger$4.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: e,
                    detectedNetwork: n,
                })
                throw (this.emit("error", i), i)
            }
            return e
        })
    }
    get blockNumber() {
        return (
            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
                (e) => {
                    this._setFastBlockNumber(e)
                },
                (e) => {}
            ),
            this._fastBlockNumber != null ? this._fastBlockNumber : -1
        )
    }
    get polling() {
        return this._poller != null
    }
    set polling(e) {
        e && !this._poller
            ? ((this._poller = setInterval(() => {
                  this.poll()
              }, this.pollingInterval)),
              this._bootstrapPoll ||
                  (this._bootstrapPoll = setTimeout(() => {
                      this.poll(),
                          (this._bootstrapPoll = setTimeout(() => {
                              this._poller || this.poll(), (this._bootstrapPoll = null)
                          }, this.pollingInterval))
                  }, 0)))
            : !e && this._poller && (clearInterval(this._poller), (this._poller = null))
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(e) {
        if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval")
        ;(this._pollingInterval = e),
            this._poller &&
                (clearInterval(this._poller),
                (this._poller = setInterval(() => {
                    this.poll()
                }, this._pollingInterval)))
    }
    _getFastBlockNumber() {
        const e = getTime()
        return (
            e - this._fastQueryDate > 2 * this._pollingInterval &&
                ((this._fastQueryDate = e),
                (this._fastBlockNumberPromise = this.getBlockNumber().then(
                    (n) => ((this._fastBlockNumber == null || n > this._fastBlockNumber) && (this._fastBlockNumber = n), this._fastBlockNumber)
                ))),
            this._fastBlockNumberPromise
        )
    }
    _setFastBlockNumber(e) {
        ;(this._fastBlockNumber != null && e < this._fastBlockNumber) ||
            ((this._fastQueryDate = getTime()),
            (this._fastBlockNumber == null || e > this._fastBlockNumber) &&
                ((this._fastBlockNumber = e), (this._fastBlockNumberPromise = Promise.resolve(e))))
    }
    waitForTransaction(e, n, i) {
        return __awaiter$2(this, void 0, void 0, function* () {
            return this._waitForTransaction(e, n == null ? 1 : n, i || 0, null)
        })
    }
    _waitForTransaction(e, n, i, o) {
        return __awaiter$2(this, void 0, void 0, function* () {
            const a = yield this.getTransactionReceipt(e)
            return (a ? a.confirmations : 0) >= n
                ? a
                : new Promise((l, c) => {
                      const g = []
                      let v = !1
                      const _ = function () {
                              return v
                                  ? !0
                                  : ((v = !0),
                                    g.forEach((B) => {
                                        B()
                                    }),
                                    !1)
                          },
                          A = (B) => {
                              B.confirmations < n || _() || l(B)
                          }
                      if (
                          (this.on(e, A),
                          g.push(() => {
                              this.removeListener(e, A)
                          }),
                          o)
                      ) {
                          let B = o.startBlock,
                              D = null
                          const I = (L) =>
                              __awaiter$2(this, void 0, void 0, function* () {
                                  v ||
                                      (yield stall(1e3),
                                      this.getTransactionCount(o.from).then(
                                          (G) =>
                                              __awaiter$2(this, void 0, void 0, function* () {
                                                  if (!v) {
                                                      if (G <= o.nonce) B = L
                                                      else {
                                                          {
                                                              const U = yield this.getTransaction(e)
                                                              if (U && U.blockNumber != null) return
                                                          }
                                                          for (D == null && ((D = B - 3), D < o.startBlock && (D = o.startBlock)); D <= L; ) {
                                                              if (v) return
                                                              const U = yield this.getBlockWithTransactions(D)
                                                              for (let F = 0; F < U.transactions.length; F++) {
                                                                  const Z = U.transactions[F]
                                                                  if (Z.hash === e) return
                                                                  if (Z.from === o.from && Z.nonce === o.nonce) {
                                                                      if (v) return
                                                                      const Y = yield this.waitForTransaction(Z.hash, n)
                                                                      if (_()) return
                                                                      let X = "replaced"
                                                                      Z.data === o.data && Z.to === o.to && Z.value.eq(o.value)
                                                                          ? (X = "repriced")
                                                                          : Z.data === "0x" &&
                                                                            Z.from === Z.to &&
                                                                            Z.value.isZero() &&
                                                                            (X = "cancelled"),
                                                                          c(
                                                                              logger$4.makeError(
                                                                                  "transaction was replaced",
                                                                                  Logger.errors.TRANSACTION_REPLACED,
                                                                                  {
                                                                                      cancelled: X === "replaced" || X === "cancelled",
                                                                                      reason: X,
                                                                                      replacement: this._wrapTransaction(Z),
                                                                                      hash: e,
                                                                                      receipt: Y,
                                                                                  }
                                                                              )
                                                                          )
                                                                      return
                                                                  }
                                                              }
                                                              D++
                                                          }
                                                      }
                                                      v || this.once("block", I)
                                                  }
                                              }),
                                          (G) => {
                                              v || this.once("block", I)
                                          }
                                      ))
                              })
                          if (v) return
                          this.once("block", I),
                              g.push(() => {
                                  this.removeListener("block", I)
                              })
                      }
                      if (typeof i == "number" && i > 0) {
                          const B = setTimeout(() => {
                              _() || c(logger$4.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: i }))
                          }, i)
                          B.unref && B.unref(),
                              g.push(() => {
                                  clearTimeout(B)
                              })
                      }
                  })
        })
    }
    getBlockNumber() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const e = yield this.perform("getGasPrice", {})
            try {
                return BigNumber.from(e)
            } catch (n) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, { method: "getGasPrice", result: e, error: n })
            }
        })
    }
    getBalance(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield resolveProperties({ address: this._getAddress(e), blockTag: this._getBlockTag(n) }),
                o = yield this.perform("getBalance", i)
            try {
                return BigNumber.from(o)
            } catch (a) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params: i,
                    result: o,
                    error: a,
                })
            }
        })
    }
    getTransactionCount(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield resolveProperties({ address: this._getAddress(e), blockTag: this._getBlockTag(n) }),
                o = yield this.perform("getTransactionCount", i)
            try {
                return BigNumber.from(o).toNumber()
            } catch (a) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: i,
                    result: o,
                    error: a,
                })
            }
        })
    }
    getCode(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield resolveProperties({ address: this._getAddress(e), blockTag: this._getBlockTag(n) }),
                o = yield this.perform("getCode", i)
            try {
                return hexlify(o)
            } catch (a) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getCode",
                    params: i,
                    result: o,
                    error: a,
                })
            }
        })
    }
    getStorageAt(e, n, i) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const o = yield resolveProperties({
                    address: this._getAddress(e),
                    blockTag: this._getBlockTag(i),
                    position: Promise.resolve(n).then((l) => hexValue(l)),
                }),
                a = yield this.perform("getStorageAt", o)
            try {
                return hexlify(a)
            } catch (l) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: o,
                    result: a,
                    error: l,
                })
            }
        })
    }
    _wrapTransaction(e, n, i) {
        if (n != null && hexDataLength(n) !== 32) throw new Error("invalid response - sendTransaction")
        const o = e
        return (
            n != null &&
                e.hash !== n &&
                logger$4.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, {
                    expectedHash: e.hash,
                    returnedHash: n,
                }),
            (o.wait = (a, l) =>
                __awaiter$2(this, void 0, void 0, function* () {
                    a == null && (a = 1), l == null && (l = 0)
                    let c
                    a !== 0 && i != null && (c = { data: e.data, from: e.from, nonce: e.nonce, to: e.to, value: e.value, startBlock: i })
                    const g = yield this._waitForTransaction(e.hash, a, l, c)
                    return g == null && a === 0
                        ? null
                        : ((this._emitted["t:" + e.hash] = g.blockNumber),
                          g.status === 0 &&
                              logger$4.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
                                  transactionHash: e.hash,
                                  transaction: e,
                                  receipt: g,
                              }),
                          g)
                })),
            o
        )
    }
    sendTransaction(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Promise.resolve(e).then((a) => hexlify(a)),
                i = this.formatter.transaction(e)
            i.confirmations == null && (i.confirmations = 0)
            const o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
            try {
                const a = yield this.perform("sendTransaction", { signedTransaction: n })
                return this._wrapTransaction(i, a, o)
            } catch (a) {
                throw ((a.transaction = i), (a.transactionHash = i.hash), a)
            }
        })
    }
    _getTransactionRequest(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            const n = yield e,
                i = {}
            return (
                ["from", "to"].forEach((o) => {
                    n[o] != null && (i[o] = Promise.resolve(n[o]).then((a) => (a ? this._getAddress(a) : null)))
                }),
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((o) => {
                    n[o] != null && (i[o] = Promise.resolve(n[o]).then((a) => (a ? BigNumber.from(a) : null)))
                }),
                ["type"].forEach((o) => {
                    n[o] != null && (i[o] = Promise.resolve(n[o]).then((a) => (a != null ? a : null)))
                }),
                n.accessList && (i.accessList = this.formatter.accessList(n.accessList)),
                ["data"].forEach((o) => {
                    n[o] != null && (i[o] = Promise.resolve(n[o]).then((a) => (a ? hexlify(a) : null)))
                }),
                this.formatter.transactionRequest(yield resolveProperties(i))
            )
        })
    }
    _getFilter(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            e = yield e
            const n = {}
            return (
                e.address != null && (n.address = this._getAddress(e.address)),
                ["blockHash", "topics"].forEach((i) => {
                    e[i] != null && (n[i] = e[i])
                }),
                ["fromBlock", "toBlock"].forEach((i) => {
                    e[i] != null && (n[i] = this._getBlockTag(e[i]))
                }),
                this.formatter.filter(yield resolveProperties(n))
            )
        })
    }
    _call(e, n, i) {
        return __awaiter$2(this, void 0, void 0, function* () {
            i >= MAX_CCIP_REDIRECTS &&
                logger$4.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, { redirects: i, transaction: e })
            const o = e.to,
                a = yield this.perform("call", { transaction: e, blockTag: n })
            if (i >= 0 && n === "latest" && o != null && a.substring(0, 10) === "0x556f1830" && hexDataLength(a) % 32 === 4)
                try {
                    const l = hexDataSlice(a, 4),
                        c = hexDataSlice(l, 0, 32)
                    BigNumber.from(c).eq(o) ||
                        logger$4.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: a,
                        })
                    const g = [],
                        v = BigNumber.from(hexDataSlice(l, 32, 64)).toNumber(),
                        _ = BigNumber.from(hexDataSlice(l, v, v + 32)).toNumber(),
                        A = hexDataSlice(l, v + 32)
                    for (let U = 0; U < _; U++) {
                        const F = _parseString(A, U * 32)
                        F == null &&
                            logger$4.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: e,
                                data: a,
                            }),
                            g.push(F)
                    }
                    const B = _parseBytes(l, 64)
                    BigNumber.from(hexDataSlice(l, 100, 128)).isZero() ||
                        logger$4.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: a,
                        })
                    const D = hexDataSlice(l, 96, 100),
                        I = _parseBytes(l, 128),
                        L = yield this.ccipReadFetch(e, B, g)
                    L == null &&
                        logger$4.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: a,
                        })
                    const G = { to: o, data: hexConcat([D, encodeBytes$1([L, I])]) }
                    return this._call(G, n, i + 1)
                } catch (l) {
                    if (l.code === Logger.errors.SERVER_ERROR) throw l
                }
            try {
                return hexlify(a)
            } catch (l) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "call",
                    params: { transaction: e, blockTag: n },
                    result: a,
                    error: l,
                })
            }
        })
    }
    call(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield resolveProperties({
                transaction: this._getTransactionRequest(e),
                blockTag: this._getBlockTag(n),
                ccipReadEnabled: Promise.resolve(e.ccipReadEnabled),
            })
            return this._call(i.transaction, i.blockTag, i.ccipReadEnabled ? 0 : -1)
        })
    }
    estimateGas(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield resolveProperties({ transaction: this._getTransactionRequest(e) }),
                i = yield this.perform("estimateGas", n)
            try {
                return BigNumber.from(i)
            } catch (o) {
                return logger$4.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params: n,
                    result: i,
                    error: o,
                })
            }
        })
    }
    _getAddress(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            ;(e = yield e), typeof e != "string" && logger$4.throwArgumentError("invalid address or ENS name", "name", e)
            const n = yield this.resolveName(e)
            return (
                n == null &&
                    logger$4.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: `resolveName(${JSON.stringify(e)})`,
                    }),
                n
            )
        })
    }
    _getBlock(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            let i = -128
            const o = { includeTransactions: !!n }
            if (isHexString(e, 32)) o.blockHash = e
            else
                try {
                    ;(o.blockTag = yield this._getBlockTag(e)), isHexString(o.blockTag) && (i = parseInt(o.blockTag.substring(2), 16))
                } catch {
                    logger$4.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
                }
            return poll(
                () =>
                    __awaiter$2(this, void 0, void 0, function* () {
                        const a = yield this.perform("getBlock", o)
                        if (a == null)
                            return (o.blockHash != null && this._emitted["b:" + o.blockHash] == null) ||
                                (o.blockTag != null && i > this._emitted.block)
                                ? null
                                : void 0
                        if (n) {
                            let l = null
                            for (let g = 0; g < a.transactions.length; g++) {
                                const v = a.transactions[g]
                                if (v.blockNumber == null) v.confirmations = 0
                                else if (v.confirmations == null) {
                                    l == null && (l = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval))
                                    let _ = l - v.blockNumber + 1
                                    _ <= 0 && (_ = 1), (v.confirmations = _)
                                }
                            }
                            const c = this.formatter.blockWithTransactions(a)
                            return (c.transactions = c.transactions.map((g) => this._wrapTransaction(g))), c
                        }
                        return this.formatter.block(a)
                    }),
                { oncePoll: this }
            )
        })
    }
    getBlock(e) {
        return this._getBlock(e, !1)
    }
    getBlockWithTransactions(e) {
        return this._getBlock(e, !0)
    }
    getTransaction(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            const n = { transactionHash: this.formatter.hash(e, !0) }
            return poll(
                () =>
                    __awaiter$2(this, void 0, void 0, function* () {
                        const i = yield this.perform("getTransaction", n)
                        if (i == null) return this._emitted["t:" + e] == null ? null : void 0
                        const o = this.formatter.transactionResponse(i)
                        if (o.blockNumber == null) o.confirmations = 0
                        else if (o.confirmations == null) {
                            let l = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - o.blockNumber + 1
                            l <= 0 && (l = 1), (o.confirmations = l)
                        }
                        return this._wrapTransaction(o)
                    }),
                { oncePoll: this }
            )
        })
    }
    getTransactionReceipt(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork(), (e = yield e)
            const n = { transactionHash: this.formatter.hash(e, !0) }
            return poll(
                () =>
                    __awaiter$2(this, void 0, void 0, function* () {
                        const i = yield this.perform("getTransactionReceipt", n)
                        if (i == null) return this._emitted["t:" + e] == null ? null : void 0
                        if (i.blockHash == null) return
                        const o = this.formatter.receipt(i)
                        if (o.blockNumber == null) o.confirmations = 0
                        else if (o.confirmations == null) {
                            let l = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - o.blockNumber + 1
                            l <= 0 && (l = 1), (o.confirmations = l)
                        }
                        return o
                    }),
                { oncePoll: this }
            )
        })
    }
    getLogs(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield resolveProperties({ filter: this._getFilter(e) }),
                i = yield this.perform("getLogs", n)
            return (
                i.forEach((o) => {
                    o.removed == null && (o.removed = !1)
                }),
                Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(i)
            )
        })
    }
    getEtherPrice() {
        return __awaiter$2(this, void 0, void 0, function* () {
            return yield this.getNetwork(), this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (((e = yield e), typeof e == "number" && e < 0)) {
                e % 1 && logger$4.throwArgumentError("invalid BlockTag", "blockTag", e)
                let n = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
                return (n += e), n < 0 && (n = 0), this.formatter.blockTag(n)
            }
            return this.formatter.blockTag(e)
        })
    }
    getResolver(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            let n = e
            for (;;) {
                if (n === "" || n === "." || (e !== "eth" && n === "eth")) return null
                const i = yield this._getResolver(n, "getResolver")
                if (i != null) {
                    const o = new Resolver(this, i, e)
                    return n !== e && !(yield o.supportsWildcard()) ? null : o
                }
                n = n.split(".").slice(1).join(".")
            }
        })
    }
    _getResolver(e, n) {
        return __awaiter$2(this, void 0, void 0, function* () {
            n == null && (n = "ENS")
            const i = yield this.getNetwork()
            i.ensAddress ||
                logger$4.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: n, network: i.name })
            try {
                const o = yield this.call({ to: i.ensAddress, data: "0x0178b8bf" + namehash(e).substring(2) })
                return this.formatter.callAddress(o)
            } catch {}
            return null
        })
    }
    resolveName(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            e = yield e
            try {
                return Promise.resolve(this.formatter.address(e))
            } catch (i) {
                if (isHexString(e)) throw i
            }
            typeof e != "string" && logger$4.throwArgumentError("invalid ENS name", "name", e)
            const n = yield this.getResolver(e)
            return n ? yield n.getAddress() : null
        })
    }
    lookupAddress(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            ;(e = yield e), (e = this.formatter.address(e))
            const n = e.substring(2).toLowerCase() + ".addr.reverse",
                i = yield this._getResolver(n, "lookupAddress")
            if (i == null) return null
            const o = _parseString(yield this.call({ to: i, data: "0x691f3431" + namehash(n).substring(2) }), 0)
            return (yield this.resolveName(o)) != e ? null : o
        })
    }
    getAvatar(e) {
        return __awaiter$2(this, void 0, void 0, function* () {
            let n = null
            if (isHexString(e)) {
                const a = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse",
                    l = yield this._getResolver(a, "getAvatar")
                if (!l) return null
                n = new Resolver(this, l, a)
                try {
                    const c = yield n.getAvatar()
                    if (c) return c.url
                } catch (c) {
                    if (c.code !== Logger.errors.CALL_EXCEPTION) throw c
                }
                try {
                    const c = _parseString(yield this.call({ to: l, data: "0x691f3431" + namehash(a).substring(2) }), 0)
                    n = yield this.getResolver(c)
                } catch (c) {
                    if (c.code !== Logger.errors.CALL_EXCEPTION) throw c
                    return null
                }
            } else if (((n = yield this.getResolver(e)), !n)) return null
            const i = yield n.getAvatar()
            return i == null ? null : i.url
        })
    }
    perform(e, n) {
        return logger$4.throwError(e + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: e })
    }
    _startEvent(e) {
        this.polling = this._events.filter((n) => n.pollable()).length > 0
    }
    _stopEvent(e) {
        this.polling = this._events.filter((n) => n.pollable()).length > 0
    }
    _addEventListener(e, n, i) {
        const o = new Event$1(getEventTag(e), n, i)
        return this._events.push(o), this._startEvent(o), this
    }
    on(e, n) {
        return this._addEventListener(e, n, !1)
    }
    once(e, n) {
        return this._addEventListener(e, n, !0)
    }
    emit(e, ...n) {
        let i = !1,
            o = [],
            a = getEventTag(e)
        return (
            (this._events = this._events.filter((l) =>
                l.tag !== a
                    ? !0
                    : (setTimeout(() => {
                          l.listener.apply(this, n)
                      }, 0),
                      (i = !0),
                      l.once ? (o.push(l), !1) : !0)
            )),
            o.forEach((l) => {
                this._stopEvent(l)
            }),
            i
        )
    }
    listenerCount(e) {
        if (!e) return this._events.length
        let n = getEventTag(e)
        return this._events.filter((i) => i.tag === n).length
    }
    listeners(e) {
        if (e == null) return this._events.map((i) => i.listener)
        let n = getEventTag(e)
        return this._events.filter((i) => i.tag === n).map((i) => i.listener)
    }
    off(e, n) {
        if (n == null) return this.removeAllListeners(e)
        const i = []
        let o = !1,
            a = getEventTag(e)
        return (
            (this._events = this._events.filter((l) => (l.tag !== a || l.listener != n || o ? !0 : ((o = !0), i.push(l), !1)))),
            i.forEach((l) => {
                this._stopEvent(l)
            }),
            this
        )
    }
    removeAllListeners(e) {
        let n = []
        if (e == null) (n = this._events), (this._events = [])
        else {
            const i = getEventTag(e)
            this._events = this._events.filter((o) => (o.tag !== i ? !0 : (n.push(o), !1)))
        }
        return (
            n.forEach((i) => {
                this._stopEvent(i)
            }),
            this
        )
    }
}
var __awaiter$1 =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$3 = new Logger(version$2),
    errorGas = ["call", "estimateGas"]
function spelunk(t, e) {
    if (t == null) return null
    if (typeof t.message == "string" && t.message.match("reverted")) {
        const n = isHexString(t.data) ? t.data : null
        if (!e || n) return { message: t.message, data: n }
    }
    if (typeof t == "object") {
        for (const n in t) {
            const i = spelunk(t[n], e)
            if (i) return i
        }
        return null
    }
    if (typeof t == "string")
        try {
            return spelunk(JSON.parse(t), e)
        } catch {}
    return null
}
function checkError(t, e, n) {
    const i = n.transaction || n.signedTransaction
    if (t === "call") {
        const a = spelunk(e, !0)
        if (a) return a.data
        logger$3.throwError(
            "missing revert data in call exception; Transaction reverted without a reason string",
            Logger.errors.CALL_EXCEPTION,
            { data: "0x", transaction: i, error: e }
        )
    }
    if (t === "estimateGas") {
        let a = spelunk(e.body, !1)
        a == null && (a = spelunk(e, !1)),
            a &&
                logger$3.throwError(
                    "cannot estimate gas; transaction may fail or may require manual gas limit",
                    Logger.errors.UNPREDICTABLE_GAS_LIMIT,
                    { reason: a.message, method: t, transaction: i, error: e }
                )
    }
    let o = e.message
    throw (
        (e.code === Logger.errors.SERVER_ERROR && e.error && typeof e.error.message == "string"
            ? (o = e.error.message)
            : typeof e.body == "string"
            ? (o = e.body)
            : typeof e.responseText == "string" && (o = e.responseText),
        (o = (o || "").toLowerCase()),
        o.match(/insufficient funds|base fee exceeds gas limit/i) &&
            logger$3.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
                error: e,
                method: t,
                transaction: i,
            }),
        o.match(/nonce (is )?too low/i) &&
            logger$3.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, { error: e, method: t, transaction: i }),
        o.match(/replacement transaction underpriced|transaction gas price.*too low/i) &&
            logger$3.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, { error: e, method: t, transaction: i }),
        o.match(/only replay-protected/i) &&
            logger$3.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
                error: e,
                method: t,
                transaction: i,
            }),
        errorGas.indexOf(t) >= 0 &&
            o.match(/gas required exceeds allowance|always failing transaction|execution reverted/) &&
            logger$3.throwError(
                "cannot estimate gas; transaction may fail or may require manual gas limit",
                Logger.errors.UNPREDICTABLE_GAS_LIMIT,
                { error: e, method: t, transaction: i }
            ),
        e)
    )
}
function timer(t) {
    return new Promise(function (e) {
        setTimeout(e, t)
    })
}
function getResult(t) {
    if (t.error) {
        const e = new Error(t.error.message)
        throw ((e.code = t.error.code), (e.data = t.error.data), e)
    }
    return t.result
}
function getLowerCase(t) {
    return t && t.toLowerCase()
}
const _constructorGuard = {}
class JsonRpcSigner extends Signer {
    constructor(e, n, i) {
        if ((super(), e !== _constructorGuard)) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner")
        defineReadOnly(this, "provider", n),
            i == null && (i = 0),
            typeof i == "string"
                ? (defineReadOnly(this, "_address", this.provider.formatter.address(i)), defineReadOnly(this, "_index", null))
                : typeof i == "number"
                ? (defineReadOnly(this, "_index", i), defineReadOnly(this, "_address", null))
                : logger$3.throwArgumentError("invalid address or index", "addressOrIndex", i)
    }
    connect(e) {
        return logger$3.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, { operation: "connect" })
    }
    connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index)
    }
    getAddress() {
        return this._address
            ? Promise.resolve(this._address)
            : this.provider
                  .send("eth_accounts", [])
                  .then(
                      (e) => (
                          e.length <= this._index &&
                              logger$3.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
                                  operation: "getAddress",
                              }),
                          this.provider.formatter.address(e[this._index])
                      )
                  )
    }
    sendUncheckedTransaction(e) {
        e = shallowCopy(e)
        const n = this.getAddress().then((i) => (i && (i = i.toLowerCase()), i))
        if (e.gasLimit == null) {
            const i = shallowCopy(e)
            ;(i.from = n), (e.gasLimit = this.provider.estimateGas(i))
        }
        return (
            e.to != null &&
                (e.to = Promise.resolve(e.to).then((i) =>
                    __awaiter$1(this, void 0, void 0, function* () {
                        if (i == null) return null
                        const o = yield this.provider.resolveName(i)
                        return o == null && logger$3.throwArgumentError("provided ENS name resolves to null", "tx.to", i), o
                    })
                )),
            resolveProperties({ tx: resolveProperties(e), sender: n }).then(({ tx: i, sender: o }) => {
                i.from != null
                    ? i.from.toLowerCase() !== o && logger$3.throwArgumentError("from address mismatch", "transaction", e)
                    : (i.from = o)
                const a = this.provider.constructor.hexlifyTransaction(i, { from: !0 })
                return this.provider.send("eth_sendTransaction", [a]).then(
                    (l) => l,
                    (l) => (
                        typeof l.message == "string" &&
                            l.message.match(/user denied/i) &&
                            logger$3.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
                                action: "sendTransaction",
                                transaction: i,
                            }),
                        checkError("sendTransaction", l, a)
                    )
                )
            })
        )
    }
    signTransaction(e) {
        return logger$3.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, { operation: "signTransaction" })
    }
    sendTransaction(e) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const n = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
                i = yield this.sendUncheckedTransaction(e)
            try {
                return yield poll(
                    () =>
                        __awaiter$1(this, void 0, void 0, function* () {
                            const o = yield this.provider.getTransaction(i)
                            if (o !== null) return this.provider._wrapTransaction(o, i, n)
                        }),
                    { oncePoll: this.provider }
                )
            } catch (o) {
                throw ((o.transactionHash = i), o)
            }
        })
    }
    signMessage(e) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const n = typeof e == "string" ? toUtf8Bytes(e) : e,
                i = yield this.getAddress()
            try {
                return yield this.provider.send("personal_sign", [hexlify(n), i.toLowerCase()])
            } catch (o) {
                throw (
                    (typeof o.message == "string" &&
                        o.message.match(/user denied/i) &&
                        logger$3.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                            action: "signMessage",
                            from: i,
                            message: n,
                        }),
                    o)
                )
            }
        })
    }
    _legacySignMessage(e) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const n = typeof e == "string" ? toUtf8Bytes(e) : e,
                i = yield this.getAddress()
            try {
                return yield this.provider.send("eth_sign", [i.toLowerCase(), hexlify(n)])
            } catch (o) {
                throw (
                    (typeof o.message == "string" &&
                        o.message.match(/user denied/i) &&
                        logger$3.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                            action: "_legacySignMessage",
                            from: i,
                            message: n,
                        }),
                    o)
                )
            }
        })
    }
    _signTypedData(e, n, i) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const o = yield TypedDataEncoder.resolveNames(e, n, i, (l) => this.provider.resolveName(l)),
                a = yield this.getAddress()
            try {
                return yield this.provider.send("eth_signTypedData_v4", [
                    a.toLowerCase(),
                    JSON.stringify(TypedDataEncoder.getPayload(o.domain, n, o.value)),
                ])
            } catch (l) {
                throw (
                    (typeof l.message == "string" &&
                        l.message.match(/user denied/i) &&
                        logger$3.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                            action: "_signTypedData",
                            from: a,
                            message: { domain: o.domain, types: n, value: o.value },
                        }),
                    l)
                )
            }
        })
    }
    unlock(e) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const n = this.provider,
                i = yield this.getAddress()
            return n.send("personal_unlockAccount", [i.toLowerCase(), e, null])
        })
    }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then((n) => ({
            hash: n,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: (i) => this.provider.waitForTransaction(n, i),
        }))
    }
}
const allowedTransactionKeys = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0,
}
class JsonRpcProvider extends BaseProvider {
    constructor(e, n) {
        let i = n
        i == null &&
            (i = new Promise((o, a) => {
                setTimeout(() => {
                    this.detectNetwork().then(
                        (l) => {
                            o(l)
                        },
                        (l) => {
                            a(l)
                        }
                    )
                }, 0)
            })),
            super(i),
            e || (e = getStatic(this.constructor, "defaultUrl")()),
            typeof e == "string"
                ? defineReadOnly(this, "connection", Object.freeze({ url: e }))
                : defineReadOnly(this, "connection", Object.freeze(shallowCopy(e))),
            (this._nextId = 42)
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return (
            this._cache.detectNetwork ||
                ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
                setTimeout(() => {
                    this._cache.detectNetwork = null
                }, 0)),
            this._cache.detectNetwork
        )
    }
    _uncachedDetectNetwork() {
        return __awaiter$1(this, void 0, void 0, function* () {
            yield timer(0)
            let e = null
            try {
                e = yield this.send("eth_chainId", [])
            } catch {
                try {
                    e = yield this.send("net_version", [])
                } catch {}
            }
            if (e != null) {
                const n = getStatic(this.constructor, "getNetwork")
                try {
                    return n(BigNumber.from(e).toNumber())
                } catch (i) {
                    return logger$3.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                        chainId: e,
                        event: "invalidNetwork",
                        serverError: i,
                    })
                }
            }
            return logger$3.throwError("could not detect network", Logger.errors.NETWORK_ERROR, { event: "noNetwork" })
        })
    }
    getSigner(e) {
        return new JsonRpcSigner(_constructorGuard, this, e)
    }
    getUncheckedSigner(e) {
        return this.getSigner(e).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((e) => e.map((n) => this.formatter.address(n)))
    }
    send(e, n) {
        const i = { method: e, params: n, id: this._nextId++, jsonrpc: "2.0" }
        this.emit("debug", { action: "request", request: deepCopy(i), provider: this })
        const o = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0
        if (o && this._cache[e]) return this._cache[e]
        const a = fetchJson(this.connection, JSON.stringify(i), getResult).then(
            (l) => (this.emit("debug", { action: "response", request: i, response: l, provider: this }), l),
            (l) => {
                throw (this.emit("debug", { action: "response", error: l, request: i, provider: this }), l)
            }
        )
        return (
            o &&
                ((this._cache[e] = a),
                setTimeout(() => {
                    this._cache[e] = null
                }, 0)),
            a
        )
    }
    prepareRequest(e, n) {
        switch (e) {
            case "getBlockNumber":
                return ["eth_blockNumber", []]
            case "getGasPrice":
                return ["eth_gasPrice", []]
            case "getBalance":
                return ["eth_getBalance", [getLowerCase(n.address), n.blockTag]]
            case "getTransactionCount":
                return ["eth_getTransactionCount", [getLowerCase(n.address), n.blockTag]]
            case "getCode":
                return ["eth_getCode", [getLowerCase(n.address), n.blockTag]]
            case "getStorageAt":
                return ["eth_getStorageAt", [getLowerCase(n.address), hexZeroPad(n.position, 32), n.blockTag]]
            case "sendTransaction":
                return ["eth_sendRawTransaction", [n.signedTransaction]]
            case "getBlock":
                return n.blockTag
                    ? ["eth_getBlockByNumber", [n.blockTag, !!n.includeTransactions]]
                    : n.blockHash
                    ? ["eth_getBlockByHash", [n.blockHash, !!n.includeTransactions]]
                    : null
            case "getTransaction":
                return ["eth_getTransactionByHash", [n.transactionHash]]
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [n.transactionHash]]
            case "call": {
                const i = getStatic(this.constructor, "hexlifyTransaction")
                return ["eth_call", [i(n.transaction, { from: !0 }), n.blockTag]]
            }
            case "estimateGas": {
                const i = getStatic(this.constructor, "hexlifyTransaction")
                return ["eth_estimateGas", [i(n.transaction, { from: !0 })]]
            }
            case "getLogs":
                return n.filter && n.filter.address != null && (n.filter.address = getLowerCase(n.filter.address)), ["eth_getLogs", [n.filter]]
        }
        return null
    }
    perform(e, n) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (e === "call" || e === "estimateGas") {
                const o = n.transaction
                if (o && o.type != null && BigNumber.from(o.type).isZero() && o.maxFeePerGas == null && o.maxPriorityFeePerGas == null) {
                    const a = yield this.getFeeData()
                    a.maxFeePerGas == null &&
                        a.maxPriorityFeePerGas == null &&
                        ((n = shallowCopy(n)), (n.transaction = shallowCopy(o)), delete n.transaction.type)
                }
            }
            const i = this.prepareRequest(e, n)
            i == null && logger$3.throwError(e + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: e })
            try {
                return yield this.send(i[0], i[1])
            } catch (o) {
                return checkError(e, o, n)
            }
        })
    }
    _startEvent(e) {
        e.tag === "pending" && this._startPending(), super._startEvent(e)
    }
    _startPending() {
        if (this._pendingFilter != null) return
        const e = this,
            n = this.send("eth_newPendingTransactionFilter", [])
        ;(this._pendingFilter = n),
            n
                .then(function (i) {
                    function o() {
                        e.send("eth_getFilterChanges", [i])
                            .then(function (a) {
                                if (e._pendingFilter != n) return null
                                let l = Promise.resolve()
                                return (
                                    a.forEach(function (c) {
                                        ;(e._emitted["t:" + c.toLowerCase()] = "pending"),
                                            (l = l.then(function () {
                                                return e.getTransaction(c).then(function (g) {
                                                    return e.emit("pending", g), null
                                                })
                                            }))
                                    }),
                                    l.then(function () {
                                        return timer(1e3)
                                    })
                                )
                            })
                            .then(function () {
                                if (e._pendingFilter != n) {
                                    e.send("eth_uninstallFilter", [i])
                                    return
                                }
                                return (
                                    setTimeout(function () {
                                        o()
                                    }, 0),
                                    null
                                )
                            })
                            .catch((a) => {})
                    }
                    return o(), i
                })
                .catch((i) => {})
    }
    _stopEvent(e) {
        e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e)
    }
    static hexlifyTransaction(e, n) {
        const i = shallowCopy(allowedTransactionKeys)
        if (n) for (const a in n) n[a] && (i[a] = !0)
        checkProperties(e, i)
        const o = {}
        return (
            ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (a) {
                if (e[a] == null) return
                const l = hexValue(BigNumber.from(e[a]))
                a === "gasLimit" && (a = "gas"), (o[a] = l)
            }),
            ["from", "to", "data"].forEach(function (a) {
                e[a] != null && (o[a] = hexlify(e[a]))
            }),
            e.accessList && (o.accessList = accessListify(e.accessList)),
            o
        )
    }
}
var __awaiter =
    (globalThis && globalThis.__awaiter) ||
    function (t, e, n, i) {
        function o(a) {
            return a instanceof n
                ? a
                : new n(function (l) {
                      l(a)
                  })
        }
        return new (n || (n = Promise))(function (a, l) {
            function c(_) {
                try {
                    v(i.next(_))
                } catch (A) {
                    l(A)
                }
            }
            function g(_) {
                try {
                    v(i.throw(_))
                } catch (A) {
                    l(A)
                }
            }
            function v(_) {
                _.done ? a(_.value) : o(_.value).then(c, g)
            }
            v((i = i.apply(t, e || [])).next())
        })
    }
const logger$2 = new Logger(version$2)
class StaticJsonRpcProvider extends JsonRpcProvider {
    detectNetwork() {
        const e = Object.create(null, { detectNetwork: { get: () => super.detectNetwork } })
        return __awaiter(this, void 0, void 0, function* () {
            let n = this.network
            return (
                n == null &&
                    ((n = yield e.detectNetwork.call(this)),
                    n || logger$2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {}),
                    this._network == null && (defineReadOnly(this, "_network", n), this.emit("network", n, null))),
                n
            )
        })
    }
}
const logger$1 = new Logger(version$2)
let _nextId = 1
function buildWeb3LegacyFetcher(t, e) {
    const n = "Web3LegacyFetcher"
    return function (i, o) {
        const a = { method: i, params: o, id: _nextId++, jsonrpc: "2.0" }
        return new Promise((l, c) => {
            this.emit("debug", { action: "request", fetcher: n, request: deepCopy(a), provider: this }),
                e(a, (g, v) => {
                    if (g) return this.emit("debug", { action: "response", fetcher: n, error: g, request: a, provider: this }), c(g)
                    if ((this.emit("debug", { action: "response", fetcher: n, request: a, response: v, provider: this }), v.error)) {
                        const _ = new Error(v.error.message)
                        return (_.code = v.error.code), (_.data = v.error.data), c(_)
                    }
                    l(v.result)
                })
        })
    }
}
function buildEip1193Fetcher(t) {
    return function (e, n) {
        n == null && (n = [])
        const i = { method: e, params: n }
        return (
            this.emit("debug", { action: "request", fetcher: "Eip1193Fetcher", request: deepCopy(i), provider: this }),
            t.request(i).then(
                (o) => (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: i, response: o, provider: this }), o),
                (o) => {
                    throw (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: i, error: o, provider: this }), o)
                }
            )
        )
    }
}
class Web3Provider extends JsonRpcProvider {
    constructor(e, n) {
        e == null && logger$1.throwArgumentError("missing provider", "provider", e)
        let i = null,
            o = null,
            a = null
        typeof e == "function"
            ? ((i = "unknown:"), (o = e))
            : ((i = e.host || e.path || ""),
              !i && e.isMetaMask && (i = "metamask"),
              (a = e),
              e.request
                  ? (i === "" && (i = "eip-1193:"), (o = buildEip1193Fetcher(e)))
                  : e.sendAsync
                  ? (o = buildWeb3LegacyFetcher(e, e.sendAsync.bind(e)))
                  : e.send
                  ? (o = buildWeb3LegacyFetcher(e, e.send.bind(e)))
                  : logger$1.throwArgumentError("unsupported provider", "provider", e),
              i || (i = "unknown:")),
            super(i, n),
            defineReadOnly(this, "jsonRpcFetchFunc", o),
            defineReadOnly(this, "provider", a)
    }
    send(e, n) {
        return this.jsonRpcFetchFunc(e, n)
    }
}
const version$1 = "ethers/5.7.0"
new Logger(version$1)
var top = "top",
    bottom = "bottom",
    right = "right",
    left = "left",
    auto = "auto",
    basePlacements = [top, bottom, right, left],
    start = "start",
    end = "end",
    clippingParents = "clippingParents",
    viewport = "viewport",
    popper = "popper",
    reference = "reference",
    variationPlacements = basePlacements.reduce(function (t, e) {
        return t.concat([e + "-" + start, e + "-" + end])
    }, []),
    placements = [].concat(basePlacements, [auto]).reduce(function (t, e) {
        return t.concat([e, e + "-" + start, e + "-" + end])
    }, []),
    beforeRead = "beforeRead",
    read$2 = "read",
    afterRead = "afterRead",
    beforeMain = "beforeMain",
    main$1 = "main",
    afterMain = "afterMain",
    beforeWrite = "beforeWrite",
    write = "write",
    afterWrite = "afterWrite",
    modifierPhases = [beforeRead, read$2, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite]
function getNodeName(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}
function getWindow(t) {
    if (t == null) return window
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument
        return (e && e.defaultView) || window
    }
    return t
}
function isElement$1(t) {
    var e = getWindow(t).Element
    return t instanceof e || t instanceof Element
}
function isHTMLElement(t) {
    var e = getWindow(t).HTMLElement
    return t instanceof e || t instanceof HTMLElement
}
function isShadowRoot(t) {
    if (typeof ShadowRoot == "undefined") return !1
    var e = getWindow(t).ShadowRoot
    return t instanceof e || t instanceof ShadowRoot
}
function applyStyles(t) {
    var e = t.state
    Object.keys(e.elements).forEach(function (n) {
        var i = e.styles[n] || {},
            o = e.attributes[n] || {},
            a = e.elements[n]
        !isHTMLElement(a) ||
            !getNodeName(a) ||
            (Object.assign(a.style, i),
            Object.keys(o).forEach(function (l) {
                var c = o[l]
                c === !1 ? a.removeAttribute(l) : a.setAttribute(l, c === !0 ? "" : c)
            }))
    })
}
function effect$2(t) {
    var e = t.state,
        n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }
    return (
        Object.assign(e.elements.popper.style, n.popper),
        (e.styles = n),
        e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function () {
            Object.keys(e.elements).forEach(function (i) {
                var o = e.elements[i],
                    a = e.attributes[i] || {},
                    l = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : n[i]),
                    c = l.reduce(function (g, v) {
                        return (g[v] = ""), g
                    }, {})
                !isHTMLElement(o) ||
                    !getNodeName(o) ||
                    (Object.assign(o.style, c),
                    Object.keys(a).forEach(function (g) {
                        o.removeAttribute(g)
                    }))
            })
        }
    )
}
var applyStyles$1 = { name: "applyStyles", enabled: !0, phase: "write", fn: applyStyles, effect: effect$2, requires: ["computeStyles"] }
function getBasePlacement(t) {
    return t.split("-")[0]
}
var max = Math.max,
    min = Math.min,
    round$1 = Math.round
function getUAString() {
    var t = navigator.userAgentData
    return t != null && t.brands
        ? t.brands
              .map(function (e) {
                  return e.brand + "/" + e.version
              })
              .join(" ")
        : navigator.userAgent
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function getBoundingClientRect(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1)
    var i = t.getBoundingClientRect(),
        o = 1,
        a = 1
    e &&
        isHTMLElement(t) &&
        ((o = (t.offsetWidth > 0 && round$1(i.width) / t.offsetWidth) || 1),
        (a = (t.offsetHeight > 0 && round$1(i.height) / t.offsetHeight) || 1))
    var l = isElement$1(t) ? getWindow(t) : window,
        c = l.visualViewport,
        g = !isLayoutViewport() && n,
        v = (i.left + (g && c ? c.offsetLeft : 0)) / o,
        _ = (i.top + (g && c ? c.offsetTop : 0)) / a,
        A = i.width / o,
        B = i.height / a
    return { width: A, height: B, top: _, right: v + A, bottom: _ + B, left: v, x: v, y: _ }
}
function getLayoutRect(t) {
    var e = getBoundingClientRect(t),
        n = t.offsetWidth,
        i = t.offsetHeight
    return (
        Math.abs(e.width - n) <= 1 && (n = e.width),
        Math.abs(e.height - i) <= 1 && (i = e.height),
        { x: t.offsetLeft, y: t.offsetTop, width: n, height: i }
    )
}
function contains(t, e) {
    var n = e.getRootNode && e.getRootNode()
    if (t.contains(e)) return !0
    if (n && isShadowRoot(n)) {
        var i = e
        do {
            if (i && t.isSameNode(i)) return !0
            i = i.parentNode || i.host
        } while (i)
    }
    return !1
}
function getComputedStyle$1(t) {
    return getWindow(t).getComputedStyle(t)
}
function isTableElement(t) {
    return ["table", "td", "th"].indexOf(getNodeName(t)) >= 0
}
function getDocumentElement(t) {
    return ((isElement$1(t) ? t.ownerDocument : t.document) || window.document).documentElement
}
function getParentNode(t) {
    return getNodeName(t) === "html" ? t : t.assignedSlot || t.parentNode || (isShadowRoot(t) ? t.host : null) || getDocumentElement(t)
}
function getTrueOffsetParent(t) {
    return !isHTMLElement(t) || getComputedStyle$1(t).position === "fixed" ? null : t.offsetParent
}
function getContainingBlock(t) {
    var e = /firefox/i.test(getUAString()),
        n = /Trident/i.test(getUAString())
    if (n && isHTMLElement(t)) {
        var i = getComputedStyle$1(t)
        if (i.position === "fixed") return null
    }
    var o = getParentNode(t)
    for (isShadowRoot(o) && (o = o.host); isHTMLElement(o) && ["html", "body"].indexOf(getNodeName(o)) < 0; ) {
        var a = getComputedStyle$1(o)
        if (
            a.transform !== "none" ||
            a.perspective !== "none" ||
            a.contain === "paint" ||
            ["transform", "perspective"].indexOf(a.willChange) !== -1 ||
            (e && a.willChange === "filter") ||
            (e && a.filter && a.filter !== "none")
        )
            return o
        o = o.parentNode
    }
    return null
}
function getOffsetParent(t) {
    for (var e = getWindow(t), n = getTrueOffsetParent(t); n && isTableElement(n) && getComputedStyle$1(n).position === "static"; )
        n = getTrueOffsetParent(n)
    return n && (getNodeName(n) === "html" || (getNodeName(n) === "body" && getComputedStyle$1(n).position === "static"))
        ? e
        : n || getContainingBlock(t) || e
}
function getMainAxisFromPlacement(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}
function within(t, e, n) {
    return max(t, min(e, n))
}
function withinMaxClamp(t, e, n) {
    var i = within(t, e, n)
    return i > n ? n : i
}
function getFreshSideObject() {
    return { top: 0, right: 0, bottom: 0, left: 0 }
}
function mergePaddingObject(t) {
    return Object.assign({}, getFreshSideObject(), t)
}
function expandToHashMap(t, e) {
    return e.reduce(function (n, i) {
        return (n[i] = t), n
    }, {})
}
var toPaddingObject = function (e, n) {
    return (
        (e = typeof e == "function" ? e(Object.assign({}, n.rects, { placement: n.placement })) : e),
        mergePaddingObject(typeof e != "number" ? e : expandToHashMap(e, basePlacements))
    )
}
function arrow(t) {
    var e,
        n = t.state,
        i = t.name,
        o = t.options,
        a = n.elements.arrow,
        l = n.modifiersData.popperOffsets,
        c = getBasePlacement(n.placement),
        g = getMainAxisFromPlacement(c),
        v = [left, right].indexOf(c) >= 0,
        _ = v ? "height" : "width"
    if (!(!a || !l)) {
        var A = toPaddingObject(o.padding, n),
            B = getLayoutRect(a),
            D = g === "y" ? top : left,
            I = g === "y" ? bottom : right,
            L = n.rects.reference[_] + n.rects.reference[g] - l[g] - n.rects.popper[_],
            G = l[g] - n.rects.reference[g],
            U = getOffsetParent(a),
            F = U ? (g === "y" ? U.clientHeight || 0 : U.clientWidth || 0) : 0,
            Z = L / 2 - G / 2,
            Y = A[D],
            X = F - B[_] - A[I],
            ie = F / 2 - B[_] / 2 + Z,
            he = within(Y, ie, X),
            oe = g
        n.modifiersData[i] = ((e = {}), (e[oe] = he), (e.centerOffset = he - ie), e)
    }
}
function effect$1(t) {
    var e = t.state,
        n = t.options,
        i = n.element,
        o = i === void 0 ? "[data-popper-arrow]" : i
    o != null &&
        ((typeof o == "string" && ((o = e.elements.popper.querySelector(o)), !o)) || !contains(e.elements.popper, o) || (e.elements.arrow = o))
}
var arrow$1 = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
}
function getVariation(t) {
    return t.split("-")[1]
}
var unsetSides = { top: "auto", right: "auto", bottom: "auto", left: "auto" }
function roundOffsetsByDPR(t) {
    var e = t.x,
        n = t.y,
        i = window,
        o = i.devicePixelRatio || 1
    return { x: round$1(e * o) / o || 0, y: round$1(n * o) / o || 0 }
}
function mapToStyles(t) {
    var e,
        n = t.popper,
        i = t.popperRect,
        o = t.placement,
        a = t.variation,
        l = t.offsets,
        c = t.position,
        g = t.gpuAcceleration,
        v = t.adaptive,
        _ = t.roundOffsets,
        A = t.isFixed,
        B = l.x,
        D = B === void 0 ? 0 : B,
        I = l.y,
        L = I === void 0 ? 0 : I,
        G = typeof _ == "function" ? _({ x: D, y: L }) : { x: D, y: L }
    ;(D = G.x), (L = G.y)
    var U = l.hasOwnProperty("x"),
        F = l.hasOwnProperty("y"),
        Z = left,
        Y = top,
        X = window
    if (v) {
        var ie = getOffsetParent(n),
            he = "clientHeight",
            oe = "clientWidth"
        if (
            (ie === getWindow(n) &&
                ((ie = getDocumentElement(n)),
                getComputedStyle$1(ie).position !== "static" && c === "absolute" && ((he = "scrollHeight"), (oe = "scrollWidth"))),
            (ie = ie),
            o === top || ((o === left || o === right) && a === end))
        ) {
            Y = bottom
            var le = A && ie === X && X.visualViewport ? X.visualViewport.height : ie[he]
            ;(L -= le - i.height), (L *= g ? 1 : -1)
        }
        if (o === left || ((o === top || o === bottom) && a === end)) {
            Z = right
            var Te = A && ie === X && X.visualViewport ? X.visualViewport.width : ie[oe]
            ;(D -= Te - i.width), (D *= g ? 1 : -1)
        }
    }
    var ye = Object.assign({ position: c }, v && unsetSides),
        Ae = _ === !0 ? roundOffsetsByDPR({ x: D, y: L }) : { x: D, y: L }
    if (((D = Ae.x), (L = Ae.y), g)) {
        var O
        return Object.assign(
            {},
            ye,
            ((O = {}),
            (O[Y] = F ? "0" : ""),
            (O[Z] = U ? "0" : ""),
            (O.transform = (X.devicePixelRatio || 1) <= 1 ? "translate(" + D + "px, " + L + "px)" : "translate3d(" + D + "px, " + L + "px, 0)"),
            O)
        )
    }
    return Object.assign({}, ye, ((e = {}), (e[Y] = F ? L + "px" : ""), (e[Z] = U ? D + "px" : ""), (e.transform = ""), e))
}
function computeStyles(t) {
    var e = t.state,
        n = t.options,
        i = n.gpuAcceleration,
        o = i === void 0 ? !0 : i,
        a = n.adaptive,
        l = a === void 0 ? !0 : a,
        c = n.roundOffsets,
        g = c === void 0 ? !0 : c,
        v = {
            placement: getBasePlacement(e.placement),
            variation: getVariation(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: o,
            isFixed: e.options.strategy === "fixed",
        }
    e.modifiersData.popperOffsets != null &&
        (e.styles.popper = Object.assign(
            {},
            e.styles.popper,
            mapToStyles(
                Object.assign({}, v, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: l, roundOffsets: g })
            )
        )),
        e.modifiersData.arrow != null &&
            (e.styles.arrow = Object.assign(
                {},
                e.styles.arrow,
                mapToStyles(Object.assign({}, v, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: g }))
            )),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }))
}
var computeStyles$1 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: computeStyles, data: {} },
    passive = { passive: !0 }
function effect(t) {
    var e = t.state,
        n = t.instance,
        i = t.options,
        o = i.scroll,
        a = o === void 0 ? !0 : o,
        l = i.resize,
        c = l === void 0 ? !0 : l,
        g = getWindow(e.elements.popper),
        v = [].concat(e.scrollParents.reference, e.scrollParents.popper)
    return (
        a &&
            v.forEach(function (_) {
                _.addEventListener("scroll", n.update, passive)
            }),
        c && g.addEventListener("resize", n.update, passive),
        function () {
            a &&
                v.forEach(function (_) {
                    _.removeEventListener("scroll", n.update, passive)
                }),
                c && g.removeEventListener("resize", n.update, passive)
        }
    )
}
var eventListeners = { name: "eventListeners", enabled: !0, phase: "write", fn: function () {}, effect, data: {} },
    hash$1 = { left: "right", right: "left", bottom: "top", top: "bottom" }
function getOppositePlacement(t) {
    return t.replace(/left|right|bottom|top/g, function (e) {
        return hash$1[e]
    })
}
var hash = { start: "end", end: "start" }
function getOppositeVariationPlacement(t) {
    return t.replace(/start|end/g, function (e) {
        return hash[e]
    })
}
function getWindowScroll(t) {
    var e = getWindow(t),
        n = e.pageXOffset,
        i = e.pageYOffset
    return { scrollLeft: n, scrollTop: i }
}
function getWindowScrollBarX(t) {
    return getBoundingClientRect(getDocumentElement(t)).left + getWindowScroll(t).scrollLeft
}
function getViewportRect(t, e) {
    var n = getWindow(t),
        i = getDocumentElement(t),
        o = n.visualViewport,
        a = i.clientWidth,
        l = i.clientHeight,
        c = 0,
        g = 0
    if (o) {
        ;(a = o.width), (l = o.height)
        var v = isLayoutViewport()
        ;(v || (!v && e === "fixed")) && ((c = o.offsetLeft), (g = o.offsetTop))
    }
    return { width: a, height: l, x: c + getWindowScrollBarX(t), y: g }
}
function getDocumentRect(t) {
    var e,
        n = getDocumentElement(t),
        i = getWindowScroll(t),
        o = (e = t.ownerDocument) == null ? void 0 : e.body,
        a = max(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
        l = max(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0),
        c = -i.scrollLeft + getWindowScrollBarX(t),
        g = -i.scrollTop
    return (
        getComputedStyle$1(o || n).direction === "rtl" && (c += max(n.clientWidth, o ? o.clientWidth : 0) - a),
        { width: a, height: l, x: c, y: g }
    )
}
function isScrollParent(t) {
    var e = getComputedStyle$1(t),
        n = e.overflow,
        i = e.overflowX,
        o = e.overflowY
    return /auto|scroll|overlay|hidden/.test(n + o + i)
}
function getScrollParent(t) {
    return ["html", "body", "#document"].indexOf(getNodeName(t)) >= 0
        ? t.ownerDocument.body
        : isHTMLElement(t) && isScrollParent(t)
        ? t
        : getScrollParent(getParentNode(t))
}
function listScrollParents(t, e) {
    var n
    e === void 0 && (e = [])
    var i = getScrollParent(t),
        o = i === ((n = t.ownerDocument) == null ? void 0 : n.body),
        a = getWindow(i),
        l = o ? [a].concat(a.visualViewport || [], isScrollParent(i) ? i : []) : i,
        c = e.concat(l)
    return o ? c : c.concat(listScrollParents(getParentNode(l)))
}
function rectToClientRect(t) {
    return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height })
}
function getInnerBoundingClientRect(t, e) {
    var n = getBoundingClientRect(t, !1, e === "fixed")
    return (
        (n.top = n.top + t.clientTop),
        (n.left = n.left + t.clientLeft),
        (n.bottom = n.top + t.clientHeight),
        (n.right = n.left + t.clientWidth),
        (n.width = t.clientWidth),
        (n.height = t.clientHeight),
        (n.x = n.left),
        (n.y = n.top),
        n
    )
}
function getClientRectFromMixedType(t, e, n) {
    return e === viewport
        ? rectToClientRect(getViewportRect(t, n))
        : isElement$1(e)
        ? getInnerBoundingClientRect(e, n)
        : rectToClientRect(getDocumentRect(getDocumentElement(t)))
}
function getClippingParents(t) {
    var e = listScrollParents(getParentNode(t)),
        n = ["absolute", "fixed"].indexOf(getComputedStyle$1(t).position) >= 0,
        i = n && isHTMLElement(t) ? getOffsetParent(t) : t
    return isElement$1(i)
        ? e.filter(function (o) {
              return isElement$1(o) && contains(o, i) && getNodeName(o) !== "body"
          })
        : []
}
function getClippingRect(t, e, n, i) {
    var o = e === "clippingParents" ? getClippingParents(t) : [].concat(e),
        a = [].concat(o, [n]),
        l = a[0],
        c = a.reduce(function (g, v) {
            var _ = getClientRectFromMixedType(t, v, i)
            return (
                (g.top = max(_.top, g.top)),
                (g.right = min(_.right, g.right)),
                (g.bottom = min(_.bottom, g.bottom)),
                (g.left = max(_.left, g.left)),
                g
            )
        }, getClientRectFromMixedType(t, l, i))
    return (c.width = c.right - c.left), (c.height = c.bottom - c.top), (c.x = c.left), (c.y = c.top), c
}
function computeOffsets(t) {
    var e = t.reference,
        n = t.element,
        i = t.placement,
        o = i ? getBasePlacement(i) : null,
        a = i ? getVariation(i) : null,
        l = e.x + e.width / 2 - n.width / 2,
        c = e.y + e.height / 2 - n.height / 2,
        g
    switch (o) {
        case top:
            g = { x: l, y: e.y - n.height }
            break
        case bottom:
            g = { x: l, y: e.y + e.height }
            break
        case right:
            g = { x: e.x + e.width, y: c }
            break
        case left:
            g = { x: e.x - n.width, y: c }
            break
        default:
            g = { x: e.x, y: e.y }
    }
    var v = o ? getMainAxisFromPlacement(o) : null
    if (v != null) {
        var _ = v === "y" ? "height" : "width"
        switch (a) {
            case start:
                g[v] = g[v] - (e[_] / 2 - n[_] / 2)
                break
            case end:
                g[v] = g[v] + (e[_] / 2 - n[_] / 2)
                break
        }
    }
    return g
}
function detectOverflow(t, e) {
    e === void 0 && (e = {})
    var n = e,
        i = n.placement,
        o = i === void 0 ? t.placement : i,
        a = n.strategy,
        l = a === void 0 ? t.strategy : a,
        c = n.boundary,
        g = c === void 0 ? clippingParents : c,
        v = n.rootBoundary,
        _ = v === void 0 ? viewport : v,
        A = n.elementContext,
        B = A === void 0 ? popper : A,
        D = n.altBoundary,
        I = D === void 0 ? !1 : D,
        L = n.padding,
        G = L === void 0 ? 0 : L,
        U = mergePaddingObject(typeof G != "number" ? G : expandToHashMap(G, basePlacements)),
        F = B === popper ? reference : popper,
        Z = t.rects.popper,
        Y = t.elements[I ? F : B],
        X = getClippingRect(isElement$1(Y) ? Y : Y.contextElement || getDocumentElement(t.elements.popper), g, _, l),
        ie = getBoundingClientRect(t.elements.reference),
        he = computeOffsets({ reference: ie, element: Z, strategy: "absolute", placement: o }),
        oe = rectToClientRect(Object.assign({}, Z, he)),
        le = B === popper ? oe : ie,
        Te = {
            top: X.top - le.top + U.top,
            bottom: le.bottom - X.bottom + U.bottom,
            left: X.left - le.left + U.left,
            right: le.right - X.right + U.right,
        },
        ye = t.modifiersData.offset
    if (B === popper && ye) {
        var Ae = ye[o]
        Object.keys(Te).forEach(function (O) {
            var u = [right, bottom].indexOf(O) >= 0 ? 1 : -1,
                E = [top, bottom].indexOf(O) >= 0 ? "y" : "x"
            Te[O] += Ae[E] * u
        })
    }
    return Te
}
function computeAutoPlacement(t, e) {
    e === void 0 && (e = {})
    var n = e,
        i = n.placement,
        o = n.boundary,
        a = n.rootBoundary,
        l = n.padding,
        c = n.flipVariations,
        g = n.allowedAutoPlacements,
        v = g === void 0 ? placements : g,
        _ = getVariation(i),
        A = _
            ? c
                ? variationPlacements
                : variationPlacements.filter(function (I) {
                      return getVariation(I) === _
                  })
            : basePlacements,
        B = A.filter(function (I) {
            return v.indexOf(I) >= 0
        })
    B.length === 0 && (B = A)
    var D = B.reduce(function (I, L) {
        return (I[L] = detectOverflow(t, { placement: L, boundary: o, rootBoundary: a, padding: l })[getBasePlacement(L)]), I
    }, {})
    return Object.keys(D).sort(function (I, L) {
        return D[I] - D[L]
    })
}
function getExpandedFallbackPlacements(t) {
    if (getBasePlacement(t) === auto) return []
    var e = getOppositePlacement(t)
    return [getOppositeVariationPlacement(t), e, getOppositeVariationPlacement(e)]
}
function flip(t) {
    var e = t.state,
        n = t.options,
        i = t.name
    if (!e.modifiersData[i]._skip) {
        for (
            var o = n.mainAxis,
                a = o === void 0 ? !0 : o,
                l = n.altAxis,
                c = l === void 0 ? !0 : l,
                g = n.fallbackPlacements,
                v = n.padding,
                _ = n.boundary,
                A = n.rootBoundary,
                B = n.altBoundary,
                D = n.flipVariations,
                I = D === void 0 ? !0 : D,
                L = n.allowedAutoPlacements,
                G = e.options.placement,
                U = getBasePlacement(G),
                F = U === G,
                Z = g || (F || !I ? [getOppositePlacement(G)] : getExpandedFallbackPlacements(G)),
                Y = [G].concat(Z).reduce(function (Q, k) {
                    return Q.concat(
                        getBasePlacement(k) === auto
                            ? computeAutoPlacement(e, {
                                  placement: k,
                                  boundary: _,
                                  rootBoundary: A,
                                  padding: v,
                                  flipVariations: I,
                                  allowedAutoPlacements: L,
                              })
                            : k
                    )
                }, []),
                X = e.rects.reference,
                ie = e.rects.popper,
                he = new Map(),
                oe = !0,
                le = Y[0],
                Te = 0;
            Te < Y.length;
            Te++
        ) {
            var ye = Y[Te],
                Ae = getBasePlacement(ye),
                O = getVariation(ye) === start,
                u = [top, bottom].indexOf(Ae) >= 0,
                E = u ? "width" : "height",
                $ = detectOverflow(e, { placement: ye, boundary: _, rootBoundary: A, altBoundary: B, padding: v }),
                N = u ? (O ? right : left) : O ? bottom : top
            X[E] > ie[E] && (N = getOppositePlacement(N))
            var M = getOppositePlacement(N),
                R = []
            if (
                (a && R.push($[Ae] <= 0),
                c && R.push($[N] <= 0, $[M] <= 0),
                R.every(function (Q) {
                    return Q
                }))
            ) {
                ;(le = ye), (oe = !1)
                break
            }
            he.set(ye, R)
        }
        if (oe)
            for (
                var C = I ? 3 : 1,
                    S = function (k) {
                        var W = Y.find(function (J) {
                            var ee = he.get(J)
                            if (ee)
                                return ee.slice(0, k).every(function (ne) {
                                    return ne
                                })
                        })
                        if (W) return (le = W), "break"
                    },
                    b = C;
                b > 0;
                b--
            ) {
                var T = S(b)
                if (T === "break") break
            }
        e.placement !== le && ((e.modifiersData[i]._skip = !0), (e.placement = le), (e.reset = !0))
    }
}
var flip$1 = { name: "flip", enabled: !0, phase: "main", fn: flip, requiresIfExists: ["offset"], data: { _skip: !1 } }
function getSideOffsets(t, e, n) {
    return (
        n === void 0 && (n = { x: 0, y: 0 }),
        { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x }
    )
}
function isAnySideFullyClipped(t) {
    return [top, right, bottom, left].some(function (e) {
        return t[e] >= 0
    })
}
function hide(t) {
    var e = t.state,
        n = t.name,
        i = e.rects.reference,
        o = e.rects.popper,
        a = e.modifiersData.preventOverflow,
        l = detectOverflow(e, { elementContext: "reference" }),
        c = detectOverflow(e, { altBoundary: !0 }),
        g = getSideOffsets(l, i),
        v = getSideOffsets(c, o, a),
        _ = isAnySideFullyClipped(g),
        A = isAnySideFullyClipped(v)
    ;(e.modifiersData[n] = { referenceClippingOffsets: g, popperEscapeOffsets: v, isReferenceHidden: _, hasPopperEscaped: A }),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": _, "data-popper-escaped": A }))
}
var hide$1 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: hide }
function distanceAndSkiddingToXY(t, e, n) {
    var i = getBasePlacement(t),
        o = [left, top].indexOf(i) >= 0 ? -1 : 1,
        a = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n,
        l = a[0],
        c = a[1]
    return (l = l || 0), (c = (c || 0) * o), [left, right].indexOf(i) >= 0 ? { x: c, y: l } : { x: l, y: c }
}
function offset(t) {
    var e = t.state,
        n = t.options,
        i = t.name,
        o = n.offset,
        a = o === void 0 ? [0, 0] : o,
        l = placements.reduce(function (_, A) {
            return (_[A] = distanceAndSkiddingToXY(A, e.rects, a)), _
        }, {}),
        c = l[e.placement],
        g = c.x,
        v = c.y
    e.modifiersData.popperOffsets != null && ((e.modifiersData.popperOffsets.x += g), (e.modifiersData.popperOffsets.y += v)),
        (e.modifiersData[i] = l)
}
var offset$1 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: offset }
function popperOffsets(t) {
    var e = t.state,
        n = t.name
    e.modifiersData[n] = computeOffsets({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement })
}
var popperOffsets$1 = { name: "popperOffsets", enabled: !0, phase: "read", fn: popperOffsets, data: {} }
function getAltAxis(t) {
    return t === "x" ? "y" : "x"
}
function preventOverflow(t) {
    var e = t.state,
        n = t.options,
        i = t.name,
        o = n.mainAxis,
        a = o === void 0 ? !0 : o,
        l = n.altAxis,
        c = l === void 0 ? !1 : l,
        g = n.boundary,
        v = n.rootBoundary,
        _ = n.altBoundary,
        A = n.padding,
        B = n.tether,
        D = B === void 0 ? !0 : B,
        I = n.tetherOffset,
        L = I === void 0 ? 0 : I,
        G = detectOverflow(e, { boundary: g, rootBoundary: v, padding: A, altBoundary: _ }),
        U = getBasePlacement(e.placement),
        F = getVariation(e.placement),
        Z = !F,
        Y = getMainAxisFromPlacement(U),
        X = getAltAxis(Y),
        ie = e.modifiersData.popperOffsets,
        he = e.rects.reference,
        oe = e.rects.popper,
        le = typeof L == "function" ? L(Object.assign({}, e.rects, { placement: e.placement })) : L,
        Te = typeof le == "number" ? { mainAxis: le, altAxis: le } : Object.assign({ mainAxis: 0, altAxis: 0 }, le),
        ye = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
        Ae = { x: 0, y: 0 }
    if (!!ie) {
        if (a) {
            var O,
                u = Y === "y" ? top : left,
                E = Y === "y" ? bottom : right,
                $ = Y === "y" ? "height" : "width",
                N = ie[Y],
                M = N + G[u],
                R = N - G[E],
                C = D ? -oe[$] / 2 : 0,
                S = F === start ? he[$] : oe[$],
                b = F === start ? -oe[$] : -he[$],
                T = e.elements.arrow,
                Q = D && T ? getLayoutRect(T) : { width: 0, height: 0 },
                k = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : getFreshSideObject(),
                W = k[u],
                J = k[E],
                ee = within(0, he[$], Q[$]),
                ne = Z ? he[$] / 2 - C - ee - W - Te.mainAxis : S - ee - W - Te.mainAxis,
                xe = Z ? -he[$] / 2 + C + ee + J + Te.mainAxis : b + ee + J + Te.mainAxis,
                ce = e.elements.arrow && getOffsetParent(e.elements.arrow),
                de = ce ? (Y === "y" ? ce.clientTop || 0 : ce.clientLeft || 0) : 0,
                H = (O = ye == null ? void 0 : ye[Y]) != null ? O : 0,
                j = N + ne - H - de,
                q = N + xe - H,
                ae = within(D ? min(M, j) : M, N, D ? max(R, q) : R)
            ;(ie[Y] = ae), (Ae[Y] = ae - N)
        }
        if (c) {
            var te,
                fe = Y === "x" ? top : left,
                Se = Y === "x" ? bottom : right,
                ue = ie[X],
                me = X === "y" ? "height" : "width",
                _e = ue + G[fe],
                Ce = ue - G[Se],
                ke = [top, left].indexOf(U) !== -1,
                Re = (te = ye == null ? void 0 : ye[X]) != null ? te : 0,
                Ne = ke ? _e : ue - he[me] - oe[me] - Re + Te.altAxis,
                Me = ke ? ue + he[me] + oe[me] - Re - Te.altAxis : Ce,
                He = D && ke ? withinMaxClamp(Ne, ue, Me) : within(D ? Ne : _e, ue, D ? Me : Ce)
            ;(ie[X] = He), (Ae[X] = He - ue)
        }
        e.modifiersData[i] = Ae
    }
}
var preventOverflow$1 = { name: "preventOverflow", enabled: !0, phase: "main", fn: preventOverflow, requiresIfExists: ["offset"] }
function getHTMLElementScroll(t) {
    return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
}
function getNodeScroll(t) {
    return t === getWindow(t) || !isHTMLElement(t) ? getWindowScroll(t) : getHTMLElementScroll(t)
}
function isElementScaled(t) {
    var e = t.getBoundingClientRect(),
        n = round$1(e.width) / t.offsetWidth || 1,
        i = round$1(e.height) / t.offsetHeight || 1
    return n !== 1 || i !== 1
}
function getCompositeRect(t, e, n) {
    n === void 0 && (n = !1)
    var i = isHTMLElement(e),
        o = isHTMLElement(e) && isElementScaled(e),
        a = getDocumentElement(e),
        l = getBoundingClientRect(t, o, n),
        c = { scrollLeft: 0, scrollTop: 0 },
        g = { x: 0, y: 0 }
    return (
        (i || (!i && !n)) &&
            ((getNodeName(e) !== "body" || isScrollParent(a)) && (c = getNodeScroll(e)),
            isHTMLElement(e)
                ? ((g = getBoundingClientRect(e, !0)), (g.x += e.clientLeft), (g.y += e.clientTop))
                : a && (g.x = getWindowScrollBarX(a))),
        { x: l.left + c.scrollLeft - g.x, y: l.top + c.scrollTop - g.y, width: l.width, height: l.height }
    )
}
function order(t) {
    var e = new Map(),
        n = new Set(),
        i = []
    t.forEach(function (a) {
        e.set(a.name, a)
    })
    function o(a) {
        n.add(a.name)
        var l = [].concat(a.requires || [], a.requiresIfExists || [])
        l.forEach(function (c) {
            if (!n.has(c)) {
                var g = e.get(c)
                g && o(g)
            }
        }),
            i.push(a)
    }
    return (
        t.forEach(function (a) {
            n.has(a.name) || o(a)
        }),
        i
    )
}
function orderModifiers(t) {
    var e = order(t)
    return modifierPhases.reduce(function (n, i) {
        return n.concat(
            e.filter(function (o) {
                return o.phase === i
            })
        )
    }, [])
}
function debounce(t) {
    var e
    return function () {
        return (
            e ||
                (e = new Promise(function (n) {
                    Promise.resolve().then(function () {
                        ;(e = void 0), n(t())
                    })
                })),
            e
        )
    }
}
function mergeByName(t) {
    var e = t.reduce(function (n, i) {
        var o = n[i.name]
        return (
            (n[i.name] = o
                ? Object.assign({}, o, i, { options: Object.assign({}, o.options, i.options), data: Object.assign({}, o.data, i.data) })
                : i),
            n
        )
    }, {})
    return Object.keys(e).map(function (n) {
        return e[n]
    })
}
var DEFAULT_OPTIONS = { placement: "bottom", modifiers: [], strategy: "absolute" }
function areValidElements() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]
    return !e.some(function (i) {
        return !(i && typeof i.getBoundingClientRect == "function")
    })
}
function popperGenerator(t) {
    t === void 0 && (t = {})
    var e = t,
        n = e.defaultModifiers,
        i = n === void 0 ? [] : n,
        o = e.defaultOptions,
        a = o === void 0 ? DEFAULT_OPTIONS : o
    return function (c, g, v) {
        v === void 0 && (v = a)
        var _ = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, DEFAULT_OPTIONS, a),
                modifiersData: {},
                elements: { reference: c, popper: g },
                attributes: {},
                styles: {},
            },
            A = [],
            B = !1,
            D = {
                state: _,
                setOptions: function (U) {
                    var F = typeof U == "function" ? U(_.options) : U
                    L(),
                        (_.options = Object.assign({}, a, _.options, F)),
                        (_.scrollParents = {
                            reference: isElement$1(c) ? listScrollParents(c) : c.contextElement ? listScrollParents(c.contextElement) : [],
                            popper: listScrollParents(g),
                        })
                    var Z = orderModifiers(mergeByName([].concat(i, _.options.modifiers)))
                    return (
                        (_.orderedModifiers = Z.filter(function (Y) {
                            return Y.enabled
                        })),
                        I(),
                        D.update()
                    )
                },
                forceUpdate: function () {
                    if (!B) {
                        var U = _.elements,
                            F = U.reference,
                            Z = U.popper
                        if (!!areValidElements(F, Z)) {
                            ;(_.rects = {
                                reference: getCompositeRect(F, getOffsetParent(Z), _.options.strategy === "fixed"),
                                popper: getLayoutRect(Z),
                            }),
                                (_.reset = !1),
                                (_.placement = _.options.placement),
                                _.orderedModifiers.forEach(function (Te) {
                                    return (_.modifiersData[Te.name] = Object.assign({}, Te.data))
                                })
                            for (var Y = 0; Y < _.orderedModifiers.length; Y++) {
                                if (_.reset === !0) {
                                    ;(_.reset = !1), (Y = -1)
                                    continue
                                }
                                var X = _.orderedModifiers[Y],
                                    ie = X.fn,
                                    he = X.options,
                                    oe = he === void 0 ? {} : he,
                                    le = X.name
                                typeof ie == "function" && (_ = ie({ state: _, options: oe, name: le, instance: D }) || _)
                            }
                        }
                    }
                },
                update: debounce(function () {
                    return new Promise(function (G) {
                        D.forceUpdate(), G(_)
                    })
                }),
                destroy: function () {
                    L(), (B = !0)
                },
            }
        if (!areValidElements(c, g)) return D
        D.setOptions(v).then(function (G) {
            !B && v.onFirstUpdate && v.onFirstUpdate(G)
        })
        function I() {
            _.orderedModifiers.forEach(function (G) {
                var U = G.name,
                    F = G.options,
                    Z = F === void 0 ? {} : F,
                    Y = G.effect
                if (typeof Y == "function") {
                    var X = Y({ state: _, name: U, instance: D, options: Z }),
                        ie = function () {}
                    A.push(X || ie)
                }
            })
        }
        function L() {
            A.forEach(function (G) {
                return G()
            }),
                (A = [])
        }
        return D
    }
}
var createPopper$2 = popperGenerator(),
    defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1],
    createPopper$1 = popperGenerator({ defaultModifiers: defaultModifiers$1 }),
    defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1],
    createPopper = popperGenerator({ defaultModifiers }),
    Popper = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                popperGenerator,
                detectOverflow,
                createPopperBase: createPopper$2,
                createPopper,
                createPopperLite: createPopper$1,
                top,
                bottom,
                right,
                left,
                auto,
                basePlacements,
                start,
                end,
                clippingParents,
                viewport,
                popper,
                reference,
                variationPlacements,
                placements,
                beforeRead,
                read: read$2,
                afterRead,
                beforeMain,
                main: main$1,
                afterMain,
                beforeWrite,
                write,
                afterWrite,
                modifierPhases,
                applyStyles: applyStyles$1,
                arrow: arrow$1,
                computeStyles: computeStyles$1,
                eventListeners,
                flip: flip$1,
                hide: hide$1,
                offset: offset$1,
                popperOffsets: popperOffsets$1,
                preventOverflow: preventOverflow$1,
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    )
/*!
 * Bootstrap v5.2.0 (https://getbootstrap.com/)
 * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */ const MAX_UID = 1e6,
    MILLISECONDS_MULTIPLIER = 1e3,
    TRANSITION_END = "transitionend",
    toType = (t) =>
        t == null
            ? `${t}`
            : Object.prototype.toString
                  .call(t)
                  .match(/\s([a-z]+)/i)[1]
                  .toLowerCase(),
    getUID = (t) => {
        do t += Math.floor(Math.random() * MAX_UID)
        while (document.getElementById(t))
        return t
    },
    getSelector = (t) => {
        let e = t.getAttribute("data-bs-target")
        if (!e || e === "#") {
            let n = t.getAttribute("href")
            if (!n || (!n.includes("#") && !n.startsWith("."))) return null
            n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), (e = n && n !== "#" ? n.trim() : null)
        }
        return e
    },
    getSelectorFromElement = (t) => {
        const e = getSelector(t)
        return e && document.querySelector(e) ? e : null
    },
    getElementFromSelector = (t) => {
        const e = getSelector(t)
        return e ? document.querySelector(e) : null
    },
    getTransitionDurationFromElement = (t) => {
        if (!t) return 0
        let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t)
        const i = Number.parseFloat(e),
            o = Number.parseFloat(n)
        return !i && !o
            ? 0
            : ((e = e.split(",")[0]), (n = n.split(",")[0]), (Number.parseFloat(e) + Number.parseFloat(n)) * MILLISECONDS_MULTIPLIER)
    },
    triggerTransitionEnd = (t) => {
        t.dispatchEvent(new Event(TRANSITION_END))
    },
    isElement = (t) => (!t || typeof t != "object" ? !1 : (typeof t.jquery != "undefined" && (t = t[0]), typeof t.nodeType != "undefined")),
    getElement = (t) => (isElement(t) ? (t.jquery ? t[0] : t) : typeof t == "string" && t.length > 0 ? document.querySelector(t) : null),
    isVisible = (t) => {
        if (!isElement(t) || t.getClientRects().length === 0) return !1
        const e = getComputedStyle(t).getPropertyValue("visibility") === "visible",
            n = t.closest("details:not([open])")
        if (!n) return e
        if (n !== t) {
            const i = t.closest("summary")
            if ((i && i.parentNode !== n) || i === null) return !1
        }
        return e
    },
    isDisabled = (t) =>
        !t || t.nodeType !== Node.ELEMENT_NODE || t.classList.contains("disabled")
            ? !0
            : typeof t.disabled != "undefined"
            ? t.disabled
            : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false",
    findShadowRoot = (t) => {
        if (!document.documentElement.attachShadow) return null
        if (typeof t.getRootNode == "function") {
            const e = t.getRootNode()
            return e instanceof ShadowRoot ? e : null
        }
        return t instanceof ShadowRoot ? t : t.parentNode ? findShadowRoot(t.parentNode) : null
    },
    noop$1 = () => {},
    reflow = (t) => {
        t.offsetHeight
    },
    getjQuery = () => (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null),
    DOMContentLoadedCallbacks = [],
    onDOMContentLoaded = (t) => {
        document.readyState === "loading"
            ? (DOMContentLoadedCallbacks.length ||
                  document.addEventListener("DOMContentLoaded", () => {
                      for (const e of DOMContentLoadedCallbacks) e()
                  }),
              DOMContentLoadedCallbacks.push(t))
            : t()
    },
    isRTL = () => document.documentElement.dir === "rtl",
    defineJQueryPlugin = (t) => {
        onDOMContentLoaded(() => {
            const e = getjQuery()
            if (e) {
                const n = t.NAME,
                    i = e.fn[n]
                ;(e.fn[n] = t.jQueryInterface), (e.fn[n].Constructor = t), (e.fn[n].noConflict = () => ((e.fn[n] = i), t.jQueryInterface))
            }
        })
    },
    execute = (t) => {
        typeof t == "function" && t()
    },
    executeAfterTransition = (t, e, n = !0) => {
        if (!n) {
            execute(t)
            return
        }
        const i = 5,
            o = getTransitionDurationFromElement(e) + i
        let a = !1
        const l = ({ target: c }) => {
            c === e && ((a = !0), e.removeEventListener(TRANSITION_END, l), execute(t))
        }
        e.addEventListener(TRANSITION_END, l),
            setTimeout(() => {
                a || triggerTransitionEnd(e)
            }, o)
    },
    getNextActiveElement = (t, e, n, i) => {
        const o = t.length
        let a = t.indexOf(e)
        return a === -1 ? (!n && i ? t[o - 1] : t[0]) : ((a += n ? 1 : -1), i && (a = (a + o) % o), t[Math.max(0, Math.min(a, o - 1))])
    },
    namespaceRegex = /[^.]*(?=\..*)\.|.*/,
    stripNameRegex = /\..*/,
    stripUidRegex = /::\d+$/,
    eventRegistry = {}
let uidEvent = 1
const customEvents = { mouseenter: "mouseover", mouseleave: "mouseout" },
    nativeEvents = new Set([
        "click",
        "dblclick",
        "mouseup",
        "mousedown",
        "contextmenu",
        "mousewheel",
        "DOMMouseScroll",
        "mouseover",
        "mouseout",
        "mousemove",
        "selectstart",
        "selectend",
        "keydown",
        "keypress",
        "keyup",
        "orientationchange",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointerleave",
        "pointercancel",
        "gesturestart",
        "gesturechange",
        "gestureend",
        "focus",
        "blur",
        "change",
        "reset",
        "select",
        "submit",
        "focusin",
        "focusout",
        "load",
        "unload",
        "beforeunload",
        "resize",
        "move",
        "DOMContentLoaded",
        "readystatechange",
        "error",
        "abort",
        "scroll",
    ])
function makeEventUid(t, e) {
    return (e && `${e}::${uidEvent++}`) || t.uidEvent || uidEvent++
}
function getElementEvents(t) {
    const e = makeEventUid(t)
    return (t.uidEvent = e), (eventRegistry[e] = eventRegistry[e] || {}), eventRegistry[e]
}
function bootstrapHandler(t, e) {
    return function n(i) {
        return hydrateObj(i, { delegateTarget: t }), n.oneOff && EventHandler.off(t, i.type, e), e.apply(t, [i])
    }
}
function bootstrapDelegationHandler(t, e, n) {
    return function i(o) {
        const a = t.querySelectorAll(e)
        for (let { target: l } = o; l && l !== this; l = l.parentNode)
            for (const c of a)
                if (c === l) return hydrateObj(o, { delegateTarget: l }), i.oneOff && EventHandler.off(t, o.type, e, n), n.apply(l, [o])
    }
}
function findHandler(t, e, n = null) {
    return Object.values(t).find((i) => i.callable === e && i.delegationSelector === n)
}
function normalizeParameters(t, e, n) {
    const i = typeof e == "string",
        o = i ? n : e || n
    let a = getTypeEvent(t)
    return nativeEvents.has(a) || (a = t), [i, o, a]
}
function addHandler(t, e, n, i, o) {
    if (typeof e != "string" || !t) return
    let [a, l, c] = normalizeParameters(e, n, i)
    e in customEvents &&
        (l = ((I) =>
            function (L) {
                if (!L.relatedTarget || (L.relatedTarget !== L.delegateTarget && !L.delegateTarget.contains(L.relatedTarget)))
                    return I.call(this, L)
            })(l))
    const g = getElementEvents(t),
        v = g[c] || (g[c] = {}),
        _ = findHandler(v, l, a ? n : null)
    if (_) {
        _.oneOff = _.oneOff && o
        return
    }
    const A = makeEventUid(l, e.replace(namespaceRegex, "")),
        B = a ? bootstrapDelegationHandler(t, n, l) : bootstrapHandler(t, l)
    ;(B.delegationSelector = a ? n : null), (B.callable = l), (B.oneOff = o), (B.uidEvent = A), (v[A] = B), t.addEventListener(c, B, a)
}
function removeHandler(t, e, n, i, o) {
    const a = findHandler(e[n], i, o)
    !a || (t.removeEventListener(n, a, Boolean(o)), delete e[n][a.uidEvent])
}
function removeNamespacedHandlers(t, e, n, i) {
    const o = e[n] || {}
    for (const a of Object.keys(o))
        if (a.includes(i)) {
            const l = o[a]
            removeHandler(t, e, n, l.callable, l.delegationSelector)
        }
}
function getTypeEvent(t) {
    return (t = t.replace(stripNameRegex, "")), customEvents[t] || t
}
const EventHandler = {
    on(t, e, n, i) {
        addHandler(t, e, n, i, !1)
    },
    one(t, e, n, i) {
        addHandler(t, e, n, i, !0)
    },
    off(t, e, n, i) {
        if (typeof e != "string" || !t) return
        const [o, a, l] = normalizeParameters(e, n, i),
            c = l !== e,
            g = getElementEvents(t),
            v = g[l] || {},
            _ = e.startsWith(".")
        if (typeof a != "undefined") {
            if (!Object.keys(v).length) return
            removeHandler(t, g, l, a, o ? n : null)
            return
        }
        if (_) for (const A of Object.keys(g)) removeNamespacedHandlers(t, g, A, e.slice(1))
        for (const A of Object.keys(v)) {
            const B = A.replace(stripUidRegex, "")
            if (!c || e.includes(B)) {
                const D = v[A]
                removeHandler(t, g, l, D.callable, D.delegationSelector)
            }
        }
    },
    trigger(t, e, n) {
        if (typeof e != "string" || !t) return null
        const i = getjQuery(),
            o = getTypeEvent(e),
            a = e !== o
        let l = null,
            c = !0,
            g = !0,
            v = !1
        a &&
            i &&
            ((l = i.Event(e, n)),
            i(t).trigger(l),
            (c = !l.isPropagationStopped()),
            (g = !l.isImmediatePropagationStopped()),
            (v = l.isDefaultPrevented()))
        let _ = new Event(e, { bubbles: c, cancelable: !0 })
        return (_ = hydrateObj(_, n)), v && _.preventDefault(), g && t.dispatchEvent(_), _.defaultPrevented && l && l.preventDefault(), _
    },
}
function hydrateObj(t, e) {
    for (const [n, i] of Object.entries(e || {}))
        try {
            t[n] = i
        } catch {
            Object.defineProperty(t, n, {
                configurable: !0,
                get() {
                    return i
                },
            })
        }
    return t
}
const elementMap = new Map(),
    Data$1 = {
        set(t, e, n) {
            elementMap.has(t) || elementMap.set(t, new Map())
            const i = elementMap.get(t)
            if (!i.has(e) && i.size !== 0) {
                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(i.keys())[0]}.`)
                return
            }
            i.set(e, n)
        },
        get(t, e) {
            return (elementMap.has(t) && elementMap.get(t).get(e)) || null
        },
        remove(t, e) {
            if (!elementMap.has(t)) return
            const n = elementMap.get(t)
            n.delete(e), n.size === 0 && elementMap.delete(t)
        },
    }
function normalizeData(t) {
    if (t === "true") return !0
    if (t === "false") return !1
    if (t === Number(t).toString()) return Number(t)
    if (t === "" || t === "null") return null
    if (typeof t != "string") return t
    try {
        return JSON.parse(decodeURIComponent(t))
    } catch {
        return t
    }
}
function normalizeDataKey(t) {
    return t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`)
}
const Manipulator = {
    setDataAttribute(t, e, n) {
        t.setAttribute(`data-bs-${normalizeDataKey(e)}`, n)
    },
    removeDataAttribute(t, e) {
        t.removeAttribute(`data-bs-${normalizeDataKey(e)}`)
    },
    getDataAttributes(t) {
        if (!t) return {}
        const e = {},
            n = Object.keys(t.dataset).filter((i) => i.startsWith("bs") && !i.startsWith("bsConfig"))
        for (const i of n) {
            let o = i.replace(/^bs/, "")
            ;(o = o.charAt(0).toLowerCase() + o.slice(1, o.length)), (e[o] = normalizeData(t.dataset[i]))
        }
        return e
    },
    getDataAttribute(t, e) {
        return normalizeData(t.getAttribute(`data-bs-${normalizeDataKey(e)}`))
    },
}
class Config {
    static get Default() {
        return {}
    }
    static get DefaultType() {
        return {}
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!')
    }
    _getConfig(e) {
        return (e = this._mergeConfigObj(e)), (e = this._configAfterMerge(e)), this._typeCheckConfig(e), e
    }
    _configAfterMerge(e) {
        return e
    }
    _mergeConfigObj(e, n) {
        const i = isElement(n) ? Manipulator.getDataAttribute(n, "config") : {}
        return {
            ...this.constructor.Default,
            ...(typeof i == "object" ? i : {}),
            ...(isElement(n) ? Manipulator.getDataAttributes(n) : {}),
            ...(typeof e == "object" ? e : {}),
        }
    }
    _typeCheckConfig(e, n = this.constructor.DefaultType) {
        for (const i of Object.keys(n)) {
            const o = n[i],
                a = e[i],
                l = isElement(a) ? "element" : toType(a)
            if (!new RegExp(o).test(l))
                throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${l}" but expected type "${o}".`)
        }
    }
}
const VERSION = "5.2.0"
class BaseComponent extends Config {
    constructor(e, n) {
        super(),
            (e = getElement(e)),
            e && ((this._element = e), (this._config = this._getConfig(n)), Data$1.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
        Data$1.remove(this._element, this.constructor.DATA_KEY), EventHandler.off(this._element, this.constructor.EVENT_KEY)
        for (const e of Object.getOwnPropertyNames(this)) this[e] = null
    }
    _queueCallback(e, n, i = !0) {
        executeAfterTransition(e, n, i)
    }
    _getConfig(e) {
        return (e = this._mergeConfigObj(e, this._element)), (e = this._configAfterMerge(e)), this._typeCheckConfig(e), e
    }
    static getInstance(e) {
        return Data$1.get(getElement(e), this.DATA_KEY)
    }
    static getOrCreateInstance(e, n = {}) {
        return this.getInstance(e) || new this(e, typeof n == "object" ? n : null)
    }
    static get VERSION() {
        return VERSION
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`
    }
    static eventName(e) {
        return `${e}${this.EVENT_KEY}`
    }
}
const enableDismissTrigger = (t, e = "hide") => {
        const n = `click.dismiss${t.EVENT_KEY}`,
            i = t.NAME
        EventHandler.on(document, n, `[data-bs-dismiss="${i}"]`, function (o) {
            if ((["A", "AREA"].includes(this.tagName) && o.preventDefault(), isDisabled(this))) return
            const a = getElementFromSelector(this) || this.closest(`.${i}`)
            t.getOrCreateInstance(a)[e]()
        })
    },
    NAME$f = "alert",
    DATA_KEY$a = "bs.alert",
    EVENT_KEY$b = `.${DATA_KEY$a}`,
    EVENT_CLOSE = `close${EVENT_KEY$b}`,
    EVENT_CLOSED = `closed${EVENT_KEY$b}`,
    CLASS_NAME_FADE$5 = "fade",
    CLASS_NAME_SHOW$8 = "show"
class Alert extends BaseComponent {
    static get NAME() {
        return NAME$f
    }
    close() {
        if (EventHandler.trigger(this._element, EVENT_CLOSE).defaultPrevented) return
        this._element.classList.remove(CLASS_NAME_SHOW$8)
        const n = this._element.classList.contains(CLASS_NAME_FADE$5)
        this._queueCallback(() => this._destroyElement(), this._element, n)
    }
    _destroyElement() {
        this._element.remove(), EventHandler.trigger(this._element, EVENT_CLOSED), this.dispose()
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Alert.getOrCreateInstance(this)
            if (typeof e == "string") {
                if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                n[e](this)
            }
        })
    }
}
enableDismissTrigger(Alert, "close")
defineJQueryPlugin(Alert)
const NAME$e = "button",
    DATA_KEY$9 = "bs.button",
    EVENT_KEY$a = `.${DATA_KEY$9}`,
    DATA_API_KEY$6 = ".data-api",
    CLASS_NAME_ACTIVE$3 = "active",
    SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]',
    EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`
class Button extends BaseComponent {
    static get NAME() {
        return NAME$e
    }
    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3))
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Button.getOrCreateInstance(this)
            e === "toggle" && n[e]()
        })
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (t) => {
    t.preventDefault()
    const e = t.target.closest(SELECTOR_DATA_TOGGLE$5)
    Button.getOrCreateInstance(e).toggle()
})
defineJQueryPlugin(Button)
const SelectorEngine = {
        find(t, e = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(e, t))
        },
        findOne(t, e = document.documentElement) {
            return Element.prototype.querySelector.call(e, t)
        },
        children(t, e) {
            return [].concat(...t.children).filter((n) => n.matches(e))
        },
        parents(t, e) {
            const n = []
            let i = t.parentNode.closest(e)
            for (; i; ) n.push(i), (i = i.parentNode.closest(e))
            return n
        },
        prev(t, e) {
            let n = t.previousElementSibling
            for (; n; ) {
                if (n.matches(e)) return [n]
                n = n.previousElementSibling
            }
            return []
        },
        next(t, e) {
            let n = t.nextElementSibling
            for (; n; ) {
                if (n.matches(e)) return [n]
                n = n.nextElementSibling
            }
            return []
        },
        focusableChildren(t) {
            const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]']
                .map((n) => `${n}:not([tabindex^="-"])`)
                .join(",")
            return this.find(e, t).filter((n) => !isDisabled(n) && isVisible(n))
        },
    },
    NAME$d = "swipe",
    EVENT_KEY$9 = ".bs.swipe",
    EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`,
    EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`,
    EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`,
    EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`,
    EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`,
    POINTER_TYPE_TOUCH = "touch",
    POINTER_TYPE_PEN = "pen",
    CLASS_NAME_POINTER_EVENT = "pointer-event",
    SWIPE_THRESHOLD = 40,
    Default$c = { endCallback: null, leftCallback: null, rightCallback: null },
    DefaultType$c = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }
class Swipe extends Config {
    constructor(e, n) {
        super(),
            (this._element = e),
            !(!e || !Swipe.isSupported()) &&
                ((this._config = this._getConfig(n)),
                (this._deltaX = 0),
                (this._supportPointerEvents = Boolean(window.PointerEvent)),
                this._initEvents())
    }
    static get Default() {
        return Default$c
    }
    static get DefaultType() {
        return DefaultType$c
    }
    static get NAME() {
        return NAME$d
    }
    dispose() {
        EventHandler.off(this._element, EVENT_KEY$9)
    }
    _start(e) {
        if (!this._supportPointerEvents) {
            this._deltaX = e.touches[0].clientX
            return
        }
        this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX)
    }
    _end(e) {
        this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), execute(this._config.endCallback)
    }
    _move(e) {
        this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX
    }
    _handleSwipe() {
        const e = Math.abs(this._deltaX)
        if (e <= SWIPE_THRESHOLD) return
        const n = e / this._deltaX
        ;(this._deltaX = 0), n && execute(n > 0 ? this._config.rightCallback : this._config.leftCallback)
    }
    _initEvents() {
        this._supportPointerEvents
            ? (EventHandler.on(this._element, EVENT_POINTERDOWN, (e) => this._start(e)),
              EventHandler.on(this._element, EVENT_POINTERUP, (e) => this._end(e)),
              this._element.classList.add(CLASS_NAME_POINTER_EVENT))
            : (EventHandler.on(this._element, EVENT_TOUCHSTART, (e) => this._start(e)),
              EventHandler.on(this._element, EVENT_TOUCHMOVE, (e) => this._move(e)),
              EventHandler.on(this._element, EVENT_TOUCHEND, (e) => this._end(e)))
    }
    _eventIsPointerPenTouch(e) {
        return this._supportPointerEvents && (e.pointerType === POINTER_TYPE_PEN || e.pointerType === POINTER_TYPE_TOUCH)
    }
    static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
    }
}
const NAME$c = "carousel",
    DATA_KEY$8 = "bs.carousel",
    EVENT_KEY$8 = `.${DATA_KEY$8}`,
    DATA_API_KEY$5 = ".data-api",
    ARROW_LEFT_KEY$1 = "ArrowLeft",
    ARROW_RIGHT_KEY$1 = "ArrowRight",
    TOUCHEVENT_COMPAT_WAIT = 500,
    ORDER_NEXT = "next",
    ORDER_PREV = "prev",
    DIRECTION_LEFT = "left",
    DIRECTION_RIGHT = "right",
    EVENT_SLIDE = `slide${EVENT_KEY$8}`,
    EVENT_SLID = `slid${EVENT_KEY$8}`,
    EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`,
    EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`,
    EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`,
    EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`,
    EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`,
    EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`,
    CLASS_NAME_CAROUSEL = "carousel",
    CLASS_NAME_ACTIVE$2 = "active",
    CLASS_NAME_SLIDE = "slide",
    CLASS_NAME_END = "carousel-item-end",
    CLASS_NAME_START = "carousel-item-start",
    CLASS_NAME_NEXT = "carousel-item-next",
    CLASS_NAME_PREV = "carousel-item-prev",
    SELECTOR_ACTIVE = ".active",
    SELECTOR_ITEM = ".carousel-item",
    SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM,
    SELECTOR_ITEM_IMG = ".carousel-item img",
    SELECTOR_INDICATORS = ".carousel-indicators",
    SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]",
    SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]',
    KEY_TO_DIRECTION = { [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT, [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT },
    Default$b = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 },
    DefaultType$b = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean",
    }
class Carousel extends BaseComponent {
    constructor(e, n) {
        super(e, n),
            (this._interval = null),
            (this._activeElement = null),
            (this._isSliding = !1),
            (this.touchTimeout = null),
            (this._swipeHelper = null),
            (this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element)),
            this._addEventListeners(),
            this._config.ride === CLASS_NAME_CAROUSEL && this.cycle()
    }
    static get Default() {
        return Default$b
    }
    static get DefaultType() {
        return DefaultType$b
    }
    static get NAME() {
        return NAME$c
    }
    next() {
        this._slide(ORDER_NEXT)
    }
    nextWhenVisible() {
        !document.hidden && isVisible(this._element) && this.next()
    }
    prev() {
        this._slide(ORDER_PREV)
    }
    pause() {
        this._isSliding && triggerTransitionEnd(this._element), this._clearInterval()
    }
    cycle() {
        this._clearInterval(), this._updateInterval(), (this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval))
    }
    _maybeEnableCycle() {
        if (!!this._config.ride) {
            if (this._isSliding) {
                EventHandler.one(this._element, EVENT_SLID, () => this.cycle())
                return
            }
            this.cycle()
        }
    }
    to(e) {
        const n = this._getItems()
        if (e > n.length - 1 || e < 0) return
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, () => this.to(e))
            return
        }
        const i = this._getItemIndex(this._getActive())
        if (i === e) return
        const o = e > i ? ORDER_NEXT : ORDER_PREV
        this._slide(o, n[e])
    }
    dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
    }
    _configAfterMerge(e) {
        return (e.defaultInterval = e.interval), e
    }
    _addEventListeners() {
        this._config.keyboard && EventHandler.on(this._element, EVENT_KEYDOWN$1, (e) => this._keydown(e)),
            this._config.pause === "hover" &&
                (EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause()),
                EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle())),
            this._config.touch && Swipe.isSupported() && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
        for (const i of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) EventHandler.on(i, EVENT_DRAG_START, (o) => o.preventDefault())
        const n = {
            leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
            rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
            endCallback: () => {
                this._config.pause === "hover" &&
                    (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    (this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval)))
            },
        }
        this._swipeHelper = new Swipe(this._element, n)
    }
    _keydown(e) {
        if (/input|textarea/i.test(e.target.tagName)) return
        const n = KEY_TO_DIRECTION[e.key]
        n && (e.preventDefault(), this._slide(this._directionToOrder(n)))
    }
    _getItemIndex(e) {
        return this._getItems().indexOf(e)
    }
    _setActiveIndicatorElement(e) {
        if (!this._indicatorsElement) return
        const n = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement)
        n.classList.remove(CLASS_NAME_ACTIVE$2), n.removeAttribute("aria-current")
        const i = SelectorEngine.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement)
        i && (i.classList.add(CLASS_NAME_ACTIVE$2), i.setAttribute("aria-current", "true"))
    }
    _updateInterval() {
        const e = this._activeElement || this._getActive()
        if (!e) return
        const n = Number.parseInt(e.getAttribute("data-bs-interval"), 10)
        this._config.interval = n || this._config.defaultInterval
    }
    _slide(e, n = null) {
        if (this._isSliding) return
        const i = this._getActive(),
            o = e === ORDER_NEXT,
            a = n || getNextActiveElement(this._getItems(), i, o, this._config.wrap)
        if (a === i) return
        const l = this._getItemIndex(a),
            c = (D) =>
                EventHandler.trigger(this._element, D, {
                    relatedTarget: a,
                    direction: this._orderToDirection(e),
                    from: this._getItemIndex(i),
                    to: l,
                })
        if (c(EVENT_SLIDE).defaultPrevented || !i || !a) return
        const v = Boolean(this._interval)
        this.pause(), (this._isSliding = !0), this._setActiveIndicatorElement(l), (this._activeElement = a)
        const _ = o ? CLASS_NAME_START : CLASS_NAME_END,
            A = o ? CLASS_NAME_NEXT : CLASS_NAME_PREV
        a.classList.add(A), reflow(a), i.classList.add(_), a.classList.add(_)
        const B = () => {
            a.classList.remove(_, A),
                a.classList.add(CLASS_NAME_ACTIVE$2),
                i.classList.remove(CLASS_NAME_ACTIVE$2, A, _),
                (this._isSliding = !1),
                c(EVENT_SLID)
        }
        this._queueCallback(B, i, this._isAnimated()), v && this.cycle()
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_SLIDE)
    }
    _getActive() {
        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)
    }
    _getItems() {
        return SelectorEngine.find(SELECTOR_ITEM, this._element)
    }
    _clearInterval() {
        this._interval && (clearInterval(this._interval), (this._interval = null))
    }
    _directionToOrder(e) {
        return isRTL() ? (e === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT) : e === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV
    }
    _orderToDirection(e) {
        return isRTL() ? (e === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT) : e === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Carousel.getOrCreateInstance(this, e)
            if (typeof e == "number") {
                n.to(e)
                return
            }
            if (typeof e == "string") {
                if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (t) {
    const e = getElementFromSelector(this)
    if (!e || !e.classList.contains(CLASS_NAME_CAROUSEL)) return
    t.preventDefault()
    const n = Carousel.getOrCreateInstance(e),
        i = this.getAttribute("data-bs-slide-to")
    if (i) {
        n.to(i), n._maybeEnableCycle()
        return
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
        n.next(), n._maybeEnableCycle()
        return
    }
    n.prev(), n._maybeEnableCycle()
})
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const t = SelectorEngine.find(SELECTOR_DATA_RIDE)
    for (const e of t) Carousel.getOrCreateInstance(e)
})
defineJQueryPlugin(Carousel)
const NAME$b = "collapse",
    DATA_KEY$7 = "bs.collapse",
    EVENT_KEY$7 = `.${DATA_KEY$7}`,
    DATA_API_KEY$4 = ".data-api",
    EVENT_SHOW$6 = `show${EVENT_KEY$7}`,
    EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`,
    EVENT_HIDE$6 = `hide${EVENT_KEY$7}`,
    EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`,
    EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`,
    CLASS_NAME_SHOW$7 = "show",
    CLASS_NAME_COLLAPSE = "collapse",
    CLASS_NAME_COLLAPSING = "collapsing",
    CLASS_NAME_COLLAPSED = "collapsed",
    CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`,
    CLASS_NAME_HORIZONTAL = "collapse-horizontal",
    WIDTH = "width",
    HEIGHT = "height",
    SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing",
    SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]',
    Default$a = { parent: null, toggle: !0 },
    DefaultType$a = { parent: "(null|element)", toggle: "boolean" }
class Collapse extends BaseComponent {
    constructor(e, n) {
        super(e, n), (this._isTransitioning = !1), (this._triggerArray = [])
        const i = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4)
        for (const o of i) {
            const a = getSelectorFromElement(o),
                l = SelectorEngine.find(a).filter((c) => c === this._element)
            a !== null && l.length && this._triggerArray.push(o)
        }
        this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
    }
    static get Default() {
        return Default$a
    }
    static get DefaultType() {
        return DefaultType$a
    }
    static get NAME() {
        return NAME$b
    }
    toggle() {
        this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (this._isTransitioning || this._isShown()) return
        let e = []
        if (
            (this._config.parent &&
                (e = this._getFirstLevelChildren(SELECTOR_ACTIVES)
                    .filter((c) => c !== this._element)
                    .map((c) => Collapse.getOrCreateInstance(c, { toggle: !1 }))),
            (e.length && e[0]._isTransitioning) || EventHandler.trigger(this._element, EVENT_SHOW$6).defaultPrevented)
        )
            return
        for (const c of e) c.hide()
        const i = this._getDimension()
        this._element.classList.remove(CLASS_NAME_COLLAPSE),
            this._element.classList.add(CLASS_NAME_COLLAPSING),
            (this._element.style[i] = 0),
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            (this._isTransitioning = !0)
        const o = () => {
                ;(this._isTransitioning = !1),
                    this._element.classList.remove(CLASS_NAME_COLLAPSING),
                    this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7),
                    (this._element.style[i] = ""),
                    EventHandler.trigger(this._element, EVENT_SHOWN$6)
            },
            l = `scroll${i[0].toUpperCase() + i.slice(1)}`
        this._queueCallback(o, this._element, !0), (this._element.style[i] = `${this._element[l]}px`)
    }
    hide() {
        if (this._isTransitioning || !this._isShown() || EventHandler.trigger(this._element, EVENT_HIDE$6).defaultPrevented) return
        const n = this._getDimension()
        ;(this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`),
            reflow(this._element),
            this._element.classList.add(CLASS_NAME_COLLAPSING),
            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7)
        for (const o of this._triggerArray) {
            const a = getElementFromSelector(o)
            a && !this._isShown(a) && this._addAriaAndCollapsedClass([o], !1)
        }
        this._isTransitioning = !0
        const i = () => {
            ;(this._isTransitioning = !1),
                this._element.classList.remove(CLASS_NAME_COLLAPSING),
                this._element.classList.add(CLASS_NAME_COLLAPSE),
                EventHandler.trigger(this._element, EVENT_HIDDEN$6)
        }
        ;(this._element.style[n] = ""), this._queueCallback(i, this._element, !0)
    }
    _isShown(e = this._element) {
        return e.classList.contains(CLASS_NAME_SHOW$7)
    }
    _configAfterMerge(e) {
        return (e.toggle = Boolean(e.toggle)), (e.parent = getElement(e.parent)), e
    }
    _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT
    }
    _initializeChildren() {
        if (!this._config.parent) return
        const e = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4)
        for (const n of e) {
            const i = getElementFromSelector(n)
            i && this._addAriaAndCollapsedClass([n], this._isShown(i))
        }
    }
    _getFirstLevelChildren(e) {
        const n = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent)
        return SelectorEngine.find(e, this._config.parent).filter((i) => !n.includes(i))
    }
    _addAriaAndCollapsedClass(e, n) {
        if (!!e.length) for (const i of e) i.classList.toggle(CLASS_NAME_COLLAPSED, !n), i.setAttribute("aria-expanded", n)
    }
    static jQueryInterface(e) {
        const n = {}
        return (
            typeof e == "string" && /show|hide/.test(e) && (n.toggle = !1),
            this.each(function () {
                const i = Collapse.getOrCreateInstance(this, n)
                if (typeof e == "string") {
                    if (typeof i[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                    i[e]()
                }
            })
        )
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (t) {
    ;(t.target.tagName === "A" || (t.delegateTarget && t.delegateTarget.tagName === "A")) && t.preventDefault()
    const e = getSelectorFromElement(this),
        n = SelectorEngine.find(e)
    for (const i of n) Collapse.getOrCreateInstance(i, { toggle: !1 }).toggle()
})
defineJQueryPlugin(Collapse)
const NAME$a = "dropdown",
    DATA_KEY$6 = "bs.dropdown",
    EVENT_KEY$6 = `.${DATA_KEY$6}`,
    DATA_API_KEY$3 = ".data-api",
    ESCAPE_KEY$2 = "Escape",
    TAB_KEY$1 = "Tab",
    ARROW_UP_KEY$1 = "ArrowUp",
    ARROW_DOWN_KEY$1 = "ArrowDown",
    RIGHT_MOUSE_BUTTON = 2,
    EVENT_HIDE$5 = `hide${EVENT_KEY$6}`,
    EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`,
    EVENT_SHOW$5 = `show${EVENT_KEY$6}`,
    EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`,
    EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`,
    EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`,
    EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`,
    CLASS_NAME_SHOW$6 = "show",
    CLASS_NAME_DROPUP = "dropup",
    CLASS_NAME_DROPEND = "dropend",
    CLASS_NAME_DROPSTART = "dropstart",
    CLASS_NAME_DROPUP_CENTER = "dropup-center",
    CLASS_NAME_DROPDOWN_CENTER = "dropdown-center",
    SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`,
    SELECTOR_MENU = ".dropdown-menu",
    SELECTOR_NAVBAR = ".navbar",
    SELECTOR_NAVBAR_NAV = ".navbar-nav",
    SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
    PLACEMENT_TOP = isRTL() ? "top-end" : "top-start",
    PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end",
    PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start",
    PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end",
    PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start",
    PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start",
    PLACEMENT_TOPCENTER = "top",
    PLACEMENT_BOTTOMCENTER = "bottom",
    Default$9 = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" },
    DefaultType$9 = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)",
    }
class Dropdown extends BaseComponent {
    constructor(e, n) {
        super(e, n),
            (this._popper = null),
            (this._parent = this._element.parentNode),
            (this._menu = SelectorEngine.findOne(SELECTOR_MENU, this._parent)),
            (this._inNavbar = this._detectNavbar())
    }
    static get Default() {
        return Default$9
    }
    static get DefaultType() {
        return DefaultType$9
    }
    static get NAME() {
        return NAME$a
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (isDisabled(this._element) || this._isShown()) return
        const e = { relatedTarget: this._element }
        if (!EventHandler.trigger(this._element, EVENT_SHOW$5, e).defaultPrevented) {
            if ((this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)))
                for (const i of [].concat(...document.body.children)) EventHandler.on(i, "mouseover", noop$1)
            this._element.focus(),
                this._element.setAttribute("aria-expanded", !0),
                this._menu.classList.add(CLASS_NAME_SHOW$6),
                this._element.classList.add(CLASS_NAME_SHOW$6),
                EventHandler.trigger(this._element, EVENT_SHOWN$5, e)
        }
    }
    hide() {
        if (isDisabled(this._element) || !this._isShown()) return
        const e = { relatedTarget: this._element }
        this._completeHide(e)
    }
    dispose() {
        this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
        ;(this._inNavbar = this._detectNavbar()), this._popper && this._popper.update()
    }
    _completeHide(e) {
        if (!EventHandler.trigger(this._element, EVENT_HIDE$5, e).defaultPrevented) {
            if ("ontouchstart" in document.documentElement)
                for (const i of [].concat(...document.body.children)) EventHandler.off(i, "mouseover", noop$1)
            this._popper && this._popper.destroy(),
                this._menu.classList.remove(CLASS_NAME_SHOW$6),
                this._element.classList.remove(CLASS_NAME_SHOW$6),
                this._element.setAttribute("aria-expanded", "false"),
                Manipulator.removeDataAttribute(this._menu, "popper"),
                EventHandler.trigger(this._element, EVENT_HIDDEN$5, e)
        }
    }
    _getConfig(e) {
        if (
            ((e = super._getConfig(e)),
            typeof e.reference == "object" && !isElement(e.reference) && typeof e.reference.getBoundingClientRect != "function")
        )
            throw new TypeError(
                `${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
            )
        return e
    }
    _createPopper() {
        if (typeof Popper == "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)")
        let e = this._element
        this._config.reference === "parent"
            ? (e = this._parent)
            : isElement(this._config.reference)
            ? (e = getElement(this._config.reference))
            : typeof this._config.reference == "object" && (e = this._config.reference)
        const n = this._getPopperConfig()
        this._popper = createPopper(e, this._menu, n)
    }
    _isShown() {
        return this._menu.classList.contains(CLASS_NAME_SHOW$6)
    }
    _getPlacement() {
        const e = this._parent
        if (e.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT
        if (e.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT
        if (e.classList.contains(CLASS_NAME_DROPUP_CENTER)) return PLACEMENT_TOPCENTER
        if (e.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) return PLACEMENT_BOTTOMCENTER
        const n = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"
        return e.classList.contains(CLASS_NAME_DROPUP) ? (n ? PLACEMENT_TOPEND : PLACEMENT_TOP) : n ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM
    }
    _detectNavbar() {
        return this._element.closest(SELECTOR_NAVBAR) !== null
    }
    _getOffset() {
        const { offset: e } = this._config
        return typeof e == "string" ? e.split(",").map((n) => Number.parseInt(n, 10)) : typeof e == "function" ? (n) => e(n, this._element) : e
    }
    _getPopperConfig() {
        const e = {
            placement: this._getPlacement(),
            modifiers: [
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "offset", options: { offset: this._getOffset() } },
            ],
        }
        return (
            (this._inNavbar || this._config.display === "static") &&
                (Manipulator.setDataAttribute(this._menu, "popper", "static"), (e.modifiers = [{ name: "applyStyles", enabled: !1 }])),
            { ...e, ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig) }
        )
    }
    _selectMenuItem({ key: e, target: n }) {
        const i = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((o) => isVisible(o))
        !i.length || getNextActiveElement(i, n, e === ARROW_DOWN_KEY$1, !i.includes(n)).focus()
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Dropdown.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
    static clearMenus(e) {
        if (e.button === RIGHT_MOUSE_BUTTON || (e.type === "keyup" && e.key !== TAB_KEY$1)) return
        const n = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN)
        for (const i of n) {
            const o = Dropdown.getInstance(i)
            if (!o || o._config.autoClose === !1) continue
            const a = e.composedPath(),
                l = a.includes(o._menu)
            if (
                a.includes(o._element) ||
                (o._config.autoClose === "inside" && !l) ||
                (o._config.autoClose === "outside" && l) ||
                (o._menu.contains(e.target) &&
                    ((e.type === "keyup" && e.key === TAB_KEY$1) || /input|select|option|textarea|form/i.test(e.target.tagName)))
            )
                continue
            const c = { relatedTarget: o._element }
            e.type === "click" && (c.clickEvent = e), o._completeHide(c)
        }
    }
    static dataApiKeydownHandler(e) {
        const n = /input|textarea/i.test(e.target.tagName),
            i = e.key === ESCAPE_KEY$2,
            o = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(e.key)
        if ((!o && !i) || (n && !i)) return
        e.preventDefault()
        const a = SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, e.delegateTarget.parentNode),
            l = Dropdown.getOrCreateInstance(a)
        if (o) {
            e.stopPropagation(), l.show(), l._selectMenuItem(e)
            return
        }
        l._isShown() && (e.stopPropagation(), l.hide(), a.focus())
    }
}
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler)
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler)
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus)
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus)
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (t) {
    t.preventDefault(), Dropdown.getOrCreateInstance(this).toggle()
})
defineJQueryPlugin(Dropdown)
const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    SELECTOR_STICKY_CONTENT = ".sticky-top",
    PROPERTY_PADDING = "padding-right",
    PROPERTY_MARGIN = "margin-right"
class ScrollBarHelper {
    constructor() {
        this._element = document.body
    }
    getWidth() {
        const e = document.documentElement.clientWidth
        return Math.abs(window.innerWidth - e)
    }
    hide() {
        const e = this.getWidth()
        this._disableOverFlow(),
            this._setElementAttributes(this._element, PROPERTY_PADDING, (n) => n + e),
            this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (n) => n + e),
            this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (n) => n - e)
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, PROPERTY_PADDING),
            this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING),
            this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN)
    }
    isOverflowing() {
        return this.getWidth() > 0
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), (this._element.style.overflow = "hidden")
    }
    _setElementAttributes(e, n, i) {
        const o = this.getWidth(),
            a = (l) => {
                if (l !== this._element && window.innerWidth > l.clientWidth + o) return
                this._saveInitialAttribute(l, n)
                const c = window.getComputedStyle(l).getPropertyValue(n)
                l.style.setProperty(n, `${i(Number.parseFloat(c))}px`)
            }
        this._applyManipulationCallback(e, a)
    }
    _saveInitialAttribute(e, n) {
        const i = e.style.getPropertyValue(n)
        i && Manipulator.setDataAttribute(e, n, i)
    }
    _resetElementAttributes(e, n) {
        const i = (o) => {
            const a = Manipulator.getDataAttribute(o, n)
            if (a === null) {
                o.style.removeProperty(n)
                return
            }
            Manipulator.removeDataAttribute(o, n), o.style.setProperty(n, a)
        }
        this._applyManipulationCallback(e, i)
    }
    _applyManipulationCallback(e, n) {
        if (isElement(e)) {
            n(e)
            return
        }
        for (const i of SelectorEngine.find(e, this._element)) n(i)
    }
}
const NAME$9 = "backdrop",
    CLASS_NAME_FADE$4 = "fade",
    CLASS_NAME_SHOW$5 = "show",
    EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`,
    Default$8 = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" },
    DefaultType$8 = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)",
    }
class Backdrop extends Config {
    constructor(e) {
        super(), (this._config = this._getConfig(e)), (this._isAppended = !1), (this._element = null)
    }
    static get Default() {
        return Default$8
    }
    static get DefaultType() {
        return DefaultType$8
    }
    static get NAME() {
        return NAME$9
    }
    show(e) {
        if (!this._config.isVisible) {
            execute(e)
            return
        }
        this._append()
        const n = this._getElement()
        this._config.isAnimated && reflow(n),
            n.classList.add(CLASS_NAME_SHOW$5),
            this._emulateAnimation(() => {
                execute(e)
            })
    }
    hide(e) {
        if (!this._config.isVisible) {
            execute(e)
            return
        }
        this._getElement().classList.remove(CLASS_NAME_SHOW$5),
            this._emulateAnimation(() => {
                this.dispose(), execute(e)
            })
    }
    dispose() {
        !this._isAppended || (EventHandler.off(this._element, EVENT_MOUSEDOWN), this._element.remove(), (this._isAppended = !1))
    }
    _getElement() {
        if (!this._element) {
            const e = document.createElement("div")
            ;(e.className = this._config.className), this._config.isAnimated && e.classList.add(CLASS_NAME_FADE$4), (this._element = e)
        }
        return this._element
    }
    _configAfterMerge(e) {
        return (e.rootElement = getElement(e.rootElement)), e
    }
    _append() {
        if (this._isAppended) return
        const e = this._getElement()
        this._config.rootElement.append(e),
            EventHandler.on(e, EVENT_MOUSEDOWN, () => {
                execute(this._config.clickCallback)
            }),
            (this._isAppended = !0)
    }
    _emulateAnimation(e) {
        executeAfterTransition(e, this._getElement(), this._config.isAnimated)
    }
}
const NAME$8 = "focustrap",
    DATA_KEY$5 = "bs.focustrap",
    EVENT_KEY$5 = `.${DATA_KEY$5}`,
    EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`,
    EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`,
    TAB_KEY = "Tab",
    TAB_NAV_FORWARD = "forward",
    TAB_NAV_BACKWARD = "backward",
    Default$7 = { autofocus: !0, trapElement: null },
    DefaultType$7 = { autofocus: "boolean", trapElement: "element" }
class FocusTrap extends Config {
    constructor(e) {
        super(), (this._config = this._getConfig(e)), (this._isActive = !1), (this._lastTabNavDirection = null)
    }
    static get Default() {
        return Default$7
    }
    static get DefaultType() {
        return DefaultType$7
    }
    static get NAME() {
        return NAME$8
    }
    activate() {
        this._isActive ||
            (this._config.autofocus && this._config.trapElement.focus(),
            EventHandler.off(document, EVENT_KEY$5),
            EventHandler.on(document, EVENT_FOCUSIN$2, (e) => this._handleFocusin(e)),
            EventHandler.on(document, EVENT_KEYDOWN_TAB, (e) => this._handleKeydown(e)),
            (this._isActive = !0))
    }
    deactivate() {
        !this._isActive || ((this._isActive = !1), EventHandler.off(document, EVENT_KEY$5))
    }
    _handleFocusin(e) {
        const { trapElement: n } = this._config
        if (e.target === document || e.target === n || n.contains(e.target)) return
        const i = SelectorEngine.focusableChildren(n)
        i.length === 0 ? n.focus() : this._lastTabNavDirection === TAB_NAV_BACKWARD ? i[i.length - 1].focus() : i[0].focus()
    }
    _handleKeydown(e) {
        e.key === TAB_KEY && (this._lastTabNavDirection = e.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD)
    }
}
const NAME$7 = "modal",
    DATA_KEY$4 = "bs.modal",
    EVENT_KEY$4 = `.${DATA_KEY$4}`,
    DATA_API_KEY$2 = ".data-api",
    ESCAPE_KEY$1 = "Escape",
    EVENT_HIDE$4 = `hide${EVENT_KEY$4}`,
    EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`,
    EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`,
    EVENT_SHOW$4 = `show${EVENT_KEY$4}`,
    EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`,
    EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`,
    EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`,
    EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`,
    EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`,
    CLASS_NAME_OPEN = "modal-open",
    CLASS_NAME_FADE$3 = "fade",
    CLASS_NAME_SHOW$4 = "show",
    CLASS_NAME_STATIC = "modal-static",
    OPEN_SELECTOR$1 = ".modal.show",
    SELECTOR_DIALOG = ".modal-dialog",
    SELECTOR_MODAL_BODY = ".modal-body",
    SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]',
    Default$6 = { backdrop: !0, focus: !0, keyboard: !0 },
    DefaultType$6 = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }
class Modal extends BaseComponent {
    constructor(e, n) {
        super(e, n),
            (this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element)),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            (this._isShown = !1),
            (this._isTransitioning = !1),
            (this._scrollBar = new ScrollBarHelper()),
            this._addEventListeners()
    }
    static get Default() {
        return Default$6
    }
    static get DefaultType() {
        return DefaultType$6
    }
    static get NAME() {
        return NAME$7
    }
    toggle(e) {
        return this._isShown ? this.hide() : this.show(e)
    }
    show(e) {
        this._isShown ||
            this._isTransitioning ||
            EventHandler.trigger(this._element, EVENT_SHOW$4, { relatedTarget: e }).defaultPrevented ||
            ((this._isShown = !0),
            (this._isTransitioning = !0),
            this._scrollBar.hide(),
            document.body.classList.add(CLASS_NAME_OPEN),
            this._adjustDialog(),
            this._backdrop.show(() => this._showElement(e)))
    }
    hide() {
        !this._isShown ||
            this._isTransitioning ||
            EventHandler.trigger(this._element, EVENT_HIDE$4).defaultPrevented ||
            ((this._isShown = !1),
            (this._isTransitioning = !0),
            this._focustrap.deactivate(),
            this._element.classList.remove(CLASS_NAME_SHOW$4),
            this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()))
    }
    dispose() {
        for (const e of [window, this._dialog]) EventHandler.off(e, EVENT_KEY$4)
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    handleUpdate() {
        this._adjustDialog()
    }
    _initializeBackDrop() {
        return new Backdrop({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() })
    }
    _initializeFocusTrap() {
        return new FocusTrap({ trapElement: this._element })
    }
    _showElement(e) {
        document.body.contains(this._element) || document.body.append(this._element),
            (this._element.style.display = "block"),
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            (this._element.scrollTop = 0)
        const n = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog)
        n && (n.scrollTop = 0), reflow(this._element), this._element.classList.add(CLASS_NAME_SHOW$4)
        const i = () => {
            this._config.focus && this._focustrap.activate(),
                (this._isTransitioning = !1),
                EventHandler.trigger(this._element, EVENT_SHOWN$4, { relatedTarget: e })
        }
        this._queueCallback(i, this._dialog, this._isAnimated())
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (e) => {
            if (e.key === ESCAPE_KEY$1) {
                if (this._config.keyboard) {
                    e.preventDefault(), this.hide()
                    return
                }
                this._triggerBackdropTransition()
            }
        }),
            EventHandler.on(window, EVENT_RESIZE$1, () => {
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }),
            EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (e) => {
                if (e.target === e.currentTarget) {
                    if (this._config.backdrop === "static") {
                        this._triggerBackdropTransition()
                        return
                    }
                    this._config.backdrop && this.hide()
                }
            })
    }
    _hideModal() {
        ;(this._element.style.display = "none"),
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            (this._isTransitioning = !1),
            this._backdrop.hide(() => {
                document.body.classList.remove(CLASS_NAME_OPEN),
                    this._resetAdjustments(),
                    this._scrollBar.reset(),
                    EventHandler.trigger(this._element, EVENT_HIDDEN$4)
            })
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$3)
    }
    _triggerBackdropTransition() {
        if (EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1).defaultPrevented) return
        const n = this._element.scrollHeight > document.documentElement.clientHeight,
            i = this._element.style.overflowY
        i === "hidden" ||
            this._element.classList.contains(CLASS_NAME_STATIC) ||
            (n || (this._element.style.overflowY = "hidden"),
            this._element.classList.add(CLASS_NAME_STATIC),
            this._queueCallback(() => {
                this._element.classList.remove(CLASS_NAME_STATIC),
                    this._queueCallback(() => {
                        this._element.style.overflowY = i
                    }, this._dialog)
            }, this._dialog),
            this._element.focus())
    }
    _adjustDialog() {
        const e = this._element.scrollHeight > document.documentElement.clientHeight,
            n = this._scrollBar.getWidth(),
            i = n > 0
        if (i && !e) {
            const o = isRTL() ? "paddingLeft" : "paddingRight"
            this._element.style[o] = `${n}px`
        }
        if (!i && e) {
            const o = isRTL() ? "paddingRight" : "paddingLeft"
            this._element.style[o] = `${n}px`
        }
    }
    _resetAdjustments() {
        ;(this._element.style.paddingLeft = ""), (this._element.style.paddingRight = "")
    }
    static jQueryInterface(e, n) {
        return this.each(function () {
            const i = Modal.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof i[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                i[e](n)
            }
        })
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (t) {
    const e = getElementFromSelector(this)
    ;["A", "AREA"].includes(this.tagName) && t.preventDefault(),
        EventHandler.one(e, EVENT_SHOW$4, (o) => {
            o.defaultPrevented ||
                EventHandler.one(e, EVENT_HIDDEN$4, () => {
                    isVisible(this) && this.focus()
                })
        })
    const n = SelectorEngine.findOne(OPEN_SELECTOR$1)
    n && Modal.getInstance(n).hide(), Modal.getOrCreateInstance(e).toggle(this)
})
enableDismissTrigger(Modal)
defineJQueryPlugin(Modal)
const NAME$6 = "offcanvas",
    DATA_KEY$3 = "bs.offcanvas",
    EVENT_KEY$3 = `.${DATA_KEY$3}`,
    DATA_API_KEY$1 = ".data-api",
    EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`,
    ESCAPE_KEY = "Escape",
    CLASS_NAME_SHOW$3 = "show",
    CLASS_NAME_SHOWING$1 = "showing",
    CLASS_NAME_HIDING = "hiding",
    CLASS_NAME_BACKDROP = "offcanvas-backdrop",
    OPEN_SELECTOR = ".offcanvas.show",
    EVENT_SHOW$3 = `show${EVENT_KEY$3}`,
    EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`,
    EVENT_HIDE$3 = `hide${EVENT_KEY$3}`,
    EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`,
    EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`,
    EVENT_RESIZE = `resize${EVENT_KEY$3}`,
    EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`,
    EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`,
    SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]',
    Default$5 = { backdrop: !0, keyboard: !0, scroll: !1 },
    DefaultType$5 = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }
class Offcanvas extends BaseComponent {
    constructor(e, n) {
        super(e, n),
            (this._isShown = !1),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            this._addEventListeners()
    }
    static get Default() {
        return Default$5
    }
    static get DefaultType() {
        return DefaultType$5
    }
    static get NAME() {
        return NAME$6
    }
    toggle(e) {
        return this._isShown ? this.hide() : this.show(e)
    }
    show(e) {
        if (this._isShown || EventHandler.trigger(this._element, EVENT_SHOW$3, { relatedTarget: e }).defaultPrevented) return
        ;(this._isShown = !0),
            this._backdrop.show(),
            this._config.scroll || new ScrollBarHelper().hide(),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add(CLASS_NAME_SHOWING$1)
        const i = () => {
            ;(!this._config.scroll || this._config.backdrop) && this._focustrap.activate(),
                this._element.classList.add(CLASS_NAME_SHOW$3),
                this._element.classList.remove(CLASS_NAME_SHOWING$1),
                EventHandler.trigger(this._element, EVENT_SHOWN$3, { relatedTarget: e })
        }
        this._queueCallback(i, this._element, !0)
    }
    hide() {
        if (!this._isShown || EventHandler.trigger(this._element, EVENT_HIDE$3).defaultPrevented) return
        this._focustrap.deactivate(),
            this._element.blur(),
            (this._isShown = !1),
            this._element.classList.add(CLASS_NAME_HIDING),
            this._backdrop.hide()
        const n = () => {
            this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || new ScrollBarHelper().reset(),
                EventHandler.trigger(this._element, EVENT_HIDDEN$3)
        }
        this._queueCallback(n, this._element, !0)
    }
    dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    _initializeBackDrop() {
        const e = () => {
                if (this._config.backdrop === "static") {
                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED)
                    return
                }
                this.hide()
            },
            n = Boolean(this._config.backdrop)
        return new Backdrop({
            className: CLASS_NAME_BACKDROP,
            isVisible: n,
            isAnimated: !0,
            rootElement: this._element.parentNode,
            clickCallback: n ? e : null,
        })
    }
    _initializeFocusTrap() {
        return new FocusTrap({ trapElement: this._element })
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (e) => {
            if (e.key === ESCAPE_KEY) {
                if (!this._config.keyboard) {
                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED)
                    return
                }
                this.hide()
            }
        })
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Offcanvas.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                n[e](this)
            }
        })
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (t) {
    const e = getElementFromSelector(this)
    if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), isDisabled(this))) return
    EventHandler.one(e, EVENT_HIDDEN$3, () => {
        isVisible(this) && this.focus()
    })
    const n = SelectorEngine.findOne(OPEN_SELECTOR)
    n && n !== e && Offcanvas.getInstance(n).hide(), Offcanvas.getOrCreateInstance(e).toggle(this)
})
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const t of SelectorEngine.find(OPEN_SELECTOR)) Offcanvas.getOrCreateInstance(t).show()
})
EventHandler.on(window, EVENT_RESIZE, () => {
    for (const t of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]"))
        getComputedStyle(t).position !== "fixed" && Offcanvas.getOrCreateInstance(t).hide()
})
enableDismissTrigger(Offcanvas)
defineJQueryPlugin(Offcanvas)
const uriAttributes = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i,
    SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    DATA_URL_PATTERN =
        /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    allowedAttribute = (t, e) => {
        const n = t.nodeName.toLowerCase()
        return e.includes(n)
            ? uriAttributes.has(n)
                ? Boolean(SAFE_URL_PATTERN.test(t.nodeValue) || DATA_URL_PATTERN.test(t.nodeValue))
                : !0
            : e.filter((i) => i instanceof RegExp).some((i) => i.test(n))
    },
    DefaultAllowlist = {
        "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
    }
function sanitizeHtml(t, e, n) {
    if (!t.length) return t
    if (n && typeof n == "function") return n(t)
    const o = new window.DOMParser().parseFromString(t, "text/html"),
        a = [].concat(...o.body.querySelectorAll("*"))
    for (const l of a) {
        const c = l.nodeName.toLowerCase()
        if (!Object.keys(e).includes(c)) {
            l.remove()
            continue
        }
        const g = [].concat(...l.attributes),
            v = [].concat(e["*"] || [], e[c] || [])
        for (const _ of g) allowedAttribute(_, v) || l.removeAttribute(_.nodeName)
    }
    return o.body.innerHTML
}
const NAME$5 = "TemplateFactory",
    Default$4 = { allowList: DefaultAllowlist, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" },
    DefaultType$4 = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string",
    },
    DefaultContentType = { entry: "(string|element|function|null)", selector: "(string|element)" }
class TemplateFactory extends Config {
    constructor(e) {
        super(), (this._config = this._getConfig(e))
    }
    static get Default() {
        return Default$4
    }
    static get DefaultType() {
        return DefaultType$4
    }
    static get NAME() {
        return NAME$5
    }
    getContent() {
        return Object.values(this._config.content)
            .map((e) => this._resolvePossibleFunction(e))
            .filter(Boolean)
    }
    hasContent() {
        return this.getContent().length > 0
    }
    changeContent(e) {
        return this._checkContent(e), (this._config.content = { ...this._config.content, ...e }), this
    }
    toHtml() {
        const e = document.createElement("div")
        e.innerHTML = this._maybeSanitize(this._config.template)
        for (const [o, a] of Object.entries(this._config.content)) this._setContent(e, a, o)
        const n = e.children[0],
            i = this._resolvePossibleFunction(this._config.extraClass)
        return i && n.classList.add(...i.split(" ")), n
    }
    _typeCheckConfig(e) {
        super._typeCheckConfig(e), this._checkContent(e.content)
    }
    _checkContent(e) {
        for (const [n, i] of Object.entries(e)) super._typeCheckConfig({ selector: n, entry: i }, DefaultContentType)
    }
    _setContent(e, n, i) {
        const o = SelectorEngine.findOne(i, e)
        if (!!o) {
            if (((n = this._resolvePossibleFunction(n)), !n)) {
                o.remove()
                return
            }
            if (isElement(n)) {
                this._putElementInTemplate(getElement(n), o)
                return
            }
            if (this._config.html) {
                o.innerHTML = this._maybeSanitize(n)
                return
            }
            o.textContent = n
        }
    }
    _maybeSanitize(e) {
        return this._config.sanitize ? sanitizeHtml(e, this._config.allowList, this._config.sanitizeFn) : e
    }
    _resolvePossibleFunction(e) {
        return typeof e == "function" ? e(this) : e
    }
    _putElementInTemplate(e, n) {
        if (this._config.html) {
            ;(n.innerHTML = ""), n.append(e)
            return
        }
        n.textContent = e.textContent
    }
}
const NAME$4 = "tooltip",
    DISALLOWED_ATTRIBUTES = new Set(["sanitize", "allowList", "sanitizeFn"]),
    CLASS_NAME_FADE$2 = "fade",
    CLASS_NAME_MODAL = "modal",
    CLASS_NAME_SHOW$2 = "show",
    SELECTOR_TOOLTIP_INNER = ".tooltip-inner",
    SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`,
    EVENT_MODAL_HIDE = "hide.bs.modal",
    TRIGGER_HOVER = "hover",
    TRIGGER_FOCUS = "focus",
    TRIGGER_CLICK = "click",
    TRIGGER_MANUAL = "manual",
    EVENT_HIDE$2 = "hide",
    EVENT_HIDDEN$2 = "hidden",
    EVENT_SHOW$2 = "show",
    EVENT_SHOWN$2 = "shown",
    EVENT_INSERTED = "inserted",
    EVENT_CLICK$1 = "click",
    EVENT_FOCUSIN$1 = "focusin",
    EVENT_FOCUSOUT$1 = "focusout",
    EVENT_MOUSEENTER = "mouseenter",
    EVENT_MOUSELEAVE = "mouseleave",
    AttachmentMap = { AUTO: "auto", TOP: "top", RIGHT: isRTL() ? "left" : "right", BOTTOM: "bottom", LEFT: isRTL() ? "right" : "left" },
    Default$3 = {
        allowList: DefaultAllowlist,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 0],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus",
    },
    DefaultType$3 = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
    }
class Tooltip extends BaseComponent {
    constructor(e, n) {
        if (typeof Popper == "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)")
        super(e, n),
            (this._isEnabled = !0),
            (this._timeout = 0),
            (this._isHovered = !1),
            (this._activeTrigger = {}),
            (this._popper = null),
            (this._templateFactory = null),
            (this._newContent = null),
            (this.tip = null),
            this._setListeners()
    }
    static get Default() {
        return Default$3
    }
    static get DefaultType() {
        return DefaultType$3
    }
    static get NAME() {
        return NAME$4
    }
    enable() {
        this._isEnabled = !0
    }
    disable() {
        this._isEnabled = !1
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }
    toggle(e) {
        if (!!this._isEnabled) {
            if (e) {
                const n = this._initializeOnDelegatedTarget(e)
                ;(n._activeTrigger.click = !n._activeTrigger.click), n._isWithActiveTrigger() ? n._enter() : n._leave()
                return
            }
            if (this._isShown()) {
                this._leave()
                return
            }
            this._enter()
        }
    }
    dispose() {
        clearTimeout(this._timeout),
            EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler),
            this.tip && this.tip.remove(),
            this._disposePopper(),
            super.dispose()
    }
    show() {
        if (this._element.style.display === "none") throw new Error("Please use show on visible elements")
        if (!(this._isWithContent() && this._isEnabled)) return
        const e = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2)),
            i = (findShadowRoot(this._element) || this._element.ownerDocument.documentElement).contains(this._element)
        if (e.defaultPrevented || !i) return
        this.tip && (this.tip.remove(), (this.tip = null))
        const o = this._getTipElement()
        this._element.setAttribute("aria-describedby", o.getAttribute("id"))
        const { container: a } = this._config
        if (
            (this._element.ownerDocument.documentElement.contains(this.tip) ||
                (a.append(o), EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED))),
            this._popper ? this._popper.update() : (this._popper = this._createPopper(o)),
            o.classList.add(CLASS_NAME_SHOW$2),
            "ontouchstart" in document.documentElement)
        )
            for (const c of [].concat(...document.body.children)) EventHandler.on(c, "mouseover", noop$1)
        const l = () => {
            const c = this._isHovered
            ;(this._isHovered = !1), EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2)), c && this._leave()
        }
        this._queueCallback(l, this.tip, this._isAnimated())
    }
    hide() {
        if (!this._isShown() || EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2)).defaultPrevented) return
        const n = this._getTipElement()
        if ((n.classList.remove(CLASS_NAME_SHOW$2), "ontouchstart" in document.documentElement))
            for (const o of [].concat(...document.body.children)) EventHandler.off(o, "mouseover", noop$1)
        ;(this._activeTrigger[TRIGGER_CLICK] = !1),
            (this._activeTrigger[TRIGGER_FOCUS] = !1),
            (this._activeTrigger[TRIGGER_HOVER] = !1),
            (this._isHovered = !1)
        const i = () => {
            this._isWithActiveTrigger() ||
                (this._isHovered || n.remove(),
                this._element.removeAttribute("aria-describedby"),
                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2)),
                this._disposePopper())
        }
        this._queueCallback(i, this.tip, this._isAnimated())
    }
    update() {
        this._popper && this._popper.update()
    }
    _isWithContent() {
        return Boolean(this._getTitle())
    }
    _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
    }
    _createTipElement(e) {
        const n = this._getTemplateFactory(e).toHtml()
        if (!n) return null
        n.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2), n.classList.add(`bs-${this.constructor.NAME}-auto`)
        const i = getUID(this.constructor.NAME).toString()
        return n.setAttribute("id", i), this._isAnimated() && n.classList.add(CLASS_NAME_FADE$2), n
    }
    setContent(e) {
        ;(this._newContent = e), this._isShown() && (this._disposePopper(), this.show())
    }
    _getTemplateFactory(e) {
        return (
            this._templateFactory
                ? this._templateFactory.changeContent(e)
                : (this._templateFactory = new TemplateFactory({
                      ...this._config,
                      content: e,
                      extraClass: this._resolvePossibleFunction(this._config.customClass),
                  })),
            this._templateFactory
        )
    }
    _getContentForTemplate() {
        return { [SELECTOR_TOOLTIP_INNER]: this._getTitle() }
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle
    }
    _initializeOnDelegatedTarget(e) {
        return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig())
    }
    _isAnimated() {
        return this._config.animation || (this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2))
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2)
    }
    _createPopper(e) {
        const n = typeof this._config.placement == "function" ? this._config.placement.call(this, e, this._element) : this._config.placement,
            i = AttachmentMap[n.toUpperCase()]
        return createPopper(this._element, e, this._getPopperConfig(i))
    }
    _getOffset() {
        const { offset: e } = this._config
        return typeof e == "string" ? e.split(",").map((n) => Number.parseInt(n, 10)) : typeof e == "function" ? (n) => e(n, this._element) : e
    }
    _resolvePossibleFunction(e) {
        return typeof e == "function" ? e.call(this._element) : e
    }
    _getPopperConfig(e) {
        const n = {
            placement: e,
            modifiers: [
                { name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } },
                { name: "offset", options: { offset: this._getOffset() } },
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } },
                {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: (i) => {
                        this._getTipElement().setAttribute("data-popper-placement", i.state.placement)
                    },
                },
            ],
        }
        return { ...n, ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(n) : this._config.popperConfig) }
    }
    _setListeners() {
        const e = this._config.trigger.split(" ")
        for (const n of e)
            if (n === "click")
                EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (i) => this.toggle(i))
            else if (n !== TRIGGER_MANUAL) {
                const i = n === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1),
                    o = n === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1)
                EventHandler.on(this._element, i, this._config.selector, (a) => {
                    const l = this._initializeOnDelegatedTarget(a)
                    ;(l._activeTrigger[a.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = !0), l._enter()
                }),
                    EventHandler.on(this._element, o, this._config.selector, (a) => {
                        const l = this._initializeOnDelegatedTarget(a)
                        ;(l._activeTrigger[a.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = l._element.contains(a.relatedTarget)),
                            l._leave()
                    })
            }
        ;(this._hideModalHandler = () => {
            this._element && this.hide()
        }),
            EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler),
            this._config.selector ? (this._config = { ...this._config, trigger: "manual", selector: "" }) : this._fixTitle()
    }
    _fixTitle() {
        const e = this._config.originalTitle
        !e ||
            (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", e),
            this._element.removeAttribute("title"))
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = !0
            return
        }
        ;(this._isHovered = !0),
            this._setTimeout(() => {
                this._isHovered && this.show()
            }, this._config.delay.show)
    }
    _leave() {
        this._isWithActiveTrigger() ||
            ((this._isHovered = !1),
            this._setTimeout(() => {
                this._isHovered || this.hide()
            }, this._config.delay.hide))
    }
    _setTimeout(e, n) {
        clearTimeout(this._timeout), (this._timeout = setTimeout(e, n))
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0)
    }
    _getConfig(e) {
        const n = Manipulator.getDataAttributes(this._element)
        for (const i of Object.keys(n)) DISALLOWED_ATTRIBUTES.has(i) && delete n[i]
        return (
            (e = { ...n, ...(typeof e == "object" && e ? e : {}) }),
            (e = this._mergeConfigObj(e)),
            (e = this._configAfterMerge(e)),
            this._typeCheckConfig(e),
            e
        )
    }
    _configAfterMerge(e) {
        return (
            (e.container = e.container === !1 ? document.body : getElement(e.container)),
            typeof e.delay == "number" && (e.delay = { show: e.delay, hide: e.delay }),
            (e.originalTitle = this._element.getAttribute("title") || ""),
            typeof e.title == "number" && (e.title = e.title.toString()),
            typeof e.content == "number" && (e.content = e.content.toString()),
            e
        )
    }
    _getDelegateConfig() {
        const e = {}
        for (const n in this._config) this.constructor.Default[n] !== this._config[n] && (e[n] = this._config[n])
        return e
    }
    _disposePopper() {
        this._popper && (this._popper.destroy(), (this._popper = null))
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Tooltip.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
defineJQueryPlugin(Tooltip)
const NAME$3 = "popover",
    SELECTOR_TITLE = ".popover-header",
    SELECTOR_CONTENT = ".popover-body",
    Default$2 = {
        ...Tooltip.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template:
            '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click",
    },
    DefaultType$2 = { ...Tooltip.DefaultType, content: "(null|string|element|function)" }
class Popover extends Tooltip {
    static get Default() {
        return Default$2
    }
    static get DefaultType() {
        return DefaultType$2
    }
    static get NAME() {
        return NAME$3
    }
    _isWithContent() {
        return this._getTitle() || this._getContent()
    }
    _getContentForTemplate() {
        return { [SELECTOR_TITLE]: this._getTitle(), [SELECTOR_CONTENT]: this._getContent() }
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Popover.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
defineJQueryPlugin(Popover)
const NAME$2 = "scrollspy",
    DATA_KEY$2 = "bs.scrollspy",
    EVENT_KEY$2 = `.${DATA_KEY$2}`,
    DATA_API_KEY = ".data-api",
    EVENT_ACTIVATE = `activate${EVENT_KEY$2}`,
    EVENT_CLICK = `click${EVENT_KEY$2}`,
    EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`,
    CLASS_NAME_DROPDOWN_ITEM = "dropdown-item",
    CLASS_NAME_ACTIVE$1 = "active",
    SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]',
    SELECTOR_TARGET_LINKS = "[href]",
    SELECTOR_NAV_LIST_GROUP = ".nav, .list-group",
    SELECTOR_NAV_LINKS = ".nav-link",
    SELECTOR_NAV_ITEMS = ".nav-item",
    SELECTOR_LIST_ITEMS = ".list-group-item",
    SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`,
    SELECTOR_DROPDOWN = ".dropdown",
    SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle",
    Default$1 = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null },
    DefaultType$1 = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element" }
class ScrollSpy extends BaseComponent {
    constructor(e, n) {
        super(e, n),
            (this._targetLinks = new Map()),
            (this._observableSections = new Map()),
            (this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element),
            (this._activeTarget = null),
            (this._observer = null),
            (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }),
            this.refresh()
    }
    static get Default() {
        return Default$1
    }
    static get DefaultType() {
        return DefaultType$1
    }
    static get NAME() {
        return NAME$2
    }
    refresh() {
        this._initializeTargetsAndObservables(),
            this._maybeEnableSmoothScroll(),
            this._observer ? this._observer.disconnect() : (this._observer = this._getNewObserver())
        for (const e of this._observableSections.values()) this._observer.observe(e)
    }
    dispose() {
        this._observer.disconnect(), super.dispose()
    }
    _configAfterMerge(e) {
        return (e.target = getElement(e.target) || document.body), e
    }
    _maybeEnableSmoothScroll() {
        !this._config.smoothScroll ||
            (EventHandler.off(this._config.target, EVENT_CLICK),
            EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (e) => {
                const n = this._observableSections.get(e.target.hash)
                if (n) {
                    e.preventDefault()
                    const i = this._rootElement || window,
                        o = n.offsetTop - this._element.offsetTop
                    if (i.scrollTo) {
                        i.scrollTo({ top: o, behavior: "smooth" })
                        return
                    }
                    i.scrollTop = o
                }
            }))
    }
    _getNewObserver() {
        const e = { root: this._rootElement, threshold: [0.1, 0.5, 1], rootMargin: this._getRootMargin() }
        return new IntersectionObserver((n) => this._observerCallback(n), e)
    }
    _observerCallback(e) {
        const n = (l) => this._targetLinks.get(`#${l.target.id}`),
            i = (l) => {
                ;(this._previousScrollData.visibleEntryTop = l.target.offsetTop), this._process(n(l))
            },
            o = (this._rootElement || document.documentElement).scrollTop,
            a = o >= this._previousScrollData.parentScrollTop
        this._previousScrollData.parentScrollTop = o
        for (const l of e) {
            if (!l.isIntersecting) {
                ;(this._activeTarget = null), this._clearActiveClass(n(l))
                continue
            }
            const c = l.target.offsetTop >= this._previousScrollData.visibleEntryTop
            if (a && c) {
                if ((i(l), !o)) return
                continue
            }
            !a && !c && i(l)
        }
    }
    _getRootMargin() {
        return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin
    }
    _initializeTargetsAndObservables() {
        ;(this._targetLinks = new Map()), (this._observableSections = new Map())
        const e = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target)
        for (const n of e) {
            if (!n.hash || isDisabled(n)) continue
            const i = SelectorEngine.findOne(n.hash, this._element)
            isVisible(i) && (this._targetLinks.set(n.hash, n), this._observableSections.set(n.hash, i))
        }
    }
    _process(e) {
        this._activeTarget !== e &&
            (this._clearActiveClass(this._config.target),
            (this._activeTarget = e),
            e.classList.add(CLASS_NAME_ACTIVE$1),
            this._activateParents(e),
            EventHandler.trigger(this._element, EVENT_ACTIVATE, { relatedTarget: e }))
    }
    _activateParents(e) {
        if (e.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
            SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, e.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1)
            return
        }
        for (const n of SelectorEngine.parents(e, SELECTOR_NAV_LIST_GROUP))
            for (const i of SelectorEngine.prev(n, SELECTOR_LINK_ITEMS)) i.classList.add(CLASS_NAME_ACTIVE$1)
    }
    _clearActiveClass(e) {
        e.classList.remove(CLASS_NAME_ACTIVE$1)
        const n = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, e)
        for (const i of n) i.classList.remove(CLASS_NAME_ACTIVE$1)
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = ScrollSpy.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const t of SelectorEngine.find(SELECTOR_DATA_SPY)) ScrollSpy.getOrCreateInstance(t)
})
defineJQueryPlugin(ScrollSpy)
const NAME$1 = "tab",
    DATA_KEY$1 = "bs.tab",
    EVENT_KEY$1 = `.${DATA_KEY$1}`,
    EVENT_HIDE$1 = `hide${EVENT_KEY$1}`,
    EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`,
    EVENT_SHOW$1 = `show${EVENT_KEY$1}`,
    EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`,
    EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`,
    EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`,
    EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`,
    ARROW_LEFT_KEY = "ArrowLeft",
    ARROW_RIGHT_KEY = "ArrowRight",
    ARROW_UP_KEY = "ArrowUp",
    ARROW_DOWN_KEY = "ArrowDown",
    CLASS_NAME_ACTIVE = "active",
    CLASS_NAME_FADE$1 = "fade",
    CLASS_NAME_SHOW$1 = "show",
    CLASS_DROPDOWN = "dropdown",
    SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle",
    SELECTOR_DROPDOWN_MENU = ".dropdown-menu",
    SELECTOR_DROPDOWN_ITEM = ".dropdown-item",
    NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(.dropdown-toggle)",
    SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]',
    SELECTOR_OUTER = ".nav-item, .list-group-item",
    SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`,
    SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`,
    SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`
class Tab extends BaseComponent {
    constructor(e) {
        super(e),
            (this._parent = this._element.closest(SELECTOR_TAB_PANEL)),
            this._parent &&
                (this._setInitialAttributes(this._parent, this._getChildren()),
                EventHandler.on(this._element, EVENT_KEYDOWN, (n) => this._keydown(n)))
    }
    static get NAME() {
        return NAME$1
    }
    show() {
        const e = this._element
        if (this._elemIsActive(e)) return
        const n = this._getActiveElem(),
            i = n ? EventHandler.trigger(n, EVENT_HIDE$1, { relatedTarget: e }) : null
        EventHandler.trigger(e, EVENT_SHOW$1, { relatedTarget: n }).defaultPrevented ||
            (i && i.defaultPrevented) ||
            (this._deactivate(n, e), this._activate(e, n))
    }
    _activate(e, n) {
        if (!e) return
        e.classList.add(CLASS_NAME_ACTIVE), this._activate(getElementFromSelector(e))
        const i = () => {
            if (e.getAttribute("role") !== "tab") {
                e.classList.add(CLASS_NAME_SHOW$1)
                return
            }
            e.focus(),
                e.removeAttribute("tabindex"),
                e.setAttribute("aria-selected", !0),
                this._toggleDropDown(e, !0),
                EventHandler.trigger(e, EVENT_SHOWN$1, { relatedTarget: n })
        }
        this._queueCallback(i, e, e.classList.contains(CLASS_NAME_FADE$1))
    }
    _deactivate(e, n) {
        if (!e) return
        e.classList.remove(CLASS_NAME_ACTIVE), e.blur(), this._deactivate(getElementFromSelector(e))
        const i = () => {
            if (e.getAttribute("role") !== "tab") {
                e.classList.remove(CLASS_NAME_SHOW$1)
                return
            }
            e.setAttribute("aria-selected", !1),
                e.setAttribute("tabindex", "-1"),
                this._toggleDropDown(e, !1),
                EventHandler.trigger(e, EVENT_HIDDEN$1, { relatedTarget: n })
        }
        this._queueCallback(i, e, e.classList.contains(CLASS_NAME_FADE$1))
    }
    _keydown(e) {
        if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(e.key)) return
        e.stopPropagation(), e.preventDefault()
        const n = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(e.key),
            i = getNextActiveElement(
                this._getChildren().filter((o) => !isDisabled(o)),
                e.target,
                n,
                !0
            )
        i && Tab.getOrCreateInstance(i).show()
    }
    _getChildren() {
        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent)
    }
    _getActiveElem() {
        return this._getChildren().find((e) => this._elemIsActive(e)) || null
    }
    _setInitialAttributes(e, n) {
        this._setAttributeIfNotExists(e, "role", "tablist")
        for (const i of n) this._setInitialAttributesOnChild(i)
    }
    _setInitialAttributesOnChild(e) {
        e = this._getInnerElement(e)
        const n = this._elemIsActive(e),
            i = this._getOuterElement(e)
        e.setAttribute("aria-selected", n),
            i !== e && this._setAttributeIfNotExists(i, "role", "presentation"),
            n || e.setAttribute("tabindex", "-1"),
            this._setAttributeIfNotExists(e, "role", "tab"),
            this._setInitialAttributesOnTargetPanel(e)
    }
    _setInitialAttributesOnTargetPanel(e) {
        const n = getElementFromSelector(e)
        !n || (this._setAttributeIfNotExists(n, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(n, "aria-labelledby", `#${e.id}`))
    }
    _toggleDropDown(e, n) {
        const i = this._getOuterElement(e)
        if (!i.classList.contains(CLASS_DROPDOWN)) return
        const o = (a, l) => {
            const c = SelectorEngine.findOne(a, i)
            c && c.classList.toggle(l, n)
        }
        o(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE),
            o(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1),
            o(SELECTOR_DROPDOWN_ITEM, CLASS_NAME_ACTIVE),
            i.setAttribute("aria-expanded", n)
    }
    _setAttributeIfNotExists(e, n, i) {
        e.hasAttribute(n) || e.setAttribute(n, i)
    }
    _elemIsActive(e) {
        return e.classList.contains(CLASS_NAME_ACTIVE)
    }
    _getInnerElement(e) {
        return e.matches(SELECTOR_INNER_ELEM) ? e : SelectorEngine.findOne(SELECTOR_INNER_ELEM, e)
    }
    _getOuterElement(e) {
        return e.closest(SELECTOR_OUTER) || e
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Tab.getOrCreateInstance(this)
            if (typeof e == "string") {
                if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`)
                n[e]()
            }
        })
    }
}
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (t) {
    ;["A", "AREA"].includes(this.tagName) && t.preventDefault(), !isDisabled(this) && Tab.getOrCreateInstance(this).show()
})
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const t of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) Tab.getOrCreateInstance(t)
})
defineJQueryPlugin(Tab)
const NAME = "toast",
    DATA_KEY = "bs.toast",
    EVENT_KEY = `.${DATA_KEY}`,
    EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`,
    EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`,
    EVENT_FOCUSIN = `focusin${EVENT_KEY}`,
    EVENT_FOCUSOUT = `focusout${EVENT_KEY}`,
    EVENT_HIDE = `hide${EVENT_KEY}`,
    EVENT_HIDDEN = `hidden${EVENT_KEY}`,
    EVENT_SHOW = `show${EVENT_KEY}`,
    EVENT_SHOWN = `shown${EVENT_KEY}`,
    CLASS_NAME_FADE = "fade",
    CLASS_NAME_HIDE = "hide",
    CLASS_NAME_SHOW = "show",
    CLASS_NAME_SHOWING = "showing",
    DefaultType = { animation: "boolean", autohide: "boolean", delay: "number" },
    Default = { animation: !0, autohide: !0, delay: 5e3 }
class Toast extends BaseComponent {
    constructor(e, n) {
        super(e, n), (this._timeout = null), (this._hasMouseInteraction = !1), (this._hasKeyboardInteraction = !1), this._setListeners()
    }
    static get Default() {
        return Default
    }
    static get DefaultType() {
        return DefaultType
    }
    static get NAME() {
        return NAME
    }
    show() {
        if (EventHandler.trigger(this._element, EVENT_SHOW).defaultPrevented) return
        this._clearTimeout(), this._config.animation && this._element.classList.add(CLASS_NAME_FADE)
        const n = () => {
            this._element.classList.remove(CLASS_NAME_SHOWING), EventHandler.trigger(this._element, EVENT_SHOWN), this._maybeScheduleHide()
        }
        this._element.classList.remove(CLASS_NAME_HIDE),
            reflow(this._element),
            this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING),
            this._queueCallback(n, this._element, this._config.animation)
    }
    hide() {
        if (!this.isShown() || EventHandler.trigger(this._element, EVENT_HIDE).defaultPrevented) return
        const n = () => {
            this._element.classList.add(CLASS_NAME_HIDE),
                this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW),
                EventHandler.trigger(this._element, EVENT_HIDDEN)
        }
        this._element.classList.add(CLASS_NAME_SHOWING), this._queueCallback(n, this._element, this._config.animation)
    }
    dispose() {
        this._clearTimeout(), this.isShown() && this._element.classList.remove(CLASS_NAME_SHOW), super.dispose()
    }
    isShown() {
        return this._element.classList.contains(CLASS_NAME_SHOW)
    }
    _maybeScheduleHide() {
        !this._config.autohide ||
            this._hasMouseInteraction ||
            this._hasKeyboardInteraction ||
            (this._timeout = setTimeout(() => {
                this.hide()
            }, this._config.delay))
    }
    _onInteraction(e, n) {
        switch (e.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = n
                break
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = n
                break
        }
        if (n) {
            this._clearTimeout()
            return
        }
        const i = e.relatedTarget
        this._element === i || this._element.contains(i) || this._maybeScheduleHide()
    }
    _setListeners() {
        EventHandler.on(this._element, EVENT_MOUSEOVER, (e) => this._onInteraction(e, !0)),
            EventHandler.on(this._element, EVENT_MOUSEOUT, (e) => this._onInteraction(e, !1)),
            EventHandler.on(this._element, EVENT_FOCUSIN, (e) => this._onInteraction(e, !0)),
            EventHandler.on(this._element, EVENT_FOCUSOUT, (e) => this._onInteraction(e, !1))
    }
    _clearTimeout() {
        clearTimeout(this._timeout), (this._timeout = null)
    }
    static jQueryInterface(e) {
        return this.each(function () {
            const n = Toast.getOrCreateInstance(this, e)
            if (typeof e == "string") {
                if (typeof n[e] == "undefined") throw new TypeError(`No method named "${e}"`)
                n[e](this)
            }
        })
    }
}
enableDismissTrigger(Toast)
defineJQueryPlugin(Toast)
var ll = Object.defineProperty,
    nl = (t, e, n) => (e in t ? ll(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n)),
    se = (t, e, n) => (nl(t, typeof e != "symbol" ? e + "" : e, n), n)
const $l = (t) =>
        computed(() => (t.value === "center" ? "justify-content-center" : t.value === "end" ? "justify-content-end" : "justify-content-start")),
    kl = (t, e) => t.indexOf(e) !== -1,
    Sl = (...t) => Array.from([...t]),
    Cl = (...t) => Array.prototype.concat.apply([], t)
class Qe {
    constructor(e, n = {}) {
        if (
            (se(this, "cancelable", !0),
            se(this, "componentId", null),
            se(this, "defaultPrevented", !1),
            se(this, "nativeEvent", null),
            se(this, "preventDefault"),
            se(this, "relatedTarget", null),
            se(this, "target", null),
            se(this, "eventType", ""),
            se(this, "vueTarget", null),
            !e)
        )
            throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`)
        Gl(this, Qe.Defaults, this.constructor.Defaults, n, { eventType: e }),
            Ul(this, { type: Ve(), cancelable: Ve(), nativeEvent: Ve(), target: Ve(), relatedTarget: Ve(), vueTarget: Ve(), componentId: Ve() })
        let i = !1
        ;(this.preventDefault = function () {
            this.cancelable && (i = !0)
        }),
            Wl(this, "defaultPrevented", {
                enumerable: !0,
                get() {
                    return i
                },
            })
    }
    static get Defaults() {
        return { eventType: "", cancelable: !0, nativeEvent: null, target: null, relatedTarget: null, vueTarget: null, componentId: null }
    }
}
const ot = (t) => `\\${t}`,
    Tl = (t) => {
        t = ft(t)
        const { length: e } = t,
            n = t.charCodeAt(0)
        return t.split("").reduce((i, o, a) => {
            const l = t.charCodeAt(a)
            return l === 0
                ? `${i}\uFFFD`
                : l === 127 || (l >= 1 && l <= 31) || (a === 0 && l >= 48 && l <= 57) || (a === 1 && l >= 48 && l <= 57 && n === 45)
                ? i + ot(`${l.toString(16)} `)
                : a === 0 && l === 45 && e === 1
                ? i + ot(o)
                : l >= 128 || l === 45 || l === 95 || (l >= 48 && l <= 57) || (l >= 65 && l <= 90) || (l >= 97 && l <= 122)
                ? i + o
                : i + ot(o)
        }, "")
    },
    Ut = typeof window < "u",
    Wt = typeof document < "u",
    wl = typeof navigator < "u",
    _l = Ut && Wt && wl,
    Xt = Wt ? document : {},
    we = (t) => !!(t && t.nodeType === Node.ELEMENT_NODE),
    Vl = (t) => (we(t) ? t.getBoundingClientRect() : null),
    xl = (t = []) => {
        const { activeElement: e } = document
        return e && !t.some((n) => n === e) ? e : null
    },
    Al = (t) => we(t) && t === xl(),
    Il = (t, e = {}) => {
        try {
            t.focus(e)
        } catch (n) {
            console.error(n)
        }
        return Al(t)
    },
    Fl = (t, e) => (e && we(t) && t.getAttribute(e)) || null,
    Ol = (t) => {
        if (Fl(t, "display") === "none") return !1
        const e = Vl(t)
        return !!(e && e.height > 0 && e.width > 0)
    },
    xt = (t, e) => !t || t(e).filter((n) => n.type !== Comment).length < 1,
    zl = (t, e) => (we(e) ? e : Xt).querySelector(t) || null,
    Nl = (t, e) => Sl((we(e) ? e : Xt).querySelectorAll(t)),
    Kt = (t, e) => (e && we(t) ? t.getAttribute(e) : null),
    Ll = (t, e, n) => {
        e && we(t) && t.setAttribute(e, n)
    },
    Pl = (t, e) => {
        e && we(t) && t.removeAttribute(e)
    },
    El = (t, e) => ft(t).toLowerCase() === ft(e).toLowerCase(),
    Ge = Ut
        ? window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          ((t) => setTimeout(t, 16))
        : (t) => setTimeout(t, 0),
    et = (t, e, n) =>
        e
            .concat(["sm", "md", "lg", "xl", "xxl"])
            .reduce((i, o) => ((i[t ? `${t}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = n), i), Object.create(null)),
    Jt = (t, e, n, i = n) =>
        Object.keys(e).reduce(
            (o, a) => (
                t[a] &&
                    o.push(
                        [i, a.replace(n, ""), t[a]]
                            .filter((l) => l && typeof l != "boolean")
                            .join("-")
                            .toLowerCase()
                    ),
                o
            ),
            []
        ),
    $e = (t = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${t}__`,
    tt = (t, e) =>
        t === !0 || t === "true" || t === ""
            ? "true"
            : t === "grammar" || t === "spelling"
            ? t
            : e === !1
            ? "true"
            : t === !1 || t === "false"
            ? "false"
            : t,
    Hl = /^[0-9]*\.?[0-9]+$/,
    st = (t) => Qt(t) === "boolean",
    Rl = (t) => t !== null && typeof t == "object",
    Pe = (t) => typeof t == "string",
    ql = (t) => t === void 0,
    Dl = (t) => t === null,
    Yt = (t) => ql(t) || Dl(t),
    Zt = (t) => Hl.test(String(t)),
    jl = (t) => typeof t == "number",
    Qt = (t) => typeof t,
    ea = (t) => Qt(t) === "function",
    ta = (t) => Object.prototype.toString.call(t) === "[object Object]",
    aa = (t) => Array.isArray(t),
    it = (t) => t && typeof t == "object" && t.constructor === Object,
    ct = (t, e, n = !0) => {
        const i = t instanceof Date && typeof t.getMonth == "function" ? new Date(t) : Object.assign({}, t)
        return (
            it(t) &&
                it(e) &&
                Object.keys(e).forEach((o) => {
                    it(e[o])
                        ? o in t
                            ? (i[o] = ct(t[o], e[o], n))
                            : Object.assign(i, { [o]: e[o] })
                        : Array.isArray(e[o]) && Array.isArray(t[o])
                        ? Object.assign(i, { [o]: n ? t[o].concat(e[o].filter((a) => !t[o].includes(a))) : e[o] })
                        : Object.assign(i, { [o]: e[o] })
                }),
            i
        )
    },
    ge = (t, e = {}, n = {}) => {
        const i = [t]
        let o
        for (let a = 0; a < i.length && !o; a++) {
            const l = i[a]
            o = n[l]
        }
        return o && ea(o) ? o(e) : o
    },
    Ee = (t, e = NaN) => (Number.isInteger(t) ? t : e),
    Ml = (t, e = NaN) => {
        const n = parseInt(t, 10)
        return isNaN(n) ? e : n
    },
    St = (t, e = NaN) => {
        const n = parseFloat(t.toString())
        return isNaN(n) ? e : n
    },
    Gl = (t, ...e) => Object.assign(t, ...e),
    Ul = (t, e) => Object.defineProperties(t, e),
    Wl = (t, e, n) => Object.defineProperty(t, e, n),
    at = (t, e) =>
        Object.keys(t)
            .filter((n) => e.indexOf(n) === -1)
            .reduce((n, i) => ({ ...n, [i]: t[i] }), {}),
    Ve = () => ({ enumerable: !0, configurable: !1, writable: !1 }),
    At = (t, e) => e + (t ? Ql(t) : ""),
    la = (t, e, n = (i) => i) => (aa(t) ? t.slice() : Object.keys(t)).reduce((i, o) => ((i[n(o)] = e[o]), i), {}),
    Xl = (t) => (typeof t == "boolean" ? t : t === "" ? !0 : t === "true"),
    De = (t) => !!(t.href || t.to),
    na = /_/g,
    oa = /([a-z])([A-Z])/g,
    Kl = /(\s|^)(\w)/g,
    Jl = /(\s|^)(\w)/,
    Ue = /\s+/,
    Yl = /^#/,
    Zl = /^#[A-Za-z]+[\w\-:.]*$/,
    ft = (t, e = 2) => (Yt(t) ? "" : aa(t) || (ta(t) && t.toString === Object.prototype.toString) ? JSON.stringify(t, null, e) : String(t)),
    It = (t) =>
        t
            .replace(na, " ")
            .replace(oa, (e, n, i) => `${n} ${i}`)
            .replace(Jl, (e, n, i) => n + i.toUpperCase()),
    Ft = (t) =>
        t
            .replace(na, " ")
            .replace(oa, (e, n, i) => `${n} ${i}`)
            .replace(Kl, (e, n, i) => n + i.toUpperCase()),
    Ql = (t) => ((t = Pe(t) ? t.trim() : String(t)), t.charAt(0).toUpperCase() + t.slice(1))
function s$1(t) {
    return computed(() => (t.value === void 0 ? void 0 : Xl(t.value)))
}
const sa = Symbol(),
    ia = {
        items: reactive([]),
        reset() {
            this.items = reactive([])
        },
    },
    en = (t) => {
        t.provide(sa, ia)
    },
    tn = () => inject(sa) || ia,
    re = (t, e, n) => {
        onMounted(() => {
            var i
            ;(i = t == null ? void 0 : t.value) == null || i.addEventListener(e, n)
        }),
            onBeforeUnmount(() => {
                var i
                ;(i = t == null ? void 0 : t.value) == null || i.removeEventListener(e, n)
            })
    },
    ra = (t) =>
        computed(() => ({
            "form-check": !t.plain && !t.button,
            "form-check-inline": t.inline,
            "form-switch": t.switch,
            [`form-control-${t.size}`]: t.size && t.size !== "md",
        })),
    ua = (t) =>
        computed(() => ({
            "form-check-input": !t.plain && !t.button,
            "is-valid": t.state === !0,
            "is-invalid": t.state === !1,
            "btn-check": t.button,
        })),
    da = (t) =>
        computed(() => ({
            "form-check-label": !t.plain && !t.button,
            btn: t.button,
            [`btn-${t.buttonVariant}`]: t.button,
            [`btn-${t.size}`]: t.button && t.size && t.size !== "md",
        })),
    ca = (t) =>
        computed(() => {
            var e
            return {
                "aria-invalid": tt(t.ariaInvalid, t.state),
                "aria-required": ((e = t.required) == null ? void 0 : e.toString()) === "true" ? "true" : null,
            }
        }),
    fa = (t) =>
        computed(() => ({
            "was-validated": t.validated,
            "btn-group": t.buttons && !t.stacked,
            "btn-group-vertical": t.stacked,
            [`btn-group-${t.size}`]: t.size,
        })),
    Je = (t, e, n) =>
        t
            .filter((i) => i.type.name === e)
            .map((i) => {
                const o = (i.children.default ? i.children.default() : []).find((a) => a.type.toString() === "Symbol(Text)")
                return { props: { disabled: n, ...i.props }, text: o ? o.children : "" }
            }),
    va = (t, e) =>
        typeof t == "string"
            ? { props: { value: t, disabled: e.disabled }, text: t }
            : {
                  props: { value: t[e.valueField], disabled: e.disabled || t[e.disabledField], ...t.props },
                  text: t[e.textField],
                  html: t[e.htmlField],
              },
    ba = (t, e, n, i, o) => ({
        ...t,
        props: {
            "button-variant": n.buttonVariant,
            form: n.form,
            name: i.value,
            id: `${o.value}_option_${e}`,
            button: n.buttons,
            state: n.state,
            plain: n.plain,
            size: n.size,
            inline: !n.stacked,
            required: n.required,
            ...t.props,
        },
    }),
    ve = (t, e) => computed(() => (t == null ? void 0 : t.value) || $e(e)),
    ma = {
        ariaInvalid: { type: [Boolean, String], default: void 0 },
        autocomplete: { type: String, required: !1 },
        autofocus: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        form: { type: String, required: !1 },
        formatter: { type: Function, required: !1 },
        id: { type: String, required: !1 },
        lazy: { type: Boolean, default: !1 },
        lazyFormatter: { type: Boolean, default: !1 },
        list: { type: String, required: !1 },
        modelValue: { type: [String, Number], default: "" },
        name: { type: String, required: !1 },
        number: { type: Boolean, default: !1 },
        placeholder: { type: String, required: !1 },
        plaintext: { type: Boolean, default: !1 },
        readonly: { type: Boolean, default: !1 },
        required: { type: Boolean, default: !1 },
        size: { type: String, required: !1 },
        state: { type: Boolean, default: null },
        trim: { type: Boolean, default: !1 },
    },
    ga = (t, e) => {
        const n = ref()
        let i = null,
            o = !0
        const a = ve(toRef(t, "id"), "input"),
            l = (L, G, U = !1) => (
                (L = String(L)), typeof t.formatter == "function" && (!t.lazyFormatter || U) ? ((o = !1), t.formatter(L, G)) : L
            ),
            c = (L) => (t.trim ? L.trim() : t.number ? parseFloat(L) : L),
            g = () => {
                nextTick(() => {
                    var L
                    t.autofocus && ((L = n.value) == null || L.focus())
                })
            }
        onMounted(g),
            onMounted(() => {
                n.value && (n.value.value = t.modelValue)
            }),
            onActivated(g)
        const v = computed(() => {
                var L
                return tt(t.ariaInvalid, (L = t.state) != null ? L : void 0)
            }),
            _ = (L) => {
                const { value: G } = L.target,
                    U = l(G, L)
                if (U === !1 || L.defaultPrevented) {
                    L.preventDefault()
                    return
                }
                if (t.lazy) return
                const F = c(U)
                t.modelValue !== F && ((i = G), e("update:modelValue", F)), e("input", U)
            },
            A = (L) => {
                const { value: G } = L.target,
                    U = l(G, L)
                if (U === !1 || L.defaultPrevented) {
                    L.preventDefault()
                    return
                }
                if (!t.lazy) return
                ;(i = G), e("update:modelValue", U)
                const F = c(U)
                t.modelValue !== F && e("change", U)
            },
            B = (L) => {
                if ((e("blur", L), !t.lazy && !t.lazyFormatter)) return
                const { value: G } = L.target,
                    U = l(G, L, !0)
                ;(i = G), e("update:modelValue", U)
            },
            D = () => {
                var L
                t.disabled || (L = n.value) == null || L.focus()
            },
            I = () => {
                var L
                t.disabled || (L = n.value) == null || L.blur()
            }
        return (
            watch(
                () => t.modelValue,
                (L) => {
                    !n.value || ((n.value.value = i && o ? i : L), (i = null), (o = !0))
                }
            ),
            { input: n, computedId: a, computedAriaInvalid: v, onInput: _, onChange: A, onBlur: B, focus: D, blur: I }
        )
    },
    ze = (t, e) => {
        if (!t) return t
        if (e in t) return t[e]
        const n = e.split(".")
        return ze(t[n[0]], n.splice(1).join("."))
    },
    rt = (t, e = null, n, i) => {
        if (Object.prototype.toString.call(t) === "[object Object]") {
            const o = ze(t, i.valueField),
                a = ze(t, i.textField),
                l = ze(t, i.htmlField),
                c = ze(t, i.disabledField),
                g = t[i.optionsField] || null
            return g !== null
                ? { label: String(ze(t, i.labelField) || a), options: Ct(g, n, i) }
                : { value: typeof o > "u" ? e || a : o, text: String(typeof a > "u" ? e : a), html: l, disabled: Boolean(c) }
        }
        return { value: e || t, text: String(t), disabled: !1 }
    },
    Ct = (t, e, n) =>
        Array.isArray(t)
            ? t.map((i) => rt(i, null, e, n))
            : Object.prototype.toString.call(t) === "[object Object]"
            ? (console.warn(`[BootstrapVue warn]: ${e} - Setting prop "options" to an object is deprecated. Use the array format instead.`),
              Object.keys(t).map((i) => {
                  const o = t[i]
                  switch (typeof o) {
                      case "object":
                          return rt(o.text, String(o.value), e, n)
                      default:
                          return rt(o, String(i), e, n)
                  }
              }))
            : [],
    an = ["id"],
    pa = Symbol(),
    ln$1 = defineComponent({
        __name: "BAccordion",
        props: { flush: { default: !1 }, free: { default: !1 }, id: { default: void 0 } },
        setup(t) {
            const e = t,
                n = ve(toRef(e, "id"), "accordion"),
                i = s$1(toRef(e, "flush")),
                o = s$1(toRef(e, "free")),
                a = computed(() => ({ "accordion-flush": i.value }))
            return (
                o.value || provide(pa, n.value.toString()),
                (l, c) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { id: unref(n), class: normalizeClass(["accordion", unref(a)]) },
                        [renderSlot(l.$slots, "default")],
                        10,
                        an
                    )
                )
            )
        },
    }),
    ha = defineComponent({
        __name: "BCollapse",
        props: {
            accordion: null,
            id: { default: $e() },
            modelValue: { default: !1 },
            tag: { default: "div" },
            toggle: { default: !1 },
            visible: { default: !1 },
            isNav: { default: !1 },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "modelValue")),
                o = s$1(toRef(n, "toggle")),
                a = s$1(toRef(n, "visible")),
                l = s$1(toRef(n, "isNav")),
                c = ref(),
                g = ref(),
                v = computed(() => ({ show: i.value, "navbar-collapse": l.value })),
                _ = () => e("update:modelValue", !1)
            return (
                re(c, "show.bs.collapse", () => {
                    e("show"), e("update:modelValue", !0)
                }),
                re(c, "hide.bs.collapse", () => {
                    e("hide"), e("update:modelValue", !1)
                }),
                re(c, "shown.bs.collapse", () => e("shown")),
                re(c, "hidden.bs.collapse", () => e("hidden")),
                onMounted(() => {
                    var A
                    ;(g.value = new Collapse(c.value, { parent: n.accordion ? `#${n.accordion}` : void 0, toggle: o.value })),
                        (a.value || i.value) && (e("update:modelValue", !0), (A = g.value) == null || A.show())
                }),
                watch(
                    () => i.value,
                    (A) => {
                        var B, D
                        A ? (B = g.value) == null || B.show() : (D = g.value) == null || D.hide()
                    }
                ),
                watch(
                    () => a.value,
                    (A) => {
                        var B, D
                        A
                            ? (e("update:modelValue", !!A), (B = g.value) == null || B.show())
                            : (e("update:modelValue", !!A), (D = g.value) == null || D.hide())
                    }
                ),
                (A, B) => (
                    openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(t.tag),
                        {
                            id: t.id,
                            ref_key: "element",
                            ref: c,
                            class: normalizeClass(["collapse", unref(v)]),
                            "data-bs-parent": t.accordion || null,
                            "is-nav": unref(l),
                        },
                        { default: withCtx(() => [renderSlot(A.$slots, "default", { visible: unref(i), close: _ })]), _: 3 },
                        8,
                        ["id", "class", "data-bs-parent", "is-nav"]
                    )
                )
            )
        },
    }),
    nn = (t) => {
        if (t.classList.contains("offcanvas")) return "offcanvas"
        if (t.classList.contains("collapse")) return "collapse"
        throw Error("Couldn't resolve toggle type")
    },
    on = (t, e) => {
        const { modifiers: n, arg: i, value: o } = t,
            a = Object.keys(n || {}),
            l = Pe(o) ? o.split(Ue) : o
        if (El(e.tagName, "a")) {
            const c = Kt(e, "href") || ""
            Zl.test(c) && a.push(c.replace(Yl, ""))
        }
        return Cl(i, l).forEach((c) => Pe(c) && a.push(c)), a.filter((c, g, v) => c && v.indexOf(c) === g)
    },
    Tt = {
        mounted(t, e) {
            const n = on(e, t),
                i = []
            let o = "data-bs-target"
            t.tagName === "a" && (o = "href")
            for (let a = 0; a < n.length; a++) {
                const l = n[a],
                    c = document.getElementById(l)
                c && (t.setAttribute("data-bs-toggle", nn(c)), i.push(`#${l}`))
            }
            i.length > 0 && t.setAttribute(o, i.join(","))
        },
    },
    sn = { class: "accordion-item" },
    rn = ["id"],
    un = ["aria-expanded", "aria-controls"],
    dn = { class: "accordion-body" },
    cn = defineComponent({
        __name: "BAccordionItem",
        props: { id: null, title: null, visible: { default: !1 } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "visible")),
                i = ve(toRef(e, "id"), "accordion_item"),
                o = inject(pa, "")
            return (a, l) => (
                openBlock(),
                createElementBlock("div", sn, [
                    createBaseVNode(
                        "h2",
                        { id: `${unref(i)}heading`, class: "accordion-header" },
                        [
                            withDirectives(
                                (openBlock(),
                                createElementBlock(
                                    "button",
                                    {
                                        class: normalizeClass(["accordion-button", { collapsed: !unref(n) }]),
                                        type: "button",
                                        "aria-expanded": unref(n) ? "true" : "false",
                                        "aria-controls": unref(i),
                                    },
                                    [renderSlot(a.$slots, "title", {}, () => [createTextVNode(toDisplayString(t.title), 1)])],
                                    10,
                                    un
                                )),
                                [[unref(Tt), void 0, unref(i)]]
                            ),
                        ],
                        8,
                        rn
                    ),
                    createVNode(
                        ha,
                        {
                            id: unref(i),
                            class: "accordion-collapse",
                            visible: unref(n),
                            accordion: unref(o),
                            "aria-labelledby": `heading${unref(i)}`,
                        },
                        { default: withCtx(() => [createBaseVNode("div", dn, [renderSlot(a.$slots, "default")])]), _: 3 },
                        8,
                        ["id", "visible", "accordion", "aria-labelledby"]
                    ),
                ])
            )
        },
    }),
    fn = ["aria-label"],
    vn = defineComponent({
        __name: "BAlert",
        props: {
            dismissLabel: { default: "Close" },
            dismissible: { default: !1 },
            fade: { default: !1 },
            modelValue: { type: [Boolean, Number], default: !1 },
            show: { default: !1 },
            variant: { default: "info" },
        },
        emits: ["dismissed", "dismiss-count-down", "update:modelValue"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "dismissible"))
            s$1(toRef(n, "fade"))
            const o = s$1(toRef(n, "show")),
                a = ref(),
                l = ref(),
                c = computed(() => ({
                    [`alert-${n.variant}`]: !!n.variant,
                    show: !!n.modelValue,
                    "alert-dismissible": i.value,
                    fade: !!n.modelValue,
                }))
            let g
            const v = (G) => {
                    if (typeof G == "boolean") return 0
                    const U = Ee(G, 0)
                    return U > 0 ? U : 0
                },
                _ = () => {
                    g !== void 0 && (clearTimeout(g), (g = void 0))
                },
                A = ref(v(n.modelValue)),
                B = computed(() => !!n.modelValue || o.value)
            onBeforeUnmount(() => {
                var G
                _(), (G = l.value) == null || G.dispose(), (l.value = void 0)
            })
            const D = computed(() => (n.modelValue === !0 ? !0 : n.modelValue === !1 || Ee(n.modelValue, 0) < 1 ? !1 : !!n.modelValue)),
                I = () => {
                    ;(A.value = v(n.modelValue)), (D.value || o.value) && !l.value && (l.value = new Alert(a.value))
                },
                L = () => {
                    typeof n.modelValue == "boolean" ? e("update:modelValue", !1) : e("update:modelValue", 0), e("dismissed")
                }
            return (
                watch(() => n.modelValue, I),
                watch(() => o.value, I),
                watch(A, (G) => {
                    _(),
                        typeof n.modelValue != "boolean" &&
                            (e("dismiss-count-down", G),
                            G === 0 && n.modelValue > 0 && e("dismissed"),
                            n.modelValue !== G && e("update:modelValue", G),
                            G > 0 &&
                                (g = setTimeout(() => {
                                    A.value--
                                }, 1e3)))
                }),
                (G, U) =>
                    unref(B)
                        ? (openBlock(),
                          createElementBlock(
                              "div",
                              { key: 0, ref_key: "element", ref: a, class: normalizeClass(["alert", unref(c)]), role: "alert" },
                              [
                                  renderSlot(G.$slots, "default"),
                                  unref(i)
                                      ? (openBlock(),
                                        createElementBlock(
                                            "button",
                                            {
                                                key: 0,
                                                type: "button",
                                                class: "btn-close",
                                                "data-bs-dismiss": "alert",
                                                "aria-label": t.dismissLabel,
                                                onClick: L,
                                            },
                                            null,
                                            8,
                                            fn
                                        ))
                                      : createCommentVNode("", !0),
                              ],
                              2
                          ))
                        : createCommentVNode("", !0)
            )
        },
    }),
    ya = Symbol(),
    bn = defineComponent({
        __name: "BAvatarGroup",
        props: {
            overlap: { default: 0.3 },
            rounded: { type: [Boolean, String], default: !1 },
            size: null,
            square: { default: !1 },
            tag: { default: "div" },
            variant: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "square")),
                i = computed(() => vt(e.size)),
                o = (c) => (Pe(c) && Zt(c) ? St(c, 0) : c || 0),
                a = computed(() => Math.min(Math.max(o(e.overlap), 0), 1) / 2),
                l = computed(() => {
                    let { value: c } = i
                    return (c = c ? `calc(${c} * ${a.value})` : null), c ? { paddingLeft: c, paddingRight: c } : {}
                })
            return (
                provide(ya, { overlapScale: a, size: e.size, square: n.value, rounded: e.rounded, variant: e.variant }),
                (c, g) => (
                    openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(t.tag),
                        { class: "b-avatar-group", role: "group" },
                        {
                            default: withCtx(() => [
                                createBaseVNode(
                                    "div",
                                    { class: "b-avatar-group-inner", style: normalizeStyle(unref(l)) },
                                    [renderSlot(c.$slots, "default")],
                                    4
                                ),
                            ]),
                            _: 3,
                        }
                    )
                )
            )
        },
    }),
    mn = { key: 0, class: "b-avatar-custom" },
    gn = { key: 1, class: "b-avatar-img" },
    pn = ["src", "alt"],
    vt = (t) => {
        const e = Pe(t) && Zt(t) ? St(t, 0) : t
        return jl(e) ? `${e}px` : e || null
    },
    hn = defineComponent({
        __name: "BAvatar",
        props: {
            alt: { default: "avatar" },
            ariaLabel: null,
            badge: { type: [Boolean, String], default: !1 },
            badgeLeft: { default: !1 },
            badgeOffset: null,
            badgeTop: { default: !1 },
            badgeVariant: { default: "primary" },
            button: { default: !1 },
            buttonType: { default: "button" },
            disabled: { default: !1 },
            icon: null,
            rounded: { type: [Boolean, String], default: "circle" },
            size: null,
            square: { default: !1 },
            src: null,
            text: null,
            textVariant: { default: void 0 },
            variant: { default: "secondary" },
        },
        emits: ["click", "img-error"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "badgeLeft")),
                o = s$1(toRef(n, "badgeTop")),
                a = s$1(toRef(n, "button")),
                l = s$1(toRef(n, "disabled")),
                c = s$1(toRef(n, "square")),
                g = useSlots(),
                v = ["sm", null, "lg"],
                _ = 0.4,
                A = _ * 0.7,
                B = inject(ya, null),
                D = (N) => {
                    const M = N
                    return M === "light" || M === "warning" ? "dark" : "light"
                },
                I = computed(() => !xt(g.default)),
                L = computed(() => !xt(g.badge)),
                G = computed(() => n.badge || n.badge === "" || L.value),
                U = computed(() => (B != null && B.size ? B.size : vt(n.size))),
                F = computed(() => (B != null && B.variant ? B.variant : n.variant)),
                Z = computed(() => (B != null && B.rounded ? B.rounded : n.rounded)),
                Y = computed(() => ({ "aria-label": n.ariaLabel || null, disabled: l.value || null })),
                X = computed(() => ({ [`bg-${n.badgeVariant}`]: !!n.badgeVariant })),
                ie = computed(() => (n.badge === !0 ? "" : n.badge)),
                he = computed(() => `text-${D(n.badgeVariant)}`),
                oe = computed(() => ({
                    [`b-avatar-${n.size}`]: !!n.size && v.indexOf(vt(n.size)) !== -1,
                    [`bg-${F.value}`]: !!F.value,
                    badge: !a.value && F.value && I.value,
                    rounded: Z.value === "" || Z.value === !0,
                    ["rounded-circle"]: !c.value && Z.value === "circle",
                    ["rounded-0"]: c.value || Z.value === "0",
                    ["rounded-1"]: !c.value && Z.value === "sm",
                    ["rounded-3"]: !c.value && Z.value === "lg",
                    ["rounded-top"]: !c.value && Z.value === "top",
                    ["rounded-bottom"]: !c.value && Z.value === "bottom",
                    ["rounded-start"]: !c.value && Z.value === "left",
                    ["rounded-end"]: !c.value && Z.value === "right",
                    btn: a.value,
                    [`btn-${F.value}`]: a.value ? !!F.value : !1,
                })),
                le = computed(() => `text-${n.textVariant || D(F.value)}`),
                Te = computed(() => {
                    const N = n.badgeOffset || "0px"
                    return {
                        fontSize: (v.indexOf(U.value || null) === -1 ? `calc(${U.value} * ${A})` : "") || "",
                        top: o.value ? N : "",
                        bottom: o.value ? "" : N,
                        left: i.value ? N : "",
                        right: i.value ? "" : N,
                    }
                }),
                ye = computed(() => {
                    const N = v.indexOf(U.value || null) === -1 ? `calc(${U.value} * ${_})` : null
                    return N ? { fontSize: N } : {}
                }),
                Ae = computed(() => {
                    var N
                    const M = ((N = B == null ? void 0 : B.overlapScale) == null ? void 0 : N.value) || 0,
                        R = U.value && M ? `calc(${U.value} * -${M})` : null
                    return R ? { marginLeft: R, marginRight: R } : {}
                }),
                O = computed(() => (a.value ? n.buttonType : "span")),
                u = computed(() => ({ ...Ae.value, width: U.value, height: U.value })),
                E = (N) => {
                    !l.value && a.value && e("click", N)
                },
                $ = (N) => e("img-error", N)
            return (N, M) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(unref(O)),
                    mergeProps({ class: ["b-avatar", unref(oe)], style: unref(u) }, unref(Y), { onClick: E }),
                    {
                        default: withCtx(() => [
                            unref(I)
                                ? (openBlock(), createElementBlock("span", mn, [renderSlot(N.$slots, "default")]))
                                : t.src
                                ? (openBlock(),
                                  createElementBlock("span", gn, [createBaseVNode("img", { src: t.src, alt: t.alt, onError: $ }, null, 40, pn)]))
                                : t.text
                                ? (openBlock(),
                                  createElementBlock(
                                      "span",
                                      { key: 2, class: normalizeClass(["b-avatar-text", unref(le)]), style: normalizeStyle(unref(ye)) },
                                      toDisplayString(t.text),
                                      7
                                  ))
                                : createCommentVNode("", !0),
                            unref(G)
                                ? (openBlock(),
                                  createElementBlock(
                                      "span",
                                      { key: 3, class: normalizeClass(["b-avatar-badge", unref(X)]), style: normalizeStyle(unref(Te)) },
                                      [
                                          unref(L)
                                              ? renderSlot(N.$slots, "badge", { key: 0 })
                                              : (openBlock(),
                                                createElementBlock(
                                                    "span",
                                                    { key: 1, class: normalizeClass(unref(he)) },
                                                    toDisplayString(unref(ie)),
                                                    3
                                                )),
                                      ],
                                      6
                                  ))
                                : createCommentVNode("", !0),
                        ]),
                        _: 3,
                    },
                    16,
                    ["class", "style"]
                )
            )
        },
    }),
    Ie = {
        active: { type: [Boolean, String], default: !1 },
        activeClass: { type: String, default: "router-link-active" },
        append: { type: [Boolean, String], default: !1 },
        disabled: { type: [Boolean, String], default: !1 },
        event: { type: [String, Array], default: "click" },
        exact: { type: [Boolean, String], default: !1 },
        exactActiveClass: { type: String, default: "router-link-exact-active" },
        href: { type: String },
        rel: { type: String, default: null },
        replace: { type: [Boolean, String], default: !1 },
        routerComponentName: { type: String, default: "router-link" },
        routerTag: { type: String, default: "a" },
        target: { type: String, default: "_self" },
        to: { type: [String, Object], default: null },
    },
    yn = defineComponent({
        props: Ie,
        emits: ["click"],
        setup(t, { emit: e, attrs: n }) {
            const i = s$1(toRef(t, "active")),
                o = s$1(toRef(t, "append")),
                a = s$1(toRef(t, "disabled")),
                l = s$1(toRef(t, "exact")),
                c = s$1(toRef(t, "replace")),
                g = getCurrentInstance(),
                v = ref(null),
                _ = computed(() => {
                    const D = t.routerComponentName
                        .split("-")
                        .map((I) => I.charAt(0).toUpperCase() + I.slice(1))
                        .join("")
                    return (g == null ? void 0 : g.appContext.app.component(D)) === void 0 || a.value || !t.to ? "a" : t.routerComponentName
                }),
                A = computed(() => {
                    const D = "#"
                    if (t.href) return t.href
                    if (typeof t.to == "string") return t.to || D
                    const I = t.to
                    if (Object.prototype.toString.call(I) === "[object Object]" && (I.path || I.query || I.hash)) {
                        const L = I.path || "",
                            G = I.query
                                ? `?${Object.keys(I.query)
                                      .map((F) => `${F}=${I.query[F]}`)
                                      .join("=")}`
                                : "",
                            U = !I.hash || I.hash.charAt(0) === "#" ? I.hash || "" : `#${I.hash}`
                        return `${L}${G}${U}` || D
                    }
                    return D
                }),
                B = computed(() => ({
                    to: t.to,
                    href: A.value,
                    target: t.target,
                    rel: t.target === "_blank" && t.rel === null ? "noopener" : t.rel || null,
                    tabindex: a.value ? "-1" : typeof n.tabindex > "u" ? null : n.tabindex,
                    "aria-disabled": a.value ? "true" : null,
                }))
            return {
                tag: _,
                routerAttr: B,
                link: v,
                clicked: (D) => {
                    if (a.value) {
                        D.preventDefault(), D.stopImmediatePropagation()
                        return
                    }
                    e("click", D)
                },
                activeBoolean: i,
                appendBoolean: o,
                disabledBoolean: a,
                replaceBoolean: c,
                exactBoolean: l,
            }
        },
    }),
    be = (t, e) => {
        const n = t.__vccOpts || t
        for (const [i, o] of e) n[i] = o
        return n
    }
function Bn(t, e, n, i, o, a) {
    return t.tag === "router-link"
        ? (openBlock(),
          createBlock$1(
              resolveDynamicComponent(t.tag),
              mergeProps({ key: 0 }, t.routerAttr, { custom: "" }),
              {
                  default: withCtx(({ href: l, navigate: c, isActive: g, isExactActive: v }) => [
                      (openBlock(),
                      createBlock$1(
                          resolveDynamicComponent(t.routerTag),
                          mergeProps({ ref: "link", href: l, class: [g && t.activeClass, v && t.exactActiveClass] }, t.$attrs, { onClick: c }),
                          { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 2 },
                          1040,
                          ["href", "class", "onClick"]
                      )),
                  ]),
                  _: 3,
              },
              16
          ))
        : (openBlock(),
          createBlock$1(
              resolveDynamicComponent(t.tag),
              mergeProps({ key: 1, ref: "link", class: { active: t.activeBoolean, disabled: t.disabledBoolean } }, t.routerAttr, {
                  onClick: t.clicked,
              }),
              { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
              16,
              ["class", "onClick"]
          ))
}
const pe = be(yn, [["render", Bn]]),
    Ot = at(Ie, ["event", "routerTag"]),
    $n = defineComponent({
        components: { BLink: pe },
        props: {
            pill: { type: [Boolean, String], default: !1 },
            tag: { type: String, default: "span" },
            variant: { type: String, default: "secondary" },
            textIndicator: { type: [Boolean, String], default: !1 },
            dotIndicator: { type: [Boolean, String], default: !1 },
            ...Ot,
        },
        setup(t) {
            const e = computed(() => De(t)),
                n = computed(() => (e.value ? pe : t.tag)),
                i = s$1(toRef(t, "pill")),
                o = s$1(toRef(t, "textIndicator")),
                a = s$1(toRef(t, "dotIndicator"))
            return {
                classes: computed(() => ({
                    [`bg-${t.variant}`]: t.variant,
                    active: t.active,
                    disabled: t.disabled,
                    "text-dark": ["warning", "info", "light"].includes(t.variant),
                    "rounded-pill": i.value,
                    "position-absolute top-0 start-100 translate-middle": o.value || a.value,
                    "p-2 border border-light rounded-circle": a.value,
                    "text-decoration-none": e.value,
                })),
                props: e.value ? la(Ot, t) : {},
                computedTag: n,
            }
        },
    })
function kn(t, e, n, i, o, a) {
    return (
        openBlock(),
        createBlock$1(
            resolveDynamicComponent(t.computedTag),
            mergeProps({ class: ["badge", t.classes] }, t.props),
            { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
            16,
            ["class"]
        )
    )
}
const Sn = be($n, [["render", kn]]),
    Cn = defineComponent({
        components: { BLink: pe },
        props: {
            ...at(Ie, ["event", "routerTag"]),
            active: { type: [Boolean, String], default: !1 },
            ariaCurrent: { type: String, default: "location" },
            disabled: { type: [Boolean, String], default: !1 },
            text: { type: String, required: !1 },
        },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = s$1(toRef(t, "active")),
                i = s$1(toRef(t, "disabled")),
                o = computed(() => ({ active: n.value })),
                a = computed(() => (n.value ? "span" : pe)),
                l = computed(() => (n.value ? t.ariaCurrent : void 0))
            return {
                liClasses: o,
                computedTag: a,
                computedAriaCurrent: l,
                clicked: (c) => {
                    if (i.value || n.value) {
                        c.preventDefault(), c.stopImmediatePropagation()
                        return
                    }
                    i.value || e("click", c)
                },
            }
        },
    })
function Tn(t, e, n, i, o, a) {
    return (
        openBlock(),
        createElementBlock(
            "li",
            { class: normalizeClass(["breadcrumb-item", t.liClasses]) },
            [
                (openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.computedTag),
                    mergeProps({ "aria-current": t.computedAriaCurrent }, t.$props, { onClick: t.clicked }),
                    { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
                    16,
                    ["aria-current", "onClick"]
                )),
            ],
            2
        )
    )
}
const Ba = be(Cn, [["render", Tn]]),
    wn = { "aria-label": "breadcrumb" },
    _n = { class: "breadcrumb" },
    Vn = defineComponent({
        __name: "BBreadcrumb",
        props: { items: null },
        setup(t) {
            const e = t,
                n = tn(),
                i = computed(() => {
                    const o = e.items || (n == null ? void 0 : n.items) || []
                    let a = !1
                    return o.map(
                        (l, c) => (
                            typeof l == "string" && ((l = { text: l }), c < o.length - 1 && (l.href = "#")),
                            l.active && (a = !0),
                            !l.active && !a && (l.active = c + 1 === o.length),
                            l
                        )
                    )
                })
            return (o, a) => (
                openBlock(),
                createElementBlock("nav", wn, [
                    createBaseVNode("ol", _n, [
                        renderSlot(o.$slots, "prepend"),
                        (openBlock(!0),
                        createElementBlock(
                            Fragment$1,
                            null,
                            renderList(
                                unref(i),
                                (l, c) => (
                                    openBlock(),
                                    createBlock$1(
                                        Ba,
                                        mergeProps({ key: c }, l),
                                        { default: withCtx(() => [createTextVNode(toDisplayString(l.text), 1)]), _: 2 },
                                        1040
                                    )
                                )
                            ),
                            128
                        )),
                        renderSlot(o.$slots, "default"),
                        renderSlot(o.$slots, "append"),
                    ]),
                ])
            )
        },
    }),
    xn = { key: 0, class: "visually-hidden" },
    $a = defineComponent({
        __name: "BSpinner",
        props: {
            label: null,
            role: { default: "status" },
            small: { default: !1 },
            tag: { default: "span" },
            type: { default: "border" },
            variant: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "small")),
                i = computed(() => ({
                    "spinner-border": e.type === "border",
                    "spinner-border-sm": e.type === "border" && n.value,
                    "spinner-grow": e.type === "grow",
                    "spinner-grow-sm": e.type === "grow" && n.value,
                    [`text-${e.variant}`]: e.variant !== void 0,
                }))
            return (o, a) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    {
                        class: normalizeClass(unref(i)),
                        role: t.label || o.$slots.label ? t.role : null,
                        "aria-hidden": t.label || o.$slots.label ? null : !0,
                    },
                    {
                        default: withCtx(() => [
                            t.label || o.$slots.label
                                ? (openBlock(),
                                  createElementBlock("span", xn, [
                                      renderSlot(o.$slots, "label", {}, () => [createTextVNode(toDisplayString(t.label), 1)]),
                                  ]))
                                : createCommentVNode("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class", "role", "aria-hidden"]
                )
            )
        },
    }),
    An = defineComponent({
        components: { BLink: pe, BSpinner: $a },
        props: {
            ...Ie,
            active: { type: [Boolean, String], default: !1 },
            disabled: { type: [Boolean, String], default: !1 },
            href: { type: String, required: !1 },
            pill: { type: [Boolean, String], default: !1 },
            pressed: { type: [Boolean, String], default: !1 },
            rel: { type: String, default: void 0 },
            size: { type: String, default: "md" },
            squared: { type: [Boolean, String], default: !1 },
            tag: { type: String, default: "button" },
            target: { type: String, default: "_self" },
            type: { type: String, default: "button" },
            variant: { type: String, default: "secondary" },
            loading: { type: [Boolean, String], default: !1 },
            loadingMode: { type: String, default: "inline" },
        },
        emits: ["click", "update:pressed"],
        setup(t, { emit: e }) {
            const n = s$1(toRef(t, "active")),
                i = s$1(toRef(t, "disabled")),
                o = s$1(toRef(t, "pill")),
                a = s$1(toRef(t, "pressed")),
                l = s$1(toRef(t, "squared")),
                c = s$1(toRef(t, "loading")),
                g = computed(() => a.value === !0),
                v = computed(() => t.tag === "button" && t.href === void 0 && t.to === null),
                _ = computed(() => De(t)),
                A = computed(() => t.to !== null),
                B = computed(() => (t.href !== void 0 ? !1 : !v.value)),
                D = computed(() => ({
                    [`btn-${t.variant}`]: !!t.variant,
                    [`btn-${t.size}`]: !!t.size,
                    active: n.value || a.value,
                    "rounded-pill": o.value,
                    "rounded-0": l.value,
                    disabled: i.value,
                })),
                I = computed(() => ({
                    "aria-disabled": B.value ? i.value : null,
                    "aria-pressed": g.value ? a.value : null,
                    autocomplete: g.value ? "off" : null,
                    disabled: v.value ? i.value : null,
                    href: t.href,
                    rel: _.value ? t.rel : null,
                    role: B.value || _.value ? "button" : null,
                    target: _.value ? t.target : null,
                    type: v.value ? t.type : null,
                    to: v.value ? null : t.to,
                    append: _.value ? t.append : null,
                    activeClass: A.value ? t.activeClass : null,
                    event: A.value ? t.event : null,
                    exact: A.value ? t.exact : null,
                    exactActiveClass: A.value ? t.exactActiveClass : null,
                    replace: A.value ? t.replace : null,
                    routerComponentName: A.value ? t.routerComponentName : null,
                    routerTag: A.value ? t.routerTag : null,
                })),
                L = computed(() => (A.value ? pe : t.href ? "a" : t.tag))
            return {
                classes: D,
                attrs: I,
                computedTag: L,
                clicked: (G) => {
                    if (i.value) {
                        G.preventDefault(), G.stopPropagation()
                        return
                    }
                    e("click", G), g.value && e("update:pressed", !a.value)
                },
                loadingBoolean: c,
            }
        },
    })
function In(t, e, n, i, o, a) {
    const l = resolveComponent("b-spinner")
    return (
        openBlock(),
        createBlock$1(
            resolveDynamicComponent(t.computedTag),
            mergeProps({ class: ["btn", t.classes] }, t.attrs, { onClick: t.clicked }),
            {
                default: withCtx(() => [
                    t.loadingBoolean
                        ? (openBlock(),
                          createElementBlock(
                              "div",
                              {
                                  key: 0,
                                  class: normalizeClass([
                                      "btn-loading",
                                      { "mode-fill": t.loadingMode === "fill", "mode-inline": t.loadingMode === "inline" },
                                  ]),
                              },
                              [
                                  renderSlot(t.$slots, "loading", {}, () => [
                                      createVNode(l, { class: "btn-spinner", small: t.size !== "lg" }, null, 8, ["small"]),
                                  ]),
                              ],
                              2
                          ))
                        : createCommentVNode("", !0),
                    createBaseVNode(
                        "div",
                        { class: normalizeClass(["btn-content", { "btn-loading-fill": t.loadingBoolean && t.loadingMode === "fill" }]) },
                        [renderSlot(t.$slots, "default")],
                        2
                    ),
                ]),
                _: 3,
            },
            16,
            ["class", "onClick"]
        )
    )
}
const je = be(An, [["render", In]]),
    Fn = defineComponent({
        __name: "BButtonGroup",
        props: { ariaLabel: { default: "Group" }, size: null, tag: { default: "div" }, vertical: { default: !1 } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "vertical")),
                i = computed(() => ({ "btn-group": !n.value, "btn-group-vertical": n.value, [`btn-group-${e.size}`]: e.size !== void 0 }))
            return (o, a) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(unref(i)), role: "group", "aria-label": t.ariaLabel },
                    { default: withCtx(() => [renderSlot(o.$slots, "default")]), _: 3 },
                    8,
                    ["class", "aria-label"]
                )
            )
        },
    }),
    On = ["aria-label"],
    zn = defineComponent({
        __name: "BButtonToolbar",
        props: { ariaLabel: { default: "Group" }, justify: { default: !1 } },
        setup(t) {
            const e = s$1(toRef(t, "justify")),
                n = computed(() => ({ "justify-content-between": e.value }))
            return (i, o) => (
                openBlock(),
                createElementBlock(
                    "div",
                    { class: normalizeClass([unref(n), "btn-toolbar"]), role: "toolbar", "aria-label": t.ariaLabel },
                    [renderSlot(i.$slots, "default")],
                    10,
                    On
                )
            )
        },
    }),
    Nn = ["disabled", "aria-label"],
    ka = defineComponent({
        __name: "BCloseButton",
        props: { disabled: { default: !1 }, white: { default: !1 }, ariaLabel: { default: "Close" } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "disabled")),
                i = s$1(toRef(e, "white")),
                o = computed(() => ({ "btn-close-white": i.value }))
            return (a, l) => (
                openBlock(),
                createElementBlock(
                    "button",
                    { type: "button", class: normalizeClass(["btn-close", unref(o)]), disabled: unref(n), "aria-label": t.ariaLabel },
                    null,
                    10,
                    Nn
                )
            )
        },
    }),
    bt = defineComponent({
        __name: "BCardImg",
        props: {
            alt: { default: void 0 },
            bottom: { default: !1 },
            end: { default: !1 },
            height: null,
            left: { default: !1 },
            right: { default: !1 },
            src: null,
            lazy: { default: !1 },
            start: { default: !1 },
            top: { default: !1 },
            width: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "bottom")),
                i = s$1(toRef(e, "end")),
                o = s$1(toRef(e, "left")),
                a = s$1(toRef(e, "right")),
                l = s$1(toRef(e, "start")),
                c = s$1(toRef(e, "top")),
                g = s$1(toRef(e, "lazy")),
                v = computed(() => ({
                    loading: g.value ? "lazy" : "eager",
                    src: e.src,
                    alt: e.alt,
                    width: (typeof e.width == "number" ? e.width : parseInt(e.width, 10)) || void 0,
                    height: (typeof e.height == "number" ? e.height : parseInt(e.height, 10)) || void 0,
                })),
                _ = computed(() => (o.value ? "float-left" : a.value ? "float-right" : "")),
                A = computed(() =>
                    c.value
                        ? "card-img-top"
                        : a.value || i.value
                        ? "card-img-right"
                        : n.value
                        ? "card-img-bottom"
                        : o.value || l.value
                        ? "card-img-left"
                        : "card-img"
                ),
                B = computed(() => ({ [_.value]: !!_.value, [A.value]: !!A.value }))
            return (D, I) => (openBlock(), createElementBlock("img", mergeProps({ class: unref(B) }, unref(v)), null, 16))
        },
    }),
    Ln = ["innerHTML"],
    Sa = defineComponent({
        __name: "BCardHeadFoot",
        props: { text: null, bgVariant: null, borderVariant: null, html: null, tag: { default: "div" }, textVariant: null },
        setup(t) {
            const e = t,
                n = computed(() => ({
                    [`text-${e.textVariant}`]: e.textVariant !== void 0,
                    [`bg-${e.bgVariant}`]: e.bgVariant !== void 0,
                    [`border-${e.borderVariant}`]: e.borderVariant !== void 0,
                }))
            return (i, o) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(unref(n)) },
                    {
                        default: withCtx(() => [
                            t.html
                                ? (openBlock(), createElementBlock("div", { key: 0, innerHTML: t.html }, null, 8, Ln))
                                : renderSlot(i.$slots, "default", { key: 1 }, () => [createTextVNode(toDisplayString(t.text), 1)]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    Ca = defineComponent({
        __name: "BCardHeader",
        props: { text: null, bgVariant: null, borderVariant: null, html: null, tag: { default: "div" }, textVariant: null },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    Sa,
                    mergeProps({ class: "card-header" }, e.$props),
                    { default: withCtx(() => [renderSlot(e.$slots, "default")]), _: 3 },
                    16
                )
            )
        },
    }),
    Ta = defineComponent({
        __name: "BCardTitle",
        props: { text: null, tag: { default: "h4" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: "card-title" },
                    { default: withCtx(() => [renderSlot(e.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)])]), _: 3 }
                )
            )
        },
    }),
    wa = defineComponent({
        __name: "BCardSubTitle",
        props: { text: null, tag: { default: "h6" }, textVariant: { default: "muted" } },
        setup(t) {
            const e = t,
                n = computed(() => ({ [`text-${e.textVariant}`]: !!e.textVariant }))
            return (i, o) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(["card-subtitle mb-2", unref(n)]) },
                    { default: withCtx(() => [renderSlot(i.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)])]), _: 3 },
                    8,
                    ["class"]
                )
            )
        },
    }),
    _a = defineComponent({
        __name: "BCardBody",
        props: {
            bodyBgVariant: null,
            bodyTag: { default: "div" },
            bodyTextVariant: null,
            overlay: { default: !1 },
            subTitle: null,
            subTitleTag: { default: "h4" },
            subTitleTextVariant: null,
            title: null,
            titleTag: { default: "h4" },
            text: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "overlay")),
                i = computed(() => ({
                    "card-img-overlay": n.value,
                    [`text-${e.bodyTextVariant}`]: e.bodyTextVariant !== void 0,
                    [`bg-${e.bodyBgVariant}`]: e.bodyBgVariant !== void 0,
                }))
            return (o, a) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.bodyTag),
                    { class: normalizeClass(["card-body", unref(i)]) },
                    {
                        default: withCtx(() => [
                            !!t.title || o.$slots.title
                                ? (openBlock(),
                                  createBlock$1(
                                      Ta,
                                      { key: 0, tag: t.titleTag },
                                      {
                                          default: withCtx(() => [
                                              renderSlot(o.$slots, "title", {}, () => [createTextVNode(toDisplayString(t.title), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      8,
                                      ["tag"]
                                  ))
                                : createCommentVNode("", !0),
                            !!t.subTitle || !!o.$slots.subTitle
                                ? (openBlock(),
                                  createBlock$1(
                                      wa,
                                      { key: 1, tag: t.subTitleTag, "text-variant": t.subTitleTextVariant },
                                      {
                                          default: withCtx(() => [
                                              renderSlot(o.$slots, "subTitle", {}, () => [createTextVNode(toDisplayString(t.subTitle), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      8,
                                      ["tag", "text-variant"]
                                  ))
                                : createCommentVNode("", !0),
                            renderSlot(o.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    Va = defineComponent({
        __name: "BCardFooter",
        props: { text: null, bgVariant: null, borderVariant: null, html: null, tag: { default: "div" }, textVariant: null },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    Sa,
                    mergeProps({ class: "card-footer" }, e.$props),
                    { default: withCtx(() => [renderSlot(e.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)])]), _: 3 },
                    16
                )
            )
        },
    }),
    Pn = defineComponent({
        __name: "BCard",
        props: {
            align: null,
            bgVariant: null,
            bodyBgVariant: null,
            bodyClass: null,
            bodyTag: { default: "div" },
            bodyTextVariant: null,
            borderVariant: null,
            footer: null,
            footerBgVariant: null,
            footerBorderVariant: null,
            footerClass: null,
            footerHtml: { default: "" },
            footerTag: { default: "div" },
            footerTextVariant: null,
            header: null,
            headerBgVariant: null,
            headerBorderVariant: null,
            headerClass: null,
            headerHtml: { default: "" },
            headerTag: { default: "div" },
            headerTextVariant: null,
            imgAlt: null,
            imgBottom: { default: !1 },
            imgEnd: { default: !1 },
            imgHeight: null,
            imgLeft: { default: !1 },
            imgRight: { default: !1 },
            imgSrc: null,
            imgStart: { default: !1 },
            imgTop: { default: !1 },
            imgWidth: null,
            noBody: { default: !1 },
            overlay: { default: !1 },
            subTitle: null,
            subTitleTag: { default: "h6" },
            subTitleTextVariant: { default: "muted" },
            tag: { default: "div" },
            textVariant: null,
            title: null,
            titleTag: { default: "h4" },
            bodyText: { default: "" },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "imgBottom")),
                i = s$1(toRef(e, "imgEnd")),
                o = s$1(toRef(e, "imgLeft")),
                a = s$1(toRef(e, "imgRight")),
                l = s$1(toRef(e, "imgStart")),
                c = s$1(toRef(e, "noBody")),
                g = computed(() => ({
                    [`text-${e.align}`]: e.align !== void 0,
                    [`text-${e.textVariant}`]: e.textVariant !== void 0,
                    [`bg-${e.bgVariant}`]: e.bgVariant !== void 0,
                    [`border-${e.borderVariant}`]: e.borderVariant !== void 0,
                    "flex-row": o.value || l.value,
                    "flex-row-reverse": i.value || a.value,
                })),
                v = computed(() => ({
                    bgVariant: e.headerBgVariant,
                    borderVariant: e.headerBorderVariant,
                    html: e.headerHtml,
                    tag: e.headerTag,
                    textVariant: e.headerTextVariant,
                })),
                _ = computed(() => ({
                    overlay: e.overlay,
                    bodyBgVariant: e.bodyBgVariant,
                    bodyTag: e.bodyTag,
                    bodyTextVariant: e.bodyTextVariant,
                    subTitle: e.subTitle,
                    subTitleTag: e.subTitleTag,
                    subTitleTextVariant: e.subTitleTextVariant,
                    title: e.title,
                    titleTag: e.titleTag,
                })),
                A = computed(() => ({
                    bgVariant: e.footerBgVariant,
                    borderVariant: e.footerBorderVariant,
                    html: e.footerHtml,
                    tag: e.footerTag,
                    textVariant: e.footerTextVariant,
                })),
                B = computed(() => ({
                    src: e.imgSrc,
                    alt: e.imgAlt,
                    height: e.imgHeight,
                    width: e.imgWidth,
                    bottom: e.imgBottom,
                    end: e.imgEnd,
                    left: e.imgLeft,
                    right: e.imgRight,
                    start: e.imgStart,
                    top: e.imgTop,
                }))
            return (D, I) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(["card", unref(g)]) },
                    {
                        default: withCtx(() => [
                            t.imgSrc && !unref(n)
                                ? (openBlock(), createBlock$1(bt, normalizeProps(mergeProps({ key: 0 }, unref(B))), null, 16))
                                : createCommentVNode("", !0),
                            t.header || D.$slots.header || t.headerHtml
                                ? (openBlock(),
                                  createBlock$1(
                                      Ca,
                                      mergeProps({ key: 1 }, unref(v), { class: t.headerClass }),
                                      {
                                          default: withCtx(() => [
                                              renderSlot(D.$slots, "header", {}, () => [createTextVNode(toDisplayString(t.header), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      16,
                                      ["class"]
                                  ))
                                : createCommentVNode("", !0),
                            unref(c)
                                ? renderSlot(D.$slots, "default", { key: 3 }, () => [createTextVNode(toDisplayString(t.bodyText), 1)])
                                : (openBlock(),
                                  createBlock$1(
                                      _a,
                                      mergeProps({ key: 2 }, unref(_), { class: t.bodyClass }),
                                      {
                                          default: withCtx(() => [
                                              renderSlot(D.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.bodyText), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      16,
                                      ["class"]
                                  )),
                            t.footer || D.$slots.footer || t.footerHtml
                                ? (openBlock(),
                                  createBlock$1(
                                      Va,
                                      mergeProps({ key: 4 }, unref(A), { class: t.footerClass }),
                                      {
                                          default: withCtx(() => [
                                              renderSlot(D.$slots, "footer", {}, () => [createTextVNode(toDisplayString(t.footer), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      16,
                                      ["class"]
                                  ))
                                : createCommentVNode("", !0),
                            t.imgSrc && unref(n)
                                ? (openBlock(), createBlock$1(bt, normalizeProps(mergeProps({ key: 5 }, unref(B))), null, 16))
                                : createCommentVNode("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    En = defineComponent({
        __name: "BCardGroup",
        props: { columns: { default: !1 }, deck: { default: !1 }, tag: { default: "div" } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "columns")),
                i = s$1(toRef(e, "deck")),
                o = computed(() => (i.value ? "card-deck" : n.value ? "card-columns" : "card-group")),
                a = computed(() => ({ [o.value]: !!o.value }))
            return (l, c) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(unref(a)) },
                    { default: withCtx(() => [renderSlot(l.$slots, "default")]), _: 3 },
                    8,
                    ["class"]
                )
            )
        },
    }),
    Hn = defineComponent({
        __name: "BCardText",
        props: { text: null, tag: { default: "p" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: "card-text" },
                    { default: withCtx(() => [renderSlot(e.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)])]), _: 3 }
                )
            )
        },
    }),
    Rn = ["id"],
    qn = { key: 0, class: "carousel-indicators" },
    Dn = ["data-bs-target", "data-bs-slide-to", "aria-label"],
    jn = { class: "carousel-inner" },
    Mn = ["data-bs-target"],
    Gn = createBaseVNode("span", { class: "carousel-control-prev-icon", "aria-hidden": "true" }, null, -1),
    Un = { class: "visually-hidden" },
    Wn = ["data-bs-target"],
    Xn = createBaseVNode("span", { class: "carousel-control-next-icon", "aria-hidden": "true" }, null, -1),
    Kn = { class: "visually-hidden" },
    xa = Symbol(),
    Jn = defineComponent({
        __name: "BCarousel",
        props: {
            id: null,
            imgHeight: null,
            imgWidth: null,
            background: null,
            modelValue: { default: 0 },
            controls: { default: !1 },
            indicators: { default: !1 },
            interval: { default: 5e3 },
            noTouch: { default: !1 },
            noWrap: { default: !1 },
            controlsPrevText: { default: "Previous" },
            controlsNextText: { default: "Next" },
            indicatorsButtonLabel: { default: "Slide" },
        },
        emits: ["sliding-start", "sliding-end"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "controls")),
                o = s$1(toRef(n, "indicators")),
                a = s$1(toRef(n, "noTouch"))
            s$1(toRef(n, "noWrap"))
            const l = useSlots(),
                c = ref(),
                g = ref(),
                v = ve(toRef(n, "id"), "accordion"),
                _ = ref([])
            return (
                re(c, "slide.bs.carousel", (A) => e("sliding-start", A)),
                re(c, "slid.bs.carousel", (A) => e("sliding-end", A)),
                onMounted(() => {
                    ;(g.value = new Carousel(c.value, { wrap: !a.value, interval: n.interval, touch: !a.value })),
                        l.default &&
                            (_.value = l.default().filter((A) => {
                                var B
                                return ((B = A.type) == null ? void 0 : B.name) === "BCarouselSlide"
                            }))
                }),
                provide(xa, { background: n.background, width: n.imgWidth, height: n.imgHeight }),
                (A, B) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { id: unref(v), ref_key: "element", ref: c, class: "carousel slide", "data-bs-ride": "carousel" },
                        [
                            unref(o)
                                ? (openBlock(),
                                  createElementBlock("div", qn, [
                                      (openBlock(!0),
                                      createElementBlock(
                                          Fragment$1,
                                          null,
                                          renderList(
                                              _.value,
                                              (D, I) => (
                                                  openBlock(),
                                                  createElementBlock(
                                                      "button",
                                                      {
                                                          key: I,
                                                          type: "button",
                                                          "data-bs-target": `#${unref(v)}`,
                                                          "data-bs-slide-to": I,
                                                          class: normalizeClass(I === 0 ? "active" : ""),
                                                          "aria-current": "true",
                                                          "aria-label": `${t.indicatorsButtonLabel} ${I}`,
                                                      },
                                                      null,
                                                      10,
                                                      Dn
                                                  )
                                              )
                                          ),
                                          128
                                      )),
                                  ]))
                                : createCommentVNode("", !0),
                            createBaseVNode("div", jn, [renderSlot(A.$slots, "default")]),
                            unref(i)
                                ? (openBlock(),
                                  createElementBlock(
                                      Fragment$1,
                                      { key: 1 },
                                      [
                                          createBaseVNode(
                                              "button",
                                              {
                                                  class: "carousel-control-prev",
                                                  type: "button",
                                                  "data-bs-target": `#${unref(v)}`,
                                                  "data-bs-slide": "prev",
                                              },
                                              [Gn, createBaseVNode("span", Un, toDisplayString(t.controlsPrevText), 1)],
                                              8,
                                              Mn
                                          ),
                                          createBaseVNode(
                                              "button",
                                              {
                                                  class: "carousel-control-next",
                                                  type: "button",
                                                  "data-bs-target": `#${unref(v)}`,
                                                  "data-bs-slide": "next",
                                              },
                                              [Xn, createBaseVNode("span", Kn, toDisplayString(t.controlsNextText), 1)],
                                              8,
                                              Wn
                                          ),
                                      ],
                                      64
                                  ))
                                : createCommentVNode("", !0),
                        ],
                        8,
                        Rn
                    )
                )
            )
        },
    }),
    Aa = defineComponent({
        __name: "BImg",
        props: {
            alt: { default: void 0 },
            blank: { default: !1 },
            blankColor: { default: "transparent" },
            block: { default: !1 },
            center: { default: !1 },
            fluid: { default: !1 },
            lazy: { default: !1 },
            fluidGrow: { default: !1 },
            height: null,
            left: { default: !1 },
            right: { default: !1 },
            rounded: { type: [Boolean, String], default: !1 },
            sizes: null,
            src: null,
            srcset: null,
            thumbnail: { default: !1 },
            width: null,
        },
        emits: ["load"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "lazy")),
                o = s$1(toRef(n, "blank")),
                a = s$1(toRef(n, "block")),
                l = s$1(toRef(n, "center")),
                c = s$1(toRef(n, "fluid")),
                g = s$1(toRef(n, "fluidGrow")),
                v = s$1(toRef(n, "left")),
                _ = s$1(toRef(n, "right")),
                A = s$1(toRef(n, "thumbnail")),
                B =
                    '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>',
                D = (U, F, Z) =>
                    `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
                        B.replace("%{w}", String(U)).replace("%{h}", String(F)).replace("%{f}", Z)
                    )}`,
                I = computed(() => {
                    let { src: U } = n,
                        F = (typeof n.width == "number" ? n.width : parseInt(n.width, 10)) || void 0,
                        Z = (typeof n.height == "number" ? n.height : parseInt(n.height, 10)) || void 0,
                        Y = ""
                    typeof n.srcset == "string"
                        ? (Y = n.srcset
                              .split(",")
                              .filter((ie) => ie)
                              .join(","))
                        : Array.isArray(n.srcset) && (Y = n.srcset.filter((ie) => ie).join(","))
                    let X = ""
                    return (
                        typeof n.sizes == "string"
                            ? (X = n.sizes
                                  .split(",")
                                  .filter((ie) => ie)
                                  .join(","))
                            : Array.isArray(n.sizes) && (X = n.sizes.filter((ie) => ie).join(",")),
                        o.value &&
                            (!Z && F ? (Z = F) : !F && Z && (F = Z),
                            !F && !Z && ((F = 1), (Z = 1)),
                            (U = D(F, Z, n.blankColor || "transparent")),
                            (Y = ""),
                            (X = "")),
                        {
                            src: U,
                            alt: n.alt,
                            width: F || void 0,
                            height: Z || void 0,
                            srcset: Y || void 0,
                            sizes: X || void 0,
                            loading: i.value ? "lazy" : "eager",
                        }
                    )
                }),
                L = computed(() => (v.value ? "float-start" : _.value ? "float-end" : l.value ? "mx-auto" : void 0)),
                G = computed(() => ({
                    "img-thumbnail": A.value,
                    "img-fluid": c.value || g.value,
                    "w-100": g.value,
                    rounded: n.rounded === "" || n.rounded === !0,
                    [`rounded-${n.rounded}`]: typeof n.rounded == "string" && n.rounded !== "",
                    [`${L.value}`]: L.value !== void 0,
                    "d-block": a.value || l.value,
                }))
            return (U, F) => (
                openBlock(),
                createElementBlock("img", mergeProps({ class: unref(G) }, unref(I), { onLoad: F[0] || (F[0] = (Z) => e("load", Z)) }), null, 16)
            )
        },
    }),
    Yn = ["id", "data-bs-interval"],
    Zn = ["innerHTML"],
    Qn = { key: 1 },
    eo = ["innerHTML"],
    to = { key: 1 },
    ao = defineComponent({
        __name: "BCarouselSlide",
        props: {
            imgSrc: null,
            imgHeight: null,
            imgWidth: null,
            interval: null,
            active: { default: !1 },
            background: null,
            caption: null,
            captionHtml: null,
            captionTag: { default: "h3" },
            contentTag: { default: "div" },
            contentVisibleUp: null,
            id: null,
            imgAlt: null,
            imgBlank: { default: !1 },
            imgBlankColor: { default: "transparent" },
            text: null,
            textHtml: null,
            textTag: { default: "p" },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "active")),
                i = s$1(toRef(e, "imgBlank")),
                o = inject(xa, {}),
                a = ve(toRef(e, "id"), "accordion")
            computed(() => (i.value ? i.value : e.imgSrc))
            const l = computed(() => ({ background: `${e.background || o.background || "rgb(171, 171, 171)"} none repeat scroll 0% 0%` })),
                c = computed(() => ({
                    "d-none": e.contentVisibleUp !== void 0,
                    [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0,
                })),
                g = computed(() => o.width),
                v = computed(() => o.height)
            return (_, A) => (
                openBlock(),
                createElementBlock(
                    "div",
                    {
                        id: unref(a),
                        class: normalizeClass(["carousel-item", { active: unref(n) }]),
                        "data-bs-interval": t.interval,
                        style: normalizeStyle(unref(l)),
                    },
                    [
                        renderSlot(_.$slots, "img", {}, () => [
                            createVNode(
                                Aa,
                                {
                                    class: "d-block w-100",
                                    alt: t.imgAlt,
                                    src: t.imgSrc,
                                    width: t.imgWidth || unref(g),
                                    height: t.imgHeight || unref(v),
                                    blank: unref(i),
                                    "blank-color": t.imgBlankColor,
                                },
                                null,
                                8,
                                ["alt", "src", "width", "height", "blank", "blank-color"]
                            ),
                        ]),
                        t.caption || t.captionHtml || t.text || t.textHtml || _.$slots.default
                            ? (openBlock(),
                              createBlock$1(
                                  resolveDynamicComponent(t.contentTag),
                                  { key: 0, class: normalizeClass(["carousel-caption", unref(c)]) },
                                  {
                                      default: withCtx(() => [
                                          t.caption || t.captionHtml
                                              ? (openBlock(),
                                                createBlock$1(
                                                    resolveDynamicComponent(t.captionTag),
                                                    { key: 0 },
                                                    {
                                                        default: withCtx(() => [
                                                            t.captionHtml
                                                                ? (openBlock(),
                                                                  createElementBlock("span", { key: 0, innerHTML: t.captionHtml }, null, 8, Zn))
                                                                : (openBlock(), createElementBlock("span", Qn, toDisplayString(t.caption), 1)),
                                                        ]),
                                                        _: 1,
                                                    }
                                                ))
                                              : createCommentVNode("", !0),
                                          t.text || t.textHtml
                                              ? (openBlock(),
                                                createBlock$1(
                                                    resolveDynamicComponent(t.textTag),
                                                    { key: 1 },
                                                    {
                                                        default: withCtx(() => [
                                                            t.textHtml
                                                                ? (openBlock(),
                                                                  createElementBlock("span", { key: 0, innerHTML: t.textHtml }, null, 8, eo))
                                                                : (openBlock(), createElementBlock("span", to, toDisplayString(t.text), 1)),
                                                        ]),
                                                        _: 1,
                                                    }
                                                ))
                                              : createCommentVNode("", !0),
                                          renderSlot(_.$slots, "default"),
                                      ]),
                                      _: 3,
                                  },
                                  8,
                                  ["class"]
                              ))
                            : createCommentVNode("", !0),
                    ],
                    14,
                    Yn
                )
            )
        },
    }),
    zt = et("", [], { type: [Boolean, String, Number], default: !1 }),
    Nt = et("offset", [""], { type: [String, Number], default: null }),
    Lt = et("order", [""], { type: [String, Number], default: null }),
    lo = defineComponent({
        name: "BCol",
        props: {
            col: { type: [Boolean, String], default: !1 },
            cols: { type: [String, Number], default: null },
            ...zt,
            offset: { type: [String, Number], default: null },
            ...Nt,
            order: { type: [String, Number], default: null },
            ...Lt,
            alignSelf: { type: String, default: null },
            tag: { type: String, default: "div" },
        },
        setup(t) {
            const e = s$1(toRef(t, "col")),
                n = [
                    { content: zt, propPrefix: "cols", classPrefix: "col" },
                    { content: Nt, propPrefix: "offset" },
                    { content: Lt, propPrefix: "order" },
                ],
                i = computed(() => n.flatMap((o) => Jt(t, o.content, o.propPrefix, o.classPrefix)))
            return {
                classes: computed(() => ({
                    col: e.value || !i.value.some((o) => /^col-/.test(o) && !t.cols),
                    [`col-${t.cols}`]: !!t.cols,
                    [`offset-${t.offset}`]: !!t.offset,
                    [`order-${t.order}`]: !!t.order,
                    [`align-self-${t.alignSelf}`]: !!t.alignSelf,
                })),
                classList: i,
            }
        },
    })
function no(t, e, n, i, o, a) {
    return (
        openBlock(),
        createBlock$1(
            resolveDynamicComponent(t.tag),
            { class: normalizeClass([t.classes, t.classList]) },
            { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
            8,
            ["class"]
        )
    )
}
const qe = be(lo, [["render", no]]),
    Ia = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: "",
    },
    oo = { ...Ia, enterActiveClass: "fade showing", leaveActiveClass: "fade showing" },
    Ye = defineComponent({
        props: {
            appear: { type: [Boolean, String], default: !1 },
            mode: { type: String, required: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            transProps: { type: Object, required: !1 },
        },
        setup(t, { slots: e }) {
            const n = s$1(toRef(t, "appear")),
                i = s$1(toRef(t, "noFade")),
                o = ref(t.transProps)
            return (
                ta(o.value) ||
                    ((o.value = i.value ? Ia : oo),
                    n.value &&
                        (o.value = {
                            ...o.value,
                            appear: !0,
                            appearClass: o.value.enterClass,
                            appearActiveClass: o.value.enterActiveClass,
                            appearToClass: o.value.enterToClass,
                        })),
                (o.value = { mode: t.mode, ...o.value, css: !0 }),
                () => h$1(Transition, { ...o.value }, { default: () => (e.default ? e.default() : []) })
            )
        },
    }),
    so = "toast-title",
    Pt = 1e3,
    Fa = defineComponent({
        components: { BLink: pe },
        props: {
            ...Ie,
            delay: { type: Number, default: 5e3 },
            bodyClass: { type: String },
            body: { type: [Object, String] },
            headerClass: { type: String },
            headerTag: { type: String, default: "div" },
            animation: { type: [Boolean, String], default: !0 },
            id: { type: String },
            isStatus: { type: [Boolean, String], default: !1 },
            autoHide: { type: [Boolean, String], default: !0 },
            noCloseButton: { type: [Boolean, String], default: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            noHoverPause: { type: [Boolean, String], default: !1 },
            solid: { type: [Boolean, String], default: !1 },
            static: { type: [Boolean, String], default: !1 },
            title: { type: String },
            modelValue: { type: [Boolean, String], default: !1 },
            toastClass: { type: Array },
            variant: { type: String },
        },
        emits: ["destroyed", "update:modelValue"],
        setup(t, { emit: e, slots: n }) {
            s$1(toRef(t, "animation"))
            const i = s$1(toRef(t, "isStatus")),
                o = s$1(toRef(t, "autoHide")),
                a = s$1(toRef(t, "noCloseButton")),
                l = s$1(toRef(t, "noFade")),
                c = s$1(toRef(t, "noHoverPause"))
            s$1(toRef(t, "solid")), s$1(toRef(t, "static"))
            const g = s$1(toRef(t, "modelValue")),
                v = ref(!1),
                _ = ref(!1),
                A = ref(!1),
                B = computed(() => ({ [`b-toast-${t.variant}`]: t.variant !== void 0, show: A.value || v.value }))
            let D, I, L
            const G = () => {
                    typeof D > "u" || (clearTimeout(D), (D = void 0))
                },
                U = computed(() => Math.max(Ee(t.delay, 0), Pt)),
                F = () => {
                    g.value &&
                        ((I = L = 0),
                        G(),
                        (_.value = !0),
                        Ge(() => {
                            A.value = !1
                        }))
                },
                Z = () => {
                    G(),
                        e("update:modelValue", !0),
                        (I = L = 0),
                        (_.value = !1),
                        nextTick(() => {
                            Ge(() => {
                                A.value = !0
                            })
                        })
                },
                Y = () => {
                    if (!o.value || c.value || !D || L) return
                    const Ae = Date.now() - I
                    Ae > 0 && (G(), (L = Math.max(U.value - Ae, Pt)))
                },
                X = () => {
                    ;(!o.value || c.value || !L) && (L = I = 0), ie()
                }
            watch(
                () => g.value,
                (Ae) => {
                    Ae ? Z() : F()
                }
            )
            const ie = () => {
                    G(), o.value && ((D = setTimeout(F, L || U.value)), (I = Date.now()), (L = 0))
                },
                he = () => {
                    ;(v.value = !0), e("update:modelValue", !0)
                },
                oe = () => {
                    ;(v.value = !1), ie()
                },
                le = () => {
                    v.value = !0
                },
                Te = () => {
                    ;(v.value = !1), (L = I = 0), e("update:modelValue", !1)
                }
            onUnmounted(() => {
                G(), o.value && e("destroyed", t.id)
            }),
                onMounted(() => {
                    nextTick(() => {
                        g.value &&
                            Ge(() => {
                                Z()
                            })
                    })
                })
            const ye = () => {
                nextTick(() => {
                    Ge(() => {
                        F()
                    })
                })
            }
            return () => {
                const Ae = () => {
                    const O = [],
                        u = ge(so, { hide: F }, n)
                    u ? O.push(h$1(u)) : t.title && O.push(h$1("strong", { class: "me-auto" }, t.title)),
                        !a.value &&
                            O.length !== 0 &&
                            O.push(
                                h$1(ka, {
                                    class: ["btn-close"],
                                    onClick: () => {
                                        F()
                                    },
                                })
                            )
                    const E = []
                    if (
                        (O.length > 0 && E.push(h$1(t.headerTag, { class: "toast-header" }, { default: () => O })),
                        ge("default", { hide: F }, n) || t.body)
                    ) {
                        const $ = h$1(
                            De(t) ? "b-link" : "div",
                            { class: ["toast-body", t.bodyClass], onClick: De(t) ? { click: ye } : {} },
                            ge("default", { hide: F }, n) || t.body
                        )
                        E.push($)
                    }
                    return h$1("div", { class: ["toast", t.toastClass, B.value], tabindex: "0" }, E)
                }
                return h$1(
                    "div",
                    {
                        class: ["b-toast"],
                        id: t.id,
                        role: _.value ? null : i.value ? "status" : "alert",
                        "aria-live": _.value ? null : i.value ? "polite" : "assertive",
                        "aria-atomic": _.value ? null : "true",
                        onmouseenter: Y,
                        onmouseleave: X,
                    },
                    [
                        h$1(Ye, { noFade: l.value, onAfterEnter: oe, onBeforeEnter: he, onAfterLeave: Te, onBeforeLeave: le }, () => [
                            A.value ? Ae() : "",
                        ]),
                    ]
                )
            }
        },
    }),
    mt = defineComponent({
        __name: "BToaster",
        props: { position: { default: "top-right" }, instance: null },
        setup(t) {
            const e = t,
                n = {
                    "top-left": "top-0 start-0",
                    "top-center": "top-0 start-50 translate-middle-x",
                    "top-right": "top-0 end-0",
                    "middle-left": "top-50 start-0 translate-middle-y",
                    "middle-center": "top-50 start-50 translate-middle",
                    "middle-right": "top-50 end-0 translate-middle-y",
                    "bottom-left": "bottom-0 start-0",
                    "bottom-center": "bottom-0 start-50 translate-middle-x",
                    "bottom-right": "bottom-0 end-0",
                },
                i = computed(() => n[e.position]),
                o = (a) => {
                    var l
                    ;(l = e.instance) == null || l.remove(a)
                }
            return (a, l) => {
                var c
                return (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { class: normalizeClass([[unref(i)], "b-toaster position-fixed p-3"]), style: { "z-index": "11" } },
                        [
                            (openBlock(!0),
                            createElementBlock(
                                Fragment$1,
                                null,
                                renderList(
                                    (c = t.instance) == null ? void 0 : c.toasts(t.position).value,
                                    (g) => (
                                        openBlock(),
                                        createBlock$1(
                                            Fa,
                                            {
                                                id: g.options.id,
                                                key: g.options.id,
                                                modelValue: g.options.value,
                                                "onUpdate:modelValue": (v) => (g.options.value = v),
                                                delay: g.options.delay,
                                                title: g.content.title,
                                                body: g.content.body,
                                                component: g.content.body,
                                                variant: g.options.variant,
                                                onDestroyed: o,
                                            },
                                            null,
                                            8,
                                            ["id", "modelValue", "onUpdate:modelValue", "delay", "title", "body", "component", "variant"]
                                        )
                                    )
                                ),
                                128
                            )),
                        ],
                        2
                    )
                )
            }
        },
    }),
    Oe = { delay: 5e3, value: !0, pos: "top-right" }
class Et {
    constructor(e) {
        se(this, "vm"),
            se(this, "containerPositions"),
            isReactive(e) ? (this.vm = e) : (this.vm = reactive(e)),
            (this.containerPositions = computed(() => {
                const n = new Set([])
                return (
                    this.vm.toasts.map((i) => {
                        i.options.pos && n.add(i.options.pos)
                    }),
                    n
                )
            }))
    }
    toasts(e) {
        return computed(
            e
                ? () =>
                      this.vm.toasts.filter((n) => {
                          if (n.options.pos === e && n.options.value) return n
                      })
                : () => this.vm.toasts
        )
    }
    remove(...e) {
        this.vm.toasts = this.vm.toasts.filter((n) => {
            if (n.options.id && !e.includes(n.options.id)) return n
        })
    }
    isRoot() {
        var e
        return (e = this.vm.root) != null ? e : !1
    }
    show(e, n = Oe) {
        const i = { id: $e(), ...Oe, ...n },
            o = { options: reactive(i), content: e }
        return this.vm.toasts.push(o), o
    }
    info(e, n = Oe) {
        return this.show(e, { variant: "info", ...n })
    }
    danger(e, n = Oe) {
        return this.show(e, { variant: "danger", ...n })
    }
    warning(e, n = Oe) {
        return this.show(e, { variant: "warning", ...n })
    }
    success(e, n = Oe) {
        return this.show(e, { variant: "success", ...n })
    }
    hide() {}
}
class io {
    constructor() {
        se(this, "vms"), se(this, "rootInstance"), se(this, "useToast", za), (this.vms = {})
    }
    getOrCreateViewModel(e) {
        if (!e) {
            if (this.rootInstance) return this.vms[this.rootInstance]
            const n = { root: !0, toasts: [], container: void 0, id: Symbol("toast") }
            return (this.rootInstance = n.id), (this.vms[n.id] = n), n
        }
        if (e.root) {
            if (this.rootInstance) return this.vms[this.rootInstance]
            this.rootInstance = e.id
        }
        return (this.vms[e.id] = e), e
    }
    getVM(e) {
        if (!e && this.rootInstance) return this.vms[this.rootInstance]
        if (e) return this.vms[e]
    }
}
const gt = Symbol(),
    Oa = Symbol(),
    ro = { container: void 0, toasts: [], root: !1 }
function uo() {
    return inject(Oa)
}
function za(t, e = gt) {
    const n = inject(uo())
    if (!t) return new Et(n.getOrCreateViewModel())
    const i = { id: Symbol("toastInstance") },
        o = { ...ro, ...i, ...t },
        a = n.getOrCreateViewModel(o)
    return new Et(a)
}
const co = {
        install: (t, e = {}) => {
            var n, i, o, a
            t.provide(Oa, (i = (n = e == null ? void 0 : e.BToast) == null ? void 0 : n.injectkey) != null ? i : gt),
                t.provide((a = (o = e == null ? void 0 : e.BToast) == null ? void 0 : o.injectkey) != null ? a : gt, new io())
        },
    },
    fo = defineComponent({
        name: "BContainer",
        props: {
            gutterX: { type: String, default: null },
            gutterY: { type: String, default: null },
            fluid: { type: [Boolean, String], default: !1 },
            toast: { type: Object },
            position: { type: String, required: !1 },
            tag: { type: String, default: "div" },
        },
        setup(t, { slots: e, expose: n }) {
            const i = ref()
            let o
            const a = computed(() => ({
                container: !t.fluid,
                ["container-fluid"]: typeof t.fluid == "boolean" && t.fluid,
                [`container-${t.fluid}`]: typeof t.fluid == "string",
                [`gx-${t.gutterX}`]: t.gutterX !== null,
                [`gy-${t.gutterY}`]: t.gutterY !== null,
            }))
            return (
                onMounted(() => {
                    t.toast
                }),
                t.toast && ((o = za({ container: i, root: t.toast.root })), n({})),
                () => {
                    var l
                    const c = []
                    return (
                        o == null ||
                            o.containerPositions.value.forEach((g) => {
                                c.push(h$1(mt, { key: g, instance: o, position: g }))
                            }),
                        h$1(t.tag, { class: [a.value, t.position], ref: i }, [...c, (l = e.default) == null ? void 0 : l.call(e)])
                    )
                }
            )
        },
        methods: {},
    }),
    vo = { class: "visually-hidden" },
    bo = ["aria-labelledby", "role"],
    Na = defineComponent({
        __name: "BDropdown",
        props: {
            id: null,
            menuClass: null,
            size: null,
            splitClass: null,
            splitVariant: null,
            text: null,
            toggleClass: null,
            autoClose: { type: [Boolean, String], default: !0 },
            block: { default: !1 },
            boundary: { default: "clippingParents" },
            dark: { default: !1 },
            disabled: { default: !1 },
            isNav: { default: !1 },
            dropup: { default: !1 },
            dropright: { default: !1 },
            dropleft: { default: !1 },
            noFlip: { default: !1 },
            offset: { default: 0 },
            popperOpts: { default: () => ({}) },
            right: { default: !1 },
            role: { default: "menu" },
            split: { default: !1 },
            splitButtonType: { default: "button" },
            splitHref: { default: void 0 },
            noCaret: { default: !1 },
            toggleText: { default: "Toggle dropdown" },
            variant: { default: "secondary" },
        },
        emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
        setup(t, { expose: e, emit: n }) {
            const i = t,
                o = s$1(toRef(i, "block")),
                a = s$1(toRef(i, "dark")),
                l = s$1(toRef(i, "disabled")),
                c = s$1(toRef(i, "dropup")),
                g = s$1(toRef(i, "dropright")),
                v = s$1(toRef(i, "isNav")),
                _ = s$1(toRef(i, "dropleft")),
                A = s$1(toRef(i, "right")),
                B = s$1(toRef(i, "split")),
                D = s$1(toRef(i, "noCaret")),
                I = ref(),
                L = ref(),
                G = ref(),
                U = ve(toRef(i, "id"), "dropdown")
            re(I, "show.bs.dropdown", () => n("show")),
                re(I, "shown.bs.dropdown", () => n("shown")),
                re(I, "hide.bs.dropdown", () => n("hide")),
                re(I, "hidden.bs.dropdown", () => n("hidden"))
            const F = (le) => {
                    B.value && n("click", le)
                },
                Z = computed(() => ({ "d-grid": o.value, "d-flex": o.value && B.value })),
                Y = computed(() => ({
                    "nav-link": v.value,
                    "dropdown-toggle": !B.value,
                    "dropdown-toggle-no-caret": D.value && !B.value,
                    "w-100": B.value && o.value,
                })),
                X = computed(() => ({ "dropdown-menu-dark": a.value, "dropdown-menu-right": A.value })),
                ie = computed(() => ({
                    "data-bs-toggle": B.value ? void 0 : "dropdown",
                    "aria-expanded": B.value ? void 0 : !1,
                    ref: B.value ? void 0 : L,
                    href: B.value ? i.splitHref : void 0,
                })),
                he = computed(() => ({ ref: B.value ? L : void 0 })),
                oe = () => {
                    var le
                    ;(le = G.value) == null || le.hide()
                }
            return (
                onMounted(() => {
                    var le
                    G.value = new Dropdown((le = L.value) == null ? void 0 : le.$el, {
                        autoClose: i.autoClose,
                        boundary: i.boundary,
                        offset: i.offset ? i.offset.toString() : "",
                        reference: i.offset || B.value ? "parent" : "toggle",
                        popperConfig: (Te) => {
                            const ye = {
                                placement: "bottom-start",
                                modifiers: i.noFlip ? [{ name: "flip", options: { fallbackPlacements: [] } }] : [],
                            }
                            return (
                                c.value
                                    ? (ye.placement = A.value ? "top-end" : "top-start")
                                    : g.value
                                    ? (ye.placement = "right-start")
                                    : _.value
                                    ? (ye.placement = "left-start")
                                    : A.value && (ye.placement = "bottom-end"),
                                ct(Te, ct(ye, i.popperOpts))
                            )
                        },
                    })
                }),
                e({ hide: oe }),
                (le, Te) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { ref_key: "parent", ref: I, class: normalizeClass([unref(Z), "btn-group"]) },
                        [
                            createVNode(
                                je,
                                mergeProps(
                                    {
                                        id: unref(U),
                                        variant: t.splitVariant || t.variant,
                                        size: t.size,
                                        class: [unref(Y), unref(B) ? t.splitClass : t.toggleClass],
                                        disabled: unref(l),
                                        type: t.splitButtonType,
                                    },
                                    unref(ie),
                                    { onClick: F }
                                ),
                                {
                                    default: withCtx(() => [
                                        createTextVNode(toDisplayString(t.text) + " ", 1),
                                        renderSlot(le.$slots, "button-content"),
                                    ]),
                                    _: 3,
                                },
                                16,
                                ["id", "variant", "size", "class", "disabled", "type"]
                            ),
                            unref(B)
                                ? (openBlock(),
                                  createBlock$1(
                                      je,
                                      mergeProps({ key: 0, variant: t.variant, size: t.size, disabled: unref(l) }, unref(he), {
                                          class: [t.toggleClass, "dropdown-toggle-split dropdown-toggle"],
                                          "data-bs-toggle": "dropdown",
                                          "aria-expanded": "false",
                                          onClick: Te[0] || (Te[0] = (ye) => n("toggle")),
                                      }),
                                      { default: withCtx(() => [createBaseVNode("span", vo, toDisplayString(t.toggleText), 1)]), _: 1 },
                                      16,
                                      ["variant", "size", "disabled", "class"]
                                  ))
                                : createCommentVNode("", !0),
                            createBaseVNode(
                                "ul",
                                { class: normalizeClass(["dropdown-menu", [t.menuClass, unref(X)]]), "aria-labelledby": unref(U), role: t.role },
                                [renderSlot(le.$slots, "default")],
                                10,
                                bo
                            ),
                        ],
                        2
                    )
                )
            )
        },
    }),
    mo = { role: "presentation" },
    go = defineComponent({
        __name: "BDropdownDivider",
        props: { tag: { default: "hr" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createElementBlock("li", mo, [
                    (openBlock(),
                    createBlock$1(resolveDynamicComponent(t.tag), {
                        class: "dropdown-divider",
                        role: "separator",
                        "aria-orientation": "horizontal",
                    })),
                ])
            )
        },
    }),
    po = {},
    ho = { role: "presentation" },
    yo = { class: "px-4 py-3" }
function Bo(t, e) {
    return openBlock(), createElementBlock("li", ho, [createBaseVNode("form", yo, [renderSlot(t.$slots, "default")])])
}
const $o = be(po, [["render", Bo]]),
    ko = { role: "presentation" },
    So = ["id", "aria-describedby"],
    Co = { inheritAttrs: !1 },
    To = defineComponent({
        ...Co,
        __name: "BDropdownGroup",
        props: {
            id: null,
            ariaDescribedby: null,
            header: null,
            headerClasses: { default: void 0 },
            headerTag: { default: "header" },
            headerVariant: { default: void 0 },
        },
        setup(t) {
            const e = t,
                n = computed(() => (e.id ? [e.id, "group_dd_header"].join("_") : void 0)),
                i = computed(() => (e.headerTag === "header" ? void 0 : "heading")),
                o = computed(() => ({ [`text-${e.headerVariant}`]: !!e.headerVariant }))
            return (a, l) => (
                openBlock(),
                createElementBlock("li", ko, [
                    (openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(t.headerTag),
                        { id: unref(n), class: normalizeClass(["dropdown-header", [unref(o), t.headerClasses]]), role: unref(i) },
                        {
                            default: withCtx(() => [renderSlot(a.$slots, "header", {}, () => [createTextVNode(toDisplayString(t.header), 1)])]),
                            _: 3,
                        },
                        8,
                        ["id", "class", "role"]
                    )),
                    createBaseVNode(
                        "ul",
                        mergeProps({ id: t.id, role: "group", class: "list-unstyled" }, a.$attrs, {
                            "aria-describedby": t.ariaDescribedby || unref(n),
                        }),
                        [renderSlot(a.$slots, "default")],
                        16,
                        So
                    ),
                ])
            )
        },
    }),
    wo = {},
    _o = { class: "dropdown-header" }
function Vo(t, e) {
    return openBlock(), createElementBlock("li", null, [createBaseVNode("h6", _o, [renderSlot(t.$slots, "default")])])
}
const xo = be(wo, [["render", Vo]]),
    Ao = { role: "presentation" },
    Io = { inheritAttrs: !1 },
    Fo = defineComponent({
        ...Io,
        __name: "BDropdownItem",
        props: {
            href: null,
            linkClass: null,
            active: { default: !1 },
            disabled: { default: !1 },
            rel: { default: void 0 },
            target: { default: "_self" },
            variant: { default: void 0 },
        },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "active")),
                o = s$1(toRef(n, "disabled")),
                a = useAttrs(),
                l = computed(() => ({ active: i.value, disabled: o.value, [`text-${n.variant}`]: !!n.variant })),
                c = computed(() => (n.href ? "a" : a.to ? pe : "button")),
                g = computed(() => ({
                    "aria-current": i.value ? "true" : null,
                    href: c.value === "a" ? n.href : null,
                    rel: n.rel,
                    type: c.value === "button" ? "button" : null,
                    target: n.target,
                    ...(a.to ? { activeClass: "active", ...a } : {}),
                })),
                v = (_) => e("click", _)
            return (_, A) => (
                openBlock(),
                createElementBlock("li", Ao, [
                    (openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(unref(c)),
                        mergeProps({ class: ["dropdown-item", [unref(l), t.linkClass]] }, unref(g), { onClick: v }),
                        { default: withCtx(() => [renderSlot(_.$slots, "default")]), _: 3 },
                        16,
                        ["class"]
                    )),
                ])
            )
        },
    }),
    Oo = { role: "presentation" },
    zo = { inheritAttrs: !1 },
    No = defineComponent({
        ...zo,
        __name: "BDropdownItemButton",
        props: { buttonClass: null, active: { default: !1 }, activeClass: { default: "active" }, disabled: { default: !1 }, variant: null },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "active")),
                o = s$1(toRef(n, "disabled")),
                a = computed(() => ({ [n.activeClass]: i.value, disabled: o.value, [`text-${n.variant}`]: n.variant !== void 0 })),
                l = computed(() => ({ disabled: o.value })),
                c = (g) => e("click", g)
            return (g, v) => (
                openBlock(),
                createElementBlock("li", Oo, [
                    createBaseVNode(
                        "button",
                        mergeProps({ role: "menu", type: "button", class: ["dropdown-item", [unref(a), t.buttonClass]] }, unref(l), {
                            onClick: c,
                        }),
                        [renderSlot(g.$slots, "default")],
                        16
                    ),
                ])
            )
        },
    }),
    Lo = { role: "presentation" },
    Po = { class: "px-4 py-1 mb-0 text-muted" },
    Eo = defineComponent({
        __name: "BDropdownText",
        props: { text: { default: "" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createElementBlock("li", Lo, [
                    createBaseVNode("p", Po, [renderSlot(e.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.text), 1)])]),
                ])
            )
        },
    }),
    Ho = ["id", "novalidate", "onSubmit"],
    La = defineComponent({
        __name: "BForm",
        props: { id: null, floating: { default: !1 }, novalidate: { default: !1 }, validated: { default: !1 } },
        emits: ["submit"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "floating")),
                o = s$1(toRef(n, "novalidate")),
                a = s$1(toRef(n, "validated")),
                l = computed(() => ({ "form-floating": i.value, "was-validated": a.value })),
                c = (g) => e("submit", g)
            return (g, v) => (
                openBlock(),
                createElementBlock(
                    "form",
                    { id: t.id, novalidate: unref(o), class: normalizeClass(unref(l)), onSubmit: withModifiers(c, ["prevent"]) },
                    [renderSlot(g.$slots, "default")],
                    42,
                    Ho
                )
            )
        },
    }),
    Ro = { class: "form-floating" },
    qo = ["for"],
    Do = defineComponent({
        __name: "BFormFloatingLabel",
        props: { labelFor: null, label: null },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createElementBlock("div", Ro, [
                    renderSlot(e.$slots, "default"),
                    createBaseVNode("label", { for: t.labelFor }, toDisplayString(t.label), 9, qo),
                ])
            )
        },
    }),
    pt = defineComponent({
        __name: "BFormInvalidFeedback",
        props: {
            ariaLive: null,
            forceShow: { default: !1 },
            id: null,
            role: null,
            state: { default: void 0 },
            tag: { default: "div" },
            tooltip: { default: !1 },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "forceShow")),
                i = s$1(toRef(e, "state")),
                o = s$1(toRef(e, "tooltip")),
                a = computed(() => n.value === !0 || i.value === !1),
                l = computed(() => ({ "d-block": a.value, "invalid-feedback": !o.value, "invalid-tooltip": o.value })),
                c = computed(() => ({
                    id: e.id || null,
                    role: e.role || null,
                    "aria-live": e.ariaLive || null,
                    "aria-atomic": e.ariaLive ? "true" : null,
                }))
            return (g, v) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    mergeProps({ class: unref(l) }, unref(c)),
                    { default: withCtx(() => [renderSlot(g.$slots, "default")]), _: 3 },
                    16,
                    ["class"]
                )
            )
        },
    }),
    We = defineComponent({
        __name: "BFormRow",
        props: { tag: { default: "div" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: "row d-flex flex-wrap" },
                    { default: withCtx(() => [renderSlot(e.$slots, "default")]), _: 3 }
                )
            )
        },
    }),
    ht = defineComponent({
        __name: "BFormText",
        props: { id: null, inline: { default: !1 }, tag: { default: "small" }, textVariant: { default: "muted" } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "inline")),
                i = computed(() => ({ "form-text": !n.value, [`text-${e.textVariant}`]: !!e.textVariant })),
                o = computed(() => ({ id: e.id || null }))
            return (a, l) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    mergeProps({ class: unref(i) }, unref(o)),
                    { default: withCtx(() => [renderSlot(a.$slots, "default")]), _: 3 },
                    16,
                    ["class"]
                )
            )
        },
    }),
    yt = defineComponent({
        __name: "BFormValidFeedback",
        props: {
            ariaLive: null,
            forceShow: { default: !1 },
            id: null,
            role: null,
            state: { default: void 0 },
            tag: { default: "div" },
            tooltip: { default: !1 },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "forceShow")),
                i = s$1(toRef(e, "state")),
                o = s$1(toRef(e, "tooltip")),
                a = computed(() => n.value === !0 || i.value === !0),
                l = computed(() => ({ "d-block": a.value, "valid-feedback": !o.value, "valid-tooltip": o.value })),
                c = computed(() => ({
                    id: e.id || null,
                    role: e.role || null,
                    "aria-live": e.ariaLive || null,
                    "aria-atomic": e.ariaLive ? "true" : null,
                }))
            return (g, v) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    mergeProps({ class: unref(l) }, unref(c)),
                    { default: withCtx(() => [renderSlot(g.$slots, "default")]), _: 3 },
                    16,
                    ["class"]
                )
            )
        },
    }),
    jo = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"],
    Mo = ["for"],
    Go = { inheritAttrs: !1 },
    Pa = defineComponent({
        ...Go,
        __name: "BFormCheckbox",
        props: {
            ariaLabel: null,
            ariaLabelledBy: null,
            form: null,
            indeterminate: null,
            name: null,
            id: { default: void 0 },
            autofocus: { default: !1 },
            plain: { default: !1 },
            button: { default: !1 },
            switch: { default: !1 },
            disabled: { default: !1 },
            buttonVariant: { default: "secondary" },
            inline: { default: !1 },
            required: { default: void 0 },
            size: { default: "md" },
            state: { default: void 0 },
            uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
            value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
            modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 },
        },
        emits: ["update:modelValue", "input", "change"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "indeterminate")),
                o = s$1(toRef(n, "autofocus")),
                a = s$1(toRef(n, "plain")),
                l = s$1(toRef(n, "button")),
                c = s$1(toRef(n, "switch")),
                g = s$1(toRef(n, "disabled")),
                v = s$1(toRef(n, "inline")),
                _ = s$1(toRef(n, "required")),
                A = s$1(toRef(n, "state")),
                B = ve(toRef(n, "id"), "form-check"),
                D = ref(null),
                I = ref(!1),
                L = computed({
                    get: () =>
                        n.uncheckedValue
                            ? Array.isArray(n.modelValue)
                                ? n.modelValue.indexOf(n.value) > -1
                                : n.modelValue === n.value
                            : n.modelValue,
                    set: (X) => {
                        let ie = X
                        Array.isArray(n.modelValue)
                            ? n.uncheckedValue &&
                              ((ie = n.modelValue),
                              X
                                  ? (ie.indexOf(n.uncheckedValue) > -1 && ie.splice(ie.indexOf(n.uncheckedValue), 1), ie.push(n.value))
                                  : (ie.indexOf(n.value) > -1 && ie.splice(ie.indexOf(n.value), 1), ie.push(n.uncheckedValue)))
                            : (ie = X ? n.value : n.uncheckedValue),
                            e("input", ie),
                            e("update:modelValue", ie),
                            e("change", ie)
                    },
                }),
                G = computed(() =>
                    Array.isArray(n.modelValue) ? n.modelValue.indexOf(n.value) > -1 : JSON.stringify(n.modelValue) === JSON.stringify(n.value)
                ),
                U = reactive({
                    plain: toRef(a, "value"),
                    button: toRef(l, "value"),
                    inline: toRef(v, "value"),
                    switch: toRef(c, "value"),
                    size: toRef(n, "size"),
                    state: toRef(A, "value"),
                    buttonVariant: toRef(n, "buttonVariant"),
                }),
                F = ra(U),
                Z = ua(U),
                Y = da(U)
            return (
                onMounted(() => {
                    o.value && D.value.focus()
                }),
                (X, ie) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { class: normalizeClass(unref(F)) },
                        [
                            withDirectives(
                                createBaseVNode(
                                    "input",
                                    mergeProps({ id: unref(B) }, X.$attrs, {
                                        ref_key: "input",
                                        ref: D,
                                        "onUpdate:modelValue": ie[0] || (ie[0] = (he) => (isRef(L) ? (L.value = he) : null)),
                                        class: unref(Z),
                                        type: "checkbox",
                                        disabled: unref(g),
                                        required: !!t.name && !!unref(_),
                                        name: t.name,
                                        form: t.form,
                                        "aria-label": t.ariaLabel,
                                        "aria-labelledby": t.ariaLabelledBy,
                                        "aria-required": t.name && unref(_) ? "true" : void 0,
                                        value: t.value,
                                        indeterminate: unref(i),
                                        onFocus: ie[1] || (ie[1] = (he) => (I.value = !0)),
                                        onBlur: ie[2] || (ie[2] = (he) => (I.value = !1)),
                                    }),
                                    null,
                                    16,
                                    jo
                                ),
                                [[vModelCheckbox, unref(L)]]
                            ),
                            X.$slots.default || !unref(a)
                                ? (openBlock(),
                                  createElementBlock(
                                      "label",
                                      { key: 0, for: unref(B), class: normalizeClass([unref(Y), { active: unref(G), focus: I.value }]) },
                                      [renderSlot(X.$slots, "default")],
                                      10,
                                      Mo
                                  ))
                                : createCommentVNode("", !0),
                        ],
                        2
                    )
                )
            )
        },
    }),
    Uo = ["id"],
    Wo = ["innerHTML"],
    Xo = ["textContent"],
    Ko = defineComponent({
        __name: "BFormCheckboxGroup",
        props: {
            id: null,
            form: null,
            modelValue: { default: () => [] },
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            buttonVariant: { default: "secondary" },
            buttons: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            name: null,
            options: { default: () => [] },
            plain: { default: !1 },
            required: { default: !1 },
            size: null,
            stacked: { default: !1 },
            state: { default: void 0 },
            switches: { default: !1 },
            textField: { default: "text" },
            validated: { default: !1 },
            valueField: { default: "value" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(t, { emit: e }) {
            const n = t
            s$1(toRef(n, "autofocus"))
            const i = s$1(toRef(n, "buttons")),
                o = s$1(toRef(n, "disabled"))
            s$1(toRef(n, "plain"))
            const a = s$1(toRef(n, "required")),
                l = s$1(toRef(n, "stacked")),
                c = s$1(toRef(n, "state")),
                g = s$1(toRef(n, "switches")),
                v = s$1(toRef(n, "validated")),
                _ = useSlots(),
                A = "BFormCheckbox",
                B = ve(toRef(n, "id"), "checkbox"),
                D = ve(toRef(n, "name"), "checkbox"),
                I = computed({
                    get: () => n.modelValue,
                    set: (Z) => {
                        if (JSON.stringify(Z) === JSON.stringify(n.modelValue)) return
                        const Y = n.options
                            .filter((X) =>
                                Z.map((ie) => JSON.stringify(ie)).includes(JSON.stringify(typeof X == "string" ? X : X[n.valueField]))
                            )
                            .map((X) => (typeof X == "string" ? X : X[n.valueField]))
                        e("input", Y), e("update:modelValue", Y), e("change", Y)
                    },
                }),
                L = computed(() =>
                    (_.first ? Je(_.first(), A, o.value) : [])
                        .concat(n.options.map((Z) => va(Z, n)))
                        .concat(_.default ? Je(_.default(), A, o.value) : [])
                        .map((Z, Y) => ba(Z, Y, n, D, B))
                        .map((Z) => ({ ...Z, props: { switch: g.value, ...Z.props } }))
                ),
                G = reactive({
                    required: toRef(a, "value"),
                    ariaInvalid: toRef(n, "ariaInvalid"),
                    state: toRef(c, "value"),
                    validated: toRef(v, "value"),
                    buttons: toRef(i, "value"),
                    stacked: toRef(l, "value"),
                    size: toRef(n, "size"),
                }),
                U = ca(G),
                F = fa(G)
            return (Z, Y) => (
                openBlock(),
                createElementBlock(
                    "div",
                    mergeProps(unref(U), { id: unref(B), role: "group", class: [unref(F), "bv-no-focus-ring"], tabindex: "-1" }),
                    [
                        (openBlock(!0),
                        createElementBlock(
                            Fragment$1,
                            null,
                            renderList(
                                unref(L),
                                (X, ie) => (
                                    openBlock(),
                                    createBlock$1(
                                        Pa,
                                        mergeProps(
                                            {
                                                key: ie,
                                                modelValue: unref(I),
                                                "onUpdate:modelValue": Y[0] || (Y[0] = (he) => (isRef(I) ? (I.value = he) : null)),
                                            },
                                            X.props
                                        ),
                                        {
                                            default: withCtx(() => [
                                                X.html
                                                    ? (openBlock(), createElementBlock("span", { key: 0, innerHTML: X.html }, null, 8, Wo))
                                                    : (openBlock(),
                                                      createElementBlock("span", { key: 1, textContent: toDisplayString(X.text) }, null, 8, Xo)),
                                            ]),
                                            _: 2,
                                        },
                                        1040,
                                        ["modelValue"]
                                    )
                                )
                            ),
                            128
                        )),
                    ],
                    16,
                    Uo
                )
            )
        },
    }),
    Ea = ["input", "select", "textarea"],
    Jo = Ea.map((t) => `${t}:not([disabled])`).join(),
    Yo = [...Ea, "a", "button", "label"],
    Zo = "label",
    Qo = "invalid-feedback",
    es = "valid-feedback",
    ts = "description",
    as = "default",
    ls = defineComponent({
        components: { BCol: qe, BFormInvalidFeedback: pt, BFormRow: We, BFormText: ht, BFormValidFeedback: yt },
        props: {
            contentCols: { type: [Boolean, String, Number], required: !1 },
            contentColsLg: { type: [Boolean, String, Number], required: !1 },
            contentColsMd: { type: [Boolean, String, Number], required: !1 },
            contentColsSm: { type: [Boolean, String, Number], required: !1 },
            contentColsXl: { type: [Boolean, String, Number], required: !1 },
            description: { type: [String], required: !1 },
            disabled: { type: [Boolean, String], default: !1 },
            feedbackAriaLive: { type: String, default: "assertive" },
            id: { type: String, required: !1 },
            invalidFeedback: { type: String, required: !1 },
            label: { type: String, required: !1 },
            labelAlign: { type: [Boolean, String, Number], required: !1 },
            labelAlignLg: { type: [Boolean, String, Number], required: !1 },
            labelAlignMd: { type: [Boolean, String, Number], required: !1 },
            labelAlignSm: { type: [Boolean, String, Number], required: !1 },
            labelAlignXl: { type: [Boolean, String, Number], required: !1 },
            labelClass: { type: [Array, Object, String], required: !1 },
            labelCols: { type: [Boolean, String, Number], required: !1 },
            labelColsLg: { type: [Boolean, String, Number], required: !1 },
            labelColsMd: { type: [Boolean, String, Number], required: !1 },
            labelColsSm: { type: [Boolean, String, Number], required: !1 },
            labelColsXl: { type: [Boolean, String, Number], required: !1 },
            labelFor: { type: String, required: !1 },
            labelSize: { type: String, required: !1 },
            labelSrOnly: { type: [Boolean, String], default: !1 },
            state: { type: [Boolean, String], default: null },
            tooltip: { type: [Boolean, String], default: !1 },
            validFeedback: { type: String, required: !1 },
            validated: { type: [Boolean, String], default: !1 },
            floating: { type: [Boolean, String], default: !1 },
        },
        setup(t, { attrs: e }) {
            const n = s$1(toRef(t, "disabled")),
                i = s$1(toRef(t, "labelSrOnly")),
                o = s$1(toRef(t, "state")),
                a = s$1(toRef(t, "tooltip")),
                l = s$1(toRef(t, "validated")),
                c = s$1(toRef(t, "floating")),
                g = null,
                v = ["xs", "sm", "md", "lg", "xl"],
                _ = (X, ie) =>
                    v.reduce((he, oe) => {
                        const le = X[At(oe, `${ie}Align`)] || null
                        return le && he.push(["text", oe, le].filter((Te) => Te).join("-")), he
                    }, []),
                A = (X, ie) =>
                    v.reduce((he, oe) => {
                        let le = X[At(oe, `${ie}Cols`)]
                        return (
                            (le = le === "" ? !0 : le || !1),
                            !st(le) && le !== "auto" && ((le = Ml(le, 0)), (le = le > 0 ? le : !1)),
                            le && (he[oe || (st(le) ? "col" : "cols")] = le),
                            he
                        )
                    }, {}),
                B = ref(),
                D = (X, ie = null) => {
                    if (_l && t.labelFor) {
                        const he = zl(`#${Tl(t.labelFor)}`, B)
                        if (he) {
                            const oe = "aria-describedby",
                                le = (X || "").split(Ue),
                                Te = (ie || "").split(Ue),
                                ye = (Kt(he, oe) || "")
                                    .split(Ue)
                                    .filter((Ae) => !kl(Te, Ae))
                                    .concat(le)
                                    .filter((Ae, O, u) => u.indexOf(Ae) === O)
                                    .filter((Ae) => Ae)
                                    .join(" ")
                                    .trim()
                            ye ? Ll(he, oe, ye) : Pl(he, oe)
                        }
                    }
                },
                I = computed(() => A(t, "content")),
                L = computed(() => _(t, "label")),
                G = computed(() => A(t, "label")),
                U = computed(() => Object.keys(I.value).length > 0 || Object.keys(G.value).length > 0),
                F = computed(() => (st(o.value) ? o.value : null)),
                Z = computed(() => {
                    const X = F.value
                    return X === !0 ? "is-valid" : X === !1 ? "is-invalid" : null
                }),
                Y = computed(() => tt(e.ariaInvalid, o.value))
            return (
                watch(
                    () => g,
                    (X, ie) => {
                        X !== ie && D(X, ie)
                    }
                ),
                onMounted(() => {
                    nextTick(() => {
                        D(g)
                    })
                }),
                {
                    disabledBoolean: n,
                    labelSrOnlyBoolean: i,
                    stateBoolean: o,
                    tooltipBoolean: a,
                    validatedBoolean: l,
                    floatingBoolean: c,
                    ariaDescribedby: g,
                    computedAriaInvalid: Y,
                    contentColProps: I,
                    isHorizontal: U,
                    labelAlignClasses: L,
                    labelColProps: G,
                    onLegendClick: (X) => {
                        if (t.labelFor) return
                        const { target: ie } = X,
                            he = ie ? ie.tagName : ""
                        if (Yo.indexOf(he) !== -1) return
                        const oe = Nl(Jo, B).filter(Ol)
                        oe.length === 1 && Il(oe[0])
                    },
                    stateClass: Z,
                }
            )
        },
        render() {
            const t = this.$props,
                e = this.$slots,
                n = ve(),
                i = !t.labelFor
            let o = null
            const a = ge(Zo, {}, e) || t.label,
                l = a ? $e("_BV_label_") : null
            if (a || this.isHorizontal) {
                const Y = i ? "legend" : "label"
                if (this.labelSrOnlyBoolean)
                    a && (o = h$1(Y, { class: "visually-hidden", id: l, for: t.labelFor || null }, a)),
                        this.isHorizontal ? (o = h$1(qe, this.labelColProps, { default: () => o })) : (o = h$1("div", {}, [o]))
                else {
                    const X = {
                        onClick: i ? this.onLegendClick : null,
                        ...(this.isHorizontal ? this.labelColProps : {}),
                        tag: this.isHorizontal ? Y : null,
                        id: l,
                        for: t.labelFor || null,
                        tabIndex: i ? "-1" : null,
                        class: [
                            this.isHorizontal ? "col-form-label" : "form-label",
                            {
                                "bv-no-focus-ring": i,
                                "col-form-label": this.isHorizontal || i,
                                "pt-0": !this.isHorizontal && i,
                                "d-block": !this.isHorizontal && !i,
                                [`col-form-label-${t.labelSize}`]: !!t.labelSize,
                            },
                            this.labelAlignClasses,
                            t.labelClass,
                        ],
                    }
                    this.isHorizontal ? (o = h$1(qe, X, { default: () => a })) : (o = h$1(Y, X, a))
                }
            }
            let c = null
            const g = ge(Qo, {}, e) || this.invalidFeedback,
                v = g ? $e("_BV_feedback_invalid_") : void 0
            g &&
                (c = h$1(
                    pt,
                    { ariaLive: t.feedbackAriaLive, id: v, state: this.stateBoolean, tooltip: this.tooltipBoolean },
                    { default: () => g }
                ))
            let _ = null
            const A = ge(es, {}, e) || this.validFeedback,
                B = A ? $e("_BV_feedback_valid_") : void 0
            A &&
                (_ = h$1(
                    yt,
                    { ariaLive: t.feedbackAriaLive, id: B, state: this.stateBoolean, tooltip: this.tooltipBoolean },
                    { default: () => A }
                ))
            let D = null
            const I = ge(ts, {}, e) || this.description,
                L = I ? $e("_BV_description_") : void 0
            I && (D = h$1(ht, { id: L }, { default: () => I }))
            const G = (this.ariaDescribedby =
                    [L, this.stateBoolean === !1 ? v : null, this.stateBoolean === !0 ? B : null].filter((Y) => Y).join(" ") || null),
                U = [ge(as, { ariaDescribedby: G, descriptionId: L, id: n, labelId: l }, e) || "", c, _, D]
            !this.isHorizontal && this.floatingBoolean && U.push(o)
            let F = h$1("div", { ref: "content", class: [{ "form-floating": !this.isHorizontal && this.floatingBoolean }] }, U)
            this.isHorizontal && (F = h$1(qe, { ref: "content", ...this.contentColProps }, { default: () => U }))
            const Z = {
                class: ["mb-3", this.stateClass, { "was-validated": this.validatedBoolean }],
                id: ve(toRef(t, "id")).value,
                disabled: i ? this.disabledBoolean : null,
                role: i ? null : "group",
                "aria-invalid": this.computedAriaInvalid,
                "aria-labelledby": i && this.isHorizontal ? l : null,
            }
            return this.isHorizontal && !i
                ? h$1(We, Z, { default: () => [o, F] })
                : h$1(
                      i ? "fieldset" : "div",
                      Z,
                      this.isHorizontal && i
                          ? [h$1(We, {}, { default: () => [o, F] })]
                          : this.isHorizontal || !this.floatingBoolean
                          ? [o, F]
                          : [F]
                  )
        },
    }),
    Ht = ["text", "number", "email", "password", "search", "url", "tel", "date", "time", "range", "color"],
    ns = defineComponent({
        props: {
            ...ma,
            max: { type: [String, Number], required: !1 },
            min: { type: [String, Number], required: !1 },
            step: { type: [String, Number], required: !1 },
            type: { type: String, default: "text", validator: (t) => Ht.includes(t) },
        },
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(t, { emit: e }) {
            const n = computed(() => {
                    const B = t.type === "range",
                        D = t.type === "color"
                    return {
                        "form-range": B,
                        "form-control": D || (!t.plaintext && !B),
                        "form-control-color": D,
                        "form-control-plaintext": t.plaintext && !B && !D,
                        [`form-control-${t.size}`]: !!t.size,
                        "is-valid": t.state === !0,
                        "is-invalid": t.state === !1,
                    }
                }),
                i = computed(() => (Ht.includes(t.type) ? t.type : "text")),
                { input: o, computedId: a, computedAriaInvalid: l, onInput: c, onChange: g, onBlur: v, focus: _, blur: A } = ga(t, e)
            return {
                classes: n,
                localType: i,
                input: o,
                computedId: a,
                computedAriaInvalid: l,
                onInput: c,
                onChange: g,
                onBlur: v,
                focus: _,
                blur: A,
            }
        },
    }),
    os = [
        "id",
        "name",
        "form",
        "type",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "min",
        "max",
        "step",
        "list",
        "aria-required",
        "aria-invalid",
    ]
function ss(t, e, n, i, o, a) {
    return (
        openBlock(),
        createElementBlock(
            "input",
            mergeProps(
                {
                    id: t.computedId,
                    ref: "input",
                    class: t.classes,
                    name: t.name || void 0,
                    form: t.form || void 0,
                    type: t.localType,
                    disabled: t.disabled,
                    placeholder: t.placeholder,
                    required: t.required,
                    autocomplete: t.autocomplete || void 0,
                    readonly: t.readonly || t.plaintext,
                    min: t.min,
                    max: t.max,
                    step: t.step,
                    list: t.type !== "password" ? t.list : void 0,
                    "aria-required": t.required ? "true" : void 0,
                    "aria-invalid": t.computedAriaInvalid,
                },
                t.$attrs,
                {
                    onInput: e[0] || (e[0] = (l) => t.onInput(l)),
                    onChange: e[1] || (e[1] = (l) => t.onChange(l)),
                    onBlur: e[2] || (e[2] = (l) => t.onBlur(l)),
                }
            ),
            null,
            16,
            os
        )
    )
}
const is$1 = be(ns, [["render", ss]]),
    rs = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"],
    us = ["for"],
    Ha = defineComponent({
        __name: "BFormRadio",
        props: {
            ariaLabel: null,
            ariaLabelledBy: null,
            form: null,
            id: null,
            name: null,
            size: null,
            autofocus: { default: !1 },
            modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
            plain: { default: !1 },
            button: { default: !1 },
            switch: { default: !1 },
            disabled: { default: !1 },
            buttonVariant: { default: "secondary" },
            inline: { default: !1 },
            required: { default: !1 },
            state: { default: void 0 },
            value: { type: [String, Boolean, Object, Number], default: !0 },
        },
        emits: ["input", "change", "update:modelValue"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "autofocus")),
                o = s$1(toRef(n, "plain")),
                a = s$1(toRef(n, "button")),
                l = s$1(toRef(n, "switch")),
                c = s$1(toRef(n, "disabled")),
                g = s$1(toRef(n, "inline")),
                v = s$1(toRef(n, "required")),
                _ = s$1(toRef(n, "state")),
                A = ve(toRef(n, "id"), "form-check"),
                B = ref(null),
                D = ref(!1),
                I = computed({
                    get: () => (Array.isArray(n.modelValue) ? n.modelValue[0] : n.modelValue),
                    set: (Y) => {
                        const X = Y ? n.value : !1,
                            ie = Array.isArray(n.modelValue) ? [X] : X
                        e("input", ie), e("change", ie), e("update:modelValue", ie)
                    },
                }),
                L = computed(() =>
                    Array.isArray(n.modelValue)
                        ? (n.modelValue || []).find((Y) => Y === n.value)
                        : JSON.stringify(n.modelValue) === JSON.stringify(n.value)
                ),
                G = reactive({
                    plain: toRef(o, "value"),
                    button: toRef(a, "value"),
                    inline: toRef(g, "value"),
                    switch: toRef(l, "value"),
                    size: toRef(n, "size"),
                    state: toRef(_, "value"),
                    buttonVariant: toRef(n, "buttonVariant"),
                }),
                U = ra(G),
                F = ua(G),
                Z = da(G)
            return (
                onMounted(() => {
                    i.value && B.value.focus()
                }),
                (Y, X) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { class: normalizeClass(unref(U)) },
                        [
                            withDirectives(
                                createBaseVNode(
                                    "input",
                                    mergeProps({ id: unref(A) }, Y.$attrs, {
                                        ref_key: "input",
                                        ref: B,
                                        "onUpdate:modelValue": X[0] || (X[0] = (ie) => (isRef(I) ? (I.value = ie) : null)),
                                        class: unref(F),
                                        type: "radio",
                                        disabled: unref(c),
                                        required: !!t.name && !!unref(v),
                                        name: t.name,
                                        form: t.form,
                                        "aria-label": t.ariaLabel,
                                        "aria-labelledby": t.ariaLabelledBy,
                                        value: t.value,
                                        "aria-required": t.name && unref(v) ? !0 : void 0,
                                        onFocus: X[1] || (X[1] = (ie) => (D.value = !0)),
                                        onBlur: X[2] || (X[2] = (ie) => (D.value = !1)),
                                    }),
                                    null,
                                    16,
                                    rs
                                ),
                                [[vModelRadio, unref(I)]]
                            ),
                            Y.$slots.default || !unref(o)
                                ? (openBlock(),
                                  createElementBlock(
                                      "label",
                                      { key: 0, for: unref(A), class: normalizeClass([unref(Z), { active: unref(L), focus: D.value }]) },
                                      [renderSlot(Y.$slots, "default")],
                                      10,
                                      us
                                  ))
                                : createCommentVNode("", !0),
                        ],
                        2
                    )
                )
            )
        },
    }),
    ds = ["id"],
    cs = ["innerHTML"],
    fs = ["textContent"],
    vs = defineComponent({
        __name: "BFormRadioGroup",
        props: {
            size: null,
            form: null,
            id: null,
            name: null,
            modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            buttonVariant: { default: "secondary" },
            buttons: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            options: { default: () => [] },
            plain: { default: !1 },
            required: { default: !1 },
            stacked: { default: !1 },
            state: { default: void 0 },
            textField: { default: "text" },
            validated: { default: !1 },
            valueField: { default: "value" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(t, { emit: e }) {
            const n = t
            s$1(toRef(n, "autofocus"))
            const i = s$1(toRef(n, "buttons")),
                o = s$1(toRef(n, "disabled"))
            s$1(toRef(n, "plain"))
            const a = s$1(toRef(n, "required")),
                l = s$1(toRef(n, "stacked")),
                c = s$1(toRef(n, "state")),
                g = s$1(toRef(n, "validated")),
                v = useSlots(),
                _ = "BFormRadio",
                A = ve(toRef(n, "id"), "radio"),
                B = ve(toRef(n, "name"), "checkbox"),
                D = computed({
                    get: () => n.modelValue,
                    set: (F) => {
                        e("input", F), e("update:modelValue", F), e("change", F)
                    },
                }),
                I = computed(() =>
                    (v.first ? Je(v.first(), _, o.value) : [])
                        .concat(n.options.map((F) => va(F, n)))
                        .concat(v.default ? Je(v.default(), _, o.value) : [])
                        .map((F, Z) => ba(F, Z, n, B, A))
                        .map((F) => ({ ...F }))
                ),
                L = reactive({
                    required: toRef(a, "value"),
                    ariaInvalid: toRef(n, "ariaInvalid"),
                    state: toRef(c, "value"),
                    validated: toRef(g, "value"),
                    buttons: toRef(i, "value"),
                    stacked: toRef(l, "value"),
                    size: toRef(n, "size"),
                }),
                G = ca(L),
                U = fa(L)
            return (F, Z) => (
                openBlock(),
                createElementBlock(
                    "div",
                    mergeProps(unref(G), { id: unref(A), role: "radiogroup", class: [unref(U), "bv-no-focus-ring"], tabindex: "-1" }),
                    [
                        (openBlock(!0),
                        createElementBlock(
                            Fragment$1,
                            null,
                            renderList(
                                unref(I),
                                (Y, X) => (
                                    openBlock(),
                                    createBlock$1(
                                        Ha,
                                        mergeProps(
                                            {
                                                key: X,
                                                modelValue: unref(D),
                                                "onUpdate:modelValue": Z[0] || (Z[0] = (ie) => (isRef(D) ? (D.value = ie) : null)),
                                            },
                                            Y.props
                                        ),
                                        {
                                            default: withCtx(() => [
                                                Y.html
                                                    ? (openBlock(), createElementBlock("span", { key: 0, innerHTML: Y.html }, null, 8, cs))
                                                    : (openBlock(),
                                                      createElementBlock("span", { key: 1, textContent: toDisplayString(Y.text) }, null, 8, fs)),
                                            ]),
                                            _: 2,
                                        },
                                        1040,
                                        ["modelValue"]
                                    )
                                )
                            ),
                            128
                        )),
                    ],
                    16,
                    ds
                )
            )
        },
    }),
    bs = ["value", "disabled"],
    wt = defineComponent({
        __name: "BFormSelectOption",
        props: { value: null, disabled: { default: !1 } },
        setup(t) {
            const e = s$1(toRef(t, "disabled"))
            return (n, i) => (
                openBlock(), createElementBlock("option", { value: t.value, disabled: unref(e) }, [renderSlot(n.$slots, "default")], 8, bs)
            )
        },
    }),
    ms$1 = ["label"],
    Ra = defineComponent({
        __name: "BFormSelectOptionGroup",
        props: {
            label: null,
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            options: { default: () => [] },
            textField: { default: "text" },
            valueField: { default: "value" },
        },
        setup(t) {
            const e = t,
                n = computed(() => Ct(e.options, "BFormSelectOptionGroup", e))
            return (i, o) => (
                openBlock(),
                createElementBlock(
                    "optgroup",
                    { label: t.label },
                    [
                        renderSlot(i.$slots, "first"),
                        (openBlock(!0),
                        createElementBlock(
                            Fragment$1,
                            null,
                            renderList(
                                unref(n),
                                (a, l) => (
                                    openBlock(),
                                    createBlock$1(
                                        wt,
                                        mergeProps({ key: `option_${l}`, value: a.value, disabled: a.disabled }, i.$attrs, {
                                            innerHTML: a.html || a.text,
                                        }),
                                        null,
                                        16,
                                        ["value", "disabled", "innerHTML"]
                                    )
                                )
                            ),
                            128
                        )),
                        renderSlot(i.$slots, "default"),
                    ],
                    8,
                    ms$1
                )
            )
        },
    }),
    gs = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"],
    ps = defineComponent({
        __name: "BFormSelect",
        props: {
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            form: null,
            htmlField: { default: "html" },
            id: null,
            labelField: { default: "label" },
            multiple: { default: !1 },
            name: null,
            options: { default: () => [] },
            optionsField: { default: "options" },
            plain: { default: !1 },
            required: { default: !1 },
            selectSize: { default: 0 },
            size: null,
            state: { default: void 0 },
            textField: { default: "text" },
            valueField: { default: "value" },
            modelValue: { default: "" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(t, { expose: e, emit: n }) {
            const i = t,
                o = s$1(toRef(i, "autofocus")),
                a = s$1(toRef(i, "disabled")),
                l = s$1(toRef(i, "multiple")),
                c = s$1(toRef(i, "plain")),
                g = s$1(toRef(i, "required")),
                v = s$1(toRef(i, "state")),
                _ = ref(),
                A = ve(toRef(i, "id"), "input"),
                B = () => {
                    nextTick(() => {
                        var F
                        o.value && ((F = _.value) == null || F.focus())
                    })
                }
            onMounted(B), onActivated(B)
            const D = computed(() => ({
                    "form-control": c.value,
                    [`form-control-${i.size}`]: i.size && c.value,
                    "form-select": !c.value,
                    [`form-select-${i.size}`]: i.size && !c.value,
                    "is-valid": v.value === !0,
                    "is-invalid": v.value === !1,
                })),
                I = computed(() => {
                    if (i.selectSize || c.value) return i.selectSize
                }),
                L = computed(() => tt(i.ariaInvalid, v.value)),
                G = computed(() => Ct(i.options, "BFormSelect", i)),
                U = computed({
                    get() {
                        return i.modelValue
                    },
                    set(F) {
                        n("change", F), n("update:modelValue", F), n("input", F)
                    },
                })
            return (
                e({
                    blur: () => {
                        var F
                        a.value || (F = _.value) == null || F.blur()
                    },
                    focus: () => {
                        var F
                        a.value || (F = _.value) == null || F.focus()
                    },
                }),
                (F, Z) =>
                    withDirectives(
                        (openBlock(),
                        createElementBlock(
                            "select",
                            mergeProps({ id: unref(A), ref_key: "input", ref: _ }, F.$attrs, {
                                "onUpdate:modelValue": Z[0] || (Z[0] = (Y) => (isRef(U) ? (U.value = Y) : null)),
                                class: unref(D),
                                name: t.name,
                                form: t.form || void 0,
                                multiple: unref(l) || void 0,
                                size: unref(I),
                                disabled: unref(a),
                                required: unref(g),
                                "aria-required": unref(g) ? !0 : void 0,
                                "aria-invalid": unref(L),
                            }),
                            [
                                renderSlot(F.$slots, "first"),
                                (openBlock(!0),
                                createElementBlock(
                                    Fragment$1,
                                    null,
                                    renderList(
                                        unref(G),
                                        (Y, X) => (
                                            openBlock(),
                                            createElementBlock(
                                                Fragment$1,
                                                null,
                                                [
                                                    Array.isArray(Y.options)
                                                        ? (openBlock(),
                                                          createBlock$1(
                                                              Ra,
                                                              { key: `option_${X}`, label: Y.label, options: Y.options },
                                                              null,
                                                              8,
                                                              ["label", "options"]
                                                          ))
                                                        : (openBlock(),
                                                          createBlock$1(
                                                              wt,
                                                              {
                                                                  key: `option2_${X}`,
                                                                  value: Y.value,
                                                                  disabled: Y.disabled,
                                                                  innerHTML: Y.html || Y.text,
                                                              },
                                                              null,
                                                              8,
                                                              ["value", "disabled", "innerHTML"]
                                                          )),
                                                ],
                                                64
                                            )
                                        )
                                    ),
                                    256
                                )),
                                renderSlot(F.$slots, "default"),
                            ],
                            16,
                            gs
                        )),
                        [[vModelSelect, unref(U)]]
                    )
            )
        },
    }),
    hs = ["id"],
    ys = ["aria-label", "aria-controls", "aria-describedby"],
    qa = defineComponent({
        __name: "BFormTag",
        props: {
            id: null,
            title: null,
            disabled: { default: !1 },
            noRemove: { default: !1 },
            pill: { default: !1 },
            removeLabel: { default: "Remove tag" },
            tag: { default: "span" },
            variant: { default: "secondary" },
        },
        emits: ["remove"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "disabled")),
                o = s$1(toRef(n, "noRemove")),
                a = s$1(toRef(n, "pill")),
                l = useSlots(),
                c = computed(() => {
                    var A, B, D
                    return (D = ((B = (A = l.default) == null ? void 0 : A.call(l)[0].children) == null ? void 0 : B.toString()) || n.title) !=
                        null
                        ? D
                        : ""
                }),
                g = ve(toRef(n, "id")),
                v = computed(() => `${g.value}taglabel__`),
                _ = computed(() => [
                    `bg-${n.variant}`,
                    { "text-dark": ["warning", "info", "light"].includes(n.variant), "rounded-pill": a.value, disabled: i.value },
                ])
            return (A, B) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    {
                        id: unref(g),
                        title: unref(c),
                        class: normalizeClass(["badge b-form-tag d-inline-flex align-items-center mw-100", unref(_)]),
                        "aria-labelledby": unref(v),
                    },
                    {
                        default: withCtx(() => [
                            createBaseVNode(
                                "span",
                                { id: unref(v), class: "b-form-tag-content flex-grow-1 text-truncate" },
                                [renderSlot(A.$slots, "default", {}, () => [createTextVNode(toDisplayString(unref(c)), 1)])],
                                8,
                                hs
                            ),
                            !unref(i) && !unref(o)
                                ? (openBlock(),
                                  createElementBlock(
                                      "button",
                                      {
                                          key: 0,
                                          "aria-keyshortcuts": "Delete",
                                          type: "button",
                                          "aria-label": t.removeLabel,
                                          class: normalizeClass([
                                              "btn-close b-form-tag-remove",
                                              { "btn-close-white": !["warning", "info", "light"].includes(t.variant) },
                                          ]),
                                          "aria-controls": t.id,
                                          "aria-describedby": unref(v),
                                          onClick: B[0] || (B[0] = (D) => e("remove", unref(c))),
                                      },
                                      null,
                                      10,
                                      ys
                                  ))
                                : createCommentVNode("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "title", "class", "aria-labelledby"]
                )
            )
        },
    }),
    Bs = ["id"],
    $s = ["id", "for", "aria-live"],
    ks = ["id", "aria-live"],
    Ss = ["id"],
    Cs = ["aria-controls"],
    Ts = { role: "group", class: "d-flex" },
    ws = ["id", "disabled", "value", "type", "placeholder", "form", "required"],
    _s = ["disabled"],
    Vs = { "aria-live": "polite", "aria-atomic": "true" },
    xs = { key: 0, class: "d-block invalid-feedback" },
    As = { key: 1, class: "form-text text-muted" },
    Is = { key: 2, class: "form-text text-muted" },
    Fs = ["name", "value"],
    Os = defineComponent({
        __name: "BFormTags",
        props: {
            addButtonText: { default: "Add" },
            addButtonVariant: { default: "outline-secondary" },
            addOnChange: { default: !1 },
            autofocus: { default: !1 },
            disabled: { default: !1 },
            duplicateTagText: { default: "Duplicate tag(s)" },
            inputAttrs: null,
            inputClass: null,
            inputId: null,
            inputType: { default: "text" },
            invalidTagText: { default: "Invalid tag(s)" },
            form: null,
            limit: null,
            limitTagsText: { default: "Tag limit reached" },
            modelValue: { default: () => [] },
            name: null,
            noAddOnEnter: { default: !1 },
            noOuterFocus: { default: !1 },
            noTagRemove: { default: !1 },
            placeholder: { default: "Add tag..." },
            removeOnDelete: { default: !1 },
            required: { default: !1 },
            separator: null,
            state: { default: void 0 },
            size: null,
            tagClass: null,
            tagPills: { default: !1 },
            tagRemoveLabel: null,
            tagRemovedLabel: { default: "Tag removed" },
            tagValidator: { type: Function, default: () => !0 },
            tagVariant: { default: "secondary" },
        },
        emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "addOnChange")),
                o = s$1(toRef(n, "autofocus")),
                a = s$1(toRef(n, "disabled")),
                l = s$1(toRef(n, "noAddOnEnter")),
                c = s$1(toRef(n, "noOuterFocus")),
                g = s$1(toRef(n, "noTagRemove")),
                v = s$1(toRef(n, "removeOnDelete")),
                _ = s$1(toRef(n, "required")),
                A = s$1(toRef(n, "state")),
                B = s$1(toRef(n, "tagPills")),
                D = ref(null),
                I = ve(),
                L = computed(() => n.inputId || `${I.value}input__`)
            onMounted(() => {
                O(), n.modelValue.length > 0 && (F.value = !0)
            }),
                onActivated(() => O()),
                watch(
                    () => n.modelValue,
                    (T) => {
                        G.value = T
                    }
                )
            const G = ref(n.modelValue),
                U = ref(""),
                F = ref(!1),
                Z = ref(!1),
                Y = ref(""),
                X = ref([]),
                ie = ref([]),
                he = ref([]),
                oe = computed(() => ({
                    [`form-control-${n.size}`]: n.size !== void 0,
                    disabled: a.value,
                    focus: Z.value,
                    "is-invalid": A.value === !1,
                    "is-valid": A.value === !0,
                })),
                le = computed(() => G.value.includes(U.value)),
                Te = computed(() => (U.value === "" ? !1 : !n.tagValidator(U.value))),
                ye = computed(() => G.value.length === n.limit),
                Ae = computed(() => !Te.value && !le.value),
                O = () => {
                    var T
                    o.value && ((T = D.value) == null || T.focus())
                },
                u = (T) => {
                    if (a.value) {
                        T.target.blur()
                        return
                    }
                    e("focusin", T)
                },
                E = (T) => {
                    a.value || c.value || ((Z.value = !0), e("focus", T))
                },
                $ = (T) => {
                    ;(Z.value = !1), e("blur", T)
                },
                N = (T) => {
                    var Q, k
                    const W = typeof T == "string" ? T : T.target.value
                    if (((F.value = !1), ((Q = n.separator) == null ? void 0 : Q.includes(W.charAt(0))) && W.length > 0)) {
                        D.value && (D.value.value = "")
                        return
                    }
                    if (((U.value = W), (k = n.separator) != null && k.includes(W.charAt(W.length - 1)))) {
                        C(W.slice(0, W.length - 1))
                        return
                    }
                    ;(X.value = n.tagValidator(W) && !le.value ? [W] : []),
                        (ie.value = n.tagValidator(W) ? [] : [W]),
                        (he.value = le.value ? [W] : []),
                        e("tag-state", X.value, ie.value, he.value)
                },
                M = (T) => {
                    i.value && (N(T), le.value || C(U.value))
                },
                R = (T) => {
                    if (T.key === "Enter" && !l.value) {
                        C(U.value)
                        return
                    }
                    ;(T.key === "Backspace" || T.key === "Delete") && v.value && U.value === "" && F.value && G.value.length > 0
                        ? S(G.value[G.value.length - 1])
                        : (F.value = !0)
                },
                C = (T) => {
                    var Q
                    if (((T = (T || U.value).trim()), T === "" || le.value || !n.tagValidator(T) || (n.limit && ye.value))) return
                    const k = [...n.modelValue, T]
                    ;(U.value = ""), (F.value = !0), e("update:modelValue", k), e("input", k), (Q = D.value) == null || Q.focus()
                },
                S = (T) => {
                    var Q
                    const k = G.value.indexOf((Q = T == null ? void 0 : T.toString()) != null ? Q : "")
                    ;(Y.value = G.value.splice(k, 1).toString()), e("update:modelValue", G.value)
                },
                b = computed(() => {
                    const {
                        addButtonText: T,
                        addButtonVariant: Q,
                        duplicateTagText: k,
                        inputAttrs: W,
                        form: J,
                        inputType: ee,
                        invalidTagText: ne,
                        limitTagsText: xe,
                        limit: ce,
                        placeholder: de,
                        separator: H,
                        size: j,
                        tagClass: q,
                        tagRemoveLabel: ae,
                        tagVariant: te,
                    } = n
                    return {
                        addButtonText: T,
                        addButtonVariant: Q,
                        addTag: C,
                        disableAddButton: Ae,
                        disabled: a.value,
                        duplicateTagText: k,
                        duplicateTags: he,
                        form: J,
                        inputAttrs: { ...W, disabled: a.value, form: J, id: L, value: U },
                        inputHandlers: { input: N, keydown: R, change: M },
                        inputId: L,
                        inputType: ee,
                        invalidTagText: ne,
                        invalidTags: ie,
                        isDuplicate: le,
                        isInvalid: Te,
                        isLimitReached: ye,
                        limitTagsText: xe,
                        limit: ce,
                        noTagRemove: g.value,
                        placeholder: de,
                        removeTag: S,
                        required: _.value,
                        separator: H,
                        size: j,
                        state: A.value,
                        tagClass: q,
                        tagPills: B.value,
                        tagRemoveLabel: ae,
                        tagVariant: te,
                        tags: G,
                    }
                })
            return (T, Q) => (
                openBlock(),
                createElementBlock(
                    "div",
                    {
                        id: unref(I),
                        class: normalizeClass(["b-form-tags form-control h-auto", unref(oe)]),
                        role: "group",
                        tabindex: "-1",
                        onFocusin: u,
                        onFocusout: Q[1] || (Q[1] = (k) => T.$emit("focusout", k)),
                    },
                    [
                        createBaseVNode(
                            "output",
                            {
                                id: `${unref(I)}selected_tags__`,
                                class: "visually-hidden",
                                role: "status",
                                for: unref(L),
                                "aria-live": Z.value ? "polite" : "off",
                                "aria-atomic": "true",
                                "aria-relevant": "additions text",
                            },
                            toDisplayString(G.value.join(", ")),
                            9,
                            $s
                        ),
                        createBaseVNode(
                            "div",
                            {
                                id: `${unref(I)}removed_tags__`,
                                role: "status",
                                "aria-live": Z.value ? "assertive" : "off",
                                "aria-atomic": "true",
                                class: "visually-hidden",
                            },
                            " (" + toDisplayString(t.tagRemovedLabel) + ") " + toDisplayString(Y.value),
                            9,
                            ks
                        ),
                        renderSlot(T.$slots, "default", normalizeProps(guardReactiveProps(unref(b))), () => [
                            createBaseVNode(
                                "ul",
                                {
                                    id: `${unref(I)}tag_list__`,
                                    class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center",
                                },
                                [
                                    (openBlock(!0),
                                    createElementBlock(
                                        Fragment$1,
                                        null,
                                        renderList(
                                            G.value,
                                            (k) => (
                                                openBlock(),
                                                createBlock$1(
                                                    qa,
                                                    {
                                                        key: k,
                                                        class: normalizeClass(t.tagClass),
                                                        tag: "li",
                                                        variant: t.tagVariant,
                                                        pill: unref(B),
                                                        onRemove: S,
                                                    },
                                                    { default: withCtx(() => [createTextVNode(toDisplayString(k), 1)]), _: 2 },
                                                    1032,
                                                    ["class", "variant", "pill"]
                                                )
                                            )
                                        ),
                                        128
                                    )),
                                    createBaseVNode(
                                        "li",
                                        {
                                            role: "none",
                                            "aria-live": "off",
                                            class: "b-from-tags-field flex-grow-1",
                                            "aria-controls": `${unref(I)}tag_list__`,
                                        },
                                        [
                                            createBaseVNode("div", Ts, [
                                                createBaseVNode(
                                                    "input",
                                                    mergeProps(
                                                        {
                                                            id: unref(L),
                                                            ref_key: "input",
                                                            ref: D,
                                                            disabled: unref(a),
                                                            value: U.value,
                                                            type: t.inputType,
                                                            placeholder: t.placeholder,
                                                            class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                                                            style: { outline: "currentcolor none 0px", "min-width": "5rem" },
                                                        },
                                                        t.inputAttrs,
                                                        {
                                                            form: t.form,
                                                            required: unref(_),
                                                            onInput: N,
                                                            onChange: M,
                                                            onKeydown: R,
                                                            onFocus: E,
                                                            onBlur: $,
                                                        }
                                                    ),
                                                    null,
                                                    16,
                                                    ws
                                                ),
                                                unref(Ae)
                                                    ? (openBlock(),
                                                      createElementBlock(
                                                          "button",
                                                          {
                                                              key: 0,
                                                              type: "button",
                                                              class: normalizeClass([
                                                                  "btn b-form-tags-button py-0",
                                                                  [
                                                                      `btn-${t.addButtonVariant}`,
                                                                      { "disabled invisible": U.value.length === 0 },
                                                                      t.inputClass,
                                                                  ],
                                                              ]),
                                                              style: { "font-size": "90%" },
                                                              disabled: unref(a) || U.value.length === 0 || unref(ye),
                                                              onClick: Q[0] || (Q[0] = (k) => C(U.value)),
                                                          },
                                                          [
                                                              renderSlot(T.$slots, "add-button-text", {}, () => [
                                                                  createTextVNode(toDisplayString(t.addButtonText), 1),
                                                              ]),
                                                          ],
                                                          10,
                                                          _s
                                                      ))
                                                    : createCommentVNode("", !0),
                                            ]),
                                        ],
                                        8,
                                        Cs
                                    ),
                                ],
                                8,
                                Ss
                            ),
                            createBaseVNode("div", Vs, [
                                unref(Te)
                                    ? (openBlock(),
                                      createElementBlock("div", xs, toDisplayString(t.invalidTagText) + ": " + toDisplayString(U.value), 1))
                                    : createCommentVNode("", !0),
                                unref(le)
                                    ? (openBlock(),
                                      createElementBlock("small", As, toDisplayString(t.duplicateTagText) + ": " + toDisplayString(U.value), 1))
                                    : createCommentVNode("", !0),
                                G.value.length === t.limit
                                    ? (openBlock(), createElementBlock("small", Is, "Tag limit reached"))
                                    : createCommentVNode("", !0),
                            ]),
                        ]),
                        t.name
                            ? (openBlock(!0),
                              createElementBlock(
                                  Fragment$1,
                                  { key: 0 },
                                  renderList(
                                      G.value,
                                      (k) => (
                                          openBlock(),
                                          createElementBlock("input", { key: k, type: "hidden", name: t.name, value: k }, null, 8, Fs)
                                      )
                                  ),
                                  128
                              ))
                            : createCommentVNode("", !0),
                    ],
                    42,
                    Bs
                )
            )
        },
    }),
    zs = defineComponent({
        props: {
            ...ma,
            noResize: { type: [Boolean, String], default: !1 },
            rows: { type: [String, Number], required: !1, default: 2 },
            wrap: { type: String, default: "soft" },
        },
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(t, { emit: e }) {
            const n = s$1(toRef(t, "noResize")),
                i = computed(() => ({
                    "form-control": !t.plaintext,
                    "form-control-plaintext": t.plaintext,
                    [`form-control-${t.size}`]: !!t.size,
                    "is-valid": t.state === !0,
                    "is-invalid": t.state === !1,
                })),
                o = computed(() => (n.value ? { resize: "none" } : void 0)),
                { input: a, computedId: l, computedAriaInvalid: c, onInput: g, onChange: v, onBlur: _, focus: A, blur: B } = ga(t, e)
            return {
                input: a,
                computedId: l,
                computedAriaInvalid: c,
                onInput: g,
                onChange: v,
                onBlur: _,
                focus: A,
                blur: B,
                classes: i,
                computedStyles: o,
            }
        },
    }),
    Ns = [
        "id",
        "name",
        "form",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "aria-required",
        "aria-invalid",
        "rows",
        "wrap",
    ]
function Ls(t, e, n, i, o, a) {
    return (
        openBlock(),
        createElementBlock(
            "textarea",
            mergeProps(
                {
                    id: t.computedId,
                    ref: "input",
                    class: t.classes,
                    name: t.name || void 0,
                    form: t.form || void 0,
                    disabled: t.disabled,
                    placeholder: t.placeholder,
                    required: t.required,
                    autocomplete: t.autocomplete || void 0,
                    readonly: t.readonly || t.plaintext,
                    "aria-required": t.required ? "true" : void 0,
                    "aria-invalid": t.computedAriaInvalid,
                    rows: t.rows,
                    style: t.computedStyles,
                    wrap: t.wrap || void 0,
                },
                t.$attrs,
                {
                    onInput: e[0] || (e[0] = (l) => t.onInput(l)),
                    onChange: e[1] || (e[1] = (l) => t.onChange(l)),
                    onBlur: e[2] || (e[2] = (l) => t.onBlur(l)),
                }
            ),
            null,
            16,
            Ns
        )
    )
}
const Ps = be(zs, [["render", Ls]]),
    Es = { key: 0, class: "input-group-text" },
    Hs = { key: 0 },
    Rs = ["innerHTML"],
    qs = { key: 0, class: "input-group-text" },
    Ds = { key: 0 },
    js = ["innerHTML"],
    Ms = defineComponent({
        __name: "BInputGroup",
        props: { append: null, appendHtml: null, id: null, prepend: null, prependHtml: null, size: null, tag: { default: "div" } },
        setup(t) {
            const e = t,
                n = computed(() => ({ "input-group-sm": e.size === "sm", "input-group-lg": e.size === "lg" })),
                i = computed(() => !!e.append || !!e.appendHtml),
                o = computed(() => !!e.prepend || !!e.prependHtml),
                a = computed(() => !!e.appendHtml),
                l = computed(() => !!e.prependHtml)
            return (c, g) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { id: t.id, class: normalizeClass(["input-group", unref(n)]), role: "group" },
                    {
                        default: withCtx(() => [
                            renderSlot(c.$slots, "prepend", {}, () => [
                                unref(o)
                                    ? (openBlock(),
                                      createElementBlock("span", Es, [
                                          unref(l)
                                              ? createCommentVNode("", !0)
                                              : (openBlock(), createElementBlock("span", Hs, toDisplayString(t.prepend), 1)),
                                          unref(l)
                                              ? (openBlock(), createElementBlock("span", { key: 1, innerHTML: t.prependHtml }, null, 8, Rs))
                                              : createCommentVNode("", !0),
                                      ]))
                                    : createCommentVNode("", !0),
                            ]),
                            renderSlot(c.$slots, "default"),
                            renderSlot(c.$slots, "append", {}, () => [
                                unref(i)
                                    ? (openBlock(),
                                      createElementBlock("span", qs, [
                                          unref(a)
                                              ? createCommentVNode("", !0)
                                              : (openBlock(), createElementBlock("span", Ds, toDisplayString(t.append), 1)),
                                          unref(a)
                                              ? (openBlock(), createElementBlock("span", { key: 1, innerHTML: t.appendHtml }, null, 8, js))
                                              : createCommentVNode("", !0),
                                      ]))
                                    : createCommentVNode("", !0),
                            ]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    Da = defineComponent({
        __name: "BInputGroupText",
        props: { tag: { default: "div" } },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: "input-group-text" },
                    { default: withCtx(() => [renderSlot(e.$slots, "default")]), _: 3 }
                )
            )
        },
    }),
    _t = defineComponent({
        __name: "BInputGroupAddon",
        props: { append: { default: !1 }, id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "append")),
                i = s$1(toRef(e, "isText")),
                o = computed(() => ({ "input-group-append": n.value, "input-group-prepend": !n.value }))
            return (a, l) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { id: t.id, class: normalizeClass(["d-flex", unref(o)]) },
                    {
                        default: withCtx(() => [
                            unref(i)
                                ? (openBlock(),
                                  createBlock$1(Da, { key: 0 }, { default: withCtx(() => [renderSlot(a.$slots, "default")]), _: 3 }))
                                : renderSlot(a.$slots, "default", { key: 1 }),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    Gs = defineComponent({
        __name: "BInputGroupAppend",
        props: { id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(t) {
            const e = s$1(toRef(t, "isText"))
            return (n, i) => (
                openBlock(),
                createBlock$1(
                    _t,
                    { id: t.id, "is-text": unref(e), tag: t.tag, append: "" },
                    { default: withCtx(() => [renderSlot(n.$slots, "default")]), _: 3 },
                    8,
                    ["id", "is-text", "tag"]
                )
            )
        },
    }),
    Us = defineComponent({
        __name: "BInputGroupPrepend",
        props: { id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(t) {
            const e = s$1(toRef(t, "isText"))
            return (n, i) => (
                openBlock(),
                createBlock$1(
                    _t,
                    { id: t.id, "is-text": unref(e), tag: t.tag, append: !1 },
                    { default: withCtx(() => [renderSlot(n.$slots, "default")]), _: 3 },
                    8,
                    ["id", "is-text", "tag"]
                )
            )
        },
    }),
    ja = Symbol(),
    Ws = defineComponent({
        __name: "BListGroup",
        props: {
            flush: { default: !1 },
            horizontal: { type: [Boolean, String], default: !1 },
            numbered: { default: !1 },
            tag: { default: "div" },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "flush")),
                i = s$1(toRef(e, "numbered")),
                o = computed(() => {
                    const l = n.value ? !1 : e.horizontal
                    return {
                        "list-group-flush": n.value,
                        "list-group-horizontal": l === !0,
                        [`list-group-horizontal-${l}`]: typeof l == "string",
                        "list-group-numbered": i.value,
                    }
                }),
                a = computed(() => (i.value === !0 ? "ol" : e.tag))
            return (
                provide(ja, { numbered: i.value }),
                (l, c) => (
                    openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(unref(a)),
                        { class: normalizeClass(["list-group", unref(o)]) },
                        { default: withCtx(() => [renderSlot(l.$slots, "default")]), _: 3 },
                        8,
                        ["class"]
                    )
                )
            )
        },
    }),
    Xs = defineComponent({
        __name: "BListGroupItem",
        props: {
            action: { default: !1 },
            active: { default: !1 },
            button: { default: !1 },
            disabled: { default: !1 },
            href: null,
            tag: { default: "div" },
            target: { default: "_self" },
            to: null,
            variant: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "action")),
                i = s$1(toRef(e, "active")),
                o = s$1(toRef(e, "button")),
                a = s$1(toRef(e, "disabled")),
                l = useAttrs(),
                c = inject(ja, null),
                g = computed(() => !o.value && (!!e.href || !!e.to)),
                v = computed(() => (c != null && c.numbered ? "li" : o.value ? "button" : g.value ? pe : e.tag)),
                _ = computed(() => {
                    const B = n.value || g.value || o.value || ["a", "router-link", "button", "b-link"].includes(e.tag)
                    return {
                        [`list-group-item-${e.variant}`]: e.variant !== void 0,
                        "list-group-item-action": B,
                        active: i.value,
                        disabled: a.value,
                    }
                }),
                A = computed(() => {
                    const B = {}
                    return o.value && ((!l || !l.type) && (B.type = "button"), a.value && (B.disabled = !0)), B
                })
            return (B, D) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(unref(v)),
                    mergeProps(
                        {
                            class: ["list-group-item", unref(_)],
                            "aria-current": unref(i) ? !0 : null,
                            "aria-disabled": unref(a) ? !0 : null,
                            target: unref(g) ? t.target : null,
                            href: unref(o) ? null : t.href,
                            to: unref(o) ? null : t.to,
                        },
                        unref(A)
                    ),
                    { default: withCtx(() => [renderSlot(B.$slots, "default")]), _: 3 },
                    16,
                    ["class", "aria-current", "aria-disabled", "target", "href", "to"]
                )
            )
        },
    }),
    Ks = ["id"],
    Js = ["aria-label"],
    Ys = { inheritAttrs: !1 },
    Zs = defineComponent({
        ...Ys,
        __name: "BModal",
        props: {
            bodyBgVariant: null,
            bodyClass: null,
            bodyTextVariant: null,
            busy: { default: !1 },
            lazy: { default: !1 },
            buttonSize: { default: "md" },
            cancelDisabled: { default: !1 },
            cancelTitle: { default: "Cancel" },
            cancelVariant: { default: "secondary" },
            centered: { default: !1 },
            contentClass: null,
            dialogClass: null,
            footerBgVariant: null,
            footerBorderVariant: null,
            footerClass: null,
            footerTextVariant: null,
            fullscreen: { type: [Boolean, String], default: !1 },
            headerBgVariant: null,
            headerBorderVariant: null,
            headerClass: null,
            headerCloseLabel: { default: "Close" },
            headerCloseWhite: { default: !1 },
            headerTextVariant: null,
            hideBackdrop: { default: !1 },
            hideFooter: { default: !1 },
            hideHeader: { default: !1 },
            hideHeaderClose: { default: !1 },
            id: null,
            modalClass: null,
            modelValue: { default: !1 },
            noCloseOnBackdrop: { default: !1 },
            noCloseOnEsc: { default: !1 },
            noFade: { default: !1 },
            noFocus: { default: !1 },
            okDisabled: { default: !1 },
            okOnly: { default: !1 },
            okTitle: { default: "Ok" },
            okVariant: { default: "primary" },
            scrollable: { default: !1 },
            show: { default: !1 },
            size: null,
            title: null,
            titleClass: null,
            titleSrOnly: { default: !1 },
            titleTag: { default: "h5" },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "busy")),
                o = s$1(toRef(n, "lazy")),
                a = s$1(toRef(n, "cancelDisabled")),
                l = s$1(toRef(n, "centered")),
                c = s$1(toRef(n, "headerCloseWhite")),
                g = s$1(toRef(n, "hideBackdrop")),
                v = s$1(toRef(n, "hideFooter")),
                _ = s$1(toRef(n, "hideHeader")),
                A = s$1(toRef(n, "hideHeaderClose")),
                B = s$1(toRef(n, "modelValue")),
                D = s$1(toRef(n, "noCloseOnBackdrop")),
                I = s$1(toRef(n, "noCloseOnEsc")),
                L = s$1(toRef(n, "noFade")),
                G = s$1(toRef(n, "noFocus")),
                U = s$1(toRef(n, "okDisabled")),
                F = s$1(toRef(n, "okOnly")),
                Z = s$1(toRef(n, "scrollable")),
                Y = s$1(toRef(n, "show")),
                X = s$1(toRef(n, "titleSrOnly")),
                ie = ref(!1),
                he = useSlots(),
                oe = ref(),
                le = ref(),
                Te = computed(() => [{ fade: !L.value, show: Y.value }, n.modalClass]),
                ye = computed(() => [
                    {
                        "modal-fullscreen": typeof n.fullscreen == "boolean" ? n.fullscreen : !1,
                        [`modal-fullscreen-${n.fullscreen}-down`]: typeof n.fullscreen == "string" ? n.fullscreen : !1,
                        [`modal-${n.size}`]: n.size,
                        "modal-dialog-centered": l.value,
                        "modal-dialog-scrollable": Z.value,
                    },
                    n.dialogClass,
                ]),
                Ae = computed(() => [
                    { [`bg-${n.bodyBgVariant}`]: n.bodyBgVariant, [`text-${n.bodyTextVariant}`]: n.bodyTextVariant },
                    n.bodyClass,
                ]),
                O = computed(() => [
                    {
                        [`bg-${n.headerBgVariant}`]: n.headerBgVariant,
                        [`border-${n.headerBorderVariant}`]: n.headerBorderVariant,
                        [`text-${n.headerTextVariant}`]: n.headerTextVariant,
                    },
                    n.headerClass,
                ]),
                u = computed(() => [
                    {
                        [`bg-${n.footerBgVariant}`]: n.footerBgVariant,
                        [`border-${n.footerBorderVariant}`]: n.footerBorderVariant,
                        [`text-${n.footerTextVariant}`]: n.footerTextVariant,
                    },
                    n.footerClass,
                ]),
                E = computed(() => [{ ["visually-hidden"]: X.value }, n.titleClass]),
                $ = computed(() => !!he["header-close"]),
                N = computed(() => [{ ["btn-close-content"]: $.value, ["d-flex"]: $.value, ["btn-close-white"]: !$.value && c.value }]),
                M = computed(() => a.value || i.value),
                R = computed(() => U.value || i.value)
            re(oe, "shown.bs.modal", (k) => C(k)), re(oe, "hidden.bs.modal", (k) => S(k))
            const C = (k) => {
                    e("shown", k), o.value === !0 && (ie.value = !0)
                },
                S = (k) => {
                    e("hidden", k), o.value === !0 && (ie.value = !1)
                },
                b = () => {
                    e("update:modelValue", !0), Q().show()
                },
                T = () => {
                    e("update:modelValue", !1), Q().hide()
                },
                Q = () => (
                    le.value !== void 0 || (le.value = new Modal(oe.value, { backdrop: !1, keyboard: !I.value, focus: !G.value })), le.value
                )
            return (
                onMounted(() => {
                    B.value && Q().show()
                }),
                watch(
                    () => n.noCloseOnBackdrop,
                    (k) => {
                        Q()._config.backdrop = n.hideBackdrop ? !1 : k ? "static" : !n.hideBackdrop
                    }
                ),
                watch(
                    () => n.noCloseOnEsc,
                    (k) => {
                        Q()._config.keyboard = !k
                    }
                ),
                watch(
                    () => B.value,
                    (k) => {
                        nextTick(() => {
                            k ? b() : T()
                        })
                    }
                ),
                (k, W) => (
                    openBlock(),
                    createBlock$1(Teleport, { to: "body" }, [
                        createBaseVNode(
                            "div",
                            mergeProps({ id: t.id, ref_key: "element", ref: oe, class: ["modal", unref(Te)], tabindex: "-1" }, k.$attrs),
                            [
                                createBaseVNode(
                                    "div",
                                    { class: normalizeClass(["modal-dialog", unref(ye)]) },
                                    [
                                        !unref(o) || (unref(o) && ie.value) || (unref(o) && unref(B) === !0)
                                            ? (openBlock(),
                                              createElementBlock(
                                                  "div",
                                                  { key: 0, class: normalizeClass(["modal-content", t.contentClass]) },
                                                  [
                                                      unref(_)
                                                          ? createCommentVNode("", !0)
                                                          : (openBlock(),
                                                            createElementBlock(
                                                                "div",
                                                                { key: 0, class: normalizeClass(["modal-header", unref(O)]) },
                                                                [
                                                                    (openBlock(),
                                                                    createBlock$1(
                                                                        resolveDynamicComponent(t.titleTag),
                                                                        { class: normalizeClass(["modal-title", unref(E)]) },
                                                                        {
                                                                            default: withCtx(() => [
                                                                                renderSlot(
                                                                                    k.$slots,
                                                                                    "title",
                                                                                    {},
                                                                                    () => [createTextVNode(toDisplayString(t.title), 1)],
                                                                                    !0
                                                                                ),
                                                                            ]),
                                                                            _: 3,
                                                                        },
                                                                        8,
                                                                        ["class"]
                                                                    )),
                                                                    unref(A)
                                                                        ? createCommentVNode("", !0)
                                                                        : (openBlock(),
                                                                          createElementBlock(
                                                                              "button",
                                                                              {
                                                                                  key: 0,
                                                                                  type: "button",
                                                                                  class: normalizeClass(["btn-close", unref(N)]),
                                                                                  "data-bs-dismiss": "modal",
                                                                                  "aria-label": t.headerCloseLabel,
                                                                              },
                                                                              [renderSlot(k.$slots, "header-close", {}, void 0, !0)],
                                                                              10,
                                                                              Js
                                                                          )),
                                                                ],
                                                                2
                                                            )),
                                                      createBaseVNode(
                                                          "div",
                                                          { class: normalizeClass(["modal-body", unref(Ae)]) },
                                                          [renderSlot(k.$slots, "default", {}, void 0, !0)],
                                                          2
                                                      ),
                                                      unref(v)
                                                          ? createCommentVNode("", !0)
                                                          : (openBlock(),
                                                            createElementBlock(
                                                                "div",
                                                                { key: 1, class: normalizeClass(["modal-footer", unref(u)]) },
                                                                [
                                                                    renderSlot(
                                                                        k.$slots,
                                                                        "footer",
                                                                        {},
                                                                        () => [
                                                                            unref(F)
                                                                                ? createCommentVNode("", !0)
                                                                                : (openBlock(),
                                                                                  createBlock$1(
                                                                                      je,
                                                                                      {
                                                                                          key: 0,
                                                                                          type: "button",
                                                                                          class: "btn",
                                                                                          disabled: unref(M),
                                                                                          size: t.buttonSize,
                                                                                          variant: t.cancelVariant,
                                                                                          onClick:
                                                                                              W[0] || (W[0] = (J) => (T(), k.$emit("cancel"))),
                                                                                      },
                                                                                      {
                                                                                          default: withCtx(() => [
                                                                                              createTextVNode(toDisplayString(t.cancelTitle), 1),
                                                                                          ]),
                                                                                          _: 1,
                                                                                      },
                                                                                      8,
                                                                                      ["disabled", "size", "variant"]
                                                                                  )),
                                                                            createVNode(
                                                                                je,
                                                                                {
                                                                                    type: "button",
                                                                                    class: "btn",
                                                                                    disabled: unref(R),
                                                                                    size: t.buttonSize,
                                                                                    variant: t.okVariant,
                                                                                    onClick: W[1] || (W[1] = (J) => (T(), k.$emit("ok"))),
                                                                                },
                                                                                {
                                                                                    default: withCtx(() => [
                                                                                        createTextVNode(toDisplayString(t.okTitle), 1),
                                                                                    ]),
                                                                                    _: 1,
                                                                                },
                                                                                8,
                                                                                ["disabled", "size", "variant"]
                                                                            ),
                                                                        ],
                                                                        !0
                                                                    ),
                                                                ],
                                                                2
                                                            )),
                                                  ],
                                                  2
                                              ))
                                            : createCommentVNode("", !0),
                                    ],
                                    2
                                ),
                                unref(g) === !1
                                    ? (openBlock(),
                                      createElementBlock("div", {
                                          key: 0,
                                          class: "modal-backdrop fade show",
                                          onClick: W[2] || (W[2] = withModifiers((J) => unref(D) === !1 && T(), ["prevent"])),
                                      }))
                                    : createCommentVNode("", !0),
                            ],
                            16,
                            Ks
                        ),
                    ])
                )
            )
        },
    }),
    Qs = be(Zs, [["__scopeId", "data-v-0368138c"]]),
    ei = defineComponent({
        __name: "BNav",
        props: {
            align: null,
            cardHeader: { default: !1 },
            fill: { default: !1 },
            justified: { default: !1 },
            pills: { default: !1 },
            small: { default: !1 },
            tabs: { default: !1 },
            tag: { default: "ul" },
            vertical: { default: !1 },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "cardHeader")),
                i = s$1(toRef(e, "fill")),
                o = s$1(toRef(e, "justified")),
                a = s$1(toRef(e, "pills")),
                l = s$1(toRef(e, "small")),
                c = s$1(toRef(e, "tabs")),
                g = s$1(toRef(e, "vertical")),
                v = computed(() => ({
                    "nav-tabs": c.value,
                    "nav-pills": a.value && !c.value,
                    "card-header-tabs": !g.value && n.value && c.value,
                    "card-header-pills": !g.value && n.value && a.value && !c.value,
                    "flex-column": g.value,
                    "nav-fill": !g.value && i.value,
                    "nav-justified": !g.value && o.value,
                    [`justify-content-${e.align}`]: !g.value && e.align !== void 0,
                    small: l.value,
                }))
            return (_, A) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(["nav", unref(v)]) },
                    { default: withCtx(() => [renderSlot(_.$slots, "default")]), _: 3 },
                    8,
                    ["class"]
                )
            )
        },
    }),
    ti = defineComponent({
        __name: "BNavForm",
        props: { role: null, id: null, floating: { default: !1 }, novalidate: { default: !1 }, validated: { default: !1 } },
        setup(t) {
            const e = t,
                n = computed(() => ({ floating: e.floating, role: e.role, id: e.id, novalidate: e.novalidate, validated: e.validated }))
            return (i, o) => (
                openBlock(),
                createBlock$1(
                    La,
                    mergeProps(unref(n), { class: "d-flex" }),
                    { default: withCtx(() => [renderSlot(i.$slots, "default")]), _: 3 },
                    16
                )
            )
        },
    }),
    ai = at(Ie, ["event", "routerTag"]),
    li = defineComponent({
        components: { BLink: pe },
        props: { ...ai },
        setup(t) {
            return { disabledBoolean: s$1(toRef(t, "disabled")) }
        },
    }),
    ni = { class: "nav-item" }
function oi(t, e, n, i, o, a) {
    const l = resolveComponent("b-link")
    return (
        openBlock(),
        createElementBlock("li", ni, [
            createVNode(
                l,
                mergeProps({ class: "nav-link" }, t.$props, {
                    tabindex: t.disabledBoolean ? -1 : void 0,
                    "aria-disabled": t.disabledBoolean ? !0 : void 0,
                }),
                { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
                16,
                ["tabindex", "aria-disabled"]
            ),
        ])
    )
}
const si = be(li, [["render", oi]]),
    ii = { class: "nav-item dropdown" },
    ri = defineComponent({
        __name: "BNavItemDropdown",
        props: {
            id: null,
            text: null,
            size: null,
            offset: null,
            autoClose: { type: [Boolean, String], default: !0 },
            dark: { type: Boolean, default: !1 },
            dropleft: { type: Boolean, default: !1 },
            dropright: { type: Boolean, default: !1 },
            dropup: { type: Boolean, default: !1 },
            right: { type: Boolean, default: !1 },
            left: { type: [Boolean, String], default: !1 },
            split: { type: Boolean, default: !1 },
            splitVariant: null,
            noCaret: { type: Boolean, default: !1 },
            variant: { default: "link" },
        },
        setup(t) {
            return (e, n) => (
                openBlock(),
                createElementBlock("li", ii, [
                    createVNode(
                        Na,
                        mergeProps(e.$props, { "is-nav": "" }),
                        createSlots({ _: 2 }, [
                            renderList(e.$slots, (i, o) => ({
                                name: o,
                                fn: withCtx((a) => [renderSlot(e.$slots, o, normalizeProps(guardReactiveProps(a || {})))]),
                            })),
                        ]),
                        1040
                    ),
                ])
            )
        },
    }),
    ui = {},
    di = { class: "navbar-text" }
function ci(t, e) {
    return openBlock(), createElementBlock("li", di, [renderSlot(t.$slots, "default")])
}
const fi = be(ui, [["render", ci]]),
    vi = defineComponent({
        __name: "BNavbar",
        props: {
            fixed: null,
            print: { default: !1 },
            sticky: null,
            tag: { default: "nav" },
            toggleable: { type: [Boolean, String], default: !1 },
            dark: { default: !1 },
            variant: null,
            container: { type: [String, Boolean], default: "fluid" },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "print")),
                i = s$1(toRef(e, "dark")),
                o = computed(() => (e.tag === "nav" ? void 0 : "navigation")),
                a = computed(() =>
                    typeof e.toggleable == "string" ? `navbar-expand-${e.toggleable}` : e.toggleable === !1 ? "navbar-expand" : void 0
                ),
                l = computed(() => (e.container === !1 ? void 0 : e.container === !0 ? "container" : `container-${e.container}`)),
                c = computed(() => ({
                    "d-print": n.value,
                    [`sticky-${e.sticky}`]: e.sticky !== void 0,
                    "navbar-dark": i.value,
                    [`bg-${e.variant}`]: e.variant !== void 0,
                    [`fixed-${e.fixed}`]: e.fixed !== void 0,
                    [`${a.value}`]: a.value !== void 0,
                }))
            return (g, v) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { class: normalizeClass(["navbar", unref(c)]), role: unref(o) },
                    {
                        default: withCtx(() => [
                            t.container !== !1
                                ? (openBlock(),
                                  createElementBlock("div", { key: 0, class: normalizeClass(unref(l)) }, [renderSlot(g.$slots, "default")], 2))
                                : renderSlot(g.$slots, "default", { key: 1 }),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class", "role"]
                )
            )
        },
    }),
    Rt = at(Ie, ["event", "routerTag"]),
    bi = defineComponent({
        components: { BLink: pe },
        props: { tag: { type: String, default: "div" }, ...Rt },
        setup(t) {
            const e = computed(() => De(t)),
                n = computed(() => (e.value ? pe : t.tag))
            return { props: e.value ? la(Rt, t) : {}, computedTag: n }
        },
    })
function mi(t, e, n, i, o, a) {
    return (
        openBlock(),
        createBlock$1(
            resolveDynamicComponent(t.computedTag),
            mergeProps({ class: "navbar-brand" }, t.props),
            { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
            16
        )
    )
}
const gi = be(bi, [["render", mi]]),
    pi = defineComponent({
        __name: "BNavbarNav",
        props: { align: null, fill: { default: !1 }, justified: { default: !1 }, small: { default: !1 }, tag: { default: "ul" } },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "fill")),
                i = s$1(toRef(e, "justified")),
                o = s$1(toRef(e, "small")),
                a = computed(() => ({
                    "nav-fill": n.value,
                    "nav-justified": i.value,
                    [`justify-content-${e.align}`]: e.align !== void 0,
                    small: o.value,
                }))
            return (l, c) => (
                openBlock(), createElementBlock("ul", { class: normalizeClass(["navbar-nav", unref(a)]) }, [renderSlot(l.$slots, "default")], 2)
            )
        },
    }),
    hi = {
        mounted(t, e) {
            let n = e.value
            Object.keys(e.modifiers).length > 0 && ([n] = Object.keys(e.modifiers)),
                t.setAttribute("data-bs-toggle", "modal"),
                t.setAttribute("data-bs-target", `#${n}`)
        },
    },
    yi = {
        mounted(t, e) {
            let n = "right"
            const i = []
            e.modifiers.left
                ? (n = "left")
                : e.modifiers.right
                ? (n = "right")
                : e.modifiers.bottom
                ? (n = "bottom")
                : e.modifiers.top && (n = "top"),
                e.modifiers.manual
                    ? i.push("manual")
                    : (e.modifiers.click && i.push("click"), e.modifiers.hover && i.push("hover"), e.modifiers.focus && i.push("focus")),
                t.setAttribute("data-bs-toggle", "popover"),
                new Popover(t, { trigger: i.length === 0 ? "click" : i.join(" "), placement: n, content: e.value })
        },
        unmounted(t) {
            const e = Popover.getInstance(t)
            e == null || e.dispose()
        },
    },
    Bi = (t) => {
        if (t.manual) return "manual"
        const e = []
        return t.click && e.push("click"), t.hover && e.push("hover"), t.focus && e.push("focus"), e.length > 0 ? e.join(" ") : "hover focus"
    },
    $i = (t) => (t.left ? "left" : t.right ? "right" : t.bottom ? "bottom" : "top"),
    ki = (t) => (t != null && t.delay ? t.delay : 0),
    Si = {
        beforeMount(t, e) {
            t.setAttribute("data-bs-toggle", "tooltip")
            const n = /<("[^"]*"|'[^']*'|[^'">])*>/.test(t.title),
                i = Bi(e.modifiers),
                o = $i(e.modifiers),
                a = ki(e.value),
                l = t.getAttribute("title")
            new Tooltip(t, { trigger: i, placement: o, delay: a, html: n }), l && t.setAttribute("data-bs-original-title", l)
        },
        updated(t) {
            const e = t.getAttribute("title"),
                n = t.getAttribute("data-bs-original-title"),
                i = Tooltip.getInstance(t)
            t.removeAttribute("title"),
                e && e !== n && (i == null || i.setContent({ ".tooltip-inner": e }), t.setAttribute("data-bs-original-title", e))
        },
        unmounted(t) {
            const e = Tooltip.getInstance(t)
            e == null || e.dispose()
        },
    },
    Xe = new Map(),
    Ma = (t) => {
        if (Xe.has(t)) {
            const e = Xe.get(t)
            e && e.stop && e.stop(), Xe.delete(t)
        }
    },
    qt = (t, e) => {
        const n = { margin: "0px", once: !1, callback: e.value }
        Object.keys(e.modifiers).forEach((o) => {
            Number.isInteger(o) ? (n.margin = `${o}px`) : o.toLowerCase() === "once" && (n.once = !0)
        }),
            Ma(t)
        const i = new Ti(t, n.margin, n.once, n.callback, e.instance)
        Xe.set(t, i)
    },
    Ci = {
        beforeMount(t, e) {
            qt(t, e)
        },
        updated(t, e) {
            qt(t, e)
        },
        unmounted(t) {
            Ma(t)
        },
    }
class Ti {
    constructor(e, n, i, o, a) {
        se(this, "element"),
            se(this, "margin"),
            se(this, "once"),
            se(this, "callback"),
            se(this, "instance"),
            se(this, "observer"),
            se(this, "doneOnce"),
            se(this, "visible"),
            (this.element = e),
            (this.margin = n),
            (this.once = i),
            (this.callback = o),
            (this.instance = a),
            this.createObserver()
    }
    createObserver() {
        if ((this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function"))) {
            try {
                this.observer = new IntersectionObserver(this.handler.bind(this), { root: null, rootMargin: this.margin, threshold: 0 })
            } catch {
                console.error("Intersection Observer not supported"), (this.doneOnce = !0), (this.observer = void 0), this.callback(null)
                return
            }
            this.instance.$nextTick(() => {
                this.observer && this.observer.observe(this.element)
            })
        }
    }
    handler(e) {
        const [n] = e,
            i = Boolean(n.isIntersecting || n.intersectionRatio > 0)
        i !== this.visible && ((this.visible = i), this.callback(i), this.once && this.visible && ((this.doneOnce = !0), this.stop()))
    }
    stop() {
        this.observer && this.observer.disconnect(), (this.observer = null)
    }
}
const wi = {
        mounted(t, e) {
            e.value !== !1 && t.focus()
        },
    },
    _i = { BModal: hi, BPopover: yi, BToggle: Tt, BTooltip: Si, BVisible: Ci, focus: wi },
    Vi = createBaseVNode("span", { class: "navbar-toggler-icon" }, null, -1),
    xi = defineComponent({
        __name: "BNavbarToggle",
        props: { disabled: { default: !1 }, label: { default: "Toggle navigation" }, target: null },
        emits: ["click"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "disabled")),
                o = computed(() => ({ disabled: i.value, "aria-label": n.label })),
                a = computed(() => ({ disabled: i.value })),
                l = () => {
                    i.value || e("click")
                }
            return (c, g) =>
                withDirectives(
                    (openBlock(),
                    createElementBlock(
                        "button",
                        mergeProps({ class: ["navbar-toggler", unref(a)], type: "button" }, unref(o), { onClick: l }),
                        [renderSlot(c.$slots, "default", {}, () => [Vi])],
                        16
                    )),
                    [[unref(Tt), unref(i) ? void 0 : t.target]]
                )
        },
    }),
    Ai = ["data-bs-backdrop", "data-bs-scroll"],
    Ii = { class: "offcanvas-header" },
    Fi = { id: "offcanvasLabel", class: "offcanvas-title" },
    Oi = ["aria-label"],
    zi = { class: "offcanvas-body" },
    Ni = defineComponent({
        __name: "BOffcanvas",
        props: {
            dismissLabel: { default: "Close" },
            modelValue: { default: !1 },
            bodyScrolling: { default: !1 },
            backdrop: { default: !0 },
            placement: { default: "start" },
            title: null,
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "modelValue")),
                o = s$1(toRef(n, "bodyScrolling")),
                a = s$1(toRef(n, "backdrop")),
                l = ref(),
                c = ref()
            re(l, "shown.bs.offcanvas", () => e("shown")),
                re(l, "hidden.bs.offcanvas", () => e("hidden")),
                re(l, "show.bs.offcanvas", () => {
                    e("show"), e("update:modelValue", !0)
                }),
                re(l, "hide.bs.offcanvas", () => {
                    e("hide"), e("update:modelValue", !1)
                }),
                onMounted(() => {
                    var v
                    ;(c.value = new Offcanvas(l.value)), i.value && ((v = c.value) == null || v.show(l.value))
                })
            const g = computed(() => ({ [`offcanvas-${n.placement}`]: !!n.placement }))
            return (
                watch(
                    () => i.value,
                    (v) => {
                        var _, A
                        v ? (_ = c.value) == null || _.show(l.value) : (A = c.value) == null || A.hide()
                    }
                ),
                (v, _) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        {
                            ref_key: "element",
                            ref: l,
                            class: normalizeClass(["offcanvas", unref(g)]),
                            tabindex: "-1",
                            "aria-labelledby": "offcanvasLabel",
                            "data-bs-backdrop": unref(a),
                            "data-bs-scroll": unref(o),
                        },
                        [
                            createBaseVNode("div", Ii, [
                                createBaseVNode("h5", Fi, [
                                    renderSlot(v.$slots, "title", {}, () => [createTextVNode(toDisplayString(t.title), 1)]),
                                ]),
                                createBaseVNode(
                                    "button",
                                    {
                                        type: "button",
                                        class: "btn-close text-reset",
                                        "data-bs-dismiss": "offcanvas",
                                        "aria-label": t.dismissLabel,
                                    },
                                    null,
                                    8,
                                    Oi
                                ),
                            ]),
                            createBaseVNode("div", zi, [renderSlot(v.$slots, "default")]),
                        ],
                        10,
                        Ai
                    )
                )
            )
        },
    }),
    ut = { top: 0, left: 0, bottom: 0, right: 0 },
    Li = "default",
    Pi = "overlay",
    Ei = defineComponent({
        components: { BTransition: Ye },
        props: {
            bgColor: { type: String, required: !1 },
            blur: { type: String, default: "2px" },
            fixed: { type: [Boolean, String], default: !1 },
            noCenter: { type: [Boolean, String], default: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            noWrap: { type: [Boolean, String], default: !1 },
            opacity: {
                type: [Number, String],
                default: 0.85,
                validator: (t) => {
                    const e = St(t, 0)
                    return e >= 0 && e <= 1
                },
            },
            overlayTag: { type: String, default: "div" },
            rounded: { type: [Boolean, String], default: !1 },
            show: { type: [Boolean, String], default: !1 },
            spinnerSmall: { type: [Boolean, String], default: !1 },
            spinnerType: { type: String, default: "border" },
            spinnerVariant: { type: String, required: !1 },
            variant: { type: String, default: "light" },
            wrapTag: { type: String, default: "div" },
            zIndex: { type: [Number, String], default: 10 },
        },
        emits: ["click", "hidden", "shown"],
        setup(t, { slots: e, emit: n }) {
            const i = s$1(toRef(t, "fixed")),
                o = s$1(toRef(t, "noCenter")),
                a = s$1(toRef(t, "noFade")),
                l = s$1(toRef(t, "noWrap")),
                c = s$1(toRef(t, "show")),
                g = s$1(toRef(t, "spinnerSmall")),
                v = computed(() => (t.rounded === !0 || t.rounded === "" ? "rounded" : t.rounded ? `rounded-${t.rounded}` : "")),
                _ = computed(() => (t.variant && !t.bgColor ? `bg-${t.variant}` : "")),
                A = computed(() => ({ spinnerType: t.spinnerType || null, spinnerVariant: t.spinnerVariant || null, spinnerSmall: g.value }))
            return () => {
                const B = (L) => h$1(resolveComponent("BSpinner"), { type: L.spinnerType, variant: L.spinnerVariant, small: g.value })
                let D = ""
                if (c.value) {
                    const L = h$1("div", {
                            class: ["position-absolute", _.value, v.value],
                            style: {
                                ...ut,
                                opacity: t.opacity,
                                backgroundColor: t.bgColor || null,
                                backdropFilter: t.blur ? `blur(${t.blur})` : null,
                            },
                        }),
                        G = h$1(
                            "div",
                            {
                                class: "position-absolute",
                                style: o.value ? { ...ut } : { top: "50%", left: "50%", transform: "translateX(-50%) translateY(-50%)" },
                            },
                            ge(Pi, A.value, e) || B(A.value) || ""
                        )
                    D = h$1(
                        t.overlayTag,
                        {
                            class: [
                                "b-overlay",
                                { "position-absolute": !l.value || (l.value && !i.value), "position-fixed": l.value && i.value },
                            ],
                            style: { ...ut, zIndex: t.zIndex || 10 },
                            onClick: (U) => n("click", U),
                            key: "overlay",
                        },
                        [L, G]
                    )
                }
                const I = () =>
                    h$1(
                        Ye,
                        {
                            noFade: a.value,
                            transProps: { enterToClass: "show" },
                            name: "fade",
                            onAfterEnter: () => n("shown"),
                            onAfterLeave: () => n("hidden"),
                        },
                        { default: () => D }
                    )
                return l.value
                    ? I()
                    : h$1(t.wrapTag, { class: ["b-overlay-wrap position-relative"], "aria-busy": c.value ? "true" : null }, [
                          h$1("span", ge(Li, {}, e)),
                          I(),
                      ])
            }
        },
    }),
    Hi = 5,
    Ga = 20,
    Ua = 0,
    Be = 3,
    Ri = "ellipsis-text",
    qi = "first-text",
    Di = "last-text",
    ji = "next-text",
    Mi = "page",
    Gi = "prev-text",
    Dt = (t) => Math.max(Ee(t) || Ga, 1),
    jt = (t) => Math.max(Ee(t) || Ua, 0),
    Ui = (t, e) => {
        const n = Ee(t) || 1
        return n > e ? e : n < 1 ? 1 : n
    },
    Wi = defineComponent({
        name: "BPagination",
        props: {
            align: { type: String, default: "start" },
            ariaControls: { type: String, required: !1 },
            ariaLabel: { type: String, default: "Pagination" },
            disabled: { type: [Boolean, String], default: !1 },
            ellipsisClass: { type: [Array, String], default: () => [] },
            ellipsisText: { type: String, default: "\u2026" },
            firstClass: { type: [Array, String], default: () => [] },
            firstNumber: { type: [Boolean, String], default: !1 },
            firstText: { type: String, default: "\xAB" },
            hideEllipsis: { type: [Boolean, String], default: !1 },
            hideGotoEndButtons: { type: [Boolean, String], default: !1 },
            labelFirstPage: { type: String, default: "Go to first page" },
            labelLastPage: { type: String, default: "Go to last page" },
            labelNextPage: { type: String, default: "Go to next page" },
            labelPage: { type: String, default: "Go to page" },
            labelPrevPage: { type: String, default: "Go to previous page" },
            lastClass: { type: [Array, String], default: () => [] },
            lastNumber: { type: [Boolean, String], default: !1 },
            lastText: { type: String, default: "\xBB" },
            limit: { type: Number, default: Hi },
            modelValue: { type: Number, default: 1 },
            nextClass: { type: [Array, String], default: () => [] },
            nextText: { type: String, default: "\u203A" },
            pageClass: { type: [Array, String], default: () => [] },
            perPage: { type: Number, default: Ga },
            pills: { type: [Boolean, String], default: !1 },
            prevClass: { type: [Array, String], default: () => [] },
            prevText: { type: String, default: "\u2039" },
            size: { type: String, required: !1 },
            totalRows: { type: Number, default: Ua },
        },
        emits: ["update:modelValue", "page-click"],
        setup(t, { emit: e, slots: n }) {
            const i = s$1(toRef(t, "disabled")),
                o = s$1(toRef(t, "firstNumber")),
                a = s$1(toRef(t, "hideEllipsis")),
                l = s$1(toRef(t, "hideGotoEndButtons")),
                c = s$1(toRef(t, "lastNumber")),
                g = s$1(toRef(t, "pills")),
                v = $l(toRef(t, "align")),
                _ = computed(() => Math.ceil(jt(t.totalRows) / Dt(t.perPage))),
                A = computed(() => {
                    let Y
                    return (
                        _.value - t.modelValue + 2 < t.limit && t.limit > Be
                            ? (Y = _.value - D.value + 1)
                            : (Y = t.modelValue - Math.floor(D.value / 2)),
                        Y < 1 ? (Y = 1) : Y > _.value - D.value && (Y = _.value - D.value + 1),
                        t.limit <= Be && c.value && _.value === Y + D.value - 1 && (Y = Math.max(Y - 1, 1)),
                        Y
                    )
                }),
                B = computed(() => {
                    const Y = _.value - t.modelValue
                    let X = !1
                    return (
                        Y + 2 < t.limit && t.limit > Be ? t.limit > Be && (X = !0) : t.limit > Be && (X = !!(!a.value || o.value)),
                        A.value <= 1 && (X = !1),
                        X && o.value && A.value < 4 && (X = !1),
                        X
                    )
                }),
                D = computed(() => {
                    let Y = t.limit
                    return (
                        _.value <= t.limit
                            ? (Y = _.value)
                            : t.modelValue < t.limit - 1 && t.limit > Be
                            ? ((!a.value || c.value) && (Y = t.limit - (o.value ? 0 : 1)), (Y = Math.min(Y, t.limit)))
                            : _.value - t.modelValue + 2 < t.limit && t.limit > Be
                            ? (!a.value || o.value) && (Y = t.limit - (c.value ? 0 : 1))
                            : t.limit > Be && (Y = t.limit - (a.value ? 0 : 2)),
                        Y
                    )
                }),
                I = computed(() => {
                    const Y = _.value - D.value
                    let X = !1
                    t.modelValue < t.limit - 1 && t.limit > Be
                        ? (!a.value || c.value) && (X = !0)
                        : t.limit > Be && (X = !!(!a.value || c.value)),
                        A.value > Y && (X = !1)
                    const ie = A.value + D.value - 1
                    return X && c.value && ie > _.value - 3 && (X = !1), X
                }),
                L = reactive({ pageSize: Dt(t.perPage), totalRows: jt(t.totalRows), numberOfPages: _.value }),
                G = (Y, X) => {
                    if (X === t.modelValue) return
                    const { target: ie } = Y,
                        he = new Qe("page-click", { cancelable: !0, vueTarget: this, target: ie })
                    e("page-click", he, X), !he.defaultPrevented && e("update:modelValue", X)
                },
                U = computed(() => (t.size ? `pagination-${t.size}` : "")),
                F = computed(() => (g.value ? "b-pagination-pills" : ""))
            watch(
                () => t.modelValue,
                (Y) => {
                    const X = Ui(Y, _.value)
                    X !== t.modelValue && e("update:modelValue", X)
                }
            ),
                watch(L, (Y, X) => {
                    Yt(Y) ||
                        (((X.pageSize !== Y.pageSize && X.totalRows === Y.totalRows) ||
                            (X.numberOfPages !== Y.numberOfPages && t.modelValue > X.numberOfPages)) &&
                            e("update:modelValue", 1))
                })
            const Z = computed(() => {
                const Y = []
                for (let X = 0; X < D.value; X++) Y.push({ number: A.value + X, classes: null })
                return Y
            })
            return () => {
                const Y = [],
                    X = Z.value.map((u) => u.number),
                    ie = (u) => u === t.modelValue,
                    he = t.modelValue < 1,
                    oe = t.align === "fill",
                    le = (u, E, $, N, M, R) => {
                        const C = i.value || ie(R) || he || u < 1 || u > _.value,
                            S = u < 1 ? 1 : u > _.value ? _.value : u,
                            b = { disabled: C, page: S, index: S - 1 },
                            T = ge($, b, n) || N || ""
                        return h$1(
                            "li",
                            { class: ["page-item", { disabled: C, "flex-fill": oe, "d-flex": oe && !C }, M] },
                            h$1(
                                C ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !C && oe }],
                                    "aria-label": E,
                                    "aria-controls": t.ariaControls || null,
                                    "aria-disabled": C ? "true" : null,
                                    role: "menuitem",
                                    type: C ? null : "button",
                                    tabindex: C ? null : "-1",
                                    onClick: (Q) => {
                                        C || G(Q, S)
                                    },
                                },
                                T
                            )
                        )
                    },
                    Te = (u) =>
                        h$1(
                            "li",
                            {
                                class: ["page-item", "disabled", "bv-d-xs-down-none", oe ? "flex-fill" : "", t.ellipsisClass],
                                role: "separator",
                                key: `ellipsis-${u ? "last" : "first"}`,
                            },
                            [h$1("span", { class: ["page-link"] }, ge(Ri, {}, n) || t.ellipsisText || "...")]
                        ),
                    ye = (u, E) => {
                        const $ = ie(u.number) && !he,
                            N = i.value ? null : $ || (he && E === 0) ? "0" : "-1",
                            M = { active: $, disabled: i.value, page: u.number, index: u.number - 1, content: u.number },
                            R = ge(Mi, M, n) || u.number,
                            C = h$1(
                                i.value ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !i.value && oe }],
                                    "aria-controls": t.ariaControls || null,
                                    "aria-disabled": i.value ? "true" : null,
                                    "aria-label": t.labelPage ? `${t.labelPage} ${u.number}` : null,
                                    role: "menuitemradio",
                                    type: i.value ? null : "button",
                                    tabindex: N,
                                    onClick: (S) => {
                                        i.value || G(S, u.number)
                                    },
                                },
                                R
                            )
                        return h$1(
                            "li",
                            {
                                class: ["page-item", { disabled: i.value, active: $, "flex-fill": oe, "d-flex": oe && !i.value }, t.pageClass],
                                role: "presentation",
                                key: `page-${u.number}`,
                            },
                            C
                        )
                    }
                if (!l.value && !o.value) {
                    const u = le(1, t.labelFirstPage, qi, t.firstText, t.firstClass, 1)
                    Y.push(u)
                }
                const Ae = le(t.modelValue - 1, t.labelFirstPage, Gi, t.prevText, t.prevClass, 1)
                Y.push(Ae),
                    o.value && X[0] !== 1 && Y.push(ye({ number: 1 }, 0)),
                    B.value && Y.push(Te(!1)),
                    Z.value.forEach((u, E) => {
                        const $ = B.value && o.value && X[0] !== 1 ? 1 : 0
                        Y.push(ye(u, E + $))
                    }),
                    I.value && Y.push(Te(!0)),
                    c.value && X[X.length - 1] !== _.value && Y.push(ye({ number: _.value }, -1))
                const O = le(t.modelValue + 1, t.labelNextPage, ji, t.nextText, t.nextClass, _.value)
                if ((Y.push(O), !c.value && !l.value)) {
                    const u = le(_.value, t.labelLastPage, Di, t.lastText, t.lastClass, _.value)
                    Y.push(u)
                }
                return h$1(
                    "ul",
                    {
                        class: ["pagination", U.value, v.value, F.value],
                        role: "menubar",
                        "aria-disabled": i.value,
                        "aria-label": t.ariaLabel || null,
                    },
                    Y
                )
            }
        },
    }),
    Xi = defineComponent({
        props: {
            container: { type: [String, Object], default: "body" },
            content: { type: String },
            id: { type: String },
            customClass: { type: String, default: "" },
            noninteractive: { type: [Boolean, String], default: !1 },
            placement: { type: String, default: "right" },
            target: { type: [String, Object], default: void 0 },
            title: { type: String },
            delay: { type: [Number, Object], default: 0 },
            triggers: { type: String, default: "click" },
            show: { type: [Boolean, String], default: !1 },
            variant: { type: String, default: void 0 },
            html: { type: [Boolean, String], default: !0 },
            sanitize: { type: [Boolean, String], default: !1 },
            offset: { type: String, default: "0" },
        },
        emits: ["show", "shown", "hide", "hidden", "inserted"],
        setup(t, { emit: e, slots: n }) {
            s$1(toRef(t, "noninteractive"))
            const i = s$1(toRef(t, "show")),
                o = s$1(toRef(t, "html")),
                a = s$1(toRef(t, "sanitize")),
                l = ref(),
                c = ref(),
                g = ref(),
                v = ref(),
                _ = ref(),
                A = computed(() => ({ [`b-popover-${t.variant}`]: t.variant !== void 0 })),
                B = (L) => {
                    if (typeof L == "string" || L instanceof HTMLElement) return L
                    if (typeof L < "u") return L.$el
                },
                D = (L) => {
                    if (L) return typeof L == "string" ? document.getElementById(L) || void 0 : L
                },
                I = (L) => {
                    ;(c.value = D(B(L))),
                        c.value &&
                            (g.value = new Popover(c.value, {
                                customClass: t.customClass,
                                container: B(t.container),
                                trigger: t.triggers,
                                placement: t.placement,
                                title: t.title || n.title ? v.value : "",
                                content: _.value,
                                html: o.value,
                                delay: t.delay,
                                sanitize: a.value,
                                offset: t.offset,
                            }))
                }
            return (
                onMounted(() => {
                    var L, G, U
                    nextTick(() => {
                        I(t.target)
                    }),
                        (G = (L = l.value) == null ? void 0 : L.parentNode) == null || G.removeChild(l.value),
                        i.value && ((U = g.value) == null || U.show())
                }),
                onBeforeUnmount(() => {
                    var L
                    ;(L = g.value) == null || L.dispose()
                }),
                watch(
                    () => t.target,
                    (L) => {
                        var G
                        ;(G = g.value) == null || G.dispose(), I(L)
                    }
                ),
                watch(
                    () => i.value,
                    (L, G) => {
                        var U, F
                        L !== G && (L ? (U = g.value) == null || U.show() : (F = g.value) == null || F.hide())
                    }
                ),
                re(c, "show.bs.popover", () => e("show")),
                re(c, "shown.bs.popover", () => e("shown")),
                re(c, "hide.bs.popover", () => e("hide")),
                re(c, "hidden.bs.popover", () => e("hidden")),
                re(c, "inserted.bs.popover", () => e("inserted")),
                { element: l, titleRef: v, contentRef: _, classes: A }
            )
        },
    }),
    Ki = ["id"],
    Ji = { ref: "titleRef" },
    Yi = { ref: "contentRef" }
function Zi(t, e, n, i, o, a) {
    return (
        openBlock(),
        createElementBlock(
            "div",
            { id: t.id, ref: "element", class: normalizeClass(["popover b-popover", t.classes]), role: "tooltip", tabindex: "-1" },
            [
                createBaseVNode("div", Ji, [renderSlot(t.$slots, "title", {}, () => [createTextVNode(toDisplayString(t.title), 1)])], 512),
                createBaseVNode("div", Yi, [renderSlot(t.$slots, "default", {}, () => [createTextVNode(toDisplayString(t.content), 1)])], 512),
            ],
            10,
            Ki
        )
    )
}
const Qi = be(Xi, [["render", Zi]]),
    Wa = defineComponent({
        props: {
            animated: { type: [Boolean, String], default: !1 },
            label: { type: String },
            labelHtml: { type: String },
            max: { type: [Number, String] },
            precision: { type: [Number, String], default: 0 },
            showProgress: { type: [Boolean, String], default: !1 },
            showValue: { type: [Boolean, String], default: !1 },
            striped: { type: [Boolean, String], default: !1 },
            value: { type: [Number, String], default: 0 },
            variant: { type: String },
        },
        setup(t, { slots: e }) {
            const n = s$1(toRef(t, "animated")),
                i = s$1(toRef(t, "showProgress")),
                o = s$1(toRef(t, "showValue")),
                a = s$1(toRef(t, "striped")),
                l = inject(Xa),
                c = computed(() => ({
                    "progress-bar-animated": n.value || (l == null ? void 0 : l.animated),
                    "progress-bar-striped": a.value || (l == null ? void 0 : l.striped) || n.value || (l == null ? void 0 : l.animated),
                    [`bg-${t.variant}`]: t.variant !== void 0,
                })),
                g = computed(() => {
                    if (o.value || (l == null ? void 0 : l.showValue)) return parseFloat(t.value).toFixed(t.precision)
                    if (i.value || (l == null ? void 0 : l.showProgress)) {
                        const A = ((t.value * 100) / parseInt(t.max || 100)).toString()
                        return parseFloat(A).toFixed(t.precision)
                    }
                    return t.label || ""
                }),
                v = computed(() =>
                    t.max || (l == null ? void 0 : l.max)
                        ? `${(t.value * 100) / parseInt(t.max || (l == null ? void 0 : l.max))}%`
                        : typeof t.value == "string"
                        ? t.value
                        : `${t.value}%`
                ),
                _ = computed(() => {
                    const A = {
                        class: ["progress-bar", c.value],
                        role: "progressbar",
                        "aria-valuenow": t.value,
                        "aria-valuemin": 0,
                        "aria-valuemax": t.max,
                        style: { width: v.value },
                    }
                    return t.labelHtml ? { ...A, innerHTML: t.labelHtml } : A
                })
            return () => {
                var A
                return h$1("div", _.value, ((A = e.default) == null ? void 0 : A.call(e)) || g.value)
            }
        },
    }),
    Xa = Symbol(),
    er = defineComponent({
        __name: "BProgress",
        props: {
            variant: null,
            max: null,
            height: null,
            animated: { default: !1 },
            precision: { default: 0 },
            showProgress: { default: !1 },
            showValue: { default: !1 },
            striped: { default: !1 },
            value: { default: 0 },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "animated")),
                i = s$1(toRef(e, "showProgress")),
                o = s$1(toRef(e, "showValue")),
                a = s$1(toRef(e, "striped"))
            return (
                provide(Xa, { animated: n.value, max: e.max, showProgress: i.value, showValue: o.value, striped: a.value }),
                (l, c) => (
                    openBlock(),
                    createElementBlock(
                        "div",
                        { class: "progress", style: normalizeStyle({ height: t.height }) },
                        [
                            renderSlot(l.$slots, "default", {}, () => [
                                createVNode(
                                    Wa,
                                    normalizeProps(
                                        guardReactiveProps({
                                            animated: unref(n),
                                            max: t.max,
                                            precision: t.precision,
                                            showProgress: unref(i),
                                            showValue: unref(o),
                                            striped: unref(a),
                                            value: t.value,
                                            variant: t.variant,
                                        })
                                    ),
                                    null,
                                    16
                                ),
                            ]),
                        ],
                        4
                    )
                )
            )
        },
    }),
    Mt = et("cols", [""], { type: [String, Number], default: null }),
    tr = defineComponent({
        name: "BRow",
        props: {
            tag: { type: String, default: "div" },
            gutterX: { type: String, default: null },
            gutterY: { type: String, default: null },
            noGutters: { type: [Boolean, String], default: !1 },
            alignV: { type: String, default: null },
            alignH: { type: String, default: null },
            alignContent: { type: String, default: null },
            ...Mt,
        },
        setup(t) {
            const e = s$1(toRef(t, "noGutters")),
                n = Jt(t, Mt, "cols", "row-cols")
            return {
                classes: computed(() => ({
                    [`gx-${t.gutterX}`]: t.gutterX !== null,
                    [`gy-${t.gutterY}`]: t.gutterY !== null,
                    "g-0": e.value,
                    [`align-items-${t.alignV}`]: t.alignV !== null,
                    [`justify-content-${t.alignH}`]: t.alignH !== null,
                    [`align-content-${t.alignContent}`]: t.alignContent !== null,
                })),
                rowColsClasses: n,
            }
        },
    })
function ar(t, e, n, i, o, a) {
    return (
        openBlock(),
        createBlock$1(
            resolveDynamicComponent(t.tag),
            { class: normalizeClass(["row", [t.classes, t.rowColsClasses]]) },
            { default: withCtx(() => [renderSlot(t.$slots, "default")]), _: 3 },
            8,
            ["class"]
        )
    )
}
const lr = be(tr, [["render", ar]]),
    Ke = defineComponent({
        __name: "BSkeleton",
        props: { height: null, width: null, size: null, animation: { default: "wave" }, type: { default: "text" }, variant: null },
        setup(t) {
            const e = t,
                n = computed(() => [
                    `b-skeleton-${e.type}`,
                    {
                        [`b-skeleton-animate-${e.animation}`]: typeof e.animation == "boolean" ? !1 : e.animation,
                        [`bg-${e.variant}`]: e.variant !== void 0,
                    },
                ]),
                i = computed(() => ({ width: e.size || e.width, height: e.size || e.height }))
            return (o, a) => (
                openBlock(),
                createElementBlock("div", { class: normalizeClass(["b-skeleton", unref(n)]), style: normalizeStyle(unref(i)) }, null, 6)
            )
        },
    }),
    nr = defineComponent({
        __name: "BSkeletonIcon",
        props: { animation: { default: "wave" } },
        setup(t) {
            const e = t,
                n = computed(() => [`b-skeleton-animate-${e.animation}`])
            return (i, o) => (
                openBlock(),
                createElementBlock(
                    "div",
                    { class: normalizeClass(["b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden", unref(n)]) },
                    [renderSlot(i.$slots, "default")],
                    2
                )
            )
        },
    }),
    Ka = defineComponent({
        __name: "BTableSimple",
        props: {
            bordered: { default: !1 },
            borderless: { default: !1 },
            borderVariant: null,
            captionTop: { default: !1 },
            dark: { default: !1 },
            hover: { default: !1 },
            responsive: { type: [Boolean, String], default: !1 },
            stacked: { type: [Boolean, String], default: !1 },
            striped: { default: !1 },
            small: { default: !1 },
            tableClass: null,
            tableVariant: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "captionTop")),
                i = s$1(toRef(e, "borderless")),
                o = s$1(toRef(e, "bordered")),
                a = s$1(toRef(e, "dark")),
                l = s$1(toRef(e, "hover")),
                c = s$1(toRef(e, "small")),
                g = s$1(toRef(e, "striped")),
                v = computed(() => [
                    "table",
                    "b-table",
                    {
                        "table-bordered": o.value,
                        "table-borderless": i.value,
                        [`border-${e.borderVariant}`]: e.borderVariant !== void 0,
                        "caption-top": n.value,
                        "table-dark": a.value,
                        "table-hover": l.value,
                        "b-table-stacked": typeof e.stacked == "boolean" && e.stacked,
                        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
                        "table-striped": g.value,
                        "table-sm": c.value,
                        [`table-${e.tableVariant}`]: e.tableVariant !== void 0,
                    },
                    e.tableClass,
                ]),
                _ = computed(() => [
                    {
                        "table-responsive": typeof e.responsive == "boolean" && e.responsive,
                        [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
                    },
                ])
            return (A, B) =>
                t.responsive
                    ? (openBlock(),
                      createElementBlock(
                          "div",
                          { key: 1, class: normalizeClass(unref(_)) },
                          [createBaseVNode("table", { role: "table", class: normalizeClass(unref(v)) }, [renderSlot(A.$slots, "default")], 2)],
                          2
                      ))
                    : (openBlock(),
                      createElementBlock(
                          "table",
                          { key: 0, role: "table", class: normalizeClass(unref(v)) },
                          [renderSlot(A.$slots, "default")],
                          2
                      ))
        },
    }),
    or$1 = { key: 0 },
    sr = { key: 1 },
    ir = defineComponent({
        __name: "BSkeletonTable",
        props: {
            animation: { default: "wave" },
            columns: { default: 5 },
            hideHeader: { default: !1 },
            rows: { default: 3 },
            showFooter: { default: !1 },
            tableProps: null,
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "hideHeader")),
                i = s$1(toRef(e, "showFooter"))
            return (o, a) => (
                openBlock(),
                createBlock$1(
                    Ka,
                    normalizeProps(guardReactiveProps(t.tableProps)),
                    {
                        default: withCtx(() => [
                            unref(n)
                                ? createCommentVNode("", !0)
                                : (openBlock(),
                                  createElementBlock("thead", or$1, [
                                      createBaseVNode("tr", null, [
                                          (openBlock(!0),
                                          createElementBlock(
                                              Fragment$1,
                                              null,
                                              renderList(
                                                  t.columns,
                                                  (l, c) => (openBlock(), createElementBlock("th", { key: c }, [createVNode(Ke)]))
                                              ),
                                              128
                                          )),
                                      ]),
                                  ])),
                            createBaseVNode("tbody", null, [
                                (openBlock(!0),
                                createElementBlock(
                                    Fragment$1,
                                    null,
                                    renderList(
                                        t.rows,
                                        (l, c) => (
                                            openBlock(),
                                            createElementBlock("tr", { key: c }, [
                                                (openBlock(!0),
                                                createElementBlock(
                                                    Fragment$1,
                                                    null,
                                                    renderList(
                                                        t.columns,
                                                        (g, v) => (
                                                            openBlock(),
                                                            createElementBlock("td", { key: v }, [createVNode(Ke, { width: "75%" })])
                                                        )
                                                    ),
                                                    128
                                                )),
                                            ])
                                        )
                                    ),
                                    128
                                )),
                            ]),
                            unref(i)
                                ? (openBlock(),
                                  createElementBlock("tfoot", sr, [
                                      createBaseVNode("tr", null, [
                                          (openBlock(!0),
                                          createElementBlock(
                                              Fragment$1,
                                              null,
                                              renderList(
                                                  t.columns,
                                                  (l, c) => (openBlock(), createElementBlock("th", { key: c }, [createVNode(Ke)]))
                                              ),
                                              128
                                          )),
                                      ]),
                                  ]))
                                : createCommentVNode("", !0),
                        ]),
                        _: 1,
                    },
                    16
                )
            )
        },
    }),
    rr = defineComponent({
        __name: "BSkeletonWrapper",
        props: { loading: { default: !1 } },
        setup(t) {
            const e = s$1(toRef(t, "loading"))
            return (n, i) => (unref(e) ? renderSlot(n.$slots, "loading", { key: 0 }) : renderSlot(n.$slots, "default", { key: 1 }))
        },
    }),
    ur = defineComponent({
        __name: "BTableContainer",
        props: { responsive: { type: [Boolean, String], default: !1 }, responsiveClasses: null },
        setup(t) {
            return (e, n) =>
                t.responsive
                    ? (openBlock(),
                      createElementBlock("div", { key: 0, class: normalizeClass(t.responsiveClasses) }, [renderSlot(e.$slots, "default")], 2))
                    : renderSlot(e.$slots, "default", { key: 1 })
        },
    }),
    dr = () => ({
        normaliseFields: (t, e) => {
            const n = []
            return !(t != null && t.length) && (e == null ? void 0 : e.length)
                ? (Object.keys(e[0]).forEach((i) => n.push({ key: i, label: It(i) })), n)
                : (Array.isArray(t) &&
                      t.forEach((i) => {
                          typeof i == "string" ? n.push({ key: i, label: It(i) }) : Rl(i) && i.key && Pe(i.key) && n.push({ ...i })
                      }),
                  n)
        },
        sortItems: (t, e, n) => {
            if (!n || !n.key) return e
            const i = n.key
            return e.sort((o, a) => (o[i] > a[i] ? (n.desc ? -1 : 1) : a[i] > o[i] ? (n.desc ? 1 : -1) : 0))
        },
    }),
    cr = { key: 0 },
    fr = ["title", "abbr", "onClick"],
    vr = { class: "d-flex flex-nowrap align-items-center gap-1" },
    br = { key: 0, class: "text-muted small" },
    mr = { key: 1 },
    gr = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"],
    pr = { key: 0 },
    hr = { key: 0 },
    yr = ["title", "abbr", "onClick"],
    Br = { key: 1 },
    $r = { key: 2 },
    kr = defineComponent({
        __name: "BTable",
        props: {
            align: null,
            caption: null,
            captionTop: { default: !1 },
            borderless: { default: !1 },
            bordered: { default: !1 },
            borderVariant: null,
            dark: { default: !1 },
            fields: { default: () => [] },
            footClone: { default: !1 },
            hover: { default: !1 },
            items: { default: () => [] },
            responsive: { type: [Boolean, String], default: !1 },
            small: { default: !1 },
            striped: { default: !1 },
            variant: null,
            sortBy: null,
            sortDesc: { default: !1 },
            sortInternal: { default: !1 },
            selectable: { default: !1 },
            selectHead: { type: [Boolean, String], default: !0 },
            selectMode: { default: "single" },
            selectionVariant: { default: "primary" },
        },
        emits: [
            "headClicked",
            "rowClicked",
            "rowDblClicked",
            "rowHovered",
            "rowUnhovered",
            "rowSelected",
            "rowUnselected",
            "selection",
            "update:sortBy",
            "update:sortDesc",
            "sorted",
        ],
        setup(t, { expose: e, emit: n }) {
            const i = t,
                o = useSlots(),
                a = s$1(toRef(i, "captionTop")),
                l = s$1(toRef(i, "borderless")),
                c = s$1(toRef(i, "bordered")),
                g = s$1(toRef(i, "dark")),
                v = s$1(toRef(i, "footClone")),
                _ = s$1(toRef(i, "hover")),
                A = s$1(toRef(i, "small")),
                B = s$1(toRef(i, "striped")),
                D = s$1(toRef(i, "sortDesc")),
                I = s$1(toRef(i, "sortInternal")),
                L = s$1(toRef(i, "selectable")),
                G = computed(() => [
                    "table",
                    {
                        [`align-${i.align}`]: i.align !== void 0,
                        [`table-${i.variant}`]: i.variant !== void 0,
                        "table-striped": B.value,
                        "table-hover": _.value,
                        "table-dark": g.value,
                        "table-bordered": c.value,
                        [`border-${i.borderVariant}`]: i.borderVariant !== void 0,
                        "table-borderless": l.value,
                        "table-sm": A.value,
                        "caption-top": a.value,
                        "b-table-selectable": L.value,
                        [`b-table-select-${i.selectMode}`]: L.value,
                        "b-table-selecting user-select-none": L.value && E.value,
                    },
                ]),
                U = dr(),
                F = computed(() => U.normaliseFields(i.fields, i.items)),
                Z = computed(() => (I.value === !0 ? U.sortItems(i.fields, i.items, { key: i.sortBy, desc: D.value }) : i.items)),
                Y = computed(() => ({
                    "table-responsive": typeof i.responsive == "boolean" && i.responsive,
                    [`table-responsive-${i.responsive}`]: typeof i.responsive == "string",
                })),
                X = (C) => (typeof C == "string" ? Ft(C) : C.label !== void 0 ? C.label : typeof C.key == "string" ? Ft(C.key) : C.key),
                ie = (C, S, b = !1) => {
                    const T = typeof C == "string" ? C : C.key
                    n("headClicked", T, C, S, b), O(C)
                },
                he = (C, S, b) => {
                    n("rowClicked", C, S, b), N(C, S, b.shiftKey)
                },
                oe = (C, S, b) => n("rowDblClicked", C, S, b),
                le = (C, S, b) => n("rowHovered", C, S, b),
                Te = (C, S, b) => n("rowUnhovered", C, S, b),
                ye = computed(() => L.value && (!!i.selectHead || o.selectHead !== void 0)),
                Ae = computed(() => i.fields.filter((C) => (typeof C == "string" ? !1 : C.sortable)).length > 0),
                O = (C) => {
                    if (!Ae.value) return
                    const S = typeof C == "string" ? C : C.key,
                        b = typeof C == "string" ? !1 : C.sortable
                    if (Ae.value === !0 && b === !0) {
                        const T = !D.value
                        S !== i.sortBy && n("update:sortBy", S), n("update:sortDesc", T), n("sorted", S, T)
                    }
                },
                u = ref(new Set([])),
                E = computed(() => u.value.size > 0),
                $ = () => {
                    !L.value || n("selection", Array.from(u.value))
                },
                N = (C, S, b = !1) => {
                    if (L.value) {
                        if (u.value.has(C)) u.value.delete(C), n("rowUnselected", C)
                        else if (
                            (i.selectMode === "single" && u.value.size > 0 && (u.value.forEach((T) => n("rowUnselected", T)), u.value.clear()),
                            i.selectMode === "range" && u.value.size > 0 && b)
                        ) {
                            const T = Array.from(u.value).pop(),
                                Q = Z.value.findIndex((J) => J === T),
                                k = Math.min(Q, S),
                                W = Math.max(Q, S)
                            Z.value.slice(k, W + 1).forEach((J) => {
                                u.value.has(J) || (u.value.add(J), n("rowSelected", J))
                            })
                        } else u.value.add(C), n("rowSelected", C)
                        $()
                    }
                },
                M = (C) => [
                    C.class,
                    C.thClass,
                    C.variant ? `table-${C.variant}` : void 0,
                    { "b-table-sortable-column": Ae.value && C.sortable },
                ],
                R = (C) => [
                    C._rowVariant ? `table-${C._rowVariant}` : null,
                    C._rowVariant ? `table-${C._rowVariant}` : null,
                    L.value && u.value.has(C) ? `selected table-${i.selectionVariant}` : null,
                ]
            return (
                e({
                    selectAllRows: () => {
                        if (!L.value) return
                        const C = u.value.size > 0 ? Array.from(u.value) : []
                        ;(u.value = new Set([...Z.value])),
                            u.value.forEach((S) => {
                                C.includes(S) || n("rowSelected", S)
                            }),
                            $()
                    },
                    clearSelected: () => {
                        !L.value ||
                            (u.value.forEach((C) => {
                                n("rowUnselected", C)
                            }),
                            (u.value = new Set([])),
                            $())
                    },
                    selectRow: (C) => {
                        if (!L.value) return
                        const S = Z.value[C]
                        !S || u.value.has(S) || (u.value.add(S), n("rowSelected", S), $())
                    },
                    unselectRow: (C) => {
                        if (!L.value) return
                        const S = Z.value[C]
                        !S || !u.value.has(S) || (u.value.delete(S), n("rowUnselected", S), $())
                    },
                }),
                (C, S) => (
                    openBlock(),
                    createBlock$1(
                        ur,
                        { responsive: t.responsive, "responsive-classes": unref(Y) },
                        {
                            default: withCtx(() => [
                                createBaseVNode(
                                    "table",
                                    { class: normalizeClass(unref(G)) },
                                    [
                                        createBaseVNode("thead", null, [
                                            C.$slots["thead-top"] ? renderSlot(C.$slots, "thead-top", { key: 0 }) : createCommentVNode("", !0),
                                            createBaseVNode("tr", null, [
                                                unref(ye)
                                                    ? (openBlock(),
                                                      createElementBlock("th", cr, [
                                                          renderSlot(C.$slots, "selectHead", {}, () => [
                                                              createTextVNode(
                                                                  toDisplayString(typeof t.selectHead == "boolean" ? "Selected" : t.selectHead),
                                                                  1
                                                              ),
                                                          ]),
                                                      ]))
                                                    : createCommentVNode("", !0),
                                                (openBlock(!0),
                                                createElementBlock(
                                                    Fragment$1,
                                                    null,
                                                    renderList(
                                                        unref(F),
                                                        (b) => (
                                                            openBlock(),
                                                            createElementBlock(
                                                                "th",
                                                                mergeProps(
                                                                    {
                                                                        key: b.key,
                                                                        scope: "col",
                                                                        class: M(b),
                                                                        title: b.headerTitle,
                                                                        abbr: b.headerAbbr,
                                                                        style: b.thStyle,
                                                                    },
                                                                    b.thAttr,
                                                                    { onClick: (T) => ie(b, T) }
                                                                ),
                                                                [
                                                                    createBaseVNode("div", vr, [
                                                                        unref(Ae) && b.sortable && b.key === t.sortBy
                                                                            ? (openBlock(),
                                                                              createElementBlock("span", br, [
                                                                                  withDirectives(createBaseVNode("span", null, "\u25BC", 512), [
                                                                                      [vShow, t.sortDesc === !0],
                                                                                  ]),
                                                                                  withDirectives(createBaseVNode("span", null, "\u25B2", 512), [
                                                                                      [vShow, t.sortDesc === !1],
                                                                                  ]),
                                                                              ]))
                                                                            : createCommentVNode("", !0),
                                                                        createBaseVNode("div", null, [
                                                                            C.$slots["head(" + b.key + ")"] || C.$slots["head()"]
                                                                                ? renderSlot(
                                                                                      C.$slots,
                                                                                      C.$slots["head(" + b.key + ")"]
                                                                                          ? "head(" + b.key + ")"
                                                                                          : "head()",
                                                                                      { key: 0, label: b.label }
                                                                                  )
                                                                                : (openBlock(),
                                                                                  createElementBlock(
                                                                                      Fragment$1,
                                                                                      { key: 1 },
                                                                                      [createTextVNode(toDisplayString(X(b)), 1)],
                                                                                      64
                                                                                  )),
                                                                        ]),
                                                                    ]),
                                                                ],
                                                                16,
                                                                fr
                                                            )
                                                        )
                                                    ),
                                                    128
                                                )),
                                            ]),
                                            C.$slots["thead-sub"]
                                                ? (openBlock(),
                                                  createElementBlock("tr", mr, [
                                                      (openBlock(!0),
                                                      createElementBlock(
                                                          Fragment$1,
                                                          null,
                                                          renderList(
                                                              unref(F),
                                                              (b) => (
                                                                  openBlock(),
                                                                  createElementBlock(
                                                                      "td",
                                                                      {
                                                                          key: b.key,
                                                                          scope: "col",
                                                                          class: normalizeClass([
                                                                              b.class,
                                                                              b.thClass,
                                                                              b.variant ? `table-${b.variant}` : "",
                                                                          ]),
                                                                      },
                                                                      [
                                                                          C.$slots["thead-sub"]
                                                                              ? renderSlot(
                                                                                    C.$slots,
                                                                                    "thead-sub",
                                                                                    mergeProps({ key: 0, items: unref(F) }, b)
                                                                                )
                                                                              : (openBlock(),
                                                                                createElementBlock(
                                                                                    Fragment$1,
                                                                                    { key: 1 },
                                                                                    [createTextVNode(toDisplayString(b.label), 1)],
                                                                                    64
                                                                                )),
                                                                      ],
                                                                      2
                                                                  )
                                                              )
                                                          ),
                                                          128
                                                      )),
                                                  ]))
                                                : createCommentVNode("", !0),
                                        ]),
                                        createBaseVNode("tbody", null, [
                                            (openBlock(!0),
                                            createElementBlock(
                                                Fragment$1,
                                                null,
                                                renderList(
                                                    unref(Z),
                                                    (b, T) => (
                                                        openBlock(),
                                                        createElementBlock(
                                                            "tr",
                                                            {
                                                                key: T,
                                                                class: normalizeClass(R(b)),
                                                                onClick: withModifiers((Q) => he(b, T, Q), ["prevent"]),
                                                                onDblclick: withModifiers((Q) => oe(b, T, Q), ["prevent"]),
                                                                onMouseenter: withModifiers((Q) => le(b, T, Q), ["prevent"]),
                                                                onMouseleave: withModifiers((Q) => Te(b, T, Q), ["prevent"]),
                                                            },
                                                            [
                                                                unref(ye)
                                                                    ? (openBlock(),
                                                                      createElementBlock("td", pr, [
                                                                          renderSlot(C.$slots, "selectCell", {}, () => [
                                                                              createBaseVNode(
                                                                                  "span",
                                                                                  {
                                                                                      class: normalizeClass(
                                                                                          u.value.has(b) ? "text-primary" : ""
                                                                                      ),
                                                                                  },
                                                                                  "\u{1F5F9}",
                                                                                  2
                                                                              ),
                                                                          ]),
                                                                      ]))
                                                                    : createCommentVNode("", !0),
                                                                (openBlock(!0),
                                                                createElementBlock(
                                                                    Fragment$1,
                                                                    null,
                                                                    renderList(
                                                                        unref(F),
                                                                        (Q, k) => (
                                                                            openBlock(),
                                                                            createElementBlock(
                                                                                "td",
                                                                                mergeProps({ key: Q.key }, Q.tdAttr, {
                                                                                    class: [
                                                                                        Q.class,
                                                                                        Q.tdClass,
                                                                                        Q.variant ? `table-${Q.variant}` : "",
                                                                                        (b == null ? void 0 : b._cellVariants) &&
                                                                                        (b == null ? void 0 : b._cellVariants[Q.key])
                                                                                            ? `table-${
                                                                                                  b == null ? void 0 : b._cellVariants[Q.key]
                                                                                              }`
                                                                                            : "",
                                                                                    ],
                                                                                }),
                                                                                [
                                                                                    C.$slots["cell(" + Q.key + ")"] || C.$slots["cell()"]
                                                                                        ? renderSlot(
                                                                                              C.$slots,
                                                                                              C.$slots["cell(" + Q.key + ")"]
                                                                                                  ? "cell(" + Q.key + ")"
                                                                                                  : "cell()",
                                                                                              {
                                                                                                  key: 0,
                                                                                                  value: b[Q.key],
                                                                                                  index: k,
                                                                                                  item: b,
                                                                                                  field: Q,
                                                                                                  items: t.items,
                                                                                              }
                                                                                          )
                                                                                        : (openBlock(),
                                                                                          createElementBlock(
                                                                                              Fragment$1,
                                                                                              { key: 1 },
                                                                                              [createTextVNode(toDisplayString(b[Q.key]), 1)],
                                                                                              64
                                                                                          )),
                                                                                ],
                                                                                16
                                                                            )
                                                                        )
                                                                    ),
                                                                    128
                                                                )),
                                                            ],
                                                            42,
                                                            gr
                                                        )
                                                    )
                                                ),
                                                128
                                            )),
                                        ]),
                                        unref(v)
                                            ? (openBlock(),
                                              createElementBlock("tfoot", hr, [
                                                  createBaseVNode("tr", null, [
                                                      (openBlock(!0),
                                                      createElementBlock(
                                                          Fragment$1,
                                                          null,
                                                          renderList(
                                                              unref(F),
                                                              (b) => (
                                                                  openBlock(),
                                                                  createElementBlock(
                                                                      "th",
                                                                      mergeProps({ key: b.key }, b.thAttr, {
                                                                          scope: "col",
                                                                          class: [b.class, b.thClass, b.variant ? `table-${b.variant}` : ""],
                                                                          title: b.headerTitle,
                                                                          abbr: b.headerAbbr,
                                                                          style: b.thStyle,
                                                                          onClick: (T) => ie(b, T, !0),
                                                                      }),
                                                                      toDisplayString(b.label),
                                                                      17,
                                                                      yr
                                                                  )
                                                              )
                                                          ),
                                                          128
                                                      )),
                                                  ]),
                                              ]))
                                            : createCommentVNode("", !0),
                                        C.$slots["table-caption"]
                                            ? (openBlock(), createElementBlock("caption", Br, [renderSlot(C.$slots, "table-caption")]))
                                            : t.caption
                                            ? (openBlock(), createElementBlock("caption", $r, toDisplayString(t.caption), 1))
                                            : createCommentVNode("", !0),
                                    ],
                                    2
                                ),
                            ]),
                            _: 3,
                        },
                        8,
                        ["responsive", "responsive-classes"]
                    )
                )
            )
        },
    }),
    Sr = defineComponent({
        __name: "BTbody",
        props: { variant: null },
        setup(t) {
            const e = t,
                n = computed(() => ({ [`thead-${e.variant}`]: e.variant !== void 0 }))
            return (i, o) => (
                openBlock(),
                createElementBlock("tbody", { role: "rowgroup", class: normalizeClass(unref(n)) }, [renderSlot(i.$slots, "default")], 2)
            )
        },
    }),
    Cr = ["scope", "colspan", "rowspan", "data-label"],
    Tr = { key: 0 },
    wr = defineComponent({
        __name: "BTd",
        props: { colspan: null, rowspan: null, stackedHeading: null, stickyColumn: { default: !1 }, variant: null },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "stickyColumn")),
                i = computed(() => ({
                    [`table-${e.variant}`]: e.variant !== void 0,
                    "b-table-sticky-column": n.value,
                    "table-b-table-default": n.value && !e.variant,
                })),
                o = computed(() => (e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col"))
            return (a, l) => (
                openBlock(),
                createElementBlock(
                    "td",
                    {
                        role: "cell",
                        scope: unref(o),
                        class: normalizeClass(unref(i)),
                        colspan: t.colspan,
                        rowspan: t.rowspan,
                        "data-label": t.stackedHeading,
                    },
                    [
                        t.stackedHeading
                            ? (openBlock(), createElementBlock("div", Tr, [renderSlot(a.$slots, "default")]))
                            : renderSlot(a.$slots, "default", { key: 1 }),
                    ],
                    10,
                    Cr
                )
            )
        },
    }),
    _r = defineComponent({
        __name: "BTfoot",
        props: { variant: null },
        setup(t) {
            const e = t,
                n = computed(() => ({ [`table-${e.variant}`]: e.variant !== void 0 }))
            return (i, o) => (
                openBlock(),
                createElementBlock("tfoot", { role: "rowgroup", class: normalizeClass(unref(n)) }, [renderSlot(i.$slots, "default")], 2)
            )
        },
    }),
    Vr = ["scope", "colspan", "rowspan", "data-label"],
    xr = { key: 0 },
    Ar = defineComponent({
        __name: "BTh",
        props: { colspan: null, rowspan: null, stackedHeading: null, stickyColumn: { default: !1 }, variant: null },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "stickyColumn")),
                i = computed(() => ({
                    [`table-${e.variant}`]: e.variant !== void 0,
                    "b-table-sticky-column": n.value,
                    "table-b-table-default": n.value && e.variant === void 0,
                })),
                o = computed(() => (e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col"))
            return (a, l) => (
                openBlock(),
                createElementBlock(
                    "th",
                    {
                        role: "columnheader",
                        scope: unref(o),
                        class: normalizeClass(unref(i)),
                        colspan: t.colspan,
                        rowspan: t.rowspan,
                        "data-label": t.stackedHeading,
                    },
                    [
                        t.stackedHeading !== void 0
                            ? (openBlock(), createElementBlock("div", xr, [renderSlot(a.$slots, "default")]))
                            : renderSlot(a.$slots, "default", { key: 1 }),
                    ],
                    10,
                    Vr
                )
            )
        },
    }),
    Ir = defineComponent({
        __name: "BThead",
        props: { variant: null },
        setup(t) {
            const e = t,
                n = computed(() => ({ [`table-${e.variant}`]: e.variant !== void 0 }))
            return (i, o) => (
                openBlock(),
                createElementBlock("thead", { role: "rowgroup", class: normalizeClass(unref(n)) }, [renderSlot(i.$slots, "default")], 2)
            )
        },
    }),
    Fr = defineComponent({
        __name: "BTr",
        props: { variant: null },
        setup(t) {
            const e = t,
                n = computed(() => ({ [`table-${e.variant}`]: e.variant !== void 0 }))
            return (i, o) => (
                openBlock(), createElementBlock("tr", { role: "row", class: normalizeClass(unref(n)) }, [renderSlot(i.$slots, "default")], 2)
            )
        },
    }),
    Or = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"],
    Ja = Symbol(),
    zr = defineComponent({
        __name: "BTabs",
        props: {
            activeNavItemClass: { default: void 0 },
            activeTabClass: { default: void 0 },
            align: { default: void 0 },
            card: { default: !1 },
            contentClass: { default: void 0 },
            end: { default: !1 },
            fill: { default: !1 },
            id: { default: void 0 },
            justified: { default: !1 },
            lazy: { default: !1 },
            navClass: { default: void 0 },
            navWrapperClass: { default: void 0 },
            noFade: { default: !1 },
            noNavStyle: { default: !1 },
            pills: { default: !1 },
            small: { default: !1 },
            tag: { default: "div" },
            vertical: { default: !1 },
            modelValue: { default: -1 },
        },
        emits: ["update:modelValue", "activate-tab", "click"],
        setup(t, { emit: e }) {
            const n = t,
                i = s$1(toRef(n, "card")),
                o = s$1(toRef(n, "end")),
                a = s$1(toRef(n, "fill")),
                l = s$1(toRef(n, "justified")),
                c = s$1(toRef(n, "lazy")),
                g = s$1(toRef(n, "noFade")),
                v = s$1(toRef(n, "noNavStyle")),
                _ = s$1(toRef(n, "pills")),
                A = s$1(toRef(n, "small")),
                B = s$1(toRef(n, "vertical")),
                D = useSlots(),
                I = ref(n.modelValue),
                L = ref(""),
                G = computed({
                    get: () => I.value,
                    set: (oe) => {
                        ;(I.value = oe),
                            U.value.length > 0 && oe >= 0 && oe < U.value.length ? (L.value = U.value[oe].buttonId) : (L.value = ""),
                            e("update:modelValue", oe)
                    },
                }),
                U = computed(() => {
                    let oe = []
                    return (
                        D.default &&
                            (oe = he(D).map((le, Te) => {
                                le.props || (le.props = {})
                                const ye = le.props["button-id"] || $e("tab"),
                                    Ae = le.props.id || $e(),
                                    O = G.value > -1 ? Te === G.value : le.props.active === "",
                                    u = le.props["title-item-class"],
                                    E = le.props["title-link-attributes"]
                                return {
                                    buttonId: ye,
                                    contentId: Ae,
                                    active: O,
                                    disabled: le.props.disabled === "" || le.props.disabled === !0,
                                    navItemClasses: [
                                        { active: O, disabled: le.props.disabled === "" || le.props.disabled === !0 },
                                        O && n.activeNavItemClass ? n.activeNavItemClass : null,
                                        le.props["title-link-class"],
                                    ],
                                    tabClasses: [{ fade: !g.value }, O && n.activeTabClass ? n.activeTabClass : null],
                                    target: `#${Ae}`,
                                    title: le.props.title,
                                    titleItemClass: u,
                                    titleLinkAttributes: E,
                                    onClick: le.props.onClick,
                                    tab: le,
                                }
                            })),
                        oe
                    )
                }),
                F = computed(() => !((U == null ? void 0 : U.value) && U.value.length > 0)),
                Z = computed(() => ({ "d-flex align-items-start": B.value })),
                Y = computed(() => ({
                    "nav-pills": _.value,
                    "flex-column me-3": B.value,
                    [`justify-content-${n.align}`]: !!n.align,
                    "nav-fill": a.value,
                    "card-header-tabs": i.value,
                    "nav-justified": l.value,
                    "nav-tabs": !v.value && !_.value,
                    small: A.value,
                })),
                X = (oe) => {
                    let le = !1
                    if (
                        oe !== void 0 &&
                        oe > -1 &&
                        oe < U.value.length &&
                        !U.value[oe].disabled &&
                        (G.value < 0 || U.value[oe].buttonId !== L.value)
                    ) {
                        const Te = new Qe("activate-tab", { cancelable: !0, vueTarget: this })
                        e("activate-tab", oe, G.value, Te), Te.defaultPrevented || ((G.value = oe), (le = !0))
                    }
                    return !le && n.modelValue !== G.value && e("update:modelValue", G.value), le
                },
                ie = (oe, le) => {
                    var Te
                    X(le),
                        le >= 0 &&
                            !U.value[le].disabled &&
                            ((Te = U.value[le]) == null ? void 0 : Te.onClick) &&
                            ea(U.value[le].onClick) &&
                            U.value[le].onClick(oe)
                },
                he = (oe) =>
                    !oe || !oe.default
                        ? []
                        : oe
                              .default()
                              .reduce((le, Te) => (typeof Te.type == "symbol" ? (le = le.concat(Te.children)) : le.push(Te), le), [])
                              .filter((le) => {
                                  var Te
                                  return ((Te = le.type) == null ? void 0 : Te.__name) === "BTab"
                              })
            return (
                X(I.value),
                watch(
                    () => n.modelValue,
                    (oe, le) => {
                        if (oe === le) return
                        if (((oe = Math.max(oe, -1)), (le = Math.max(le, -1)), U.value.length <= 0)) {
                            G.value = -1
                            return
                        }
                        const Te = oe > le
                        let ye = oe
                        const Ae = U.value.length - 1
                        for (; ye >= 0 && ye <= Ae && U.value[ye].disabled; ) ye += Te ? 1 : -1
                        if (ye < 0) {
                            X(0)
                            return
                        }
                        if (ye >= U.value.length) {
                            X(U.value.length - 1)
                            return
                        }
                        X(ye)
                    }
                ),
                watch(
                    () => U.value,
                    () => {
                        let oe = U.value.map((le) => le.active && !le.disabled).lastIndexOf(!0)
                        oe < 0 &&
                            (G.value >= U.value.length
                                ? (oe = U.value.map((le) => !le.disabled).lastIndexOf(!0))
                                : U.value[G.value] && !U.value[G.value].disabled && (oe = G.value)),
                            oe < 0 && (oe = U.value.map((le) => !le.disabled).indexOf(!0)),
                            U.value.forEach((le, Te) => (le.active = Te === oe)),
                            X(oe)
                    }
                ),
                onMounted(() => {
                    if (G.value < 0 && U.value.length > 0 && !U.value.some((oe) => oe.active)) {
                        const oe = U.value.map((le) => !le.disabled).indexOf(!0)
                        X(oe >= 0 ? oe : -1)
                    }
                }),
                provide(Ja, { lazy: c.value, card: i.value }),
                (oe, le) => (
                    openBlock(),
                    createBlock$1(
                        resolveDynamicComponent(t.tag),
                        { id: t.id, class: normalizeClass(["tabs", unref(Z)]) },
                        {
                            default: withCtx(() => [
                                unref(o)
                                    ? (openBlock(),
                                      createElementBlock(
                                          "div",
                                          { key: 0, class: normalizeClass(["tab-content", t.contentClass]) },
                                          [
                                              (openBlock(!0),
                                              createElementBlock(
                                                  Fragment$1,
                                                  null,
                                                  renderList(
                                                      unref(U),
                                                      ({ tab: Te, contentId: ye, tabClasses: Ae, active: O }, u) => (
                                                          openBlock(),
                                                          createBlock$1(
                                                              resolveDynamicComponent(Te),
                                                              { key: u, id: ye, class: normalizeClass(Ae), active: O },
                                                              null,
                                                              8,
                                                              ["id", "class", "active"]
                                                          )
                                                      )
                                                  ),
                                                  128
                                              )),
                                              unref(F)
                                                  ? (openBlock(),
                                                    createElementBlock(
                                                        "div",
                                                        {
                                                            key: "bv-empty-tab",
                                                            class: normalizeClass(["tab-pane active", { "card-body": unref(i) }]),
                                                        },
                                                        [renderSlot(oe.$slots, "empty")],
                                                        2
                                                    ))
                                                  : createCommentVNode("", !0),
                                          ],
                                          2
                                      ))
                                    : createCommentVNode("", !0),
                                createBaseVNode(
                                    "div",
                                    {
                                        class: normalizeClass([
                                            t.navWrapperClass,
                                            { "card-header": unref(i), "ms-auto": t.vertical && unref(o) },
                                        ]),
                                    },
                                    [
                                        createBaseVNode(
                                            "ul",
                                            { class: normalizeClass(["nav", [unref(Y), t.navClass]]), role: "tablist" },
                                            [
                                                renderSlot(oe.$slots, "tabs-start"),
                                                (openBlock(!0),
                                                createElementBlock(
                                                    Fragment$1,
                                                    null,
                                                    renderList(
                                                        unref(U),
                                                        (
                                                            { tab: Te, buttonId: ye, contentId: Ae, navItemClasses: O, active: u, target: E },
                                                            $
                                                        ) => (
                                                            openBlock(),
                                                            createElementBlock(
                                                                "li",
                                                                { key: $, class: normalizeClass(["nav-item", Te.props["title-item-class"]]) },
                                                                [
                                                                    createBaseVNode(
                                                                        "button",
                                                                        mergeProps(
                                                                            {
                                                                                id: ye,
                                                                                class: ["nav-link", O],
                                                                                "data-bs-toggle": "tab",
                                                                                "data-bs-target": E,
                                                                                role: "tab",
                                                                                "aria-controls": Ae,
                                                                                "aria-selected": u,
                                                                            },
                                                                            Te.props["title-link-attributes"],
                                                                            { onClick: withModifiers((N) => ie(N, $), ["stop", "prevent"]) }
                                                                        ),
                                                                        [
                                                                            Te.children && Te.children.title
                                                                                ? (openBlock(),
                                                                                  createBlock$1(resolveDynamicComponent(Te.children.title), {
                                                                                      key: 0,
                                                                                  }))
                                                                                : (openBlock(),
                                                                                  createElementBlock(
                                                                                      Fragment$1,
                                                                                      { key: 1 },
                                                                                      [createTextVNode(toDisplayString(Te.props.title), 1)],
                                                                                      64
                                                                                  )),
                                                                        ],
                                                                        16,
                                                                        Or
                                                                    ),
                                                                ],
                                                                2
                                                            )
                                                        )
                                                    ),
                                                    128
                                                )),
                                                renderSlot(oe.$slots, "tabs-end"),
                                            ],
                                            2
                                        ),
                                    ],
                                    2
                                ),
                                unref(o)
                                    ? createCommentVNode("", !0)
                                    : (openBlock(),
                                      createElementBlock(
                                          "div",
                                          { key: 1, class: normalizeClass(["tab-content", t.contentClass]) },
                                          [
                                              (openBlock(!0),
                                              createElementBlock(
                                                  Fragment$1,
                                                  null,
                                                  renderList(
                                                      unref(U),
                                                      ({ tab: Te, contentId: ye, tabClasses: Ae, active: O }, u) => (
                                                          openBlock(),
                                                          createBlock$1(
                                                              resolveDynamicComponent(Te),
                                                              { key: u, id: ye, class: normalizeClass(Ae), active: O },
                                                              null,
                                                              8,
                                                              ["id", "class", "active"]
                                                          )
                                                      )
                                                  ),
                                                  128
                                              )),
                                              unref(F)
                                                  ? (openBlock(),
                                                    createElementBlock(
                                                        "div",
                                                        {
                                                            key: "bv-empty-tab",
                                                            class: normalizeClass(["tab-pane active", { "card-body": unref(i) }]),
                                                        },
                                                        [renderSlot(oe.$slots, "empty")],
                                                        2
                                                    ))
                                                  : createCommentVNode("", !0),
                                          ],
                                          2
                                      )),
                            ]),
                            _: 3,
                        },
                        8,
                        ["id", "class"]
                    )
                )
            )
        },
    }),
    Nr = defineComponent({
        __name: "BTab",
        props: {
            id: null,
            title: null,
            active: { default: !1 },
            buttonId: { default: void 0 },
            disabled: { default: !1 },
            lazy: { default: !1 },
            noBody: { type: [Boolean, String], default: !1 },
            tag: { default: "div" },
            titleItemClass: { default: void 0 },
            titleLinkAttributes: { default: void 0 },
            titleLinkClass: { default: void 0 },
        },
        setup(t) {
            const e = t,
                n = s$1(toRef(e, "active")),
                i = s$1(toRef(e, "disabled")),
                o = s$1(toRef(e, "lazy")),
                a = inject(Ja, null),
                l = computed(() => (a == null ? void 0 : a.lazy) || o.value),
                c = computed(() => n.value && !i.value),
                g = computed(() => c.value || !l.value),
                v = computed(() => ({ active: n.value, show: n.value, "card-body": (a == null ? void 0 : a.card) && e.noBody === !1 }))
            return (_, A) => (
                openBlock(),
                createBlock$1(
                    resolveDynamicComponent(t.tag),
                    { id: t.id, class: normalizeClass(["tab-pane", unref(v)]), role: "tabpanel", "aria-labelledby": "profile-tab" },
                    { default: withCtx(() => [unref(g) ? renderSlot(_.$slots, "default", { key: 0 }) : createCommentVNode("", !0)]), _: 3 },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    Lr = {
        BAccordion: ln$1,
        BAccordionItem: cn,
        BNavText: fi,
        BAlert: vn,
        BAvatar: hn,
        BAvatarGroup: bn,
        BNavForm: ti,
        BBadge: Sn,
        BBreadcrumb: Vn,
        BBreadcrumbItem: Ba,
        BButton: je,
        BButtonGroup: Fn,
        BButtonToolbar: zn,
        BCard: Pn,
        BCardBody: _a,
        BCardFooter: Va,
        BCardGroup: En,
        BCardHeader: Ca,
        BCardImg: bt,
        BCardSubTitle: wa,
        BCardText: Hn,
        BCardTitle: Ta,
        BCarousel: Jn,
        BCarouselSlide: ao,
        BCloseButton: ka,
        BCol: qe,
        BCollapse: ha,
        BContainer: fo,
        BDropdown: Na,
        BDropdownDivider: go,
        BDropdownForm: $o,
        BDropdownGroup: To,
        BDropdownHeader: xo,
        BDropdownItem: Fo,
        BDropdownItemButton: No,
        BDropdownText: Eo,
        BForm: La,
        BFormCheckbox: Pa,
        BFormCheckboxGroup: Ko,
        BFormFloatingLabel: Do,
        BFormGroup: ls,
        BFormInput: is$1,
        BFormInvalidFeedback: pt,
        BFormRadio: Ha,
        BFormRadioGroup: vs,
        BFormRow: We,
        BFormSelect: ps,
        BFormSelectOption: wt,
        BFormSelectOptionGroup: Ra,
        BFormText: ht,
        BFormTextarea: Ps,
        BFormTag: qa,
        BFormTags: Os,
        BFormValidFeedback: yt,
        BImg: Aa,
        BInputGroup: Ms,
        BInputGroupAddon: _t,
        BInputGroupAppend: Gs,
        BInputGroupPrepend: Us,
        BInputGroupText: Da,
        BLink: pe,
        BListGroup: Ws,
        BListGroupItem: Xs,
        BModal: Qs,
        BNav: ei,
        BNavbar: vi,
        BNavbarBrand: gi,
        BNavbarNav: pi,
        BNavbarToggle: xi,
        BNavItem: si,
        BNavItemDropdown: ri,
        BOffcanvas: Ni,
        BOverlay: Ei,
        BPagination: Wi,
        BPopover: Qi,
        BProgress: er,
        BProgressBar: Wa,
        BRow: lr,
        BSkeleton: Ke,
        BSkeletonIcon: nr,
        BSkeletonTable: ir,
        BSkeletonWrapper: rr,
        BSpinner: $a,
        BTab: Nr,
        BTable: kr,
        BTableSimple: Ka,
        BTbody: Sr,
        BTd: wr,
        BTfoot: _r,
        BTh: Ar,
        BThead: Ir,
        BTr: Fr,
        BToast: Fa,
        BToaster: mt,
        BToastContainer: mt,
        BTabs: zr,
        BTransition: Ye,
        BToastPlugin: co,
    },
    Rr = {
        install(t, e = {}) {
            Object.entries(Lr).forEach(([n, i]) => {
                t.component(n, i)
            }),
                Object.entries(_i).forEach(([n, i]) => {
                    t.directive(n, i)
                }),
                en(t)
        },
    }
var bootstrap_min = "",
    bootstrapVue3 = ""
const _abi$4 = [
        { inputs: [], stateMutability: "nonpayable", type: "constructor" },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "previousOwner", type: "address" },
                { indexed: !0, internalType: "address", name: "newOwner", type: "address" },
            ],
            name: "OwnershipTransferred",
            type: "event",
        },
        { inputs: [], name: "claimOwnership", outputs: [], stateMutability: "nonpayable", type: "function" },
        {
            inputs: [],
            name: "owner",
            outputs: [{ internalType: "address", name: "", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "pendingOwner",
            outputs: [{ internalType: "address", name: "", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "newOwner", type: "address" },
                { internalType: "bool", name: "direct", type: "bool" },
                { internalType: "bool", name: "renounce", type: "bool" },
            ],
            name: "transferOwnership",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
    ],
    _bytecode$4 =
        "0x608060405234801561001057600080fd5b50600080546001600160a01b0319163390811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a36104878061005f6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063078dfbe7146100515780634e71e0c8146100665780638da5cb5b1461006e578063e30c3978146100b7575b600080fd5b61006461005f3660046103f3565b6100d7565b005b6100646102c8565b60005461008e9073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60015461008e9073ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff16331461015d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b81156102815773ffffffffffffffffffffffffffffffffffffffff83161515806101845750805b6101ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4f776e61626c653a207a65726f206164647265737300000000000000000000006044820152606401610154565b6000805460405173ffffffffffffffffffffffffffffffffffffffff808716939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff85167fffffffffffffffffffffffff000000000000000000000000000000000000000091821617909155600180549091169055505050565b6001805473ffffffffffffffffffffffffffffffffffffffff85167fffffffffffffffffffffffff0000000000000000000000000000000000000000909116179055505050565b60015473ffffffffffffffffffffffffffffffffffffffff1633811461034a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c657220213d2070656e64696e67206f776e65726044820152606401610154565b6000805460405173ffffffffffffffffffffffffffffffffffffffff808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a36000805473ffffffffffffffffffffffffffffffffffffffff9092167fffffffffffffffffffffffff0000000000000000000000000000000000000000928316179055600180549091169055565b803580151581146103ee57600080fd5b919050565b60008060006060848603121561040857600080fd5b833573ffffffffffffffffffffffffffffffffffffffff8116811461042c57600080fd5b925061043a602085016103de565b9150610448604085016103de565b9050925092509256fea264697066735822122092e741d588ee32e73e3f18f147241e09605893c45272f1ab81f14b41d878af7e64736f6c63430008090033",
    isSuperArgs$4 = (t) => t.length > 1
class BoringOwnable__factory extends ContractFactory {
    constructor(...e) {
        var n = (...i) => {
            super(...i)
        }
        isSuperArgs$4(e) ? n(...e) : n(_abi$4, _bytecode$4, e[0]), (this.contractName = "BoringOwnable")
    }
    deploy(e) {
        return super.deploy(e || {})
    }
    getDeployTransaction(e) {
        return super.getDeployTransaction(e || {})
    }
    attach(e) {
        return super.attach(e)
    }
    connect(e) {
        return super.connect(e)
    }
    static createInterface() {
        return new Interface(_abi$4)
    }
    static connect(e, n) {
        return new Contract(e, _abi$4, n)
    }
}
BoringOwnable__factory.bytecode = _bytecode$4
BoringOwnable__factory.abi = _abi$4
const _abi$3 = [
        {
            inputs: [],
            name: "owner",
            outputs: [{ internalType: "address", name: "", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "pendingOwner",
            outputs: [{ internalType: "address", name: "", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
    ],
    _bytecode$3 =
        "0x608060405234801561001057600080fd5b5060d48061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80638da5cb5b146037578063e30c397814607f575b600080fd5b60005460569073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b60015460569073ffffffffffffffffffffffffffffffffffffffff168156fea2646970667358221220ea0f493ca911bfc1265da3c0f3007e801402d71230e614154b75b70fba22a32664736f6c63430008090033",
    isSuperArgs$3 = (t) => t.length > 1
class BoringOwnableData__factory extends ContractFactory {
    constructor(...e) {
        var n = (...i) => {
            super(...i)
        }
        isSuperArgs$3(e) ? n(...e) : n(_abi$3, _bytecode$3, e[0]), (this.contractName = "BoringOwnableData")
    }
    deploy(e) {
        return super.deploy(e || {})
    }
    getDeployTransaction(e) {
        return super.getDeployTransaction(e || {})
    }
    attach(e) {
        return super.attach(e)
    }
    connect(e) {
        return super.connect(e)
    }
    static createInterface() {
        return new Interface(_abi$3)
    }
    static connect(e, n) {
        return new Contract(e, _abi$3, n)
    }
}
BoringOwnableData__factory.bytecode = _bytecode$3
BoringOwnableData__factory.abi = _abi$3
const _abi$2 = [
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_owner", type: "address" },
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !1, internalType: "bool", name: "_approved", type: "bool" },
            ],
            name: "ApprovalForAll",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !0, internalType: "address", name: "_from", type: "address" },
                { indexed: !0, internalType: "address", name: "_to", type: "address" },
                { indexed: !1, internalType: "uint256[]", name: "_ids", type: "uint256[]" },
                { indexed: !1, internalType: "uint256[]", name: "_values", type: "uint256[]" },
            ],
            name: "TransferBatch",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !0, internalType: "address", name: "_from", type: "address" },
                { indexed: !0, internalType: "address", name: "_to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "_id", type: "uint256" },
                { indexed: !1, internalType: "uint256", name: "_value", type: "uint256" },
            ],
            name: "TransferSingle",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !1, internalType: "string", name: "_value", type: "string" },
                { indexed: !0, internalType: "uint256", name: "_id", type: "uint256" },
            ],
            name: "URI",
            type: "event",
        },
        {
            inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
            ],
            name: "balanceOf",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address[]", name: "owners", type: "address[]" },
                { internalType: "uint256[]", name: "ids", type: "uint256[]" },
            ],
            name: "balanceOfBatch",
            outputs: [{ internalType: "uint256[]", name: "balances", type: "uint256[]" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
            ],
            name: "isApprovedForAll",
            outputs: [{ internalType: "bool", name: "", type: "bool" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256[]", name: "ids", type: "uint256[]" },
                { internalType: "uint256[]", name: "values", type: "uint256[]" },
                { internalType: "bytes", name: "data", type: "bytes" },
            ],
            name: "safeBatchTransferFrom",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "id", type: "uint256" },
                { internalType: "uint256", name: "value", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
            ],
            name: "safeTransferFrom",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "operator", type: "address" },
                { internalType: "bool", name: "approved", type: "bool" },
            ],
            name: "setApprovalForAll",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "bytes4", name: "interfaceID", type: "bytes4" }],
            name: "supportsInterface",
            outputs: [{ internalType: "bool", name: "", type: "bool" }],
            stateMutability: "pure",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            name: "totalSupply",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            name: "uri",
            outputs: [{ internalType: "string", name: "", type: "string" }],
            stateMutability: "view",
            type: "function",
        },
    ],
    _bytecode$2 =
        "0x608060405234801561001057600080fd5b5061134d806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a25760003560e01c80634e1273f411610076578063bd85b0391161005b578063bd85b0391461017e578063e985e9c51461019e578063f242432a146101c957600080fd5b80634e1273f41461014b578063a22cb4651461016b57600080fd5b8062fdd58e146100a757806301ffc9a7146100e55780630e89341c146101085780632eb2c2d614610136575b600080fd5b6100d26100b5366004610c75565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b6100f86100f3366004610ccd565b6101dc565b60405190151581526020016100dc565b610129610116366004610cf1565b5060408051602081019091526000815290565b6040516100dc9190610d0a565b610149610144366004610e0b565b6102c1565b005b61015e610159366004610ec6565b6104aa565b6040516100dc9190610f32565b610149610179366004610f76565b61062e565b6100d261018c366004610cf1565b60026020526000908152604090205481565b6100f86101ac366004610fb2565b600060208181529281526040808220909352908152205460ff1681565b6101496101d7366004610fe5565b6106c3565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a700000000000000000000000000000000000000000000000000000000148061026f57507fd9b67a26000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b806102bb57507f0e89341c000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b84831461032f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f455243313135353a204c656e677468206d69736d61746368000000000000000060448201526064015b60405180910390fd5b61033888610836565b6103468888888888886108f6565b73ffffffffffffffffffffffffffffffffffffffff87163b156104a0576040517fbc197c81000000000000000000000000000000000000000000000000000000008082529073ffffffffffffffffffffffffffffffffffffffff89169063bc197c81906103c59033908d908c908c908c908c908c908c906004016110f5565b602060405180830381600087803b1580156103df57600080fd5b505af11580156103f3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104179190611166565b7fffffffff0000000000000000000000000000000000000000000000000000000016146104a0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f57726f6e672072657475726e2076616c756500000000000000000000000000006044820152606401610326565b5050505050505050565b606083828114610516576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f455243313135353a204c656e677468206d69736d6174636800000000000000006044820152606401610326565b8067ffffffffffffffff81111561052f5761052f611183565b604051908082528060200260200182016040528015610558578160200160208202803683370190505b50915060005b81811015610624576001600088888481811061057c5761057c6111b2565b905060200201602081019061059191906111e1565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008686848181106105df576105df6111b2565b90506020020135815260200190815260200160002054838281518110610607576106076111b2565b60209081029190910101528061061c8161122b565b91505061055e565b5050949350505050565b3360008181526020818152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b6106cc86610836565b6106d886868686610ae7565b73ffffffffffffffffffffffffffffffffffffffff85163b1561082e576040517ff23a6e61000000000000000000000000000000000000000000000000000000008082529073ffffffffffffffffffffffffffffffffffffffff87169063f23a6e61906107539033908b908a908a908a908a90600401611264565b602060405180830381600087803b15801561076d57600080fd5b505af1158015610781573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a59190611166565b7fffffffff00000000000000000000000000000000000000000000000000000000161461082e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f57726f6e672072657475726e2076616c756500000000000000000000000000006044820152606401610326565b505050505050565b73ffffffffffffffffffffffffffffffffffffffff811633148061088d575073ffffffffffffffffffffffffffffffffffffffff811660009081526020818152604080832033845290915290205460ff1615156001145b6108f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f5472616e73666572206e6f7420616c6c6f7765640000000000000000000000006044820152606401610326565b50565b73ffffffffffffffffffffffffffffffffffffffff8516610973576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f2030206164647265737300000000000000000000000000000000000000006044820152606401610326565b60005b83811015610a5c576000858583818110610992576109926111b2565b90506020020135905060008484848181106109af576109af6111b2565b73ffffffffffffffffffffffffffffffffffffffff8c166000908152600160209081526040808320888452825282208054939091029490940135945084939250906109fb9084906112b6565b909155505073ffffffffffffffffffffffffffffffffffffffff8816600090815260016020908152604080832085845290915281208054839290610a409084906112cd565b9250508190555050508080610a549061122b565b915050610976565b508473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb87878787604051610ad794939291906112e5565b60405180910390a4505050505050565b73ffffffffffffffffffffffffffffffffffffffff8316610b64576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f2030206164647265737300000000000000000000000000000000000000006044820152606401610326565b73ffffffffffffffffffffffffffffffffffffffff8416600090815260016020908152604080832085845290915281208054839290610ba49084906112b6565b909155505073ffffffffffffffffffffffffffffffffffffffff8316600090815260016020908152604080832085845290915281208054839290610be99084906112cd565b9091555050604080518381526020810183905273ffffffffffffffffffffffffffffffffffffffff808616929087169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a450505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610c7057600080fd5b919050565b60008060408385031215610c8857600080fd5b610c9183610c4c565b946020939093013593505050565b7fffffffff00000000000000000000000000000000000000000000000000000000811681146108f357600080fd5b600060208284031215610cdf57600080fd5b8135610cea81610c9f565b9392505050565b600060208284031215610d0357600080fd5b5035919050565b600060208083528351808285015260005b81811015610d3757858101830151858201604001528201610d1b565b81811115610d49576000604083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016929092016040019392505050565b60008083601f840112610d8f57600080fd5b50813567ffffffffffffffff811115610da757600080fd5b6020830191508360208260051b8501011115610dc257600080fd5b9250929050565b60008083601f840112610ddb57600080fd5b50813567ffffffffffffffff811115610df357600080fd5b602083019150836020828501011115610dc257600080fd5b60008060008060008060008060a0898b031215610e2757600080fd5b610e3089610c4c565b9750610e3e60208a01610c4c565b9650604089013567ffffffffffffffff80821115610e5b57600080fd5b610e678c838d01610d7d565b909850965060608b0135915080821115610e8057600080fd5b610e8c8c838d01610d7d565b909650945060808b0135915080821115610ea557600080fd5b50610eb28b828c01610dc9565b999c989b5096995094979396929594505050565b60008060008060408587031215610edc57600080fd5b843567ffffffffffffffff80821115610ef457600080fd5b610f0088838901610d7d565b90965094506020870135915080821115610f1957600080fd5b50610f2687828801610d7d565b95989497509550505050565b6020808252825182820181905260009190848201906040850190845b81811015610f6a57835183529284019291840191600101610f4e565b50909695505050505050565b60008060408385031215610f8957600080fd5b610f9283610c4c565b915060208301358015158114610fa757600080fd5b809150509250929050565b60008060408385031215610fc557600080fd5b610fce83610c4c565b9150610fdc60208401610c4c565b90509250929050565b60008060008060008060a08789031215610ffe57600080fd5b61100787610c4c565b955061101560208801610c4c565b94506040870135935060608701359250608087013567ffffffffffffffff81111561103f57600080fd5b61104b89828a01610dc9565b979a9699509497509295939492505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561108f57600080fd5b8260051b8083602087013760009401602001938452509192915050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600073ffffffffffffffffffffffffffffffffffffffff808b168352808a1660208401525060a0604083015261112f60a08301888a61105d565b828103606084015261114281878961105d565b905082810360808401526111578185876110ac565b9b9a5050505050505050505050565b60006020828403121561117857600080fd5b8151610cea81610c9f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000602082840312156111f357600080fd5b610cea82610c4c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561125d5761125d6111fc565b5060010190565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015260a060808301526112aa60a0830184866110ac565b98975050505050505050565b6000828210156112c8576112c86111fc565b500390565b600082198211156112e0576112e06111fc565b500190565b6040815260006112f960408301868861105d565b828103602084015261130c81858761105d565b97965050505050505056fea2646970667358221220e5c890d05e1830b36908de23646b38d5d21468bb487fdf2ca032bccf59987ecc64736f6c63430008090033",
    isSuperArgs$2 = (t) => t.length > 1
class ERC1155__factory extends ContractFactory {
    constructor(...e) {
        var n = (...i) => {
            super(...i)
        }
        isSuperArgs$2(e) ? n(...e) : n(_abi$2, _bytecode$2, e[0]), (this.contractName = "ERC1155")
    }
    deploy(e) {
        return super.deploy(e || {})
    }
    getDeployTransaction(e) {
        return super.getDeployTransaction(e || {})
    }
    attach(e) {
        return super.attach(e)
    }
    connect(e) {
        return super.connect(e)
    }
    static createInterface() {
        return new Interface(_abi$2)
    }
    static connect(e, n) {
        return new Contract(e, _abi$2, n)
    }
}
ERC1155__factory.bytecode = _bytecode$2
ERC1155__factory.abi = _abi$2
const _abi$1 = [
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_owner", type: "address" },
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !1, internalType: "bool", name: "_approved", type: "bool" },
            ],
            name: "ApprovalForAll",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "uint256", name: "serie", type: "uint256" },
                { indexed: !0, internalType: "uint256", name: "artwork", type: "uint256" },
                { indexed: !1, internalType: "uint128", name: "price", type: "uint128" },
                { indexed: !0, internalType: "address", name: "gallery", type: "address" },
            ],
            name: "LogBuy",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [{ indexed: !0, internalType: "uint256", name: "index", type: "uint256" }],
            name: "LogCreateSeries",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !0, internalType: "address", name: "_from", type: "address" },
                { indexed: !0, internalType: "address", name: "_to", type: "address" },
                { indexed: !1, internalType: "uint256[]", name: "_ids", type: "uint256[]" },
                { indexed: !1, internalType: "uint256[]", name: "_values", type: "uint256[]" },
            ],
            name: "TransferBatch",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !0, internalType: "address", name: "_operator", type: "address" },
                { indexed: !0, internalType: "address", name: "_from", type: "address" },
                { indexed: !0, internalType: "address", name: "_to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "_id", type: "uint256" },
                { indexed: !1, internalType: "uint256", name: "_value", type: "uint256" },
            ],
            name: "TransferSingle",
            type: "event",
        },
        {
            anonymous: !1,
            inputs: [
                { indexed: !1, internalType: "string", name: "_value", type: "string" },
                { indexed: !0, internalType: "uint256", name: "_id", type: "uint256" },
            ],
            name: "URI",
            type: "event",
        },
        {
            inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
            ],
            name: "balanceOf",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address[]", name: "owners", type: "address[]" },
                { internalType: "uint256[]", name: "ids", type: "uint256[]" },
            ],
            name: "balanceOfBatch",
            outputs: [{ internalType: "uint256[]", name: "balances", type: "uint256[]" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "uint32", name: "serie", type: "uint32" },
                { internalType: "uint32", name: "artwork", type: "uint32" },
                { internalType: "address", name: "gallery", type: "address" },
            ],
            name: "buy",
            outputs: [],
            stateMutability: "payable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "string", name: "author", type: "string" },
                { internalType: "string", name: "name", type: "string" },
                { internalType: "string", name: "description", type: "string" },
                { internalType: "string", name: "process", type: "string" },
                { internalType: "uint128", name: "price", type: "uint128" },
                { internalType: "string[]", name: "imageUrls", type: "string[]" },
            ],
            name: "createSeries",
            outputs: [{ internalType: "uint32", name: "index", type: "uint32" }],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "serie", type: "uint256" }],
            name: "getSerie",
            outputs: [
                {
                    components: [
                        { internalType: "address", name: "creator", type: "address" },
                        { internalType: "string", name: "author", type: "string" },
                        { internalType: "string", name: "name", type: "string" },
                        { internalType: "string", name: "description", type: "string" },
                        { internalType: "string", name: "process", type: "string" },
                        { internalType: "uint128", name: "price", type: "uint128" },
                        { internalType: "string[]", name: "artworks", type: "string[]" },
                    ],
                    internalType: "struct UnRealArt.Series",
                    name: "",
                    type: "tuple",
                },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
            ],
            name: "isApprovedForAll",
            outputs: [{ internalType: "bool", name: "", type: "bool" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "uint256", name: "id", type: "uint256" },
                { internalType: "uint256", name: "price", type: "uint256" },
            ],
            name: "royaltyInfo",
            outputs: [
                { internalType: "address", name: "receiver", type: "address" },
                { internalType: "uint256", name: "royaltyAmount", type: "uint256" },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256[]", name: "ids", type: "uint256[]" },
                { internalType: "uint256[]", name: "values", type: "uint256[]" },
                { internalType: "bytes", name: "data", type: "bytes" },
            ],
            name: "safeBatchTransferFrom",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "id", type: "uint256" },
                { internalType: "uint256", name: "value", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
            ],
            name: "safeTransferFrom",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            name: "series",
            outputs: [
                { internalType: "address", name: "creator", type: "address" },
                { internalType: "string", name: "author", type: "string" },
                { internalType: "string", name: "name", type: "string" },
                { internalType: "string", name: "description", type: "string" },
                { internalType: "string", name: "process", type: "string" },
                { internalType: "uint128", name: "price", type: "uint128" },
            ],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "seriesCount",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "address", name: "operator", type: "address" },
                { internalType: "bool", name: "approved", type: "bool" },
            ],
            name: "setApprovalForAll",
            outputs: [],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            name: "soldTo",
            outputs: [{ internalType: "address", name: "", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [{ internalType: "bytes4", name: "interfaceID", type: "bytes4" }],
            name: "supportsInterface",
            outputs: [{ internalType: "bool", name: "", type: "bool" }],
            stateMutability: "pure",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            name: "totalSupply",
            outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "id", type: "uint256" }],
            name: "uri",
            outputs: [{ internalType: "string", name: "", type: "string" }],
            stateMutability: "view",
            type: "function",
        },
    ],
    _bytecode$1 =
        "0x60806040526005805460ff1916905534801561001a57600080fd5b5061359c8061002a6000396000f3fe6080604052600436106100f25760003560e01c8063a22cb4651161008a578063dc22cb6a11610059578063dc22cb6a14610311578063e985e9c514610343578063f242432a1461037b578063f2b8f4241461039b57600080fd5b8063a22cb4651461029c578063bd85b039146102bc578063d78e7c9a146102e9578063d7f2c0ef146102fc57600080fd5b80632eb2c2d6116100c65780632eb2c2d6146101eb5780634e1273f41461020d57806353576d951461023a578063662b1d231461026757600080fd5b8062fdd58e146100f757806301ffc9a7146101425780630e89341c146101725780632a55205a1461019f575b600080fd5b34801561010357600080fd5b5061012f610112366004612684565b600160209081526000928352604080842090915290825290205481565b6040519081526020015b60405180910390f35b34801561014e57600080fd5b5061016261015d3660046126dc565b610403565b6040519015158152602001610139565b34801561017e57600080fd5b5061019261018d366004612700565b610460565b6040516101399190612793565b3480156101ab57600080fd5b506101bf6101ba3660046127a6565b6105b0565b6040805173ffffffffffffffffffffffffffffffffffffffff9093168352602083019190915201610139565b3480156101f757600080fd5b5061020b61020636600461284f565b610615565b005b34801561021957600080fd5b5061022d61022836600461290a565b6107fe565b6040516101399190612976565b34801561024657600080fd5b5061025a610255366004612700565b610982565b6040516101399190612a0f565b34801561027357600080fd5b50610287610282366004612b2e565b610d7b565b60405163ffffffff9091168152602001610139565b3480156102a857600080fd5b5061020b6102b7366004612c32565b61115b565b3480156102c857600080fd5b5061012f6102d7366004612700565b60026020526000908152604090205481565b61020b6102f7366004612c82565b6111f0565b34801561030857600080fd5b5060035461012f565b34801561031d57600080fd5b5061033161032c366004612700565b61179d565b60405161013996959493929190612cc5565b34801561034f57600080fd5b5061016261035e366004612d54565b600060208181529281526040808220909352908152205460ff1681565b34801561038757600080fd5b5061020b610396366004612d87565b611a2e565b3480156103a757600080fd5b506103de6103b6366004612700565b60046020526000908152604090205473ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610139565b600061040e82611ba1565b8061045a57507f2a55205a000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b60606000610476670de0b6b3a764000084612e5d565b9050600061048c670de0b6b3a764000085612e71565b9050610588600383815481106104a4576104a4612e85565b9060005260206000209060070201600201600384815481106104c8576104c8612e85565b9060005260206000209060070201600301600385815481106104ec576104ec612e85565b9060005260206000209060070201600601848154811061050e5761050e612e85565b906000526020600020016003868154811061052b5761052b612e85565b90600052602060002090600702016001016003878154811061054f5761054f612e85565b9060005260206000209060070201600401604051602001610574959493929190612fd9565b604051602081830303815290604052611c82565b6040516020016105989190613129565b60405160208183030381529060405292505050919050565b60008060036105c7670de0b6b3a764000086612e5d565b815481106105d7576105d7612e85565b600091825260209091206007909102015473ffffffffffffffffffffffffffffffffffffffff16610609600a85612e5d565b915091505b9250929050565b848314610683576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f455243313135353a204c656e677468206d69736d61746368000000000000000060448201526064015b60405180910390fd5b61068c88611e5b565b61069a888888888888611f1b565b73ffffffffffffffffffffffffffffffffffffffff87163b156107f4576040517fbc197c81000000000000000000000000000000000000000000000000000000008082529073ffffffffffffffffffffffffffffffffffffffff89169063bc197c81906107199033908d908c908c908c908c908c908c90600401613206565b602060405180830381600087803b15801561073357600080fd5b505af1158015610747573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076b9190613277565b7fffffffff0000000000000000000000000000000000000000000000000000000016146107f4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f57726f6e672072657475726e2076616c75650000000000000000000000000000604482015260640161067a565b5050505050505050565b60608382811461086a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f455243313135353a204c656e677468206d69736d617463680000000000000000604482015260640161067a565b8067ffffffffffffffff81111561088357610883613294565b6040519080825280602002602001820160405280156108ac578160200160208202803683370190505b50915060005b8181101561097857600160008888848181106108d0576108d0612e85565b90506020020160208101906108e591906132c3565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600086868481811061093357610933612e85565b9050602002013581526020019081526020016000205483828151811061095b5761095b612e85565b602090810291909101015280610970816132de565b9150506108b2565b5050949350505050565b6109ea6040518060e00160405280600073ffffffffffffffffffffffffffffffffffffffff1681526020016060815260200160608152602001606081526020016060815260200160006fffffffffffffffffffffffffffffffff168152602001606081525090565b600382815481106109fd576109fd612e85565b60009182526020918290206040805160e08101909152600790920201805473ffffffffffffffffffffffffffffffffffffffff1682526001810180549293919291840191610a4a90612eb4565b80601f0160208091040260200160405190810160405280929190818152602001828054610a7690612eb4565b8015610ac35780601f10610a9857610100808354040283529160200191610ac3565b820191906000526020600020905b815481529060010190602001808311610aa657829003601f168201915b50505050508152602001600282018054610adc90612eb4565b80601f0160208091040260200160405190810160405280929190818152602001828054610b0890612eb4565b8015610b555780601f10610b2a57610100808354040283529160200191610b55565b820191906000526020600020905b815481529060010190602001808311610b3857829003601f168201915b50505050508152602001600382018054610b6e90612eb4565b80601f0160208091040260200160405190810160405280929190818152602001828054610b9a90612eb4565b8015610be75780601f10610bbc57610100808354040283529160200191610be7565b820191906000526020600020905b815481529060010190602001808311610bca57829003601f168201915b50505050508152602001600482018054610c0090612eb4565b80601f0160208091040260200160405190810160405280929190818152602001828054610c2c90612eb4565b8015610c795780601f10610c4e57610100808354040283529160200191610c79565b820191906000526020600020905b815481529060010190602001808311610c5c57829003601f168201915b505050918352505060058201546fffffffffffffffffffffffffffffffff16602080830191909152600683018054604080518285028101850182528281529401939260009084015b82821015610d6d578382906000526020600020018054610ce090612eb4565b80601f0160208091040260200160405190810160405280929190818152602001828054610d0c90612eb4565b8015610d595780601f10610d2e57610100808354040283529160200191610d59565b820191906000526020600020905b815481529060010190602001808311610d3c57829003601f168201915b505050505081526020019060010190610cc1565b505050915250909392505050565b6003546040805160e0810182526060602080830182905282840182905281830182905260808301829052600060a084015260c08301919091523382528251601f8f018290048202810182019093528d83529091908e908e908190840183828082843760009201919091525050505060208083019190915260408051601f8d018390048302810183019091528b8152908c908c908190840183828082843760009201919091525050505060408083019190915280516020601f8b01819004810282018101909252898152908a908a90819084018382808284376000920191909152505050506060820152604080516020601f8901819004810282018101909252878152908890889081908401838280828437600092018290525060808601949094525050506fffffffffffffffffffffffffffffffff861660a083015260038054600181018255915281517fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b600790920291820180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117815560208084015180518594610f6a937fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85c909101920190612480565b5060408201518051610f86916002840191602090910190612480565b5060608201518051610fa2916003840191602090910190612480565b5060808201518051610fbe916004840191602090910190612480565b5060a08201516005820180547fffffffffffffffffffffffffffffffff00000000000000000000000000000000166fffffffffffffffffffffffffffffffff90921691909117905560c08201518051611021916006840191602090910190612504565b50505060005b8381101561111957600060038463ffffffff168154811061104a5761104a612e85565b600091825260209091206006600790920201015461107663ffffffff8616670de0b6b3a7640000613317565b67ffffffffffffffff1661108a9190613347565b90506110983382600161210c565b60038463ffffffff16815481106110b1576110b1612e85565b90600052602060002090600702016006018686848181106110d4576110d4612e85565b90506020028101906110e6919061335f565b8254600181018455600093845260209093206111049301919061255d565b50508080611111906132de565b915050611027565b5060405163ffffffff8316907f2371cef6032b20ad35a9487c8cce5e454620dab2674022e4302a03ccff15031c90600090a2509b9a5050505050505050505050565b3360008181526020818152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915590519081529192917f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35050565b60055460ff161561125d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f4e6f7420616761696e2100000000000000000000000000000000000000000000604482015260640161067a565b600580547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055600063ffffffff808416906112a7908616670de0b6b3a7640000613317565b6112b191906133c4565b67ffffffffffffffff1660008181526004602052604090205490915073ffffffffffffffffffffffffffffffffffffffff161561134a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f416c726561647920736f6c640000000000000000000000000000000000000000604482015260640161067a565b6001600060038663ffffffff168154811061136757611367612e85565b6000918252602080832060079092029091015473ffffffffffffffffffffffffffffffffffffffff1683528281019390935260409182018120848252909252902054600114611412576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f7420666f722073616c650000000000000000000000000000000000000000604482015260640161067a565b600060038563ffffffff168154811061142d5761142d612e85565b60009182526020909120600560079092020101546fffffffffffffffffffffffffffffffff169050348111156114bf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f4e6f7420656e6f7567682066756e64732073656e740000000000000000000000604482015260640161067a565b60038563ffffffff16815481106114d8576114d8612e85565b600091825260209091206007909102015473ffffffffffffffffffffffffffffffffffffffff16331415611568576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f43616e6e6f7420627579206f776e20776f726b00000000000000000000000000604482015260640161067a565b600082815260046020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001633179055600380546115ed919063ffffffff88169081106115bd576115bd612e85565b600091825260209091206007909102015473ffffffffffffffffffffffffffffffffffffffff163384600161224c565b61161361160c6fffffffffffffffffffffffffffffffff8316476133f0565b33906123b1565b611685606461162383605a613407565b61162d9190613436565b6fffffffffffffffffffffffffffffffff1660038763ffffffff168154811061165857611658612e85565b600091825260209091206007909102015473ffffffffffffffffffffffffffffffffffffffff16906123b1565b611704606461169583600a613407565b61169f9190613436565b6fffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff85166116e657739e6e344f94305d36ea59912b0911fe2c9149ed3e6116e8565b845b73ffffffffffffffffffffffffffffffffffffffff16906123b1565b6040516fffffffffffffffffffffffffffffffff8216815273ffffffffffffffffffffffffffffffffffffffff84169063ffffffff80871691908816907fc14306f241220755eadc850dca73f5e0ecd55bfa3c7ae970b5fe1911d9cd84ae9060200160405180910390a45050600580547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169055505050565b600381815481106117ad57600080fd5b60009182526020909120600790910201805460018201805473ffffffffffffffffffffffffffffffffffffffff9092169350906117e990612eb4565b80601f016020809104026020016040519081016040528092919081815260200182805461181590612eb4565b80156118625780601f1061183757610100808354040283529160200191611862565b820191906000526020600020905b81548152906001019060200180831161184557829003601f168201915b50505050509080600201805461187790612eb4565b80601f01602080910402602001604051908101604052809291908181526020018280546118a390612eb4565b80156118f05780601f106118c5576101008083540402835291602001916118f0565b820191906000526020600020905b8154815290600101906020018083116118d357829003601f168201915b50505050509080600301805461190590612eb4565b80601f016020809104026020016040519081016040528092919081815260200182805461193190612eb4565b801561197e5780601f106119535761010080835404028352916020019161197e565b820191906000526020600020905b81548152906001019060200180831161196157829003601f168201915b50505050509080600401805461199390612eb4565b80601f01602080910402602001604051908101604052809291908181526020018280546119bf90612eb4565b8015611a0c5780601f106119e157610100808354040283529160200191611a0c565b820191906000526020600020905b8154815290600101906020018083116119ef57829003601f168201915b505050600590930154919250506fffffffffffffffffffffffffffffffff1686565b611a3786611e5b565b611a438686868661224c565b73ffffffffffffffffffffffffffffffffffffffff85163b15611b99576040517ff23a6e61000000000000000000000000000000000000000000000000000000008082529073ffffffffffffffffffffffffffffffffffffffff87169063f23a6e6190611abe9033908b908a908a908a908a90600401613465565b602060405180830381600087803b158015611ad857600080fd5b505af1158015611aec573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b109190613277565b7fffffffff000000000000000000000000000000000000000000000000000000001614611b99576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f57726f6e672072657475726e2076616c75650000000000000000000000000000604482015260640161067a565b505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f01ffc9a7000000000000000000000000000000000000000000000000000000001480611c3457507fd9b67a26000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b8061045a5750507fffffffff00000000000000000000000000000000000000000000000000000000167f0e89341c000000000000000000000000000000000000000000000000000000001490565b6060815160001415611ca257505060408051602081019091526000815290565b60006040518060600160405280604081526020016135276040913990506000600384516002611cd19190613347565b611cdb9190612e5d565b611ce69060046134b7565b90506000611cf5826020613347565b67ffffffffffffffff811115611d0d57611d0d613294565b6040519080825280601f01601f191660200182016040528015611d37576020820181803683370190505b509050818152600183018586518101602084015b81831015611da3576003830192508251603f8160121c168501518253600182019150603f81600c1c168501518253600182019150603f8160061c168501518253600182019150603f8116850151825350600101611d4b565b600389510660018114611dbd5760028114611e0757611e4d565b7f3d3d0000000000000000000000000000000000000000000000000000000000007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe830152611e4d565b7f3d000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8301525b509398975050505050505050565b73ffffffffffffffffffffffffffffffffffffffff8116331480611eb2575073ffffffffffffffffffffffffffffffffffffffff811660009081526020818152604080832033845290915290205460ff1615156001145b611f18576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f5472616e73666572206e6f7420616c6c6f776564000000000000000000000000604482015260640161067a565b50565b73ffffffffffffffffffffffffffffffffffffffff8516611f98576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f203020616464726573730000000000000000000000000000000000000000604482015260640161067a565b60005b83811015612081576000858583818110611fb757611fb7612e85565b9050602002013590506000848484818110611fd457611fd4612e85565b73ffffffffffffffffffffffffffffffffffffffff8c166000908152600160209081526040808320888452825282208054939091029490940135945084939250906120209084906133f0565b909155505073ffffffffffffffffffffffffffffffffffffffff8816600090815260016020908152604080832085845290915281208054839290612065908490613347565b9250508190555050508080612079906132de565b915050611f9b565b508473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb878787876040516120fc94939291906134f4565b60405180910390a4505050505050565b73ffffffffffffffffffffffffffffffffffffffff8316612189576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f203020616464726573730000000000000000000000000000000000000000604482015260640161067a565b73ffffffffffffffffffffffffffffffffffffffff83166000908152600160209081526040808320858452909152812080548392906121c9908490613347565b9091555050600082815260026020526040812080548392906121ec908490613347565b9091555050604080518381526020810183905273ffffffffffffffffffffffffffffffffffffffff85169160009133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4505050565b73ffffffffffffffffffffffffffffffffffffffff83166122c9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e6f203020616464726573730000000000000000000000000000000000000000604482015260640161067a565b73ffffffffffffffffffffffffffffffffffffffff84166000908152600160209081526040808320858452909152812080548392906123099084906133f0565b909155505073ffffffffffffffffffffffffffffffffffffffff831660009081526001602090815260408083208584529091528120805483929061234e908490613347565b9091555050604080518381526020810183905273ffffffffffffffffffffffffffffffffffffffff808616929087169133917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a450505050565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d806000811461240b576040519150601f19603f3d011682016040523d82523d6000602084013e612410565b606091505b505090508061247b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f426f72696e67416464726573733a207472616e73666572206661696c65640000604482015260640161067a565b505050565b82805461248c90612eb4565b90600052602060002090601f0160209004810192826124ae57600085556124f4565b82601f106124c757805160ff19168380011785556124f4565b828001600101855582156124f4579182015b828111156124f45782518255916020019190600101906124d9565b506125009291506125ef565b5090565b828054828255906000526020600020908101928215612551579160200282015b828111156125515782518051612541918491602090910190612480565b5091602001919060010190612524565b50612500929150612604565b82805461256990612eb4565b90600052602060002090601f01602090048101928261258b57600085556124f4565b82601f106125c2578280017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff008235161785556124f4565b828001600101855582156124f4579182015b828111156124f45782358255916020019190600101906125d4565b5b8082111561250057600081556001016125f0565b808211156125005760006126188282612621565b50600101612604565b50805461262d90612eb4565b6000825580601f1061263d575050565b601f016020900490600052602060002090810190611f1891906125ef565b803573ffffffffffffffffffffffffffffffffffffffff8116811461267f57600080fd5b919050565b6000806040838503121561269757600080fd5b6126a08361265b565b946020939093013593505050565b7fffffffff0000000000000000000000000000000000000000000000000000000081168114611f1857600080fd5b6000602082840312156126ee57600080fd5b81356126f9816126ae565b9392505050565b60006020828403121561271257600080fd5b5035919050565b60005b8381101561273457818101518382015260200161271c565b83811115612743576000848401525b50505050565b60008151808452612761816020860160208601612719565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006126f96020830184612749565b600080604083850312156127b957600080fd5b50508035926020909101359150565b60008083601f8401126127da57600080fd5b50813567ffffffffffffffff8111156127f257600080fd5b6020830191508360208260051b850101111561060e57600080fd5b60008083601f84011261281f57600080fd5b50813567ffffffffffffffff81111561283757600080fd5b60208301915083602082850101111561060e57600080fd5b60008060008060008060008060a0898b03121561286b57600080fd5b6128748961265b565b975061288260208a0161265b565b9650604089013567ffffffffffffffff8082111561289f57600080fd5b6128ab8c838d016127c8565b909850965060608b01359150808211156128c457600080fd5b6128d08c838d016127c8565b909650945060808b01359150808211156128e957600080fd5b506128f68b828c0161280d565b999c989b5096995094979396929594505050565b6000806000806040858703121561292057600080fd5b843567ffffffffffffffff8082111561293857600080fd5b612944888389016127c8565b9096509450602087013591508082111561295d57600080fd5b5061296a878288016127c8565b95989497509550505050565b6020808252825182820181905260009190848201906040850190845b818110156129ae57835183529284019291840191600101612992565b50909695505050505050565b600081518084526020808501808196508360051b8101915082860160005b85811015612a025782840389526129f0848351612749565b988501989350908401906001016129d8565b5091979650505050505050565b6020815273ffffffffffffffffffffffffffffffffffffffff82511660208201526000602083015160e06040840152612a4c610100840182612749565b905060408401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe080858403016060860152612a888383612749565b92506060860151915080858403016080860152612aa58383612749565b925060808601519150808584030160a0860152612ac28383612749565b925060a08601519150612ae960c08601836fffffffffffffffffffffffffffffffff169052565b60c08601519150808584030160e086015250612b0582826129ba565b95945050505050565b80356fffffffffffffffffffffffffffffffff8116811461267f57600080fd5b600080600080600080600080600080600060c08c8e031215612b4f57600080fd5b67ffffffffffffffff808d351115612b6657600080fd5b612b738e8e358f0161280d565b909c509a5060208d0135811015612b8957600080fd5b612b998e60208f01358f0161280d565b909a50985060408d0135811015612baf57600080fd5b612bbf8e60408f01358f0161280d565b909850965060608d0135811015612bd557600080fd5b612be58e60608f01358f0161280d565b9096509450612bf660808e01612b0e565b93508060a08e01351115612c0957600080fd5b50612c1a8d60a08e01358e016127c8565b81935080925050509295989b509295989b9093969950565b60008060408385031215612c4557600080fd5b612c4e8361265b565b915060208301358015158114612c6357600080fd5b809150509250929050565b803563ffffffff8116811461267f57600080fd5b600080600060608486031215612c9757600080fd5b612ca084612c6e565b9250612cae60208501612c6e565b9150612cbc6040850161265b565b90509250925092565b73ffffffffffffffffffffffffffffffffffffffff8716815260c060208201526000612cf460c0830188612749565b8281036040840152612d068188612749565b90508281036060840152612d1a8187612749565b90508281036080840152612d2e8186612749565b9150506fffffffffffffffffffffffffffffffff831660a0830152979650505050505050565b60008060408385031215612d6757600080fd5b612d708361265b565b9150612d7e6020840161265b565b90509250929050565b60008060008060008060a08789031215612da057600080fd5b612da98761265b565b9550612db76020880161265b565b94506040870135935060608701359250608087013567ffffffffffffffff811115612de157600080fd5b612ded89828a0161280d565b979a9699509497509295939492505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082612e6c57612e6c612dff565b500490565b600082612e8057612e80612dff565b500690565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600181811c90821680612ec857607f821691505b60208210811415612f02577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b8054600090600181811c9080831680612f2257607f831692505b6020808410821415612f5d577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b818015612f715760018114612fa057612fcd565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00861689528489019650612fcd565b60008881526020902060005b86811015612fc55781548b820152908501908301612fac565b505084890196505b50505050505092915050565b7f7b226e616d65223a2200000000000000000000000000000000000000000000008152600061300b6009830188612f08565b7f222c226465736372697074696f6e223a22000000000000000000000000000000815261303b6011820188612f08565b90507f222c22696d616765223a22697066733a2f2f697066732f000000000000000000815261306d6017820187612f08565b90507f222c22646563696d616c73223a302c2270726f70657274696573223a7b22617581527f74686f72223a220000000000000000000000000000000000000000000000000060208201526130c56027820186612f08565b90507f222c2270726f63657373223a220000000000000000000000000000000000000081526130f7600d820185612f08565b7f227d7d0000000000000000000000000000000000000000000000000000000000815260030198975050505050505050565b7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c00000081526000825161316181601d850160208701612719565b91909101601d0192915050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8311156131a057600080fd5b8260051b8083602087013760009401602001938452509192915050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600073ffffffffffffffffffffffffffffffffffffffff808b168352808a1660208401525060a0604083015261324060a08301888a61316e565b828103606084015261325381878961316e565b905082810360808401526132688185876131bd565b9b9a5050505050505050505050565b60006020828403121561328957600080fd5b81516126f9816126ae565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000602082840312156132d557600080fd5b6126f98261265b565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561331057613310612e2e565b5060010190565b600067ffffffffffffffff8083168185168183048111821515161561333e5761333e612e2e565b02949350505050565b6000821982111561335a5761335a612e2e565b500190565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261339457600080fd5b83018035915067ffffffffffffffff8211156133af57600080fd5b60200191503681900382131561060e57600080fd5b600067ffffffffffffffff8083168185168083038211156133e7576133e7612e2e565b01949350505050565b60008282101561340257613402612e2e565b500390565b60006fffffffffffffffffffffffffffffffff8083168185168183048111821515161561333e5761333e612e2e565b60006fffffffffffffffffffffffffffffffff8084168061345957613459612dff565b92169190910492915050565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015260a060808301526134ab60a0830184866131bd565b98975050505050505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156134ef576134ef612e2e565b500290565b60408152600061350860408301868861316e565b828103602084015261351b81858761316e565b97965050505050505056fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2fa26469706673582212204d25b63364b969f3a4226d53db5f8e430457682be6288634261a96f999134b2964736f6c63430008090033",
    isSuperArgs$1 = (t) => t.length > 1
class UnRealArt__factory extends ContractFactory {
    constructor(...e) {
        var n = (...i) => {
            super(...i)
        }
        isSuperArgs$1(e) ? n(...e) : n(_abi$1, _bytecode$1, e[0]), (this.contractName = "UnRealArt")
    }
    deploy(e) {
        return super.deploy(e || {})
    }
    getDeployTransaction(e) {
        return super.getDeployTransaction(e || {})
    }
    attach(e) {
        return super.attach(e)
    }
    connect(e) {
        return super.connect(e)
    }
    static createInterface() {
        return new Interface(_abi$1)
    }
    static connect(e, n) {
        return new Contract(e, _abi$1, n)
    }
}
UnRealArt__factory.bytecode = _bytecode$1
UnRealArt__factory.abi = _abi$1
var Network = ((t) => (
    (t[(t.NONE = 0)] = "NONE"),
    (t[(t.ETHEREUM = 1)] = "ETHEREUM"),
    (t[(t.ROPSTEN = 3)] = "ROPSTEN"),
    (t[(t.KOVAN = 42)] = "KOVAN"),
    (t[(t.RINKEBY = 4)] = "RINKEBY"),
    (t[(t.GOERLI = 5)] = "GOERLI"),
    (t[(t.OPTIMISM = 10)] = "OPTIMISM"),
    (t[(t.BINANCE = 56)] = "BINANCE"),
    (t[(t.OKEX_TEST = 65)] = "OKEX_TEST"),
    (t[(t.OKEX = 66)] = "OKEX"),
    (t[(t.BINANCE_TEST = 98)] = "BINANCE_TEST"),
    (t[(t.FUSE = 122)] = "FUSE"),
    (t[(t.POLYGON = 137)] = "POLYGON"),
    (t[(t.POLYGON_TEST = 80001)] = "POLYGON_TEST"),
    (t[(t.XDAI = 100)] = "XDAI"),
    (t[(t.HUOBI = 128)] = "HUOBI"),
    (t[(t.HUOBI_TEST = 256)] = "HUOBI_TEST"),
    (t[(t.ENERGY_WEB_CHAIN = 246)] = "ENERGY_WEB_CHAIN"),
    (t[(t.ENERGY_WEB_CHAIN_TEST = 73799)] = "ENERGY_WEB_CHAIN_TEST"),
    (t[(t.ARBITRUM = 42161)] = "ARBITRUM"),
    (t[(t.ARBITRUM_TEST = 421611)] = "ARBITRUM_TEST"),
    (t[(t.AVALANCHE = 43114)] = "AVALANCHE"),
    (t[(t.AVALANCHE_TEST = 43113)] = "AVALANCHE_TEST"),
    (t[(t.TOMO = 88)] = "TOMO"),
    (t[(t.TOMO_TEST = 89)] = "TOMO_TEST"),
    (t[(t.FANTOM = 250)] = "FANTOM"),
    (t[(t.FANTOM_TEST = 4002)] = "FANTOM_TEST"),
    (t[(t.MOONBEAM = 1284)] = "MOONBEAM"),
    (t[(t.MOONBEAM_KUSAMA = 1285)] = "MOONBEAM_KUSAMA"),
    (t[(t.MOONBEAM_TEST = 1287)] = "MOONBEAM_TEST"),
    (t[(t.HARDHAT = 31337)] = "HARDHAT"),
    (t[(t.CELO = 42220)] = "CELO"),
    (t[(t.HARMONY = 16666e5)] = "HARMONY"),
    (t[(t.HARMONY_TEST = 16667e5)] = "HARMONY_TEST"),
    (t[(t.PALM = 11297108109)] = "PALM"),
    (t[(t.TELOS = 40)] = "TELOS"),
    (t[(t.BOBA = 288)] = "BOBA"),
    (t[(t.AURORA = 1313161554)] = "AURORA"),
    (t[(t.AURORA_TEST = 1313161555)] = "AURORA_TEST"),
    (t[(t.AURORA_BETA = 1313161556)] = "AURORA_BETA"),
    (t[(t.UBIQ = 8)] = "UBIQ"),
    (t[(t.UBIQ_TEST = 9)] = "UBIQ_TEST"),
    (t[(t.CRONOS = 25)] = "CRONOS"),
    (t[(t.KLAYTN = 8217)] = "KLAYTN"),
    (t[(t.METIS = 1088)] = "METIS"),
    (t[(t.METIS_TEST = 588)] = "METIS_TEST"),
    t
))(Network || {})
const _abi = [
        {
            inputs: [
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "aggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes[]", name: "returnData", type: "bytes[]" },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "blockAndAggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes32", name: "blockHash", type: "bytes32" },
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
            name: "getBlockHash",
            outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getBlockNumber",
            outputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockCoinbase",
            outputs: [{ internalType: "address", name: "coinbase", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockDifficulty",
            outputs: [{ internalType: "uint256", name: "difficulty", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockGasLimit",
            outputs: [{ internalType: "uint256", name: "gaslimit", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockTimestamp",
            outputs: [{ internalType: "uint256", name: "timestamp", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "addr", type: "address" }],
            name: "getEthBalance",
            outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getLastBlockHash",
            outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "bool", name: "requireSuccess", type: "bool" },
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "tryAggregate",
            outputs: [
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "bool", name: "requireSuccess", type: "bool" },
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "tryBlockAndAggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes32", name: "blockHash", type: "bytes32" },
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
    ],
    _bytecode =
        "0x608060405234801561001057600080fd5b506110ee806100206000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806372425d9d1161007157806372425d9d146101a657806386d516e8146101c4578063a8b0574e146101e2578063bce38bd714610200578063c3077fa914610230578063ee82ac5e14610262576100b4565b80630f28c97d146100b9578063252dba42146100d757806327e86d6e14610108578063399542e91461012657806342cbb15c146101585780634d2301cc14610176575b600080fd5b6100c1610292565b6040516100ce91906106a3565b60405180910390f35b6100f160048036038101906100ec91906109d2565b61029a565b6040516100ff929190610b65565b60405180910390f35b610110610423565b60405161011d9190610bae565b60405180910390f35b610140600480360381019061013b9190610c01565b610438565b60405161014f93929190610d6b565b60405180910390f35b610160610457565b60405161016d91906106a3565b60405180910390f35b610190600480360381019061018b9190610da9565b61045f565b60405161019d91906106a3565b60405180910390f35b6101ae610480565b6040516101bb91906106a3565b60405180910390f35b6101cc610488565b6040516101d991906106a3565b60405180910390f35b6101ea610490565b6040516101f79190610de5565b60405180910390f35b61021a60048036038101906102159190610c01565b610498565b6040516102279190610e00565b60405180910390f35b61024a600480360381019061024591906109d2565b610640565b60405161025993929190610d6b565b60405180910390f35b61027c60048036038101906102779190610e4e565b610663565b6040516102899190610bae565b60405180910390f35b600042905090565b60006060439150825167ffffffffffffffff8111156102bc576102bb6106e8565b5b6040519080825280602002602001820160405280156102ef57816020015b60608152602001906001900390816102da5790505b50905060005b835181101561041d5760008085838151811061031457610313610e7b565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1686848151811061034957610348610e7b565b5b6020026020010151602001516040516103629190610ee6565b6000604051808303816000865af19150503d806000811461039f576040519150601f19603f3d011682016040523d82523d6000602084013e6103a4565b606091505b5091509150816103e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103e090610f5a565b60405180910390fd5b808484815181106103fd576103fc610e7b565b5b60200260200101819052505050808061041590610fa9565b9150506102f5565b50915091565b60006001436104329190610ff2565b40905090565b60008060604392504340915061044e8585610498565b90509250925092565b600043905090565b60008173ffffffffffffffffffffffffffffffffffffffff16319050919050565b600044905090565b600045905090565b600041905090565b6060815167ffffffffffffffff8111156104b5576104b46106e8565b5b6040519080825280602002602001820160405280156104ee57816020015b6104db61066e565b8152602001906001900390816104d35790505b50905060005b82518110156106395760008084838151811061051357610512610e7b565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1685848151811061054857610547610e7b565b5b6020026020010151602001516040516105619190610ee6565b6000604051808303816000865af19150503d806000811461059e576040519150601f19603f3d011682016040523d82523d6000602084013e6105a3565b606091505b509150915085156105ef57816105ee576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105e590611098565b60405180910390fd5b5b604051806040016040528083151581526020018281525084848151811061061957610618610e7b565b5b60200260200101819052505050808061063190610fa9565b9150506104f4565b5092915050565b6000806060610650600185610438565b8093508194508295505050509193909250565b600081409050919050565b6040518060400160405280600015158152602001606081525090565b6000819050919050565b61069d8161068a565b82525050565b60006020820190506106b86000830184610694565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610720826106d7565b810181811067ffffffffffffffff8211171561073f5761073e6106e8565b5b80604052505050565b60006107526106be565b905061075e8282610717565b919050565b600067ffffffffffffffff82111561077e5761077d6106e8565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006107c98261079e565b9050919050565b6107d9816107be565b81146107e457600080fd5b50565b6000813590506107f6816107d0565b92915050565b600080fd5b600067ffffffffffffffff82111561081c5761081b6106e8565b5b610825826106d7565b9050602081019050919050565b82818337600083830152505050565b600061085461084f84610801565b610748565b9050828152602081018484840111156108705761086f6107fc565b5b61087b848285610832565b509392505050565b600082601f830112610898576108976106d2565b5b81356108a8848260208601610841565b91505092915050565b6000604082840312156108c7576108c6610794565b5b6108d16040610748565b905060006108e1848285016107e7565b600083015250602082013567ffffffffffffffff81111561090557610904610799565b5b61091184828501610883565b60208301525092915050565b600061093061092b84610763565b610748565b905080838252602082019050602084028301858111156109535761095261078f565b5b835b8181101561099a57803567ffffffffffffffff811115610978576109776106d2565b5b80860161098589826108b1565b85526020850194505050602081019050610955565b5050509392505050565b600082601f8301126109b9576109b86106d2565b5b81356109c984826020860161091d565b91505092915050565b6000602082840312156109e8576109e76106c8565b5b600082013567ffffffffffffffff811115610a0657610a056106cd565b5b610a12848285016109a4565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a81578082015181840152602081019050610a66565b83811115610a90576000848401525b50505050565b6000610aa182610a47565b610aab8185610a52565b9350610abb818560208601610a63565b610ac4816106d7565b840191505092915050565b6000610adb8383610a96565b905092915050565b6000602082019050919050565b6000610afb82610a1b565b610b058185610a26565b935083602082028501610b1785610a37565b8060005b85811015610b535784840389528151610b348582610acf565b9450610b3f83610ae3565b925060208a01995050600181019050610b1b565b50829750879550505050505092915050565b6000604082019050610b7a6000830185610694565b8181036020830152610b8c8184610af0565b90509392505050565b6000819050919050565b610ba881610b95565b82525050565b6000602082019050610bc36000830184610b9f565b92915050565b60008115159050919050565b610bde81610bc9565b8114610be957600080fd5b50565b600081359050610bfb81610bd5565b92915050565b60008060408385031215610c1857610c176106c8565b5b6000610c2685828601610bec565b925050602083013567ffffffffffffffff811115610c4757610c466106cd565b5b610c53858286016109a4565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610c9281610bc9565b82525050565b6000604083016000830151610cb06000860182610c89565b5060208301518482036020860152610cc88282610a96565b9150508091505092915050565b6000610ce18383610c98565b905092915050565b6000602082019050919050565b6000610d0182610c5d565b610d0b8185610c68565b935083602082028501610d1d85610c79565b8060005b85811015610d595784840389528151610d3a8582610cd5565b9450610d4583610ce9565b925060208a01995050600181019050610d21565b50829750879550505050505092915050565b6000606082019050610d806000830186610694565b610d8d6020830185610b9f565b8181036040830152610d9f8184610cf6565b9050949350505050565b600060208284031215610dbf57610dbe6106c8565b5b6000610dcd848285016107e7565b91505092915050565b610ddf816107be565b82525050565b6000602082019050610dfa6000830184610dd6565b92915050565b60006020820190508181036000830152610e1a8184610cf6565b905092915050565b610e2b8161068a565b8114610e3657600080fd5b50565b600081359050610e4881610e22565b92915050565b600060208284031215610e6457610e636106c8565b5b6000610e7284828501610e39565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081905092915050565b6000610ec082610a47565b610eca8185610eaa565b9350610eda818560208601610a63565b80840191505092915050565b6000610ef28284610eb5565b915081905092915050565b600082825260208201905092915050565b7f4d756c746963616c6c206167677265676174653a2063616c6c206661696c6564600082015250565b6000610f44602083610efd565b9150610f4f82610f0e565b602082019050919050565b60006020820190508181036000830152610f7381610f37565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610fb48261068a565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610fe757610fe6610f7a565b5b600182019050919050565b6000610ffd8261068a565b91506110088361068a565b92508282101561101b5761101a610f7a565b5b828203905092915050565b7f4d756c746963616c6c32206167677265676174653a2063616c6c206661696c6560008201527f6400000000000000000000000000000000000000000000000000000000000000602082015250565b6000611082602183610efd565b915061108d82611026565b604082019050919050565b600060208201905081810360008301526110b181611075565b905091905056fea26469706673582212202ad79168f7d1dfe0e32b590efa8eefaaaf0c61e9f6257161be30bcbab1ad332264736f6c63430008090033",
    isSuperArgs = (t) => t.length > 1
class Multicall2__factory extends ContractFactory {
    constructor(...e) {
        var n = (...i) => {
            super(...i)
        }
        isSuperArgs(e) ? n(...e) : n(_abi, _bytecode, e[0]), (this.contractName = "Multicall2")
    }
    deploy(e) {
        return super.deploy(e || {})
    }
    getDeployTransaction(e) {
        return super.getDeployTransaction(e || {})
    }
    attach(e) {
        return super.attach(e)
    }
    connect(e) {
        return super.connect(e)
    }
    static createInterface() {
        return new Interface(_abi)
    }
    static connect(e, n) {
        return new Contract(e, _abi, n)
    }
}
Multicall2__factory.bytecode = _bytecode
Multicall2__factory.abi = _abi
class NetworkConnector {
    constructor(e) {
        ;(this.items = []), e ? (this.provider = e) : (this.provider = new StaticJsonRpcProvider({ url: this.rpcUrls[0] }))
    }
    static get chainId() {
        return Network.NONE
    }
    static get chainName() {
        return "None"
    }
    static get nativeCurrency() {
        return { name: "None", symbol: "NONE", decimals: 18 }
    }
    static get rpcUrls() {
        return []
    }
    static get blockExplorerUrls() {
        return []
    }
    static get multiCallAddress() {
        return ""
    }
    static get chainParams() {
        return {
            chainId: hexStripZeros(hexlify(this.chainId)),
            chainName: this.chainName,
            nativeCurrency: this.nativeCurrency,
            rpcUrls: this.rpcUrls,
            blockExplorerUrls: this.blockExplorerUrls,
        }
    }
    static get coinGeckoId() {
        return ""
    }
    get type() {
        return this.constructor
    }
    get chainId() {
        return this.type.chainId
    }
    get chainName() {
        return this.type.chainName
    }
    get nativeCurrency() {
        return this.type.nativeCurrency
    }
    get rpcUrls() {
        return this.type.rpcUrls
    }
    get blockExplorerUrls() {
        return this.type.blockExplorerUrls
    }
    get multiCallAddress() {
        return this.type.multiCallAddress
    }
    get coinGeckoId() {
        return this.type.coinGeckoId
    }
    queue(e, n, i, o) {
        this.items.push({ transactionPromise: e, contractInterface: n, callback: i, failcallback: o })
    }
    async call(e = 0) {
        const n = []
        for (; this.items.length; ) {
            const i = Multicall2__factory.connect(this.multiCallAddress, this.provider),
                o = this.items.splice(0, e || this.items.length)
            for (let c in o) o[c].transaction = await o[c].transactionPromise
            const a = o.map((c) => ({ target: c.transaction.to, callData: c.transaction.data })),
                l = await i.callStatic.tryAggregate(!1, a)
            o.forEach((c, g) => {
                var v
                if (l[g].success) {
                    let _ = l[g].returnData
                    if (c.contractInterface)
                        try {
                            ;(_ = c.contractInterface.decodeFunctionResult(
                                c.contractInterface.parseTransaction({ data: ((v = c.transaction) == null ? void 0 : v.data) || "" }).name,
                                l[g].returnData
                            )),
                                c.callback && c.callback(_.length === 1 ? _[0] : _, c.transaction)
                        } catch (A) {
                            console.log(A)
                        }
                    n.push(_.length === 1 ? _[0] : _)
                } else c.failcallback && c.failcallback(c.transaction), console.log("Fail"), n.push(new Error("Failed"))
            })
        }
        return n
    }
}
class EthereumConnector extends NetworkConnector {
    static get chainId() {
        return Network.ETHEREUM
    }
    static get chainName() {
        return "Ethereum"
    }
    static get nativeCurrency() {
        return { name: "Ethereum", symbol: "ETH", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://mainnet.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://etherscan.io/"]
    }
    static get multiCallAddress() {
        return "0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696"
    }
    static get coinGeckoId() {
        return "ethereum"
    }
}
class RopstenConnector extends EthereumConnector {
    static get chainId() {
        return Network.ROPSTEN
    }
    static get chainName() {
        return "Ropsten"
    }
    static get rpcUrls() {
        return ["https://ropsten.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://ropsten.etherscan.io/"]
    }
    static get coinGeckoId() {
        return "ethereum"
    }
}
class KovanConnector extends EthereumConnector {
    static get chainId() {
        return Network.KOVAN
    }
    static get chainName() {
        return "Kovan"
    }
    static get rpcUrls() {
        return ["https://kovan.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://kovan.etherscan.io/"]
    }
}
class RinkebyConnector extends EthereumConnector {
    static get chainId() {
        return Network.RINKEBY
    }
    static get chainName() {
        return "Rinkeby"
    }
    static get rpcUrls() {
        return ["https://rinkeby.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://rinkeby.etherscan.io/"]
    }
}
class GoerliConnector extends EthereumConnector {
    static get chainId() {
        return Network.GOERLI
    }
    static get chainName() {
        return "G\xF6rli"
    }
    static get rpcUrls() {
        return ["https://goerli.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://goerli.etherscan.io/"]
    }
}
class BinanceConnector extends NetworkConnector {
    static get chainId() {
        return Network.BINANCE
    }
    static get chainName() {
        return "Binance Smart Chain"
    }
    static get nativeCurrency() {
        return { name: "BNB", symbol: "BNB", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://bsc-dataseed.binance.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://bscscan.com/"]
    }
    static get multiCallAddress() {
        return "0xa9193376D09C7f31283C54e56D013fCF370Cd9D9"
    }
    static get coinGeckoId() {
        return "binance-smart-chain"
    }
}
class BinanceTestConnector extends BinanceConnector {
    static get chainId() {
        return Network.BINANCE_TEST
    }
    static get chainName() {
        return "Binance Smart Chain Testnet"
    }
    static get rpcUrls() {
        return ["https://data-seed-prebsc-1-s1.binance.org:8545/"]
    }
    static get blockExplorerUrls() {
        return ["https://testnet.bscscan.com/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class FuseConnector extends NetworkConnector {
    static get chainId() {
        return Network.FUSE
    }
    static get chainName() {
        return "Fuse"
    }
    static get nativeCurrency() {
        return { name: "Fuse", symbol: "FUSE", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.fuse.io/"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.fuse.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
    static get coinGeckoId() {
        return "fuse"
    }
}
class PolygonConnector extends NetworkConnector {
    static get chainId() {
        return Network.POLYGON
    }
    static get chainName() {
        return "Polygon"
    }
    static get nativeCurrency() {
        return { name: "MATIC", symbol: "MATIC", decimals: 18 }
    }
    static get rpcUrls() {
        return [
            "https://matic-mainnet.chainstacklabs.com/",
            "https://rpc-mainnet.matic.network/",
            "https://rpc-mainnet.maticvigil.com/",
            "https://rpc-mainnet.matic.quiknode.pro/",
            "https://matic-mainnet-full-rpc.bwarelabs.com/",
            "https://matic-mainnet-archive-rpc.bwarelabs.com/",
        ]
    }
    static get blockExplorerUrls() {
        return [
            "https://polygonscan.com/",
            "https://polygon-explorer-mainnet.chainstacklabs.com/",
            "https://explorer-mainnet.maticvigil.com/",
            "https://explorer.matic.network/",
            "https://backup-explorer.matic.network/",
        ]
    }
    static get multiCallAddress() {
        return "0x02817C1e3543c2d908a590F5dB6bc97f933dB4BD"
    }
    static get coinGeckoId() {
        return "polygon-pos"
    }
}
class PolygonTestConnector extends PolygonConnector {
    static get chainId() {
        return Network.POLYGON_TEST
    }
    static get chainName() {
        return "Mumbai (Polygon Testnet)"
    }
    static get rpcUrls() {
        return [
            "https://matic-mumbai.chainstacklabs.com/",
            "https://rpc-mumbai.matic.today/",
            "https://rpc-mumbai.maticvigil.com/",
            "https://matic-testnet-archive-rpc.bwarelabs.com/",
        ]
    }
    static get blockExplorerUrls() {
        return [
            "https://mumbai.polygonscan.com/",
            "https://polygon-explorer-mumbai.chainstacklabs.com/",
            "https://explorer-mumbai.maticvigil.com/",
            "https://mumbai-explorer.matic.today/",
            "https://backup-mumbai-explorer.matic.today/",
        ]
    }
    static get multiCallAddress() {
        return "0xc1400d49baa8e307B4462cD46E0a20109D25F50f"
    }
}
class GnosisConnector extends NetworkConnector {
    static get chainId() {
        return Network.XDAI
    }
    static get chainName() {
        return "Gnosis (xDai)"
    }
    static get nativeCurrency() {
        return { name: "xDai", symbol: "xDAI", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.gnosischain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://blockscout.com/xdai/mainnet/"]
    }
    static get multiCallAddress() {
        return "0x67dA5f2FfaDDfF067AB9d5F025F8810634d84287"
    }
    static get coinGeckoId() {
        return "xdai"
    }
}
class HuobiConnector extends NetworkConnector {
    static get chainId() {
        return Network.HUOBI
    }
    static get chainName() {
        return "Heco"
    }
    static get nativeCurrency() {
        return { name: "HT", symbol: "HT", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://http-mainnet-node.huobichain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.hecochain.io/", "https://hecoinfo.com/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
    static get coinGeckoId() {
        return "huobi-token"
    }
}
class HuobiTestConnector extends HuobiConnector {
    static get chainId() {
        return Network.HUOBI_TEST
    }
    static get chainName() {
        return "Heco Testnet"
    }
    static get rpcUrls() {
        return ["https://http-testnet.hecochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan-testnet.hecochain.com/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class ArbitrumConnector extends EthereumConnector {
    static get chainId() {
        return Network.ARBITRUM
    }
    static get chainName() {
        return "Arbitrum"
    }
    static get rpcUrls() {
        return ["https://arb1.arbitrum.io/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://arbiscan.io/"]
    }
    static get multiCallAddress() {
        return "0x80C7DD17B01855a6D2347444a0FCC36136a314de"
    }
    static get coinGeckoId() {
        return "arbitrum-one"
    }
}
class ArbitrumTestConnector extends ArbitrumConnector {
    static get chainId() {
        return Network.ARBITRUM_TEST
    }
    static get chainName() {
        return "Arbitrum Testnet"
    }
    static get rpcUrls() {
        return ["https://rinkeby.arbitrum.io/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://rinkeby-explorer.arbitrum.io/"]
    }
    static get multiCallAddress() {
        return "0xa501c031958F579dB7676fF1CE78AD305794d579"
    }
}
class AvalancheConnector extends NetworkConnector {
    static get chainId() {
        return Network.AVALANCHE
    }
    static get chainName() {
        return "Avalanche Mainnet C-Chain"
    }
    static get nativeCurrency() {
        return { name: "Avalanche", symbol: "AVAX", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://api.avax.network/ext/bc/C/rpc"]
    }
    static get blockExplorerUrls() {
        return ["https://cchain.explorer.avax.network/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
    static get coinGeckoId() {
        return "avalanche"
    }
}
class AvalancheTestConnector extends AvalancheConnector {
    static get chainId() {
        return Network.AVALANCHE_TEST
    }
    static get chainName() {
        return "Avalanche Testnet C-Chain"
    }
    static get rpcUrls() {
        return ["https://api.avax-test.network/ext/bc/C/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://cchain.explorer.avax-test.network/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class TomoConnector extends NetworkConnector {
    static get chainId() {
        return Network.TOMO
    }
    static get chainName() {
        return "TomoChain"
    }
    static get nativeCurrency() {
        return { name: "TOMO", symbol: "TOMO", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.tomochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan.tomochain.com/"]
    }
    static get coinGeckoId() {
        return "tomochain"
    }
}
class TomoTestConnector extends TomoConnector {
    static get chainId() {
        return Network.TOMO_TEST
    }
    static get chainName() {
        return "TomoChain Testnet"
    }
    static get rpcUrls() {
        return ["https://rpc.testnet.tomochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan.testnet.tomochain.com/"]
    }
}
class FantomConnector extends NetworkConnector {
    static get chainId() {
        return Network.FANTOM
    }
    static get chainName() {
        return "Fantom Opera"
    }
    static get nativeCurrency() {
        return { name: "FTM", symbol: "FTM", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.ftm.tools/"]
    }
    static get blockExplorerUrls() {
        return ["https://ftmscan.com/"]
    }
    static get multiCallAddress() {
        return "0x22D4cF72C45F8198CfbF4B568dBdB5A85e8DC0B5"
    }
    static get coinGeckoId() {
        return "fantom"
    }
}
class FantomTestConnector extends FantomConnector {
    static get chainId() {
        return Network.FANTOM
    }
    static get chainName() {
        return "Fantom Testnet"
    }
    static get rpcUrls() {
        return ["https://rpc.testnet.fantom.network/"]
    }
    static get blockExplorerUrls() {
        return []
    }
    static get multiCallAddress() {
        return ""
    }
}
class MoonbeamConnector extends NetworkConnector {
    static get chainId() {
        return Network.MOONBEAM
    }
    static get chainName() {
        return "Moonbeam"
    }
    static get nativeCurrency() {
        return { name: "Moonbeam", symbol: "GLMR", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://moonscan.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
}
class MoonbeamTestConnector extends NetworkConnector {
    static get chainId() {
        return Network.MOONBEAM_TEST
    }
    static get chainName() {
        return "Moonbase Alpha"
    }
    static get nativeCurrency() {
        return { name: "DEV", symbol: "DEV", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonbase.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://moonbase-blockscout.testnet.moonbeam.network/"]
    }
}
class MoonbeamKusamaConnector extends NetworkConnector {
    static get chainId() {
        return Network.MOONBEAM_KUSAMA
    }
    static get chainName() {
        return "Moonriver"
    }
    static get nativeCurrency() {
        return { name: "MOVR", symbol: "MOVR", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonriver.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://blockscout.moonriver.moonbeam.network/"]
    }
    static get multiCallAddress() {
        return "0x270f2F35bED92B7A59eA5F08F6B3fd34c8D9D9b5"
    }
    static get coinGeckoId() {
        return "moonriver"
    }
}
class HardhatConnector extends EthereumConnector {
    static get chainId() {
        return Network.HARDHAT
    }
    static get chainName() {
        return "Hardhat"
    }
    static get rpcUrls() {
        return ["http://127.0.0.1:8545/"]
    }
    static get blockExplorerUrls() {
        return ["https://localhost:2504/"]
    }
}
class CeloConnector extends NetworkConnector {
    static get chainId() {
        return Network.CELO
    }
    static get chainName() {
        return "Celo"
    }
    static get nativeCurrency() {
        return { name: "Celo", symbol: "CELO", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://forno.celo.org"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.celo.org/"]
    }
    static get multiCallAddress() {
        return "0x9aac9048fC8139667D6a2597B902865bfdc225d3"
    }
    static get coinGeckoId() {
        return "celo"
    }
}
class HarmonyConnector extends NetworkConnector {
    static get chainId() {
        return Network.HARMONY
    }
    static get chainName() {
        return "Harmony"
    }
    static get nativeCurrency() {
        return { name: "Harmony", symbol: "ONE", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://api.harmony.one"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.harmony.one/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
}
class HarmonyTestConnector extends HarmonyConnector {
    static get chainId() {
        return Network.HARMONY_TEST
    }
    static get chainName() {
        return "Harmony Testnet"
    }
    static get rpcUrls() {
        return ["https://api.s0.b.hmny.io/"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.pops.one/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class OKExConnector extends NetworkConnector {
    static get chainId() {
        return Network.OKEX
    }
    static get chainName() {
        return "OKExChain"
    }
    static get nativeCurrency() {
        return { name: "OEC Token", symbol: "OKT", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://exchainrpc.okex.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.oklink.com/oec/"]
    }
    static get multiCallAddress() {
        return "0xF4d73326C13a4Fc5FD7A064217e12780e9Bd62c3"
    }
    static get coinGeckoId() {
        return "okex-chain"
    }
}
class OKExTestConnector extends OKExConnector {
    static get chainId() {
        return Network.OKEX_TEST
    }
    static get chainName() {
        return "OKExChain Testnet"
    }
    static get rpcUrls() {
        return ["https://exchaintestrpc.okex.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.oklink.com/oec-test/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class PalmConnector extends NetworkConnector {
    static get chainId() {
        return Network.PALM
    }
    static get chainName() {
        return "Palm"
    }
    static get nativeCurrency() {
        return { name: "Palm", symbol: "PALM", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://palm-mainnet.infura.io/v3/3a961d6501e54add9a41aa53f15de99b"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.palm.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
}
class TelosConnector extends NetworkConnector {
    static get chainId() {
        return Network.TELOS
    }
    static get chainName() {
        return "Telos"
    }
    static get nativeCurrency() {
        return { name: "Telos", symbol: "TLOS", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://mainnet.telos.net/evm"]
    }
    static get blockExplorerUrls() {
        return ["https://rpc1.us.telos.net/v2/explore/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
}
const connectors = {
        [Network.NONE]: NetworkConnector,
        [Network.ETHEREUM]: EthereumConnector,
        [Network.ROPSTEN]: RopstenConnector,
        [Network.KOVAN]: KovanConnector,
        [Network.RINKEBY]: RinkebyConnector,
        [Network.GOERLI]: GoerliConnector,
        [Network.BINANCE]: BinanceConnector,
        [Network.BINANCE_TEST]: BinanceTestConnector,
        [Network.FUSE]: FuseConnector,
        [Network.POLYGON]: PolygonConnector,
        [Network.POLYGON_TEST]: PolygonTestConnector,
        [Network.XDAI]: GnosisConnector,
        [Network.HUOBI]: HuobiConnector,
        [Network.HUOBI_TEST]: HuobiTestConnector,
        [Network.ARBITRUM]: ArbitrumConnector,
        [Network.ARBITRUM_TEST]: ArbitrumTestConnector,
        [Network.AVALANCHE]: AvalancheConnector,
        [Network.AVALANCHE_TEST]: AvalancheTestConnector,
        [Network.TOMO]: TomoConnector,
        [Network.TOMO_TEST]: TomoTestConnector,
        [Network.FANTOM]: FantomConnector,
        [Network.FANTOM_TEST]: FantomTestConnector,
        [Network.MOONBEAM]: MoonbeamConnector,
        [Network.MOONBEAM_TEST]: MoonbeamTestConnector,
        [Network.MOONBEAM_KUSAMA]: MoonbeamKusamaConnector,
        [Network.HARDHAT]: HardhatConnector,
        [Network.CELO]: CeloConnector,
        [Network.HARMONY]: HarmonyConnector,
        [Network.HARMONY_TEST]: HarmonyTestConnector,
        [Network.OKEX]: OKExConnector,
        [Network.OKEX_TEST]: OKExTestConnector,
        [Network.PALM]: PalmConnector,
        [Network.TELOS]: TelosConnector,
    },
    LOAD_BASE = (t) => Promise.reject(new Error(`No base found for "${t}"`))
class Multibases {
    constructor(e) {
        ;(this._basesByName = {}), (this._basesByPrefix = {}), (this._loadBase = e.loadBase || LOAD_BASE)
        for (const n of e.bases) this.addBase(n)
    }
    addBase(e) {
        if (this._basesByName[e.name] || this._basesByPrefix[e.prefix]) throw new Error(`Codec already exists for codec "${e.name}"`)
        ;(this._basesByName[e.name] = e), (this._basesByPrefix[e.prefix] = e)
    }
    removeBase(e) {
        delete this._basesByName[e.name], delete this._basesByPrefix[e.prefix]
    }
    async getBase(e) {
        if (this._basesByName[e]) return this._basesByName[e]
        if (this._basesByPrefix[e]) return this._basesByPrefix[e]
        const n = await this._loadBase(e)
        return this._basesByName[n.name] == null && this._basesByPrefix[n.prefix] == null && this.addBase(n), n
    }
    listBases() {
        return Object.values(this._basesByName)
    }
}
const LOAD_CODEC = (t) => Promise.reject(new Error(`No codec found for "${t}"`))
class Multicodecs {
    constructor(e) {
        ;(this._codecsByName = {}), (this._codecsByCode = {}), (this._loadCodec = e.loadCodec || LOAD_CODEC)
        for (const n of e.codecs) this.addCodec(n)
    }
    addCodec(e) {
        if (this._codecsByName[e.name] || this._codecsByCode[e.code]) throw new Error(`Resolver already exists for codec "${e.name}"`)
        ;(this._codecsByName[e.name] = e), (this._codecsByCode[e.code] = e)
    }
    removeCodec(e) {
        delete this._codecsByName[e.name], delete this._codecsByCode[e.code]
    }
    async getCodec(e) {
        const n = typeof e == "string" ? this._codecsByName : this._codecsByCode
        if (n[e]) return n[e]
        const i = await this._loadCodec(e)
        return n[e] == null && this.addCodec(i), i
    }
    listCodecs() {
        return Object.values(this._codecsByName)
    }
}
const LOAD_HASHER = (t) => Promise.reject(new Error(`No hasher found for "${t}"`))
class Multihashes {
    constructor(e) {
        ;(this._hashersByName = {}), (this._hashersByCode = {}), (this._loadHasher = e.loadHasher || LOAD_HASHER)
        for (const n of e.hashers) this.addHasher(n)
    }
    addHasher(e) {
        if (this._hashersByName[e.name] || this._hashersByCode[e.code]) throw new Error(`Resolver already exists for codec "${e.name}"`)
        ;(this._hashersByName[e.name] = e), (this._hashersByCode[e.code] = e)
    }
    removeHasher(e) {
        delete this._hashersByName[e.name], delete this._hashersByCode[e.code]
    }
    async getHasher(e) {
        const n = typeof e == "string" ? this._hashersByName : this._hashersByCode
        if (n[e]) return n[e]
        const i = await this._loadHasher(e)
        return n[e] == null && this.addHasher(i), i
    }
    listHashers() {
        return Object.values(this._hashersByName)
    }
}
var encode_1$1 = encode$e,
    MSB$2 = 128,
    REST$2 = 127,
    MSBALL$1 = ~REST$2,
    INT$1 = Math.pow(2, 31)
function encode$e(t, e, n) {
    ;(e = e || []), (n = n || 0)
    for (var i = n; t >= INT$1; ) (e[n++] = (t & 255) | MSB$2), (t /= 128)
    for (; t & MSBALL$1; ) (e[n++] = (t & 255) | MSB$2), (t >>>= 7)
    return (e[n] = t | 0), (encode$e.bytes = n - i + 1), e
}
var decode$f = read$1,
    MSB$1$1 = 128,
    REST$1$1 = 127
function read$1(t, i) {
    var n = 0,
        i = i || 0,
        o = 0,
        a = i,
        l,
        c = t.length
    do {
        if (a >= c) throw ((read$1.bytes = 0), new RangeError("Could not decode varint"))
        ;(l = t[a++]), (n += o < 28 ? (l & REST$1$1) << o : (l & REST$1$1) * Math.pow(2, o)), (o += 7)
    } while (l >= MSB$1$1)
    return (read$1.bytes = a - i), n
}
var N1$1 = Math.pow(2, 7),
    N2$1 = Math.pow(2, 14),
    N3$1 = Math.pow(2, 21),
    N4$1 = Math.pow(2, 28),
    N5$1 = Math.pow(2, 35),
    N6$1 = Math.pow(2, 42),
    N7$1 = Math.pow(2, 49),
    N8$1 = Math.pow(2, 56),
    N9$1 = Math.pow(2, 63),
    length$1 = function (t) {
        return t < N1$1
            ? 1
            : t < N2$1
            ? 2
            : t < N3$1
            ? 3
            : t < N4$1
            ? 4
            : t < N5$1
            ? 5
            : t < N6$1
            ? 6
            : t < N7$1
            ? 7
            : t < N8$1
            ? 8
            : t < N9$1
            ? 9
            : 10
    },
    varint$1 = { encode: encode_1$1, decode: decode$f, encodingLength: length$1 },
    _brrp_varint = varint$1
const decode$e = (t) => [_brrp_varint.decode(t), _brrp_varint.decode.bytes],
    encodeTo = (t, e, n = 0) => (_brrp_varint.encode(t, e, n), e),
    encodingLength = (t) => _brrp_varint.encodingLength(t),
    equals$2 = (t, e) => {
        if (t === e) return !0
        if (t.byteLength !== e.byteLength) return !1
        for (let n = 0; n < t.byteLength; n++) if (t[n] !== e[n]) return !1
        return !0
    },
    coerce = (t) => {
        if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t
        if (t instanceof ArrayBuffer) return new Uint8Array(t)
        if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
        throw new Error("Unknown type, must be binary type")
    },
    fromString$3 = (t) => new TextEncoder().encode(t),
    toString$5 = (t) => new TextDecoder().decode(t),
    create$3 = (t, e) => {
        const n = e.byteLength,
            i = encodingLength(t),
            o = i + encodingLength(n),
            a = new Uint8Array(o + n)
        return encodeTo(t, a, 0), encodeTo(n, a, i), a.set(e, o), new Digest(t, n, e, a)
    },
    decode$d = (t) => {
        const e = coerce(t),
            [n, i] = decode$e(e),
            [o, a] = decode$e(e.subarray(i)),
            l = e.subarray(i + a)
        if (l.byteLength !== o) throw new Error("Incorrect length")
        return new Digest(n, o, l, e)
    },
    equals$1 = (t, e) => (t === e ? !0 : t.code === e.code && t.size === e.size && equals$2(t.bytes, e.bytes))
class Digest {
    constructor(e, n, i, o) {
        ;(this.code = e), (this.size = n), (this.digest = i), (this.bytes = o)
    }
}
function base(t, e) {
    if (t.length >= 255) throw new TypeError("Alphabet too long")
    for (var n = new Uint8Array(256), i = 0; i < n.length; i++) n[i] = 255
    for (var o = 0; o < t.length; o++) {
        var a = t.charAt(o),
            l = a.charCodeAt(0)
        if (n[l] !== 255) throw new TypeError(a + " is ambiguous")
        n[l] = o
    }
    var c = t.length,
        g = t.charAt(0),
        v = Math.log(c) / Math.log(256),
        _ = Math.log(256) / Math.log(c)
    function A(I) {
        if (
            (I instanceof Uint8Array ||
                (ArrayBuffer.isView(I)
                    ? (I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength))
                    : Array.isArray(I) && (I = Uint8Array.from(I))),
            !(I instanceof Uint8Array))
        )
            throw new TypeError("Expected Uint8Array")
        if (I.length === 0) return ""
        for (var L = 0, G = 0, U = 0, F = I.length; U !== F && I[U] === 0; ) U++, L++
        for (var Z = ((F - U) * _ + 1) >>> 0, Y = new Uint8Array(Z); U !== F; ) {
            for (var X = I[U], ie = 0, he = Z - 1; (X !== 0 || ie < G) && he !== -1; he--, ie++)
                (X += (256 * Y[he]) >>> 0), (Y[he] = X % c >>> 0), (X = (X / c) >>> 0)
            if (X !== 0) throw new Error("Non-zero carry")
            ;(G = ie), U++
        }
        for (var oe = Z - G; oe !== Z && Y[oe] === 0; ) oe++
        for (var le = g.repeat(L); oe < Z; ++oe) le += t.charAt(Y[oe])
        return le
    }
    function B(I) {
        if (typeof I != "string") throw new TypeError("Expected String")
        if (I.length === 0) return new Uint8Array()
        var L = 0
        if (I[L] !== " ") {
            for (var G = 0, U = 0; I[L] === g; ) G++, L++
            for (var F = ((I.length - L) * v + 1) >>> 0, Z = new Uint8Array(F); I[L]; ) {
                var Y = n[I.charCodeAt(L)]
                if (Y === 255) return
                for (var X = 0, ie = F - 1; (Y !== 0 || X < U) && ie !== -1; ie--, X++)
                    (Y += (c * Z[ie]) >>> 0), (Z[ie] = Y % 256 >>> 0), (Y = (Y / 256) >>> 0)
                if (Y !== 0) throw new Error("Non-zero carry")
                ;(U = X), L++
            }
            if (I[L] !== " ") {
                for (var he = F - U; he !== F && Z[he] === 0; ) he++
                for (var oe = new Uint8Array(G + (F - he)), le = G; he !== F; ) oe[le++] = Z[he++]
                return oe
            }
        }
    }
    function D(I) {
        var L = B(I)
        if (L) return L
        throw new Error(`Non-${e} character`)
    }
    return { encode: A, decodeUnsafe: B, decode: D }
}
var src$1 = base,
    _brrp__multiformats_scope_baseX = src$1
class Encoder {
    constructor(e, n, i) {
        ;(this.name = e), (this.prefix = n), (this.baseEncode = i)
    }
    encode(e) {
        if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
        throw Error("Unknown type, must be binary type")
    }
}
class Decoder {
    constructor(e, n, i) {
        if (((this.name = e), (this.prefix = n), n.codePointAt(0) === void 0)) throw new Error("Invalid prefix character")
        ;(this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = i)
    }
    decode(e) {
        if (typeof e == "string") {
            if (e.codePointAt(0) !== this.prefixCodePoint)
                throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${
                        this.prefix
                    }`
                )
            return this.baseDecode(e.slice(this.prefix.length))
        } else throw Error("Can only multibase decode strings")
    }
    or(e) {
        return or(this, e)
    }
}
class ComposedDecoder {
    constructor(e) {
        this.decoders = e
    }
    or(e) {
        return or(this, e)
    }
    decode(e) {
        const n = e[0],
            i = this.decoders[n]
        if (i) return i.decode(e)
        throw RangeError(
            `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
        )
    }
}
const or = (t, e) => new ComposedDecoder({ ...(t.decoders || { [t.prefix]: t }), ...(e.decoders || { [e.prefix]: e }) })
class Codec {
    constructor(e, n, i, o) {
        ;(this.name = e),
            (this.prefix = n),
            (this.baseEncode = i),
            (this.baseDecode = o),
            (this.encoder = new Encoder(e, n, i)),
            (this.decoder = new Decoder(e, n, o))
    }
    encode(e) {
        return this.encoder.encode(e)
    }
    decode(e) {
        return this.decoder.decode(e)
    }
}
const from$1 = ({ name: t, prefix: e, encode: n, decode: i }) => new Codec(t, e, n, i),
    baseX = ({ prefix: t, name: e, alphabet: n }) => {
        const { encode: i, decode: o } = _brrp__multiformats_scope_baseX(n, e)
        return from$1({ prefix: t, name: e, encode: i, decode: (a) => coerce(o(a)) })
    },
    decode$c = (t, e, n, i) => {
        const o = {}
        for (let _ = 0; _ < e.length; ++_) o[e[_]] = _
        let a = t.length
        for (; t[a - 1] === "="; ) --a
        const l = new Uint8Array(((a * n) / 8) | 0)
        let c = 0,
            g = 0,
            v = 0
        for (let _ = 0; _ < a; ++_) {
            const A = o[t[_]]
            if (A === void 0) throw new SyntaxError(`Non-${i} character`)
            ;(g = (g << n) | A), (c += n), c >= 8 && ((c -= 8), (l[v++] = 255 & (g >> c)))
        }
        if (c >= n || 255 & (g << (8 - c))) throw new SyntaxError("Unexpected end of data")
        return l
    },
    encode$d = (t, e, n) => {
        const i = e[e.length - 1] === "=",
            o = (1 << n) - 1
        let a = "",
            l = 0,
            c = 0
        for (let g = 0; g < t.length; ++g) for (c = (c << 8) | t[g], l += 8; l > n; ) (l -= n), (a += e[o & (c >> l)])
        if ((l && (a += e[o & (c << (n - l))]), i)) for (; (a.length * n) & 7; ) a += "="
        return a
    },
    rfc4648 = ({ name: t, prefix: e, bitsPerChar: n, alphabet: i }) =>
        from$1({
            prefix: e,
            name: t,
            encode(o) {
                return encode$d(o, i, n)
            },
            decode(o) {
                return decode$c(o, i, n, t)
            },
        }),
    base58btc = baseX({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }),
    base58flickr = baseX({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" })
var base58 = Object.freeze(Object.defineProperty({ __proto__: null, base58btc, base58flickr }, Symbol.toStringTag, { value: "Module" }))
const base32 = rfc4648({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }),
    base32upper = rfc4648({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }),
    base32pad = rfc4648({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }),
    base32padupper = rfc4648({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }),
    base32hex = rfc4648({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }),
    base32hexupper = rfc4648({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }),
    base32hexpad = rfc4648({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }),
    base32hexpadupper = rfc4648({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }),
    base32z = rfc4648({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 })
var base32$1 = Object.freeze(
    Object.defineProperty(
        { __proto__: null, base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z },
        Symbol.toStringTag,
        { value: "Module" }
    )
)
class CID {
    constructor(e, n, i, o) {
        ;(this.code = n),
            (this.version = e),
            (this.multihash = i),
            (this.bytes = o),
            (this.byteOffset = o.byteOffset),
            (this.byteLength = o.byteLength),
            (this.asCID = this),
            (this._baseCache = new Map()),
            Object.defineProperties(this, {
                byteOffset: hidden,
                byteLength: hidden,
                code: readonly,
                version: readonly,
                multihash: readonly,
                bytes: readonly,
                _baseCache: hidden,
                asCID: hidden,
            })
    }
    toV0() {
        switch (this.version) {
            case 0:
                return this
            default: {
                const { code: e, multihash: n } = this
                if (e !== DAG_PB_CODE) throw new Error("Cannot convert a non dag-pb CID to CIDv0")
                if (n.code !== SHA_256_CODE) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0")
                return CID.createV0(n)
            }
        }
    }
    toV1() {
        switch (this.version) {
            case 0: {
                const { code: e, digest: n } = this.multihash,
                    i = create$3(e, n)
                return CID.createV1(this.code, i)
            }
            case 1:
                return this
            default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
        }
    }
    equals(e) {
        return e && this.code === e.code && this.version === e.version && equals$1(this.multihash, e.multihash)
    }
    toString(e) {
        const { bytes: n, version: i, _baseCache: o } = this
        switch (i) {
            case 0:
                return toStringV0(n, o, e || base58btc.encoder)
            default:
                return toStringV1(n, o, e || base32.encoder)
        }
    }
    toJSON() {
        return { code: this.code, version: this.version, hash: this.multihash.bytes }
    }
    get [Symbol.toStringTag]() {
        return "CID"
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")"
    }
    static isCID(e) {
        return deprecate(/^0\.0/, IS_CID_DEPRECATION), !!(e && (e[cidSymbol] || e.asCID === e))
    }
    get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()")
    }
    get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead')
    }
    get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")
    }
    get multibaseName() {
        throw new Error('"multibaseName" property is deprecated')
    }
    get prefix() {
        throw new Error('"prefix" property is deprecated')
    }
    static asCID(e) {
        if (e instanceof CID) return e
        if (e != null && e.asCID === e) {
            const { version: n, code: i, multihash: o, bytes: a } = e
            return new CID(n, i, o, a || encodeCID$1(n, i, o.bytes))
        } else if (e != null && e[cidSymbol] === !0) {
            const { version: n, multihash: i, code: o } = e,
                a = decode$d(i)
            return CID.create(n, o, a)
        } else return null
    }
    static create(e, n, i) {
        if (typeof n != "number") throw new Error("String codecs are no longer supported")
        switch (e) {
            case 0: {
                if (n !== DAG_PB_CODE) throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`)
                return new CID(e, n, i, i.bytes)
            }
            case 1: {
                const o = encodeCID$1(e, n, i.bytes)
                return new CID(e, n, i, o)
            }
            default:
                throw new Error("Invalid version")
        }
    }
    static createV0(e) {
        return CID.create(0, DAG_PB_CODE, e)
    }
    static createV1(e, n) {
        return CID.create(1, e, n)
    }
    static decode(e) {
        const [n, i] = CID.decodeFirst(e)
        if (i.length) throw new Error("Incorrect length")
        return n
    }
    static decodeFirst(e) {
        const n = CID.inspectBytes(e),
            i = n.size - n.multihashSize,
            o = coerce(e.subarray(i, i + n.multihashSize))
        if (o.byteLength !== n.multihashSize) throw new Error("Incorrect length")
        const a = o.subarray(n.multihashSize - n.digestSize),
            l = new Digest(n.multihashCode, n.digestSize, a, o)
        return [n.version === 0 ? CID.createV0(l) : CID.createV1(n.codec, l), e.subarray(n.size)]
    }
    static inspectBytes(e) {
        let n = 0
        const i = () => {
            const [A, B] = decode$e(e.subarray(n))
            return (n += B), A
        }
        let o = i(),
            a = DAG_PB_CODE
        if ((o === 18 ? ((o = 0), (n = 0)) : o === 1 && (a = i()), o !== 0 && o !== 1)) throw new RangeError(`Invalid CID version ${o}`)
        const l = n,
            c = i(),
            g = i(),
            v = n + g,
            _ = v - l
        return { version: o, codec: a, multihashCode: c, digestSize: g, multihashSize: _, size: v }
    }
    static parse(e, n) {
        const [i, o] = parseCIDtoBytes(e, n),
            a = CID.decode(o)
        return a._baseCache.set(i, e), a
    }
}
const parseCIDtoBytes = (t, e) => {
        switch (t[0]) {
            case "Q": {
                const n = e || base58btc
                return [base58btc.prefix, n.decode(`${base58btc.prefix}${t}`)]
            }
            case base58btc.prefix: {
                const n = e || base58btc
                return [base58btc.prefix, n.decode(t)]
            }
            case base32.prefix: {
                const n = e || base32
                return [base32.prefix, n.decode(t)]
            }
            default: {
                if (e == null) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided")
                return [t[0], e.decode(t)]
            }
        }
    },
    toStringV0 = (t, e, n) => {
        const { prefix: i } = n
        if (i !== base58btc.prefix) throw Error(`Cannot string encode V0 in ${n.name} encoding`)
        const o = e.get(i)
        if (o == null) {
            const a = n.encode(t).slice(1)
            return e.set(i, a), a
        } else return o
    },
    toStringV1 = (t, e, n) => {
        const { prefix: i } = n,
            o = e.get(i)
        if (o == null) {
            const a = n.encode(t)
            return e.set(i, a), a
        } else return o
    },
    DAG_PB_CODE = 112,
    SHA_256_CODE = 18,
    encodeCID$1 = (t, e, n) => {
        const i = encodingLength(t),
            o = i + encodingLength(e),
            a = new Uint8Array(o + n.byteLength)
        return encodeTo(t, a, 0), encodeTo(e, a, i), a.set(n, o), a
    },
    cidSymbol = Symbol.for("@ipld/js-cid/CID"),
    readonly = { writable: !1, configurable: !1, enumerable: !0 },
    hidden = { writable: !1, enumerable: !1, configurable: !1 },
    version = "0.0.0-dev",
    deprecate = (t, e) => {
        if (t.test(version)) console.warn(e)
        else throw new Error(e)
    },
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
    textDecoder$2 = new TextDecoder()
function decodeVarint(t, e) {
    let n = 0
    for (let i = 0; ; i += 7) {
        if (i >= 64) throw new Error("protobuf: varint overflow")
        if (e >= t.length) throw new Error("protobuf: unexpected end of data")
        const o = t[e++]
        if (((n += i < 28 ? (o & 127) << i : (o & 127) * 2 ** i), o < 128)) break
    }
    return [n, e]
}
function decodeBytes(t, e) {
    let n
    ;[n, e] = decodeVarint(t, e)
    const i = e + n
    if (n < 0 || i < 0) throw new Error("protobuf: invalid length")
    if (i > t.length) throw new Error("protobuf: unexpected end of data")
    return [t.subarray(e, i), i]
}
function decodeKey(t, e) {
    let n
    return ([n, e] = decodeVarint(t, e)), [n & 7, n >> 3, e]
}
function decodeLink(t) {
    const e = {},
        n = t.length
    let i = 0
    for (; i < n; ) {
        let o, a
        if ((([o, a, i] = decodeKey(t, i)), a === 1)) {
            if (e.Hash) throw new Error("protobuf: (PBLink) duplicate Hash section")
            if (o !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Hash`)
            if (e.Name !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Name before Hash")
            if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash")
            ;[e.Hash, i] = decodeBytes(t, i)
        } else if (a === 2) {
            if (e.Name !== void 0) throw new Error("protobuf: (PBLink) duplicate Name section")
            if (o !== 2) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Name`)
            if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name")
            let l
            ;([l, i] = decodeBytes(t, i)), (e.Name = textDecoder$2.decode(l))
        } else if (a === 3) {
            if (e.Tsize !== void 0) throw new Error("protobuf: (PBLink) duplicate Tsize section")
            if (o !== 0) throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Tsize`)
            ;[e.Tsize, i] = decodeVarint(t, i)
        } else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${a}`)
    }
    if (i > n) throw new Error("protobuf: (PBLink) unexpected end of data")
    return e
}
function decodeNode(t) {
    const e = t.length
    let n = 0,
        i,
        o = !1,
        a
    for (; n < e; ) {
        let c, g
        if ((([c, g, n] = decodeKey(t, n)), c !== 2)) throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${c}`)
        if (g === 1) {
            if (a) throw new Error("protobuf: (PBNode) duplicate Data section")
            ;([a, n] = decodeBytes(t, n)), i && (o = !0)
        } else if (g === 2) {
            if (o) throw new Error("protobuf: (PBNode) duplicate Links section")
            i || (i = [])
            let v
            ;([v, n] = decodeBytes(t, n)), i.push(decodeLink(v))
        } else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${g}`)
    }
    if (n > e) throw new Error("protobuf: (PBNode) unexpected end of data")
    const l = {}
    return a && (l.Data = a), (l.Links = i || []), l
}
const textEncoder$3 = new TextEncoder(),
    maxInt32 = 2 ** 32,
    maxUInt32 = 2 ** 31
function encodeLink(t, e) {
    let n = e.length
    if (typeof t.Tsize == "number") {
        if (t.Tsize < 0) throw new Error("Tsize cannot be negative")
        if (!Number.isSafeInteger(t.Tsize)) throw new Error("Tsize too large for encoding")
        ;(n = encodeVarint(e, n, t.Tsize) - 1), (e[n] = 24)
    }
    if (typeof t.Name == "string") {
        const i = textEncoder$3.encode(t.Name)
        ;(n -= i.length), e.set(i, n), (n = encodeVarint(e, n, i.length) - 1), (e[n] = 18)
    }
    return t.Hash && ((n -= t.Hash.length), e.set(t.Hash, n), (n = encodeVarint(e, n, t.Hash.length) - 1), (e[n] = 10)), e.length - n
}
function encodeNode(t) {
    const e = sizeNode(t),
        n = new Uint8Array(e)
    let i = e
    if ((t.Data && ((i -= t.Data.length), n.set(t.Data, i), (i = encodeVarint(n, i, t.Data.length) - 1), (n[i] = 10)), t.Links))
        for (let o = t.Links.length - 1; o >= 0; o--) {
            const a = encodeLink(t.Links[o], n.subarray(0, i))
            ;(i -= a), (i = encodeVarint(n, i, a) - 1), (n[i] = 18)
        }
    return n
}
function sizeLink(t) {
    let e = 0
    if (t.Hash) {
        const n = t.Hash.length
        e += 1 + n + sov(n)
    }
    if (typeof t.Name == "string") {
        const n = textEncoder$3.encode(t.Name).length
        e += 1 + n + sov(n)
    }
    return typeof t.Tsize == "number" && (e += 1 + sov(t.Tsize)), e
}
function sizeNode(t) {
    let e = 0
    if (t.Data) {
        const n = t.Data.length
        e += 1 + n + sov(n)
    }
    if (t.Links)
        for (const n of t.Links) {
            const i = sizeLink(n)
            e += 1 + i + sov(i)
        }
    return e
}
function encodeVarint(t, e, n) {
    e -= sov(n)
    const i = e
    for (; n >= maxUInt32; ) (t[e++] = (n & 127) | 128), (n /= 128)
    for (; n >= 128; ) (t[e++] = (n & 127) | 128), (n >>>= 7)
    return (t[e] = n), i
}
function sov(t) {
    return t % 2 === 0 && t++, Math.floor((len64(t) + 6) / 7)
}
function len64(t) {
    let e = 0
    return (
        t >= maxInt32 && ((t = Math.floor(t / maxInt32)), (e = 32)),
        t >= 1 << 16 && ((t >>>= 16), (e += 16)),
        t >= 1 << 8 && ((t >>>= 8), (e += 8)),
        e + len8tab[t]
    )
}
const len8tab = [
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    ],
    pbNodeProperties = ["Data", "Links"],
    pbLinkProperties = ["Hash", "Name", "Tsize"],
    textEncoder$2 = new TextEncoder()
function linkComparator(t, e) {
    if (t === e) return 0
    const n = t.Name ? textEncoder$2.encode(t.Name) : [],
        i = e.Name ? textEncoder$2.encode(e.Name) : []
    let o = n.length,
        a = i.length
    for (let l = 0, c = Math.min(o, a); l < c; ++l)
        if (n[l] !== i[l]) {
            ;(o = n[l]), (a = i[l])
            break
        }
    return o < a ? -1 : a < o ? 1 : 0
}
function hasOnlyProperties(t, e) {
    return !Object.keys(t).some((n) => !e.includes(n))
}
function asLink(t) {
    if (typeof t.asCID == "object") {
        const n = CID.asCID(t)
        if (!n) throw new TypeError("Invalid DAG-PB form")
        return { Hash: n }
    }
    if (typeof t != "object" || Array.isArray(t)) throw new TypeError("Invalid DAG-PB form")
    const e = {}
    if (t.Hash) {
        let n = CID.asCID(t.Hash)
        try {
            n || (typeof t.Hash == "string" ? (n = CID.parse(t.Hash)) : t.Hash instanceof Uint8Array && (n = CID.decode(t.Hash)))
        } catch (i) {
            throw new TypeError(`Invalid DAG-PB form: ${i.message}`)
        }
        n && (e.Hash = n)
    }
    if (!e.Hash) throw new TypeError("Invalid DAG-PB form")
    return typeof t.Name == "string" && (e.Name = t.Name), typeof t.Tsize == "number" && (e.Tsize = t.Tsize), e
}
function prepare(t) {
    if (((t instanceof Uint8Array || typeof t == "string") && (t = { Data: t }), typeof t != "object" || Array.isArray(t)))
        throw new TypeError("Invalid DAG-PB form")
    const e = {}
    if (t.Data !== void 0)
        if (typeof t.Data == "string") e.Data = textEncoder$2.encode(t.Data)
        else if (t.Data instanceof Uint8Array) e.Data = t.Data
        else throw new TypeError("Invalid DAG-PB form")
    if (t.Links !== void 0)
        if (Array.isArray(t.Links)) (e.Links = t.Links.map(asLink)), e.Links.sort(linkComparator)
        else throw new TypeError("Invalid DAG-PB form")
    else e.Links = []
    return e
}
function validate(t) {
    if (!t || typeof t != "object" || Array.isArray(t)) throw new TypeError("Invalid DAG-PB form")
    if (!hasOnlyProperties(t, pbNodeProperties)) throw new TypeError("Invalid DAG-PB form (extraneous properties)")
    if (t.Data !== void 0 && !(t.Data instanceof Uint8Array)) throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)")
    if (!Array.isArray(t.Links)) throw new TypeError("Invalid DAG-PB form (Links must be an array)")
    for (let e = 0; e < t.Links.length; e++) {
        const n = t.Links[e]
        if (!n || typeof n != "object" || Array.isArray(n)) throw new TypeError("Invalid DAG-PB form (bad link object)")
        if (!hasOnlyProperties(n, pbLinkProperties)) throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)")
        if (!n.Hash) throw new TypeError("Invalid DAG-PB form (link must have a Hash)")
        if (n.Hash.asCID !== n.Hash) throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)")
        if (n.Name !== void 0 && typeof n.Name != "string") throw new TypeError("Invalid DAG-PB form (link Name must be a string)")
        if (n.Tsize !== void 0 && (typeof n.Tsize != "number" || n.Tsize % 1 !== 0))
            throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)")
        if (e > 0 && linkComparator(n, t.Links[e - 1]) === -1) throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")
    }
}
function createNode(t, e = []) {
    return prepare({ Data: t, Links: e })
}
function createLink(t, e, n) {
    return asLink({ Hash: n, Name: t, Tsize: e })
}
const name$6 = "dag-pb",
    code$6 = 112
function encode$c(t) {
    validate(t)
    const e = {}
    return (
        t.Links &&
            (e.Links = t.Links.map((n) => {
                const i = {}
                return n.Hash && (i.Hash = n.Hash.bytes), n.Name !== void 0 && (i.Name = n.Name), n.Tsize !== void 0 && (i.Tsize = n.Tsize), i
            })),
        t.Data && (e.Data = t.Data),
        encodeNode(e)
    )
}
function decode$b(t) {
    const e = decodeNode(t),
        n = {}
    return (
        e.Data && (n.Data = e.Data),
        e.Links &&
            (n.Links = e.Links.map((i) => {
                const o = {}
                try {
                    o.Hash = CID.decode(i.Hash)
                } catch {}
                if (!o.Hash) throw new Error("Invalid Hash field found in link, expected CID")
                return i.Name !== void 0 && (o.Name = i.Name), i.Tsize !== void 0 && (o.Tsize = i.Tsize), o
            })),
        n
    )
}
var dagPB = Object.freeze(
    Object.defineProperty(
        { __proto__: null, name: name$6, code: code$6, encode: encode$c, decode: decode$b, prepare, validate, createNode, createLink },
        Symbol.toStringTag,
        { value: "Module" }
    )
)
const typeofs = ["string", "number", "bigint", "symbol"],
    objectTypeNames = [
        "Function",
        "Generator",
        "AsyncGenerator",
        "GeneratorFunction",
        "AsyncGeneratorFunction",
        "AsyncFunction",
        "Observable",
        "Array",
        "Buffer",
        "Object",
        "RegExp",
        "Date",
        "Error",
        "Map",
        "Set",
        "WeakMap",
        "WeakSet",
        "ArrayBuffer",
        "SharedArrayBuffer",
        "DataView",
        "Promise",
        "URL",
        "HTMLElement",
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array",
        "BigInt64Array",
        "BigUint64Array",
    ]
function is(t) {
    if (t === null) return "null"
    if (t === void 0) return "undefined"
    if (t === !0 || t === !1) return "boolean"
    const e = typeof t
    if (typeofs.includes(e)) return e
    if (e === "function") return "Function"
    if (Array.isArray(t)) return "Array"
    if (isBuffer$1(t)) return "Buffer"
    const n = getObjectType(t)
    return n || "Object"
}
function isBuffer$1(t) {
    return t && t.constructor && t.constructor.isBuffer && t.constructor.isBuffer.call(null, t)
}
function getObjectType(t) {
    const e = Object.prototype.toString.call(t).slice(8, -1)
    if (objectTypeNames.includes(e)) return e
}
class Type {
    constructor(e, n, i) {
        ;(this.major = e), (this.majorEncoded = e << 5), (this.name = n), (this.terminal = i)
    }
    toString() {
        return `Type[${this.major}].${this.name}`
    }
    compare(e) {
        return this.major < e.major ? -1 : this.major > e.major ? 1 : 0
    }
}
Type.uint = new Type(0, "uint", !0)
Type.negint = new Type(1, "negint", !0)
Type.bytes = new Type(2, "bytes", !0)
Type.string = new Type(3, "string", !0)
Type.array = new Type(4, "array", !1)
Type.map = new Type(5, "map", !1)
Type.tag = new Type(6, "tag", !1)
Type.float = new Type(7, "float", !0)
Type.false = new Type(7, "false", !0)
Type.true = new Type(7, "true", !0)
Type.null = new Type(7, "null", !0)
Type.undefined = new Type(7, "undefined", !0)
Type.break = new Type(7, "break", !0)
class Token {
    constructor(e, n, i) {
        ;(this.type = e), (this.value = n), (this.encodedLength = i), (this.encodedBytes = void 0), (this.byteValue = void 0)
    }
    toString() {
        return `Token[${this.type}].${this.value}`
    }
}
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function",
    textDecoder$1 = new TextDecoder(),
    textEncoder$1 = new TextEncoder()
function isBuffer(t) {
    return useBuffer && globalThis.Buffer.isBuffer(t)
}
function asU8A(t) {
    return t instanceof Uint8Array ? (isBuffer(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t) : Uint8Array.from(t)
}
const toString$4 = useBuffer
        ? (t, e, n) => (n - e > 64 ? globalThis.Buffer.from(t.subarray(e, n)).toString("utf8") : utf8Slice(t, e, n))
        : (t, e, n) => (n - e > 64 ? textDecoder$1.decode(t.subarray(e, n)) : utf8Slice(t, e, n)),
    fromString$2 = useBuffer
        ? (t) => (t.length > 64 ? globalThis.Buffer.from(t) : utf8ToBytes(t))
        : (t) => (t.length > 64 ? textEncoder$1.encode(t) : utf8ToBytes(t)),
    fromArray = (t) => Uint8Array.from(t),
    slice = useBuffer ? (t, e, n) => (isBuffer(t) ? new Uint8Array(t.subarray(e, n)) : t.slice(e, n)) : (t, e, n) => t.slice(e, n),
    concat$1 = useBuffer
        ? (t, e) => ((t = t.map((n) => (n instanceof Uint8Array ? n : globalThis.Buffer.from(n)))), asU8A(globalThis.Buffer.concat(t, e)))
        : (t, e) => {
              const n = new Uint8Array(e)
              let i = 0
              for (let o of t) i + o.length > n.length && (o = o.subarray(0, n.length - i)), n.set(o, i), (i += o.length)
              return n
          },
    alloc = useBuffer ? (t) => globalThis.Buffer.allocUnsafe(t) : (t) => new Uint8Array(t)
function compare(t, e) {
    if (isBuffer(t) && isBuffer(e)) return t.compare(e)
    for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return t[n] < e[n] ? -1 : 1
    return 0
}
function utf8ToBytes(t, e = 1 / 0) {
    let n
    const i = t.length
    let o = null
    const a = []
    for (let l = 0; l < i; ++l) {
        if (((n = t.charCodeAt(l)), n > 55295 && n < 57344)) {
            if (!o) {
                if (n > 56319) {
                    ;(e -= 3) > -1 && a.push(239, 191, 189)
                    continue
                } else if (l + 1 === i) {
                    ;(e -= 3) > -1 && a.push(239, 191, 189)
                    continue
                }
                o = n
                continue
            }
            if (n < 56320) {
                ;(e -= 3) > -1 && a.push(239, 191, 189), (o = n)
                continue
            }
            n = (((o - 55296) << 10) | (n - 56320)) + 65536
        } else o && (e -= 3) > -1 && a.push(239, 191, 189)
        if (((o = null), n < 128)) {
            if ((e -= 1) < 0) break
            a.push(n)
        } else if (n < 2048) {
            if ((e -= 2) < 0) break
            a.push((n >> 6) | 192, (n & 63) | 128)
        } else if (n < 65536) {
            if ((e -= 3) < 0) break
            a.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (n & 63) | 128)
        } else if (n < 1114112) {
            if ((e -= 4) < 0) break
            a.push((n >> 18) | 240, ((n >> 12) & 63) | 128, ((n >> 6) & 63) | 128, (n & 63) | 128)
        } else throw new Error("Invalid code point")
    }
    return a
}
function utf8Slice(t, e, n) {
    const i = []
    for (; e < n; ) {
        const o = t[e]
        let a = null,
            l = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1
        if (e + l <= n) {
            let c, g, v, _
            switch (l) {
                case 1:
                    o < 128 && (a = o)
                    break
                case 2:
                    ;(c = t[e + 1]), (c & 192) === 128 && ((_ = ((o & 31) << 6) | (c & 63)), _ > 127 && (a = _))
                    break
                case 3:
                    ;(c = t[e + 1]),
                        (g = t[e + 2]),
                        (c & 192) === 128 &&
                            (g & 192) === 128 &&
                            ((_ = ((o & 15) << 12) | ((c & 63) << 6) | (g & 63)), _ > 2047 && (_ < 55296 || _ > 57343) && (a = _))
                    break
                case 4:
                    ;(c = t[e + 1]),
                        (g = t[e + 2]),
                        (v = t[e + 3]),
                        (c & 192) === 128 &&
                            (g & 192) === 128 &&
                            (v & 192) === 128 &&
                            ((_ = ((o & 15) << 18) | ((c & 63) << 12) | ((g & 63) << 6) | (v & 63)), _ > 65535 && _ < 1114112 && (a = _))
            }
        }
        a === null ? ((a = 65533), (l = 1)) : a > 65535 && ((a -= 65536), i.push(((a >>> 10) & 1023) | 55296), (a = 56320 | (a & 1023))),
            i.push(a),
            (e += l)
    }
    return decodeCodePointsArray(i)
}
const MAX_ARGUMENTS_LENGTH = 4096
function decodeCodePointsArray(t) {
    const e = t.length
    if (e <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, t)
    let n = "",
        i = 0
    for (; i < e; ) n += String.fromCharCode.apply(String, t.slice(i, (i += MAX_ARGUMENTS_LENGTH)))
    return n
}
const defaultChunkSize = 256
class Bl {
    constructor(e = defaultChunkSize) {
        ;(this.chunkSize = e), (this.cursor = 0), (this.maxCursor = -1), (this.chunks = []), (this._initReuseChunk = null)
    }
    reset() {
        ;(this.cursor = 0),
            (this.maxCursor = -1),
            this.chunks.length && (this.chunks = []),
            this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), (this.maxCursor = this._initReuseChunk.length - 1))
    }
    push(e) {
        let n = this.chunks[this.chunks.length - 1]
        if (this.cursor + e.length <= this.maxCursor + 1) {
            const o = n.length - (this.maxCursor - this.cursor) - 1
            n.set(e, o)
        } else {
            if (n) {
                const o = n.length - (this.maxCursor - this.cursor) - 1
                o < n.length && ((this.chunks[this.chunks.length - 1] = n.subarray(0, o)), (this.maxCursor = this.cursor - 1))
            }
            e.length < 64 && e.length < this.chunkSize
                ? ((n = alloc(this.chunkSize)),
                  this.chunks.push(n),
                  (this.maxCursor += n.length),
                  this._initReuseChunk === null && (this._initReuseChunk = n),
                  n.set(e, 0))
                : (this.chunks.push(e), (this.maxCursor += e.length))
        }
        this.cursor += e.length
    }
    toBytes(e = !1) {
        let n
        if (this.chunks.length === 1) {
            const i = this.chunks[0]
            e && this.cursor > i.length / 2
                ? ((n = this.cursor === i.length ? i : i.subarray(0, this.cursor)), (this._initReuseChunk = null), (this.chunks = []))
                : (n = slice(i, 0, this.cursor))
        } else n = concat$1(this.chunks, this.cursor)
        return e && this.reset(), n
    }
}
const decodeErrPrefix = "CBOR decode error:",
    encodeErrPrefix = "CBOR encode error:"
function assertEnoughData(t, e, n) {
    if (t.length - e < n) throw new Error(`${decodeErrPrefix} not enough data for type`)
}
const uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")]
function readUint8(t, e, n) {
    assertEnoughData(t, e, 1)
    const i = t[e]
    if (n.strict === !0 && i < uintBoundaries[0])
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)
    return i
}
function readUint16(t, e, n) {
    assertEnoughData(t, e, 2)
    const i = (t[e] << 8) | t[e + 1]
    if (n.strict === !0 && i < uintBoundaries[1])
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)
    return i
}
function readUint32(t, e, n) {
    assertEnoughData(t, e, 4)
    const i = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3]
    if (n.strict === !0 && i < uintBoundaries[2])
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)
    return i
}
function readUint64(t, e, n) {
    assertEnoughData(t, e, 8)
    const i = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3],
        o = t[e + 4] * 16777216 + (t[e + 5] << 16) + (t[e + 6] << 8) + t[e + 7],
        a = (BigInt(i) << BigInt(32)) + BigInt(o)
    if (n.strict === !0 && a < uintBoundaries[3])
        throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)
    if (a <= Number.MAX_SAFE_INTEGER) return Number(a)
    if (n.allowBigInt === !0) return a
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)
}
function decodeUint8(t, e, n, i) {
    return new Token(Type.uint, readUint8(t, e + 1, i), 2)
}
function decodeUint16(t, e, n, i) {
    return new Token(Type.uint, readUint16(t, e + 1, i), 3)
}
function decodeUint32(t, e, n, i) {
    return new Token(Type.uint, readUint32(t, e + 1, i), 5)
}
function decodeUint64(t, e, n, i) {
    return new Token(Type.uint, readUint64(t, e + 1, i), 9)
}
function encodeUint(t, e) {
    return encodeUintValue(t, 0, e.value)
}
function encodeUintValue(t, e, n) {
    if (n < uintBoundaries[0]) {
        const i = Number(n)
        t.push([e | i])
    } else if (n < uintBoundaries[1]) {
        const i = Number(n)
        t.push([e | 24, i])
    } else if (n < uintBoundaries[2]) {
        const i = Number(n)
        t.push([e | 25, i >>> 8, i & 255])
    } else if (n < uintBoundaries[3]) {
        const i = Number(n)
        t.push([e | 26, (i >>> 24) & 255, (i >>> 16) & 255, (i >>> 8) & 255, i & 255])
    } else {
        const i = BigInt(n)
        if (i < uintBoundaries[4]) {
            const o = [e | 27, 0, 0, 0, 0, 0, 0, 0]
            let a = Number(i & BigInt(4294967295)),
                l = Number((i >> BigInt(32)) & BigInt(4294967295))
            ;(o[8] = a & 255),
                (a = a >> 8),
                (o[7] = a & 255),
                (a = a >> 8),
                (o[6] = a & 255),
                (a = a >> 8),
                (o[5] = a & 255),
                (o[4] = l & 255),
                (l = l >> 8),
                (o[3] = l & 255),
                (l = l >> 8),
                (o[2] = l & 255),
                (l = l >> 8),
                (o[1] = l & 255),
                t.push(o)
        } else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)
    }
}
encodeUint.encodedSize = function (e) {
    return encodeUintValue.encodedSize(e.value)
}
encodeUintValue.encodedSize = function (e) {
    return e < uintBoundaries[0] ? 1 : e < uintBoundaries[1] ? 2 : e < uintBoundaries[2] ? 3 : e < uintBoundaries[3] ? 5 : 9
}
encodeUint.compareTokens = function (e, n) {
    return e.value < n.value ? -1 : e.value > n.value ? 1 : 0
}
function decodeNegint8(t, e, n, i) {
    return new Token(Type.negint, -1 - readUint8(t, e + 1, i), 2)
}
function decodeNegint16(t, e, n, i) {
    return new Token(Type.negint, -1 - readUint16(t, e + 1, i), 3)
}
function decodeNegint32(t, e, n, i) {
    return new Token(Type.negint, -1 - readUint32(t, e + 1, i), 5)
}
const neg1b = BigInt(-1),
    pos1b = BigInt(1)
function decodeNegint64(t, e, n, i) {
    const o = readUint64(t, e + 1, i)
    if (typeof o != "bigint") {
        const a = -1 - o
        if (a >= Number.MIN_SAFE_INTEGER) return new Token(Type.negint, a, 9)
    }
    if (i.allowBigInt !== !0) throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)
    return new Token(Type.negint, neg1b - BigInt(o), 9)
}
function encodeNegint(t, e) {
    const n = e.value,
        i = typeof n == "bigint" ? n * neg1b - pos1b : n * -1 - 1
    encodeUintValue(t, e.type.majorEncoded, i)
}
encodeNegint.encodedSize = function (e) {
    const n = e.value,
        i = typeof n == "bigint" ? n * neg1b - pos1b : n * -1 - 1
    return i < uintBoundaries[0] ? 1 : i < uintBoundaries[1] ? 2 : i < uintBoundaries[2] ? 3 : i < uintBoundaries[3] ? 5 : 9
}
encodeNegint.compareTokens = function (e, n) {
    return e.value < n.value ? 1 : e.value > n.value ? -1 : 0
}
function toToken$3(t, e, n, i) {
    assertEnoughData(t, e, n + i)
    const o = slice(t, e + n, e + n + i)
    return new Token(Type.bytes, o, n + i)
}
function decodeBytesCompact(t, e, n, i) {
    return toToken$3(t, e, 1, n)
}
function decodeBytes8(t, e, n, i) {
    return toToken$3(t, e, 2, readUint8(t, e + 1, i))
}
function decodeBytes16(t, e, n, i) {
    return toToken$3(t, e, 3, readUint16(t, e + 1, i))
}
function decodeBytes32(t, e, n, i) {
    return toToken$3(t, e, 5, readUint32(t, e + 1, i))
}
function decodeBytes64(t, e, n, i) {
    const o = readUint64(t, e + 1, i)
    if (typeof o == "bigint") throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)
    return toToken$3(t, e, 9, o)
}
function tokenBytes(t) {
    return t.encodedBytes === void 0 && (t.encodedBytes = t.type === Type.string ? fromString$2(t.value) : t.value), t.encodedBytes
}
function encodeBytes(t, e) {
    const n = tokenBytes(e)
    encodeUintValue(t, e.type.majorEncoded, n.length), t.push(n)
}
encodeBytes.encodedSize = function (e) {
    const n = tokenBytes(e)
    return encodeUintValue.encodedSize(n.length) + n.length
}
encodeBytes.compareTokens = function (e, n) {
    return compareBytes(tokenBytes(e), tokenBytes(n))
}
function compareBytes(t, e) {
    return t.length < e.length ? -1 : t.length > e.length ? 1 : compare(t, e)
}
function toToken$2(t, e, n, i, o) {
    const a = n + i
    assertEnoughData(t, e, a)
    const l = new Token(Type.string, toString$4(t, e + n, e + a), a)
    return o.retainStringBytes === !0 && (l.byteValue = slice(t, e + n, e + a)), l
}
function decodeStringCompact(t, e, n, i) {
    return toToken$2(t, e, 1, n, i)
}
function decodeString8(t, e, n, i) {
    return toToken$2(t, e, 2, readUint8(t, e + 1, i), i)
}
function decodeString16(t, e, n, i) {
    return toToken$2(t, e, 3, readUint16(t, e + 1, i), i)
}
function decodeString32(t, e, n, i) {
    return toToken$2(t, e, 5, readUint32(t, e + 1, i), i)
}
function decodeString64(t, e, n, i) {
    const o = readUint64(t, e + 1, i)
    if (typeof o == "bigint") throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)
    return toToken$2(t, e, 9, o, i)
}
const encodeString = encodeBytes
function toToken$1(t, e, n, i) {
    return new Token(Type.array, i, n)
}
function decodeArrayCompact(t, e, n, i) {
    return toToken$1(t, e, 1, n)
}
function decodeArray8(t, e, n, i) {
    return toToken$1(t, e, 2, readUint8(t, e + 1, i))
}
function decodeArray16(t, e, n, i) {
    return toToken$1(t, e, 3, readUint16(t, e + 1, i))
}
function decodeArray32(t, e, n, i) {
    return toToken$1(t, e, 5, readUint32(t, e + 1, i))
}
function decodeArray64(t, e, n, i) {
    const o = readUint64(t, e + 1, i)
    if (typeof o == "bigint") throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)
    return toToken$1(t, e, 9, o)
}
function decodeArrayIndefinite(t, e, n, i) {
    if (i.allowIndefinite === !1) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)
    return toToken$1(t, e, 1, 1 / 0)
}
function encodeArray(t, e) {
    encodeUintValue(t, Type.array.majorEncoded, e.value)
}
encodeArray.compareTokens = encodeUint.compareTokens
encodeArray.encodedSize = function (e) {
    return encodeUintValue.encodedSize(e.value)
}
function toToken(t, e, n, i) {
    return new Token(Type.map, i, n)
}
function decodeMapCompact(t, e, n, i) {
    return toToken(t, e, 1, n)
}
function decodeMap8(t, e, n, i) {
    return toToken(t, e, 2, readUint8(t, e + 1, i))
}
function decodeMap16(t, e, n, i) {
    return toToken(t, e, 3, readUint16(t, e + 1, i))
}
function decodeMap32(t, e, n, i) {
    return toToken(t, e, 5, readUint32(t, e + 1, i))
}
function decodeMap64(t, e, n, i) {
    const o = readUint64(t, e + 1, i)
    if (typeof o == "bigint") throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)
    return toToken(t, e, 9, o)
}
function decodeMapIndefinite(t, e, n, i) {
    if (i.allowIndefinite === !1) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)
    return toToken(t, e, 1, 1 / 0)
}
function encodeMap(t, e) {
    encodeUintValue(t, Type.map.majorEncoded, e.value)
}
encodeMap.compareTokens = encodeUint.compareTokens
encodeMap.encodedSize = function (e) {
    return encodeUintValue.encodedSize(e.value)
}
function decodeTagCompact(t, e, n, i) {
    return new Token(Type.tag, n, 1)
}
function decodeTag8(t, e, n, i) {
    return new Token(Type.tag, readUint8(t, e + 1, i), 2)
}
function decodeTag16(t, e, n, i) {
    return new Token(Type.tag, readUint16(t, e + 1, i), 3)
}
function decodeTag32(t, e, n, i) {
    return new Token(Type.tag, readUint32(t, e + 1, i), 5)
}
function decodeTag64(t, e, n, i) {
    return new Token(Type.tag, readUint64(t, e + 1, i), 9)
}
function encodeTag(t, e) {
    encodeUintValue(t, Type.tag.majorEncoded, e.value)
}
encodeTag.compareTokens = encodeUint.compareTokens
encodeTag.encodedSize = function (e) {
    return encodeUintValue.encodedSize(e.value)
}
const MINOR_FALSE = 20,
    MINOR_TRUE = 21,
    MINOR_NULL = 22,
    MINOR_UNDEFINED = 23
function decodeUndefined(t, e, n, i) {
    if (i.allowUndefined === !1) throw new Error(`${decodeErrPrefix} undefined values are not supported`)
    return i.coerceUndefinedToNull === !0 ? new Token(Type.null, null, 1) : new Token(Type.undefined, void 0, 1)
}
function decodeBreak(t, e, n, i) {
    if (i.allowIndefinite === !1) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)
    return new Token(Type.break, void 0, 1)
}
function createToken(t, e, n) {
    if (n) {
        if (n.allowNaN === !1 && Number.isNaN(t)) throw new Error(`${decodeErrPrefix} NaN values are not supported`)
        if (n.allowInfinity === !1 && (t === 1 / 0 || t === -1 / 0)) throw new Error(`${decodeErrPrefix} Infinity values are not supported`)
    }
    return new Token(Type.float, t, e)
}
function decodeFloat16(t, e, n, i) {
    return createToken(readFloat16(t, e + 1), 3, i)
}
function decodeFloat32(t, e, n, i) {
    return createToken(readFloat32(t, e + 1), 5, i)
}
function decodeFloat64(t, e, n, i) {
    return createToken(readFloat64(t, e + 1), 9, i)
}
function encodeFloat(t, e, n) {
    const i = e.value
    if (i === !1) t.push([Type.float.majorEncoded | MINOR_FALSE])
    else if (i === !0) t.push([Type.float.majorEncoded | MINOR_TRUE])
    else if (i === null) t.push([Type.float.majorEncoded | MINOR_NULL])
    else if (i === void 0) t.push([Type.float.majorEncoded | MINOR_UNDEFINED])
    else {
        let o,
            a = !1
        ;(!n || n.float64 !== !0) &&
            (encodeFloat16(i),
            (o = readFloat16(ui8a, 1)),
            i === o || Number.isNaN(i)
                ? ((ui8a[0] = 249), t.push(ui8a.slice(0, 3)), (a = !0))
                : (encodeFloat32(i), (o = readFloat32(ui8a, 1)), i === o && ((ui8a[0] = 250), t.push(ui8a.slice(0, 5)), (a = !0)))),
            a || (encodeFloat64(i), (o = readFloat64(ui8a, 1)), (ui8a[0] = 251), t.push(ui8a.slice(0, 9)))
    }
}
encodeFloat.encodedSize = function (e, n) {
    const i = e.value
    if (i === !1 || i === !0 || i === null || i === void 0) return 1
    if (!n || n.float64 !== !0) {
        encodeFloat16(i)
        let o = readFloat16(ui8a, 1)
        if (i === o || Number.isNaN(i)) return 3
        if ((encodeFloat32(i), (o = readFloat32(ui8a, 1)), i === o)) return 5
    }
    return 9
}
const buffer = new ArrayBuffer(9),
    dataView = new DataView(buffer, 1),
    ui8a = new Uint8Array(buffer, 0)
function encodeFloat16(t) {
    if (t === 1 / 0) dataView.setUint16(0, 31744, !1)
    else if (t === -1 / 0) dataView.setUint16(0, 64512, !1)
    else if (Number.isNaN(t)) dataView.setUint16(0, 32256, !1)
    else {
        dataView.setFloat32(0, t)
        const e = dataView.getUint32(0),
            n = (e & 2139095040) >> 23,
            i = e & 8388607
        if (n === 255) dataView.setUint16(0, 31744, !1)
        else if (n === 0) dataView.setUint16(0, ((t & 2147483648) >> 16) | (i >> 13), !1)
        else {
            const o = n - 127
            o < -24
                ? dataView.setUint16(0, 0)
                : o < -14
                ? dataView.setUint16(0, ((e & 2147483648) >> 16) | (1 << (24 + o)), !1)
                : dataView.setUint16(0, ((e & 2147483648) >> 16) | ((o + 15) << 10) | (i >> 13), !1)
        }
    }
}
function readFloat16(t, e) {
    if (t.length - e < 2) throw new Error(`${decodeErrPrefix} not enough data for float16`)
    const n = (t[e] << 8) + t[e + 1]
    if (n === 31744) return 1 / 0
    if (n === 64512) return -1 / 0
    if (n === 32256) return NaN
    const i = (n >> 10) & 31,
        o = n & 1023
    let a
    return i === 0 ? (a = o * 2 ** -24) : i !== 31 ? (a = (o + 1024) * 2 ** (i - 25)) : (a = o === 0 ? 1 / 0 : NaN), n & 32768 ? -a : a
}
function encodeFloat32(t) {
    dataView.setFloat32(0, t, !1)
}
function readFloat32(t, e) {
    if (t.length - e < 4) throw new Error(`${decodeErrPrefix} not enough data for float32`)
    const n = (t.byteOffset || 0) + e
    return new DataView(t.buffer, n, 4).getFloat32(0, !1)
}
function encodeFloat64(t) {
    dataView.setFloat64(0, t, !1)
}
function readFloat64(t, e) {
    if (t.length - e < 8) throw new Error(`${decodeErrPrefix} not enough data for float64`)
    const n = (t.byteOffset || 0) + e
    return new DataView(t.buffer, n, 8).getFloat64(0, !1)
}
encodeFloat.compareTokens = encodeUint.compareTokens
function invalidMinor(t, e, n) {
    throw new Error(`${decodeErrPrefix} encountered invalid minor (${n}) for major ${t[e] >>> 5}`)
}
function errorer(t) {
    return () => {
        throw new Error(`${decodeErrPrefix} ${t}`)
    }
}
const jump = []
for (let t = 0; t <= 23; t++) jump[t] = invalidMinor
jump[24] = decodeUint8
jump[25] = decodeUint16
jump[26] = decodeUint32
jump[27] = decodeUint64
jump[28] = invalidMinor
jump[29] = invalidMinor
jump[30] = invalidMinor
jump[31] = invalidMinor
for (let t = 32; t <= 55; t++) jump[t] = invalidMinor
jump[56] = decodeNegint8
jump[57] = decodeNegint16
jump[58] = decodeNegint32
jump[59] = decodeNegint64
jump[60] = invalidMinor
jump[61] = invalidMinor
jump[62] = invalidMinor
jump[63] = invalidMinor
for (let t = 64; t <= 87; t++) jump[t] = decodeBytesCompact
jump[88] = decodeBytes8
jump[89] = decodeBytes16
jump[90] = decodeBytes32
jump[91] = decodeBytes64
jump[92] = invalidMinor
jump[93] = invalidMinor
jump[94] = invalidMinor
jump[95] = errorer("indefinite length bytes/strings are not supported")
for (let t = 96; t <= 119; t++) jump[t] = decodeStringCompact
jump[120] = decodeString8
jump[121] = decodeString16
jump[122] = decodeString32
jump[123] = decodeString64
jump[124] = invalidMinor
jump[125] = invalidMinor
jump[126] = invalidMinor
jump[127] = errorer("indefinite length bytes/strings are not supported")
for (let t = 128; t <= 151; t++) jump[t] = decodeArrayCompact
jump[152] = decodeArray8
jump[153] = decodeArray16
jump[154] = decodeArray32
jump[155] = decodeArray64
jump[156] = invalidMinor
jump[157] = invalidMinor
jump[158] = invalidMinor
jump[159] = decodeArrayIndefinite
for (let t = 160; t <= 183; t++) jump[t] = decodeMapCompact
jump[184] = decodeMap8
jump[185] = decodeMap16
jump[186] = decodeMap32
jump[187] = decodeMap64
jump[188] = invalidMinor
jump[189] = invalidMinor
jump[190] = invalidMinor
jump[191] = decodeMapIndefinite
for (let t = 192; t <= 215; t++) jump[t] = decodeTagCompact
jump[216] = decodeTag8
jump[217] = decodeTag16
jump[218] = decodeTag32
jump[219] = decodeTag64
jump[220] = invalidMinor
jump[221] = invalidMinor
jump[222] = invalidMinor
jump[223] = invalidMinor
for (let t = 224; t <= 243; t++) jump[t] = errorer("simple values are not supported")
jump[244] = invalidMinor
jump[245] = invalidMinor
jump[246] = invalidMinor
jump[247] = decodeUndefined
jump[248] = errorer("simple values are not supported")
jump[249] = decodeFloat16
jump[250] = decodeFloat32
jump[251] = decodeFloat64
jump[252] = invalidMinor
jump[253] = invalidMinor
jump[254] = invalidMinor
jump[255] = decodeBreak
const quick = []
for (let t = 0; t < 24; t++) quick[t] = new Token(Type.uint, t, 1)
for (let t = -1; t >= -24; t--) quick[31 - t] = new Token(Type.negint, t, 1)
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1)
quick[96] = new Token(Type.string, "", 1)
quick[128] = new Token(Type.array, 0, 1)
quick[160] = new Token(Type.map, 0, 1)
quick[244] = new Token(Type.false, !1, 1)
quick[245] = new Token(Type.true, !0, 1)
quick[246] = new Token(Type.null, null, 1)
function quickEncodeToken(t) {
    switch (t.type) {
        case Type.false:
            return fromArray([244])
        case Type.true:
            return fromArray([245])
        case Type.null:
            return fromArray([246])
        case Type.bytes:
            return t.value.length ? void 0 : fromArray([64])
        case Type.string:
            return t.value === "" ? fromArray([96]) : void 0
        case Type.array:
            return t.value === 0 ? fromArray([128]) : void 0
        case Type.map:
            return t.value === 0 ? fromArray([160]) : void 0
        case Type.uint:
            return t.value < 24 ? fromArray([Number(t.value)]) : void 0
        case Type.negint:
            if (t.value >= -24) return fromArray([31 - Number(t.value)])
    }
}
const defaultEncodeOptions$1 = { float64: !1, mapSorter: mapSorter$1, quickEncodeToken }
function makeCborEncoders() {
    const t = []
    return (
        (t[Type.uint.major] = encodeUint),
        (t[Type.negint.major] = encodeNegint),
        (t[Type.bytes.major] = encodeBytes),
        (t[Type.string.major] = encodeString),
        (t[Type.array.major] = encodeArray),
        (t[Type.map.major] = encodeMap),
        (t[Type.tag.major] = encodeTag),
        (t[Type.float.major] = encodeFloat),
        t
    )
}
const cborEncoders = makeCborEncoders(),
    buf = new Bl()
class Ref {
    constructor(e, n) {
        ;(this.obj = e), (this.parent = n)
    }
    includes(e) {
        let n = this
        do if (n.obj === e) return !0
        while ((n = n.parent))
        return !1
    }
    static createCheck(e, n) {
        if (e && e.includes(n)) throw new Error(`${encodeErrPrefix} object contains circular references`)
        return new Ref(n, e)
    }
}
const simpleTokens = {
        null: new Token(Type.null, null),
        undefined: new Token(Type.undefined, void 0),
        true: new Token(Type.true, !0),
        false: new Token(Type.false, !1),
        emptyArray: new Token(Type.array, 0),
        emptyMap: new Token(Type.map, 0),
    },
    typeEncoders = {
        number(t, e, n, i) {
            return !Number.isInteger(t) || !Number.isSafeInteger(t)
                ? new Token(Type.float, t)
                : t >= 0
                ? new Token(Type.uint, t)
                : new Token(Type.negint, t)
        },
        bigint(t, e, n, i) {
            return t >= BigInt(0) ? new Token(Type.uint, t) : new Token(Type.negint, t)
        },
        Uint8Array(t, e, n, i) {
            return new Token(Type.bytes, t)
        },
        string(t, e, n, i) {
            return new Token(Type.string, t)
        },
        boolean(t, e, n, i) {
            return t ? simpleTokens.true : simpleTokens.false
        },
        null(t, e, n, i) {
            return simpleTokens.null
        },
        undefined(t, e, n, i) {
            return simpleTokens.undefined
        },
        ArrayBuffer(t, e, n, i) {
            return new Token(Type.bytes, new Uint8Array(t))
        },
        DataView(t, e, n, i) {
            return new Token(Type.bytes, new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
        },
        Array(t, e, n, i) {
            if (!t.length) return n.addBreakTokens === !0 ? [simpleTokens.emptyArray, new Token(Type.break)] : simpleTokens.emptyArray
            i = Ref.createCheck(i, t)
            const o = []
            let a = 0
            for (const l of t) o[a++] = objectToTokens(l, n, i)
            return n.addBreakTokens ? [new Token(Type.array, t.length), o, new Token(Type.break)] : [new Token(Type.array, t.length), o]
        },
        Object(t, e, n, i) {
            const o = e !== "Object",
                a = o ? t.keys() : Object.keys(t),
                l = o ? t.size : a.length
            if (!l) return n.addBreakTokens === !0 ? [simpleTokens.emptyMap, new Token(Type.break)] : simpleTokens.emptyMap
            i = Ref.createCheck(i, t)
            const c = []
            let g = 0
            for (const v of a) c[g++] = [objectToTokens(v, n, i), objectToTokens(o ? t.get(v) : t[v], n, i)]
            return sortMapEntries(c, n), n.addBreakTokens ? [new Token(Type.map, l), c, new Token(Type.break)] : [new Token(Type.map, l), c]
        },
    }
typeEncoders.Map = typeEncoders.Object
typeEncoders.Buffer = typeEncoders.Uint8Array
for (const t of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))
    typeEncoders[`${t}Array`] = typeEncoders.DataView
function objectToTokens(t, e = {}, n) {
    const i = is(t),
        o = (e && e.typeEncoders && e.typeEncoders[i]) || typeEncoders[i]
    if (typeof o == "function") {
        const l = o(t, i, e, n)
        if (l != null) return l
    }
    const a = typeEncoders[i]
    if (!a) throw new Error(`${encodeErrPrefix} unsupported type: ${i}`)
    return a(t, i, e, n)
}
function sortMapEntries(t, e) {
    e.mapSorter && t.sort(e.mapSorter)
}
function mapSorter$1(t, e) {
    const n = Array.isArray(t[0]) ? t[0][0] : t[0],
        i = Array.isArray(e[0]) ? e[0][0] : e[0]
    if (n.type !== i.type) return n.type.compare(i.type)
    const o = n.type.major,
        a = cborEncoders[o].compareTokens(n, i)
    return a === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), a
}
function tokensToEncoded(t, e, n, i) {
    if (Array.isArray(e)) for (const o of e) tokensToEncoded(t, o, n, i)
    else n[e.type.major](t, e, i)
}
function encodeCustom(t, e, n) {
    const i = objectToTokens(t, n)
    if (!Array.isArray(i) && n.quickEncodeToken) {
        const o = n.quickEncodeToken(i)
        if (o) return o
        const a = e[i.type.major]
        if (a.encodedSize) {
            const l = a.encodedSize(i, n),
                c = new Bl(l)
            if ((a(c, i, n), c.chunks.length !== 1)) throw new Error(`Unexpected error: pre-calculated length for ${i} was wrong`)
            return asU8A(c.chunks[0])
        }
    }
    return buf.reset(), tokensToEncoded(buf, i, e, n), buf.toBytes(!0)
}
function encode$b(t, e) {
    return (e = Object.assign({}, defaultEncodeOptions$1, e)), encodeCustom(t, cborEncoders, e)
}
const defaultDecodeOptions = { strict: !1, allowIndefinite: !0, allowUndefined: !0, allowBigInt: !0 }
class Tokeniser {
    constructor(e, n = {}) {
        ;(this.pos = 0), (this.data = e), (this.options = n)
    }
    done() {
        return this.pos >= this.data.length
    }
    next() {
        const e = this.data[this.pos]
        let n = quick[e]
        if (n === void 0) {
            const i = jump[e]
            if (!i) throw new Error(`${decodeErrPrefix} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, "0")})`)
            const o = e & 31
            n = i(this.data, this.pos, o, this.options)
        }
        return (this.pos += n.encodedLength), n
    }
}
const DONE = Symbol.for("DONE"),
    BREAK = Symbol.for("BREAK")
function tokenToArray(t, e, n) {
    const i = []
    for (let o = 0; o < t.value; o++) {
        const a = tokensToObject(e, n)
        if (a === BREAK) {
            if (t.value === 1 / 0) break
            throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)
        }
        if (a === DONE) throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${t.value})`)
        i[o] = a
    }
    return i
}
function tokenToMap(t, e, n) {
    const i = n.useMaps === !0,
        o = i ? void 0 : {},
        a = i ? new Map() : void 0
    for (let l = 0; l < t.value; l++) {
        const c = tokensToObject(e, n)
        if (c === BREAK) {
            if (t.value === 1 / 0) break
            throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)
        }
        if (c === DONE) throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${l} [no key], expected ${t.value})`)
        if (i !== !0 && typeof c != "string") throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof c})`)
        const g = tokensToObject(e, n)
        if (g === DONE) throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${l} [no value], expected ${t.value})`)
        i ? a.set(c, g) : (o[c] = g)
    }
    return i ? a : o
}
function tokensToObject(t, e) {
    if (t.done()) return DONE
    const n = t.next()
    if (n.type === Type.break) return BREAK
    if (n.type.terminal) return n.value
    if (n.type === Type.array) return tokenToArray(n, t, e)
    if (n.type === Type.map) return tokenToMap(n, t, e)
    if (n.type === Type.tag) {
        if (e.tags && typeof e.tags[n.value] == "function") {
            const i = tokensToObject(t, e)
            return e.tags[n.value](i)
        }
        throw new Error(`${decodeErrPrefix} tag not supported (${n.value})`)
    }
    throw new Error("unsupported")
}
function decode$a(t, e) {
    if (!(t instanceof Uint8Array)) throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)
    e = Object.assign({}, defaultDecodeOptions, e)
    const n = e.tokenizer || new Tokeniser(t, e),
        i = tokensToObject(n, e)
    if (i === DONE) throw new Error(`${decodeErrPrefix} did not find any content to decode`)
    if (i === BREAK) throw new Error(`${decodeErrPrefix} got unexpected break`)
    if (!n.done()) throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)
    return i
}
const CID_CBOR_TAG = 42
function cidEncoder$1(t) {
    if (t.asCID !== t) return null
    const e = CID.asCID(t)
    if (!e) return null
    const n = new Uint8Array(e.bytes.byteLength + 1)
    return n.set(e.bytes, 1), [new Token(Type.tag, CID_CBOR_TAG), new Token(Type.bytes, n)]
}
function undefinedEncoder$1() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")
}
function numberEncoder$1(t) {
    if (Number.isNaN(t)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded")
    if (t === 1 / 0 || t === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded")
    return null
}
const encodeOptions$1 = { float64: !0, typeEncoders: { Object: cidEncoder$1, undefined: undefinedEncoder$1, number: numberEncoder$1 } }
function cidDecoder(t) {
    if (t[0] !== 0) throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00")
    return CID.decode(t.subarray(1))
}
const decodeOptions$1 = {
    allowIndefinite: !1,
    coerceUndefinedToNull: !0,
    allowNaN: !1,
    allowInfinity: !1,
    allowBigInt: !0,
    strict: !0,
    useMaps: !1,
    tags: [],
}
decodeOptions$1.tags[CID_CBOR_TAG] = cidDecoder
const name$5 = "dag-cbor",
    code$5 = 113,
    encode$a = (t) => encode$b(t, encodeOptions$1),
    decode$9 = (t) => decode$a(t, decodeOptions$1)
var dagCBOR = Object.freeze(
    Object.defineProperty({ __proto__: null, name: name$5, code: code$5, encode: encode$a, decode: decode$9 }, Symbol.toStringTag, {
        value: "Module",
    })
)
const from = ({ name: t, code: e, encode: n }) => new Hasher(t, e, n)
class Hasher {
    constructor(e, n, i) {
        ;(this.name = e), (this.code = n), (this.encode = i)
    }
    digest(e) {
        if (e instanceof Uint8Array) {
            const n = this.encode(e)
            return n instanceof Uint8Array ? create$3(this.code, n) : n.then((i) => create$3(this.code, i))
        } else throw Error("Unknown type, must be binary type")
    }
}
const base64$2 = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6,
    }),
    base64pad = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6,
    }),
    base64url = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6,
    }),
    base64urlpad = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6,
    })
var base64$3 = Object.freeze(
    Object.defineProperty({ __proto__: null, base64: base64$2, base64pad, base64url, base64urlpad }, Symbol.toStringTag, { value: "Module" })
)
class JSONEncoder extends Array {
    constructor() {
        super(), (this.inRecursive = [])
    }
    prefix(e) {
        const n = this.inRecursive[this.inRecursive.length - 1]
        n &&
            (n.type === Type.array && (n.elements++, n.elements !== 1 && e.push([44])),
            n.type === Type.map && (n.elements++, n.elements !== 1 && (n.elements % 2 === 1 ? e.push([44]) : e.push([58]))))
    }
    [Type.uint.major](e, n) {
        this.prefix(e)
        const i = String(n.value),
            o = []
        for (let a = 0; a < i.length; a++) o[a] = i.charCodeAt(a)
        e.push(o)
    }
    [Type.negint.major](e, n) {
        this[Type.uint.major](e, n)
    }
    [Type.bytes.major](e, n) {
        throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)
    }
    [Type.string.major](e, n) {
        this.prefix(e)
        const i = fromString$2(JSON.stringify(n.value))
        e.push(i.length > 32 ? asU8A(i) : i)
    }
    [Type.array.major](e, n) {
        this.prefix(e), this.inRecursive.push({ type: Type.array, elements: 0 }), e.push([91])
    }
    [Type.map.major](e, n) {
        this.prefix(e), this.inRecursive.push({ type: Type.map, elements: 0 }), e.push([123])
    }
    [Type.tag.major](e, n) {}
    [Type.float.major](e, n) {
        if (n.type.name === "break") {
            const l = this.inRecursive.pop()
            if (l) {
                if (l.type === Type.array) e.push([93])
                else if (l.type === Type.map) e.push([125])
                else throw new Error("Unexpected recursive type; this should not happen!")
                return
            }
            throw new Error("Unexpected break; this should not happen!")
        }
        if (n.value === void 0) throw new Error(`${encodeErrPrefix} unsupported type: undefined`)
        if ((this.prefix(e), n.type.name === "true")) {
            e.push([116, 114, 117, 101])
            return
        } else if (n.type.name === "false") {
            e.push([102, 97, 108, 115, 101])
            return
        } else if (n.type.name === "null") {
            e.push([110, 117, 108, 108])
            return
        }
        const i = String(n.value),
            o = []
        let a = !1
        for (let l = 0; l < i.length; l++) (o[l] = i.charCodeAt(l)), !a && (o[l] === 46 || o[l] === 101 || o[l] === 69) && (a = !0)
        a || (o.push(46), o.push(48)), e.push(o)
    }
}
function mapSorter(t, e) {
    if (Array.isArray(t[0]) || Array.isArray(e[0])) throw new Error(`${encodeErrPrefix} complex map keys are not supported`)
    const n = t[0],
        i = e[0]
    if (n.type !== Type.string || i.type !== Type.string) throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)
    if (n < i) return -1
    if (n > i) return 1
    throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)
}
const defaultEncodeOptions = { addBreakTokens: !0, mapSorter }
function encode$9(t, e) {
    return (e = Object.assign({}, defaultEncodeOptions, e)), encodeCustom(t, new JSONEncoder(), e)
}
class Tokenizer {
    constructor(e, n = {}) {
        ;(this.pos = 0), (this.data = e), (this.options = n), (this.modeStack = ["value"]), (this.lastToken = "")
    }
    done() {
        return this.pos >= this.data.length
    }
    ch() {
        return this.data[this.pos]
    }
    currentMode() {
        return this.modeStack[this.modeStack.length - 1]
    }
    skipWhitespace() {
        let e = this.ch()
        for (; e === 32 || e === 9 || e === 13 || e === 10; ) e = this.data[++this.pos]
    }
    expect(e) {
        if (this.data.length - this.pos < e.length) throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`)
        for (let n = 0; n < e.length; n++)
            if (this.data[this.pos++] !== e[n])
                throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...e)}'`)
    }
    parseNumber() {
        const e = this.pos
        let n = !1,
            i = !1
        const o = (c) => {
            for (; !this.done(); ) {
                const g = this.ch()
                if (c.includes(g)) this.pos++
                else break
            }
        }
        if ((this.ch() === 45 && ((n = !0), this.pos++), this.ch() === 48))
            if ((this.pos++, this.ch() === 46)) this.pos++, (i = !0)
            else return new Token(Type.uint, 0, this.pos - e)
        if ((o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), n && this.pos === e + 1))
            throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`)
        if (!this.done() && this.ch() === 46) {
            if (i) throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`)
            ;(i = !0), this.pos++, o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57])
        }
        !this.done() &&
            (this.ch() === 101 || this.ch() === 69) &&
            ((i = !0),
            this.pos++,
            !this.done() && (this.ch() === 43 || this.ch() === 45) && this.pos++,
            o([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]))
        const a = String.fromCharCode.apply(null, this.data.subarray(e, this.pos)),
            l = parseFloat(a)
        return i
            ? new Token(Type.float, l, this.pos - e)
            : this.options.allowBigInt !== !0 || Number.isSafeInteger(l)
            ? new Token(l >= 0 ? Type.uint : Type.negint, l, this.pos - e)
            : new Token(l >= 0 ? Type.uint : Type.negint, BigInt(a), this.pos - e)
    }
    parseString() {
        if (this.ch() !== 34) throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`)
        this.pos++
        for (let a = this.pos, l = 0; a < this.data.length && l < 65536; a++, l++) {
            const c = this.data[a]
            if (c === 92 || c < 32 || c >= 128) break
            if (c === 34) {
                const g = String.fromCharCode.apply(null, this.data.subarray(this.pos, a))
                return (this.pos = a + 1), new Token(Type.string, g, l)
            }
        }
        const e = this.pos,
            n = [],
            i = () => {
                if (this.pos + 4 >= this.data.length)
                    throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`)
                let a = 0
                for (let l = 0; l < 4; l++) {
                    let c = this.ch()
                    if (c >= 48 && c <= 57) c -= 48
                    else if (c >= 97 && c <= 102) c = c - 97 + 10
                    else if (c >= 65 && c <= 70) c = c - 65 + 10
                    else throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`)
                    ;(a = a * 16 + c), this.pos++
                }
                return a
            },
            o = () => {
                const a = this.ch()
                let l = null,
                    c = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1
                if (this.pos + c > this.data.length) throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`)
                let g, v, _, A
                switch (c) {
                    case 1:
                        a < 128 && (l = a)
                        break
                    case 2:
                        ;(g = this.data[this.pos + 1]), (g & 192) === 128 && ((A = ((a & 31) << 6) | (g & 63)), A > 127 && (l = A))
                        break
                    case 3:
                        ;(g = this.data[this.pos + 1]),
                            (v = this.data[this.pos + 2]),
                            (g & 192) === 128 &&
                                (v & 192) === 128 &&
                                ((A = ((a & 15) << 12) | ((g & 63) << 6) | (v & 63)), A > 2047 && (A < 55296 || A > 57343) && (l = A))
                        break
                    case 4:
                        ;(g = this.data[this.pos + 1]),
                            (v = this.data[this.pos + 2]),
                            (_ = this.data[this.pos + 3]),
                            (g & 192) === 128 &&
                                (v & 192) === 128 &&
                                (_ & 192) === 128 &&
                                ((A = ((a & 15) << 18) | ((g & 63) << 12) | ((v & 63) << 6) | (_ & 63)), A > 65535 && A < 1114112 && (l = A))
                }
                l === null ? ((l = 65533), (c = 1)) : l > 65535 && ((l -= 65536), n.push(((l >>> 10) & 1023) | 55296), (l = 56320 | (l & 1023))),
                    n.push(l),
                    (this.pos += c)
            }
        for (; !this.done(); ) {
            const a = this.ch()
            let l
            switch (a) {
                case 92:
                    if ((this.pos++, this.done())) throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`)
                    switch (((l = this.ch()), this.pos++, l)) {
                        case 34:
                        case 39:
                        case 92:
                        case 47:
                            n.push(l)
                            break
                        case 98:
                            n.push(8)
                            break
                        case 116:
                            n.push(9)
                            break
                        case 110:
                            n.push(10)
                            break
                        case 102:
                            n.push(12)
                            break
                        case 114:
                            n.push(13)
                            break
                        case 117:
                            n.push(i())
                            break
                        default:
                            throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`)
                    }
                    break
                case 34:
                    return this.pos++, new Token(Type.string, decodeCodePointsArray(n), this.pos - e)
                default:
                    if (a < 32) throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`)
                    a < 128 ? (n.push(a), this.pos++) : o()
            }
        }
        throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`)
    }
    parseValue() {
        switch (this.ch()) {
            case 123:
                return this.modeStack.push("obj-start"), this.pos++, new Token(Type.map, 1 / 0, 1)
            case 91:
                return this.modeStack.push("array-start"), this.pos++, new Token(Type.array, 1 / 0, 1)
            case 34:
                return this.parseString()
            case 110:
                return this.expect([110, 117, 108, 108]), new Token(Type.null, null, 4)
            case 102:
                return this.expect([102, 97, 108, 115, 101]), new Token(Type.false, !1, 5)
            case 116:
                return this.expect([116, 114, 117, 101]), new Token(Type.true, !0, 4)
            case 45:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return this.parseNumber()
            default:
                throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`)
        }
    }
    next() {
        switch ((this.skipWhitespace(), this.currentMode())) {
            case "value":
                return this.modeStack.pop(), this.parseValue()
            case "array-value": {
                if ((this.modeStack.pop(), this.ch() === 93)) return this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1)
                if (this.ch() !== 44)
                    throw new Error(
                        `${decodeErrPrefix} unexpected character at position ${
                            this.pos
                        }, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`
                    )
                return this.pos++, this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue()
            }
            case "array-start":
                return (
                    this.modeStack.pop(),
                    this.ch() === 93
                        ? (this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1))
                        : (this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue())
                )
            case "obj-key":
                if (this.ch() === 125) return this.modeStack.pop(), this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1)
                if (this.ch() !== 44)
                    throw new Error(
                        `${decodeErrPrefix} unexpected character at position ${
                            this.pos
                        }, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`
                    )
                this.pos++, this.skipWhitespace()
            case "obj-start": {
                if ((this.modeStack.pop(), this.ch() === 125)) return this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1)
                const e = this.parseString()
                if ((this.skipWhitespace(), this.ch() !== 58))
                    throw new Error(
                        `${decodeErrPrefix} unexpected character at position ${
                            this.pos
                        }, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`
                    )
                return this.pos++, this.modeStack.push("obj-value"), e
            }
            case "obj-value":
                return this.modeStack.pop(), this.modeStack.push("obj-key"), this.skipWhitespace(), this.parseValue()
            default:
                throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`)
        }
    }
}
function decode$8(t, e) {
    return (e = Object.assign({ tokenizer: new Tokenizer(t, e) }, e)), decode$a(t, e)
}
function cidEncoder(t) {
    if (t.asCID !== t) return null
    const e = CID.asCID(t)
    if (!e) return null
    const n = e.toString()
    return [new Token(Type.map, 1 / 0, 1), new Token(Type.string, "/", 1), new Token(Type.string, n, n.length), new Token(Type.break, void 0, 1)]
}
function bytesEncoder(t) {
    const e = base64$2.encode(t).slice(1)
    return [
        new Token(Type.map, 1 / 0, 1),
        new Token(Type.string, "/", 1),
        new Token(Type.map, 1 / 0, 1),
        new Token(Type.string, "bytes", 5),
        new Token(Type.string, e, e.length),
        new Token(Type.break, void 0, 1),
        new Token(Type.break, void 0, 1),
    ]
}
function undefinedEncoder() {
    throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")
}
function numberEncoder(t) {
    if (Number.isNaN(t)) throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded")
    if (t === 1 / 0 || t === -1 / 0) throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded")
    return null
}
const encodeOptions = {
    typeEncoders: { Object: cidEncoder, Uint8Array: bytesEncoder, Buffer: bytesEncoder, undefined: undefinedEncoder, number: numberEncoder },
}
class DagJsonTokenizer extends Tokenizer {
    constructor(e, n) {
        super(e, n), (this.tokenBuffer = [])
    }
    done() {
        return this.tokenBuffer.length === 0 && super.done()
    }
    _next() {
        return this.tokenBuffer.length > 0 ? this.tokenBuffer.pop() : super.next()
    }
    next() {
        const e = this._next()
        if (e.type === Type.map) {
            const n = this._next()
            if (n.type === Type.string && n.value === "/") {
                const i = this._next()
                if (i.type === Type.string) {
                    if (this._next().type !== Type.break) throw new Error("Invalid encoded CID form")
                    return this.tokenBuffer.push(i), new Token(Type.tag, 42, 0)
                }
                if (i.type === Type.map) {
                    const o = this._next()
                    if (o.type === Type.string && o.value === "bytes") {
                        const a = this._next()
                        if (a.type === Type.string) {
                            for (let c = 0; c < 2; c++) if (this._next().type !== Type.break) throw new Error("Invalid encoded Bytes form")
                            const l = base64$2.decode(`m${a.value}`)
                            return new Token(Type.bytes, l, a.value.length)
                        }
                        this.tokenBuffer.push(a)
                    }
                    this.tokenBuffer.push(o)
                }
                this.tokenBuffer.push(i)
            }
            this.tokenBuffer.push(n)
        }
        return e
    }
}
const decodeOptions = {
    allowIndefinite: !1,
    allowUndefined: !1,
    allowNaN: !1,
    allowInfinity: !1,
    allowBigInt: !0,
    strict: !0,
    useMaps: !1,
    tags: [],
}
decodeOptions.tags[42] = CID.parse
const name$4 = "dag-json",
    code$4 = 297,
    encode$8 = (t) => encode$9(t, encodeOptions),
    decode$7 = (t) => {
        const e = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(t, decodeOptions) })
        return decode$8(t, e)
    }
var dagJSON = Object.freeze(
    Object.defineProperty({ __proto__: null, name: name$4, code: code$4, encode: encode$8, decode: decode$7 }, Symbol.toStringTag, {
        value: "Module",
    })
)
function toBase64url(t) {
    return base64url.encode(t).slice(1)
}
function fromBase64url(t) {
    return base64url.decode(`u${t}`)
}
function fromSplit$1(t) {
    const [e, n, i] = t
    return { payload: n, signatures: [{ protected: e, signature: i }], link: CID.decode(fromBase64url(n)) }
}
function encodeSignature(t) {
    const e = { signature: fromBase64url(t.signature) }
    return t.header && (e.header = t.header), t.protected && (e.protected = fromBase64url(t.protected)), e
}
function encode$7(t) {
    const e = fromBase64url(t.payload)
    try {
        CID.decode(e)
    } catch {
        throw new Error("Not a valid DagJWS")
    }
    return { payload: e, signatures: t.signatures.map(encodeSignature) }
}
function decodeSignature(t) {
    const e = { signature: toBase64url(t.signature) }
    return t.header && (e.header = t.header), t.protected && (e.protected = toBase64url(t.protected)), e
}
function decode$6(t) {
    const e = { payload: toBase64url(t.payload), signatures: t.signatures.map(decodeSignature) }
    return (e.link = CID.decode(new Uint8Array(t.payload))), e
}
function fromSplit(t) {
    const [e, n, i, o, a] = t,
        l = { ciphertext: o, iv: i, protected: e, tag: a }
    return n && (l.recipients = [{ encrypted_key: n }]), l
}
function encodeRecipient(t) {
    const e = {}
    return t.encrypted_key && (e.encrypted_key = fromBase64url(t.encrypted_key)), t.header && (e.header = t.header), e
}
function encode$6(t) {
    const e = {
        ciphertext: fromBase64url(t.ciphertext),
        protected: fromBase64url(t.protected),
        iv: fromBase64url(t.iv),
        tag: fromBase64url(t.tag),
    }
    return (
        t.aad && (e.aad = fromBase64url(t.aad)),
        t.recipients && (e.recipients = t.recipients.map(encodeRecipient)),
        t.unprotected && (e.unprotected = t.unprotected),
        e
    )
}
function decodeRecipient(t) {
    const e = {}
    return t.encrypted_key && (e.encrypted_key = toBase64url(t.encrypted_key)), t.header && (e.header = t.header), e
}
function decode$5(t) {
    const e = { ciphertext: toBase64url(t.ciphertext), protected: toBase64url(t.protected), iv: toBase64url(t.iv), tag: toBase64url(t.tag) }
    return (
        t.aad && (e.aad = toBase64url(t.aad)),
        t.recipients && (e.recipients = t.recipients.map(decodeRecipient)),
        t.unprotected && (e.unprotected = t.unprotected),
        e
    )
}
const name$3 = "dag-jose",
    code$3 = 133
function isDagJWS(t) {
    return "payload" in t && typeof t.payload == "string" && "signatures" in t && Array.isArray(t.signatures)
}
function isEncodedJWS(t) {
    return "payload" in t && t.payload instanceof Uint8Array && "signatures" in t && Array.isArray(t.signatures)
}
function isEncodedJWE(t) {
    return (
        "ciphertext" in t &&
        t.ciphertext instanceof Uint8Array &&
        "iv" in t &&
        t.iv instanceof Uint8Array &&
        "protected" in t &&
        t.protected instanceof Uint8Array &&
        "tag" in t &&
        t.tag instanceof Uint8Array
    )
}
function isDagJWE(t) {
    return (
        "ciphertext" in t &&
        typeof t.ciphertext == "string" &&
        "iv" in t &&
        typeof t.iv == "string" &&
        "protected" in t &&
        typeof t.protected == "string" &&
        "tag" in t &&
        typeof t.tag == "string"
    )
}
function toGeneral(t) {
    if (typeof t == "string") {
        const e = t.split(".")
        if (e.length === 3) return fromSplit$1(e)
        if (e.length === 5) return fromSplit(e)
        throw new Error("Not a valid JOSE string")
    }
    if (isDagJWS(t) || isDagJWE(t)) return t
    throw new Error("Not a valid unencoded JOSE object")
}
function encode$5(t) {
    typeof t == "string" && (t = toGeneral(t))
    let e
    if (isDagJWS(t)) e = encode$7(t)
    else if (isDagJWE(t)) e = encode$6(t)
    else throw new Error("Not a valid JOSE object")
    return new Uint8Array(encode$a(e))
}
function decode$4(t) {
    let e
    try {
        e = decode$9(t)
    } catch {
        throw new Error("Not a valid DAG-JOSE object")
    }
    if (isEncodedJWS(e)) return decode$6(e)
    if (isEncodedJWE(e)) return decode$5(e)
    throw new Error("Not a valid DAG-JOSE object")
}
var dagJOSE = Object.freeze(
    Object.defineProperty({ __proto__: null, name: name$3, code: code$3, toGeneral, encode: encode$5, decode: decode$4 }, Symbol.toStringTag, {
        value: "Module",
    })
)
const code$2 = 0,
    name$2 = "identity",
    encode$4 = coerce,
    digest = (t) => create$3(code$2, encode$4(t)),
    identity$1 = { code: code$2, name: name$2, encode: encode$4, digest }
var identity$2 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$1 }, Symbol.toStringTag, { value: "Module" }))
const identity = from$1({ prefix: "\0", name: "identity", encode: (t) => toString$5(t), decode: (t) => fromString$3(t) })
var identityBase = Object.freeze(Object.defineProperty({ __proto__: null, identity }, Symbol.toStringTag, { value: "Module" }))
const base2 = rfc4648({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 })
var base2$1 = Object.freeze(Object.defineProperty({ __proto__: null, base2 }, Symbol.toStringTag, { value: "Module" }))
const base8 = rfc4648({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 })
var base8$1 = Object.freeze(Object.defineProperty({ __proto__: null, base8 }, Symbol.toStringTag, { value: "Module" }))
const base10 = baseX({ prefix: "9", name: "base10", alphabet: "0123456789" })
var base10$1 = Object.freeze(Object.defineProperty({ __proto__: null, base10 }, Symbol.toStringTag, { value: "Module" }))
const base16 = rfc4648({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }),
    base16upper = rfc4648({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 })
var base16$1 = Object.freeze(Object.defineProperty({ __proto__: null, base16, base16upper }, Symbol.toStringTag, { value: "Module" }))
const base36 = baseX({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }),
    base36upper = baseX({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" })
var base36$1 = Object.freeze(Object.defineProperty({ __proto__: null, base36, base36upper }, Symbol.toStringTag, { value: "Module" }))
const alphabet = Array.from(
        "\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"
    ),
    alphabetBytesToChars = alphabet.reduce((t, e, n) => ((t[n] = e), t), []),
    alphabetCharsToBytes = alphabet.reduce((t, e, n) => ((t[e.codePointAt(0)] = n), t), [])
function encode$3(t) {
    return t.reduce((e, n) => ((e += alphabetBytesToChars[n]), e), "")
}
function decode$3(t) {
    const e = []
    for (const n of t) {
        const i = alphabetCharsToBytes[n.codePointAt(0)]
        if (i === void 0) throw new Error(`Non-base256emoji character: ${n}`)
        e.push(i)
    }
    return new Uint8Array(e)
}
const base256emoji = from$1({ prefix: "\u{1F680}", name: "base256emoji", encode: encode$3, decode: decode$3 })
var base256emoji$1 = Object.freeze(Object.defineProperty({ __proto__: null, base256emoji }, Symbol.toStringTag, { value: "Module" }))
const sha = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)),
    sha256 = from({ name: "sha2-256", code: 18, encode: sha("SHA-256") }),
    sha512 = from({ name: "sha2-512", code: 19, encode: sha("SHA-512") })
var sha2 = Object.freeze(Object.defineProperty({ __proto__: null, sha256, sha512 }, Symbol.toStringTag, { value: "Module" }))
const name$1 = "raw",
    code$1 = 85,
    encode$2 = (t) => coerce(t),
    decode$2 = (t) => coerce(t)
var raw = Object.freeze(
    Object.defineProperty({ __proto__: null, name: name$1, code: code$1, encode: encode$2, decode: decode$2 }, Symbol.toStringTag, {
        value: "Module",
    })
)
const textEncoder = new TextEncoder(),
    textDecoder = new TextDecoder(),
    name = "json",
    code = 512,
    encode$1 = (t) => textEncoder.encode(JSON.stringify(t)),
    decode$1 = (t) => JSON.parse(textDecoder.decode(t))
var json = Object.freeze(
    Object.defineProperty({ __proto__: null, name, code, encode: encode$1, decode: decode$1 }, Symbol.toStringTag, { value: "Module" })
)
const bases = {
        ...identityBase,
        ...base2$1,
        ...base8$1,
        ...base10$1,
        ...base16$1,
        ...base32$1,
        ...base36$1,
        ...base58,
        ...base64$3,
        ...base256emoji$1,
    },
    hashes = { ...sha2, ...identity$2 },
    codecs = { raw, json },
    word = "[a-fA-F\\d:]",
    boundry = (t) => (t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : ""),
    v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
    v6segment = "[a-fA-F\\d]{1,4}",
    v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`
        .replace(/\s*\/\/.*$/gm, "")
        .replace(/\n/g, "")
        .trim(),
    v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`),
    v4exact = new RegExp(`^${v4}$`),
    v6exact = new RegExp(`^${v6}$`),
    ipRegex = (t) => (t && t.exact ? v46Exact : new RegExp(`(?:${boundry(t)}${v4}${boundry(t)})|(?:${boundry(t)}${v6}${boundry(t)})`, "g"))
ipRegex.v4 = (t) => (t && t.exact ? v4exact : new RegExp(`${boundry(t)}${v4}${boundry(t)}`, "g"))
ipRegex.v6 = (t) => (t && t.exact ? v6exact : new RegExp(`${boundry(t)}${v6}${boundry(t)}`, "g"))
function functionTimeout(t) {
    const e = (...n) => t(...n)
    return Object.defineProperty(e, "name", { value: `functionTimeout(${t.name || "<anonymous>"})`, configurable: !0 }), e
}
const { toString: toString$3 } = Object.prototype
function isRegexp(t) {
    return toString$3.call(t) === "[object RegExp]"
}
const flagMap = { global: "g", ignoreCase: "i", multiline: "m", dotAll: "s", sticky: "y", unicode: "u" }
function clonedRegexp(t, e = {}) {
    if (!isRegexp(t)) throw new TypeError("Expected a RegExp instance")
    const n = Object.keys(flagMap)
            .map((o) => ((typeof e[o] == "boolean" ? e[o] : t[o]) ? flagMap[o] : ""))
            .join(""),
        i = new RegExp(e.source || t.source, n)
    return (i.lastIndex = typeof e.lastIndex == "number" ? e.lastIndex : t.lastIndex), i
}
function isMatch(t, e, { timeout: n } = {}) {
    try {
        return functionTimeout(() => clonedRegexp(t).test(e), { timeout: n })()
    } catch (i) {
        throw i
    }
}
const maxIPv4Length = 15,
    maxIPv6Length = 45,
    options = { timeout: 400 }
function isIP(t) {
    return isMatch(ipRegex({ exact: !0 }), t.slice(0, maxIPv6Length), options)
}
function isIPv6(t) {
    return isMatch(ipRegex.v6({ exact: !0 }), t.slice(0, maxIPv6Length), options)
}
function isIPv4(t) {
    return isMatch(ipRegex.v4({ exact: !0 }), t.slice(0, maxIPv4Length), options)
}
function allocUnsafe(t = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t)
}
function createCodec(t, e, n, i) {
    return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: n }, decoder: { decode: i } }
}
const string = createCodec(
        "utf8",
        "u",
        (t) => {
            const e = new TextDecoder("utf8")
            return "u" + e.decode(t)
        },
        (t) => new TextEncoder().encode(t.substring(1))
    ),
    ascii = createCodec(
        "ascii",
        "a",
        (t) => {
            let e = "a"
            for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n])
            return e
        },
        (t) => {
            t = t.substring(1)
            const e = allocUnsafe(t.length)
            for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n)
            return e
        }
    ),
    BASES = { utf8: string, "utf-8": string, hex: bases.base16, latin1: ascii, ascii, binary: ascii, ...bases }
function toString$2(t, e = "utf8") {
    const n = BASES[e]
    if (!n) throw new Error(`Unsupported encoding "${e}"`)
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8")
        : n.encoder.encode(t).substring(1)
}
const isV4 = isIPv4,
    isV6 = isIPv6,
    toBytes$1 = function (t) {
        let e = 0,
            n
        if (isV4(t))
            (n = new Uint8Array(e + 4)),
                t.split(/\./g).forEach((i) => {
                    n[e++] = parseInt(i, 10) & 255
                })
        else if (isV6(t)) {
            const i = t.split(":", 8)
            let o
            for (o = 0; o < i.length; o++) {
                const a = isV4(i[o])
                let l
                a && ((l = toBytes$1(i[o])), (i[o] = toString$2(l.slice(0, 2), "base16"))),
                    l != null && ++o < 8 && i.splice(o, 0, toString$2(l.slice(2, 4), "base16"))
            }
            if (i[0] === "") for (; i.length < 8; ) i.unshift("0")
            else if (i[i.length - 1] === "") for (; i.length < 8; ) i.push("0")
            else if (i.length < 8) {
                for (o = 0; o < i.length && i[o] !== ""; o++);
                const a = [o, 1]
                for (o = 9 - i.length; o > 0; o--) a.push("0")
                i.splice.apply(i, a)
            }
            for (n = new Uint8Array(e + 16), o = 0; o < i.length; o++) {
                const a = parseInt(i[o], 16)
                ;(n[e++] = (a >> 8) & 255), (n[e++] = a & 255)
            }
        }
        if (n == null) throw Error("Invalid ip address: " + t)
        return n
    },
    toString$1 = function (t, e, n) {
        ;(e = ~~e), (n = n != null ? n : t.length - e)
        const i = []
        let o = ""
        const a = new DataView(t.buffer)
        if (n === 4) {
            for (let l = 0; l < n; l++) i.push(t[e + l])
            o = i.join(".")
        } else if (n === 16) {
            for (let l = 0; l < n; l += 2) i.push(a.getUint16(e + l).toString(16))
            ;(o = i.join(":")), (o = o.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3")), (o = o.replace(/:{3,4}/, "::"))
        }
        return o
    },
    V = -1,
    names = {},
    codes = {},
    table = [
        [4, 32, "ip4"],
        [6, 16, "tcp"],
        [33, 16, "dccp"],
        [41, 128, "ip6"],
        [42, V, "ip6zone"],
        [53, V, "dns", !0],
        [54, V, "dns4", !0],
        [55, V, "dns6", !0],
        [56, V, "dnsaddr", !0],
        [132, 16, "sctp"],
        [273, 16, "udp"],
        [275, 0, "p2p-webrtc-star"],
        [276, 0, "p2p-webrtc-direct"],
        [277, 0, "p2p-stardust"],
        [280, 0, "webrtc"],
        [290, 0, "p2p-circuit"],
        [301, 0, "udt"],
        [302, 0, "utp"],
        [400, V, "unix", !1, !0],
        [421, V, "ipfs"],
        [421, V, "p2p"],
        [443, 0, "https"],
        [444, 96, "onion"],
        [445, 296, "onion3"],
        [446, V, "garlic64"],
        [460, 0, "quic"],
        [466, V, "certhash"],
        [477, 0, "ws"],
        [478, 0, "wss"],
        [479, 0, "p2p-websocket-star"],
        [480, 0, "http"],
        [777, V, "memory"],
    ]
table.forEach((t) => {
    const e = createProtocol(...t)
    ;(codes[e.code] = e), (names[e.name] = e)
})
function createProtocol(t, e, n, i, o) {
    return { code: t, size: e, name: n, resolvable: Boolean(i), path: Boolean(o) }
}
function getProtocol(t) {
    if (typeof t == "number") {
        if (codes[t] != null) return codes[t]
        throw new Error(`no protocol with code: ${t}`)
    } else if (typeof t == "string") {
        if (names[t] != null) return names[t]
        throw new Error(`no protocol with name: ${t}`)
    }
    throw new Error(`invalid protocol id type: ${typeof t}`)
}
var encode_1 = encode,
    MSB$1 = 128,
    REST$1 = 127,
    MSBALL = ~REST$1,
    INT = Math.pow(2, 31)
function encode(t, e, n) {
    if (Number.MAX_SAFE_INTEGER && t > Number.MAX_SAFE_INTEGER) throw ((encode.bytes = 0), new RangeError("Could not encode varint"))
    ;(e = e || []), (n = n || 0)
    for (var i = n; t >= INT; ) (e[n++] = (t & 255) | MSB$1), (t /= 128)
    for (; t & MSBALL; ) (e[n++] = (t & 255) | MSB$1), (t >>>= 7)
    return (e[n] = t | 0), (encode.bytes = n - i + 1), e
}
var decode = read,
    MSB = 128,
    REST = 127
function read(t, i) {
    var n = 0,
        i = i || 0,
        o = 0,
        a = i,
        l,
        c = t.length
    do {
        if (a >= c || o > 49) throw ((read.bytes = 0), new RangeError("Could not decode varint"))
        ;(l = t[a++]), (n += o < 28 ? (l & REST) << o : (l & REST) * Math.pow(2, o)), (o += 7)
    } while (l >= MSB)
    return (read.bytes = a - i), n
}
var N1 = Math.pow(2, 7),
    N2 = Math.pow(2, 14),
    N3 = Math.pow(2, 21),
    N4 = Math.pow(2, 28),
    N5 = Math.pow(2, 35),
    N6 = Math.pow(2, 42),
    N7 = Math.pow(2, 49),
    N8 = Math.pow(2, 56),
    N9 = Math.pow(2, 63),
    length = function (t) {
        return t < N1 ? 1 : t < N2 ? 2 : t < N3 ? 3 : t < N4 ? 4 : t < N5 ? 5 : t < N6 ? 6 : t < N7 ? 7 : t < N8 ? 8 : t < N9 ? 9 : 10
    },
    varint = { encode: encode_1, decode, encodingLength: length }
function fromString$1(t, e = "utf8") {
    const n = BASES[e]
    if (!n) throw new Error(`Unsupported encoding "${e}"`)
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null
        ? globalThis.Buffer.from(t, "utf8")
        : n.decoder.decode(`${n.prefix}${t}`)
}
function concat(t, e) {
    e || (e = t.reduce((o, a) => o + a.length, 0))
    const n = allocUnsafe(e)
    let i = 0
    for (const o of t) n.set(o, i), (i += o.length)
    return n
}
function convertToString(t, e) {
    switch (getProtocol(t).code) {
        case 4:
        case 41:
            return bytes2ip(e)
        case 6:
        case 273:
        case 33:
        case 132:
            return bytes2port(e).toString()
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
            return bytes2str(e)
        case 421:
            return bytes2mh(e)
        case 444:
            return bytes2onion(e)
        case 445:
            return bytes2onion(e)
        case 466:
            return bytes2mb(e)
        default:
            return toString$2(e, "base16")
    }
}
function convertToBytes(t, e) {
    switch (getProtocol(t).code) {
        case 4:
            return ip2bytes(e)
        case 41:
            return ip2bytes(e)
        case 6:
        case 273:
        case 33:
        case 132:
            return port2bytes(parseInt(e, 10))
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
            return str2bytes(e)
        case 421:
            return mh2bytes(e)
        case 444:
            return onion2bytes(e)
        case 445:
            return onion32bytes(e)
        case 466:
            return mb2bytes(e)
        default:
            return fromString$1(e, "base16")
    }
}
const decoders = Object.values(bases).map((t) => t.decoder),
    anybaseDecoder = (function () {
        let t = decoders[0].or(decoders[1])
        return decoders.slice(2).forEach((e) => (t = t.or(e))), t
    })()
function ip2bytes(t) {
    if (!isIP(t)) throw new Error("invalid ip address")
    return toBytes$1(t)
}
function bytes2ip(t) {
    const e = toString$1(t, 0, t.length)
    if (e == null || !isIP(e)) throw new Error("invalid ip address")
    return e
}
function port2bytes(t) {
    const e = new ArrayBuffer(2)
    return new DataView(e).setUint16(0, t), new Uint8Array(e)
}
function bytes2port(t) {
    return new DataView(t.buffer).getUint16(t.byteOffset)
}
function str2bytes(t) {
    const e = fromString$1(t),
        n = Uint8Array.from(varint.encode(e.length))
    return concat([n, e], n.length + e.length)
}
function bytes2str(t) {
    const e = varint.decode(t)
    if (((t = t.slice(varint.decode.bytes)), t.length !== e)) throw new Error("inconsistent lengths")
    return toString$2(t)
}
function mh2bytes(t) {
    let e
    t[0] === "Q" || t[0] === "1" ? (e = decode$d(base58btc.decode(`z${t}`)).bytes) : (e = CID.parse(t).multihash.bytes)
    const n = Uint8Array.from(varint.encode(e.length))
    return concat([n, e], n.length + e.length)
}
function mb2bytes(t) {
    const e = anybaseDecoder.decode(t),
        n = Uint8Array.from(varint.encode(e.length))
    return concat([n, e], n.length + e.length)
}
function bytes2mb(t) {
    const e = varint.decode(t),
        n = t.slice(varint.decode.bytes)
    if (n.length !== e) throw new Error("inconsistent lengths")
    return "u" + toString$2(n, "base64url")
}
function bytes2mh(t) {
    const e = varint.decode(t),
        n = t.slice(varint.decode.bytes)
    if (n.length !== e) throw new Error("inconsistent lengths")
    return toString$2(n, "base58btc")
}
function onion2bytes(t) {
    const e = t.split(":")
    if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`)
    if (e[0].length !== 16) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`)
    const n = base32.decode("b" + e[0]),
        i = parseInt(e[1], 10)
    if (i < 1 || i > 65536) throw new Error("Port number is not in range(1, 65536)")
    const o = port2bytes(i)
    return concat([n, o], n.length + o.length)
}
function onion32bytes(t) {
    const e = t.split(":")
    if (e.length !== 2) throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`)
    if (e[0].length !== 56) throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`)
    const n = base32.decode(`b${e[0]}`),
        i = parseInt(e[1], 10)
    if (i < 1 || i > 65536) throw new Error("Port number is not in range(1, 65536)")
    const o = port2bytes(i)
    return concat([n, o], n.length + o.length)
}
function bytes2onion(t) {
    const e = t.slice(0, t.length - 2),
        n = t.slice(t.length - 2),
        i = toString$2(e, "base32"),
        o = bytes2port(n)
    return `${i}:${o}`
}
function stringToStringTuples(t) {
    const e = [],
        n = t.split("/").slice(1)
    if (n.length === 1 && n[0] === "") return []
    for (let i = 0; i < n.length; i++) {
        const o = n[i],
            a = getProtocol(o)
        if (a.size === 0) {
            e.push([o])
            continue
        }
        if ((i++, i >= n.length)) throw ParseError("invalid address: " + t)
        if (a.path === !0) {
            e.push([o, cleanPath(n.slice(i).join("/"))])
            break
        }
        e.push([o, n[i]])
    }
    return e
}
function stringTuplesToString(t) {
    const e = []
    return (
        t.map((n) => {
            const i = protoFromTuple(n)
            return e.push(i.name), n.length > 1 && n[1] != null && e.push(n[1]), null
        }),
        cleanPath(e.join("/"))
    )
}
function stringTuplesToTuples(t) {
    return t.map((e) => {
        Array.isArray(e) || (e = [e])
        const n = protoFromTuple(e)
        return e.length > 1 ? [n.code, convertToBytes(n.code, e[1])] : [n.code]
    })
}
function tuplesToStringTuples(t) {
    return t.map((e) => {
        const n = protoFromTuple(e)
        return e[1] != null ? [n.code, convertToString(n.code, e[1])] : [n.code]
    })
}
function tuplesToBytes(t) {
    return fromBytes(
        concat(
            t.map((e) => {
                const n = protoFromTuple(e)
                let i = Uint8Array.from(varint.encode(n.code))
                return e.length > 1 && e[1] != null && (i = concat([i, e[1]])), i
            })
        )
    )
}
function sizeForAddr(t, e) {
    return t.size > 0 ? t.size / 8 : t.size === 0 ? 0 : varint.decode(e) + varint.decode.bytes
}
function bytesToTuples(t) {
    const e = []
    let n = 0
    for (; n < t.length; ) {
        const i = varint.decode(t, n),
            o = varint.decode.bytes,
            a = getProtocol(i),
            l = sizeForAddr(a, t.slice(n + o))
        if (l === 0) {
            e.push([i]), (n += o)
            continue
        }
        const c = t.slice(n + o, n + o + l)
        if (((n += l + o), n > t.length)) throw ParseError("Invalid address Uint8Array: " + toString$2(t, "base16"))
        e.push([i, c])
    }
    return e
}
function bytesToString(t) {
    const e = bytesToTuples(t),
        n = tuplesToStringTuples(e)
    return stringTuplesToString(n)
}
function stringToBytes(t) {
    t = cleanPath(t)
    const e = stringToStringTuples(t),
        n = stringTuplesToTuples(e)
    return tuplesToBytes(n)
}
function fromString(t) {
    return stringToBytes(t)
}
function fromBytes(t) {
    const e = validateBytes(t)
    if (e != null) throw e
    return Uint8Array.from(t)
}
function validateBytes(t) {
    try {
        bytesToTuples(t)
    } catch (e) {
        return e
    }
}
function cleanPath(t) {
    return (
        "/" +
        t
            .trim()
            .split("/")
            .filter((e) => e)
            .join("/")
    )
}
function ParseError(t) {
    return new Error("Error parsing address: " + t)
}
function protoFromTuple(t) {
    return getProtocol(t[0])
}
function assign$1(t, e) {
    for (const n in e) Object.defineProperty(t, n, { value: e[n], enumerable: !0, configurable: !0 })
    return t
}
function createError(t, e, n) {
    if (!t || typeof t == "string") throw new TypeError("Please pass an Error to err-code")
    n || (n = {}), typeof e == "object" && ((n = e), (e = "")), e && (n.code = e)
    try {
        return assign$1(t, n)
    } catch {
        ;(n.message = t.message), (n.stack = t.stack)
        const o = function () {}
        return (o.prototype = Object.create(Object.getPrototypeOf(t))), assign$1(new o(), n)
    }
}
var errCode = createError
function equals(t, e) {
    if (t === e) return !0
    if (t.byteLength !== e.byteLength) return !1
    for (let n = 0; n < t.byteLength; n++) if (t[n] !== e[n]) return !1
    return !0
}
const inspect = Symbol.for("nodejs.util.inspect.custom"),
    DNS_CODES = [getProtocol("dns").code, getProtocol("dns4").code, getProtocol("dns6").code, getProtocol("dnsaddr").code],
    P2P_CODES = [getProtocol("p2p").code, getProtocol("ipfs").code],
    resolvers = new Map(),
    symbol$1 = Symbol.for("@multiformats/js-multiaddr/multiaddr")
class Multiaddr {
    constructor(e) {
        if ((e == null && (e = ""), Object.defineProperty(this, symbol$1, { value: !0 }), e instanceof Uint8Array)) this.bytes = fromBytes(e)
        else if (typeof e == "string") {
            if (e.length > 0 && e.charAt(0) !== "/") throw new Error(`multiaddr "${e}" must start with a "/"`)
            this.bytes = fromString(e)
        } else if (Multiaddr.isMultiaddr(e)) this.bytes = fromBytes(e.bytes)
        else throw new Error("addr must be a string, Buffer, or another Multiaddr")
    }
    toString() {
        return bytesToString(this.bytes)
    }
    toJSON() {
        return this.toString()
    }
    toOptions() {
        const e = this.protoCodes(),
            n = this.toString().split("/").slice(1)
        let i, o
        if (n.length > 2)
            DNS_CODES.includes(e[0]) && P2P_CODES.includes(e[1])
                ? ((i = getProtocol("tcp").name), (o = 443))
                : ((i = getProtocol(n[2]).name), (o = parseInt(n[3])))
        else if (DNS_CODES.includes(e[0])) (i = getProtocol("tcp").name), (o = 443)
        else throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".')
        return { family: e[0] === 41 || e[0] === 55 ? 6 : 4, host: n[1], transport: i, port: o }
    }
    protos() {
        return this.protoCodes().map((e) => Object.assign({}, getProtocol(e)))
    }
    protoCodes() {
        const e = [],
            n = this.bytes
        let i = 0
        for (; i < n.length; ) {
            const o = varint.decode(n, i),
                a = varint.decode.bytes,
                l = getProtocol(o)
            ;(i += sizeForAddr(l, n.slice(i + a)) + a), e.push(o)
        }
        return e
    }
    protoNames() {
        return this.protos().map((e) => e.name)
    }
    tuples() {
        return bytesToTuples(this.bytes)
    }
    stringTuples() {
        const e = bytesToTuples(this.bytes)
        return tuplesToStringTuples(e)
    }
    encapsulate(e) {
        return (e = new Multiaddr(e)), new Multiaddr(this.toString() + e.toString())
    }
    decapsulate(e) {
        const n = e.toString(),
            i = this.toString(),
            o = i.lastIndexOf(n)
        if (o < 0) throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`)
        return new Multiaddr(i.slice(0, o))
    }
    decapsulateCode(e) {
        const n = this.tuples()
        for (let i = n.length - 1; i >= 0; i--) if (n[i][0] === e) return new Multiaddr(tuplesToBytes(n.slice(0, i)))
        return this
    }
    getPeerId() {
        try {
            const n = this.stringTuples()
                .filter((i) => i[0] === names.ipfs.code)
                .pop()
            if ((n == null ? void 0 : n[1]) != null) {
                const i = n[1]
                return i[0] === "Q" || i[0] === "1"
                    ? toString$2(base58btc.decode(`z${i}`), "base58btc")
                    : toString$2(CID.parse(i).multihash.bytes, "base58btc")
            }
            return null
        } catch {
            return null
        }
    }
    getPath() {
        let e = null
        try {
            ;(e = this.stringTuples().filter((n) => getProtocol(n[0]).path === !0)[0][1]), e == null && (e = null)
        } catch {
            e = null
        }
        return e
    }
    equals(e) {
        return equals(this.bytes, e.bytes)
    }
    async resolve(e) {
        const n = this.protos().find((a) => a.resolvable)
        if (n == null) return [this]
        const i = resolvers.get(n.name)
        if (i == null) throw errCode(new Error(`no available resolver for ${n.name}`), "ERR_NO_AVAILABLE_RESOLVER")
        return (await i(this, e)).map((a) => new Multiaddr(a))
    }
    nodeAddress() {
        const e = this.toOptions()
        if (e.transport !== "tcp" && e.transport !== "udp")
            throw new Error(
                `multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`
            )
        return { family: e.family, address: e.host, port: e.port }
    }
    isThinWaistAddress(e) {
        const n = (e != null ? e : this).protos()
        return !(n.length !== 2 || (n[0].code !== 4 && n[0].code !== 41) || (n[1].code !== 6 && n[1].code !== 273))
    }
    static fromNodeAddress(e, n) {
        if (e == null) throw new Error("requires node address object")
        if (n == null) throw new Error("requires transport protocol")
        let i
        switch (e.family) {
            case 4:
                i = "ip4"
                break
            case 6:
                i = "ip6"
                break
            default:
                throw Error("Invalid addr family, should be 4 or 6.")
        }
        return new Multiaddr("/" + [i, e.address, n, e.port].join("/"))
    }
    static isName(e) {
        return Multiaddr.isMultiaddr(e) ? e.protos().some((n) => n.resolvable) : !1
    }
    static isMultiaddr(e) {
        return Boolean(e == null ? void 0 : e[symbol$1])
    }
    [inspect]() {
        return "<Multiaddr " + toString$2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">"
    }
    inspect() {
        return "<Multiaddr " + toString$2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">"
    }
}
Multiaddr.resolvers = resolvers
function isElectron$1() {
    return (
        (typeof window != "undefined" && typeof window.process == "object" && window.process.type === "renderer") ||
        (typeof process != "undefined" && typeof process.versions == "object" && !!process.versions.electron) ||
        (typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0)
    )
}
var isElectron_1 = isElectron$1
const isElectron = isElectron_1,
    IS_ENV_WITH_DOM = typeof window == "object" && typeof document == "object" && document.nodeType === 9,
    IS_ELECTRON = isElectron(),
    IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON,
    IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM,
    IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM,
    IS_NODE =
        typeof commonjsRequire$1 == "function" &&
        typeof process != "undefined" &&
        typeof process.release != "undefined" &&
        process.release.name === "node" &&
        !IS_ELECTRON,
    IS_WEBWORKER =
        typeof importScripts == "function" &&
        typeof self != "undefined" &&
        typeof WorkerGlobalScope != "undefined" &&
        self instanceof WorkerGlobalScope,
    IS_TEST = typeof process != "undefined" && typeof process.env != "undefined" && !1,
    IS_REACT_NATIVE = typeof navigator != "undefined" && navigator.product === "ReactNative"
var env = {
    isTest: IS_TEST,
    isElectron: IS_ELECTRON,
    isElectronMain: IS_ELECTRON_MAIN,
    isElectronRenderer: IS_ELECTRON_RENDERER,
    isNode: IS_NODE,
    isBrowser: IS_BROWSER,
    isWebWorker: IS_WEBWORKER,
    isEnvWithDom: IS_ENV_WITH_DOM,
    isReactNative: IS_REACT_NATIVE,
}
let durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/giu
parse$1.nanosecond = parse$1.ns = 1 / 1e6
parse$1.µs = parse$1.μs = parse$1.us = parse$1.microsecond = 1 / 1e3
parse$1.millisecond = parse$1.ms = parse$1[""] = 1
parse$1.second = parse$1.sec = parse$1.s = parse$1.ms * 1e3
parse$1.minute = parse$1.min = parse$1.m = parse$1.s * 60
parse$1.hour = parse$1.hr = parse$1.h = parse$1.m * 60
parse$1.day = parse$1.d = parse$1.h * 24
parse$1.week = parse$1.wk = parse$1.w = parse$1.d * 7
parse$1.month = parse$1.b = parse$1.d * (365.25 / 12)
parse$1.year = parse$1.yr = parse$1.y = parse$1.d * 365.25
function parse$1(t = "", e = "ms") {
    var n = null
    return (
        (t = (t + "").replace(/(\d)[,_](\d)/g, "$1$2")),
        t.replace(durationRE, function (i, o, a) {
            ;(a = unitRatio(a)), a && (n = (n || 0) + parseFloat(o, 10) * a)
        }),
        n && n / (unitRatio(e) || 1)
    )
}
function unitRatio(t) {
    return parse$1[t] || parse$1[t.toLowerCase().replace(/s$/, "")]
}
var browser$1 = { exports: {} },
    s = 1e3,
    m = s * 60,
    h = m * 60,
    d = h * 24,
    w = d * 7,
    y = d * 365.25,
    ms = function (t, e) {
        e = e || {}
        var n = typeof t
        if (n === "string" && t.length > 0) return parse(t)
        if (n === "number" && isFinite(t)) return e.long ? fmtLong(t) : fmtShort(t)
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t))
    }
function parse(t) {
    if (((t = String(t)), !(t.length > 100))) {
        var e =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                t
            )
        if (!!e) {
            var n = parseFloat(e[1]),
                i = (e[2] || "ms").toLowerCase()
            switch (i) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return n * y
                case "weeks":
                case "week":
                case "w":
                    return n * w
                case "days":
                case "day":
                case "d":
                    return n * d
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return n * h
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return n * m
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return n * s
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return n
                default:
                    return
            }
        }
    }
}
function fmtShort(t) {
    var e = Math.abs(t)
    return e >= d
        ? Math.round(t / d) + "d"
        : e >= h
        ? Math.round(t / h) + "h"
        : e >= m
        ? Math.round(t / m) + "m"
        : e >= s
        ? Math.round(t / s) + "s"
        : t + "ms"
}
function fmtLong(t) {
    var e = Math.abs(t)
    return e >= d
        ? plural(t, e, d, "day")
        : e >= h
        ? plural(t, e, h, "hour")
        : e >= m
        ? plural(t, e, m, "minute")
        : e >= s
        ? plural(t, e, s, "second")
        : t + " ms"
}
function plural(t, e, n, i) {
    var o = e >= n * 1.5
    return Math.round(t / n) + " " + i + (o ? "s" : "")
}
function setup(t) {
    ;(n.debug = n),
        (n.default = n),
        (n.coerce = g),
        (n.disable = a),
        (n.enable = o),
        (n.enabled = l),
        (n.humanize = ms),
        (n.destroy = v),
        Object.keys(t).forEach((_) => {
            n[_] = t[_]
        }),
        (n.names = []),
        (n.skips = []),
        (n.formatters = {})
    function e(_) {
        let A = 0
        for (let B = 0; B < _.length; B++) (A = (A << 5) - A + _.charCodeAt(B)), (A |= 0)
        return n.colors[Math.abs(A) % n.colors.length]
    }
    n.selectColor = e
    function n(_) {
        let A,
            B = null,
            D,
            I
        function L(...G) {
            if (!L.enabled) return
            const U = L,
                F = Number(new Date()),
                Z = F - (A || F)
            ;(U.diff = Z), (U.prev = A), (U.curr = F), (A = F), (G[0] = n.coerce(G[0])), typeof G[0] != "string" && G.unshift("%O")
            let Y = 0
            ;(G[0] = G[0].replace(/%([a-zA-Z%])/g, (ie, he) => {
                if (ie === "%%") return "%"
                Y++
                const oe = n.formatters[he]
                if (typeof oe == "function") {
                    const le = G[Y]
                    ;(ie = oe.call(U, le)), G.splice(Y, 1), Y--
                }
                return ie
            })),
                n.formatArgs.call(U, G),
                (U.log || n.log).apply(U, G)
        }
        return (
            (L.namespace = _),
            (L.useColors = n.useColors()),
            (L.color = n.selectColor(_)),
            (L.extend = i),
            (L.destroy = n.destroy),
            Object.defineProperty(L, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () => (B !== null ? B : (D !== n.namespaces && ((D = n.namespaces), (I = n.enabled(_))), I)),
                set: (G) => {
                    B = G
                },
            }),
            typeof n.init == "function" && n.init(L),
            L
        )
    }
    function i(_, A) {
        const B = n(this.namespace + (typeof A == "undefined" ? ":" : A) + _)
        return (B.log = this.log), B
    }
    function o(_) {
        n.save(_), (n.namespaces = _), (n.names = []), (n.skips = [])
        let A
        const B = (typeof _ == "string" ? _ : "").split(/[\s,]+/),
            D = B.length
        for (A = 0; A < D; A++)
            !B[A] ||
                ((_ = B[A].replace(/\*/g, ".*?")),
                _[0] === "-" ? n.skips.push(new RegExp("^" + _.slice(1) + "$")) : n.names.push(new RegExp("^" + _ + "$")))
    }
    function a() {
        const _ = [...n.names.map(c), ...n.skips.map(c).map((A) => "-" + A)].join(",")
        return n.enable(""), _
    }
    function l(_) {
        if (_[_.length - 1] === "*") return !0
        let A, B
        for (A = 0, B = n.skips.length; A < B; A++) if (n.skips[A].test(_)) return !1
        for (A = 0, B = n.names.length; A < B; A++) if (n.names[A].test(_)) return !0
        return !1
    }
    function c(_) {
        return _.toString()
            .substring(2, _.toString().length - 2)
            .replace(/\.\*\?$/, "*")
    }
    function g(_) {
        return _ instanceof Error ? _.stack || _.message : _
    }
    function v() {
        console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
        )
    }
    return n.enable(n.load()), n
}
var common = setup
;(function (t, e) {
    ;(e.formatArgs = i),
        (e.save = o),
        (e.load = a),
        (e.useColors = n),
        (e.storage = l()),
        (e.destroy = (() => {
            let g = !1
            return () => {
                g ||
                    ((g = !0),
                    console.warn(
                        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                    ))
            }
        })()),
        (e.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33",
        ])
    function n() {
        return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)
            ? !0
            : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
            ? !1
            : (typeof document != "undefined" &&
                  document.documentElement &&
                  document.documentElement.style &&
                  document.documentElement.style.WebkitAppearance) ||
              (typeof window != "undefined" &&
                  window.console &&
                  (window.console.firebug || (window.console.exception && window.console.table))) ||
              (typeof navigator != "undefined" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
              (typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    }
    function i(g) {
        if (
            ((g[0] =
                (this.useColors ? "%c" : "") +
                this.namespace +
                (this.useColors ? " %c" : " ") +
                g[0] +
                (this.useColors ? "%c " : " ") +
                "+" +
                t.exports.humanize(this.diff)),
            !this.useColors)
        )
            return
        const v = "color: " + this.color
        g.splice(1, 0, v, "color: inherit")
        let _ = 0,
            A = 0
        g[0].replace(/%[a-zA-Z%]/g, (B) => {
            B !== "%%" && (_++, B === "%c" && (A = _))
        }),
            g.splice(A, 0, v)
    }
    e.log = console.debug || console.log || (() => {})
    function o(g) {
        try {
            g ? e.storage.setItem("debug", g) : e.storage.removeItem("debug")
        } catch {}
    }
    function a() {
        let g
        try {
            g = e.storage.getItem("debug")
        } catch {}
        return !g && typeof process != "undefined" && "env" in process && (g = {}.DEBUG), g
    }
    function l() {
        try {
            return localStorage
        } catch {}
    }
    t.exports = common(e)
    const { formatters: c } = t.exports
    c.j = function (g) {
        try {
            return JSON.stringify(g)
        } catch (v) {
            return "[UnexpectedJSONParseError]: " + v.message
        }
    }
})(browser$1, browser$1.exports)
var debug = browser$1.exports
debug.formatters.b = (t) => (t == null ? "undefined" : base58btc.baseEncode(t))
debug.formatters.t = (t) => (t == null ? "undefined" : base32.baseEncode(t))
debug.formatters.m = (t) => (t == null ? "undefined" : base64$2.baseEncode(t))
debug.formatters.p = (t) => (t == null ? "undefined" : t.toString())
debug.formatters.c = (t) => (t == null ? "undefined" : t.toString())
debug.formatters.k = (t) => (t == null ? "undefined" : t.toString())
function logger(t) {
    return Object.assign(debug(t), { error: debug(`${t}:error`), trace: debug(`${t}:trace`) })
}
var error = {}
class TimeoutError$2 extends Error {
    constructor(e = "Request timed out") {
        super(e), (this.name = "TimeoutError")
    }
}
error.TimeoutError = TimeoutError$2
class AbortError$1 extends Error {
    constructor(e = "The operation was aborted.") {
        super(e), (this.name = "AbortError")
    }
}
error.AbortError = AbortError$1
class HTTPError$1 extends Error {
    constructor(e) {
        super(e.statusText), (this.name = "HTTPError"), (this.response = e)
    }
}
error.HTTPError = HTTPError$1
var src = { exports: {} },
    browser = { exports: {} }
;(function (t, e) {
    var n = function () {
            if (typeof self != "undefined") return self
            if (typeof window != "undefined") return window
            if (typeof i != "undefined") return i
            throw new Error("unable to locate global object")
        },
        i = n()
    ;(t.exports = e = i.fetch),
        i.fetch && (e.default = i.fetch.bind(i)),
        (e.Headers = i.Headers),
        (e.Request = i.Request),
        (e.Response = i.Response)
})(browser, browser.exports)
globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response
    ? (src.exports = { default: globalThis.fetch, Headers: globalThis.Headers, Request: globalThis.Request, Response: globalThis.Response })
    : (src.exports = {
          default: browser.exports.default,
          Headers: browser.exports.Headers,
          Request: browser.exports.Request,
          Response: browser.exports.Response,
      })
var fetch_browser$1 = src.exports
const { TimeoutError: TimeoutError$1, AbortError } = error,
    { Response: Response$1, Request: Request$1, Headers: Headers$1, default: fetch$2 } = fetch_browser$1,
    fetchWithProgress = (t, e = {}) => {
        const n = new XMLHttpRequest()
        n.open(e.method || "GET", t.toString(), !0)
        const { timeout: i, headers: o } = e
        if ((i && i > 0 && i < 1 / 0 && (n.timeout = i), e.overrideMimeType != null && n.overrideMimeType(e.overrideMimeType), o))
            for (const [a, l] of new Headers$1(o)) n.setRequestHeader(a, l)
        return (
            e.signal && (e.signal.onabort = () => n.abort()),
            e.onUploadProgress && (n.upload.onprogress = e.onUploadProgress),
            (n.responseType = "arraybuffer"),
            new Promise((a, l) => {
                const c = (g) => {
                    switch (g.type) {
                        case "error": {
                            a(Response$1.error())
                            break
                        }
                        case "load": {
                            a(
                                new ResponseWithURL(n.responseURL, n.response, {
                                    status: n.status,
                                    statusText: n.statusText,
                                    headers: parseHeaders(n.getAllResponseHeaders()),
                                })
                            )
                            break
                        }
                        case "timeout": {
                            l(new TimeoutError$1())
                            break
                        }
                        case "abort": {
                            l(new AbortError())
                            break
                        }
                    }
                }
                ;(n.onerror = c), (n.onload = c), (n.ontimeout = c), (n.onabort = c), n.send(e.body)
            })
        )
    },
    fetchWithStreaming = fetch$2,
    fetchWith = (t, e = {}) => (e.onUploadProgress != null ? fetchWithProgress(t, e) : fetchWithStreaming(t, e)),
    parseHeaders = (t) => {
        const e = new Headers$1()
        for (const n of t.trim().split(/[\r\n]+/)) {
            const i = n.indexOf(": ")
            i > 0 && e.set(n.slice(0, i), n.slice(i + 1))
        }
        return e
    }
class ResponseWithURL extends Response$1 {
    constructor(e, n, i) {
        super(n, i), Object.defineProperty(this, "url", { value: e })
    }
}
var fetch_browser = { fetch: fetchWith, Request: Request$1, Headers: Headers$1 },
    isPlainObj = (t) => {
        if (Object.prototype.toString.call(t) !== "[object Object]") return !1
        const e = Object.getPrototypeOf(t)
        return e === null || e === Object.prototype
    }
const isOptionObject = isPlainObj,
    { hasOwnProperty } = Object.prototype,
    { propertyIsEnumerable } = Object,
    defineProperty = (t, e, n) => Object.defineProperty(t, e, { value: n, writable: !0, enumerable: !0, configurable: !0 }),
    globalThis$1 = commonjsGlobal,
    defaultMergeOptions = { concatArrays: !1, ignoreUndefined: !1 },
    getEnumerableOwnPropertyKeys = (t) => {
        const e = []
        for (const n in t) hasOwnProperty.call(t, n) && e.push(n)
        if (Object.getOwnPropertySymbols) {
            const n = Object.getOwnPropertySymbols(t)
            for (const i of n) propertyIsEnumerable.call(t, i) && e.push(i)
        }
        return e
    }
function clone$1(t) {
    return Array.isArray(t) ? cloneArray(t) : isOptionObject(t) ? cloneOptionObject(t) : t
}
function cloneArray(t) {
    const e = t.slice(0, 0)
    return (
        getEnumerableOwnPropertyKeys(t).forEach((n) => {
            defineProperty(e, n, clone$1(t[n]))
        }),
        e
    )
}
function cloneOptionObject(t) {
    const e = Object.getPrototypeOf(t) === null ? Object.create(null) : {}
    return (
        getEnumerableOwnPropertyKeys(t).forEach((n) => {
            defineProperty(e, n, clone$1(t[n]))
        }),
        e
    )
}
const mergeKeys = (t, e, n, i) => (
        n.forEach((o) => {
            ;(typeof e[o] == "undefined" && i.ignoreUndefined) ||
                (o in t && t[o] !== Object.getPrototypeOf(t)
                    ? defineProperty(t, o, merge$2(t[o], e[o], i))
                    : defineProperty(t, o, clone$1(e[o])))
        }),
        t
    ),
    concatArrays = (t, e, n) => {
        let i = t.slice(0, 0),
            o = 0
        return (
            [t, e].forEach((a) => {
                const l = []
                for (let c = 0; c < a.length; c++)
                    !hasOwnProperty.call(a, c) ||
                        (l.push(String(c)), a === t ? defineProperty(i, o++, a[c]) : defineProperty(i, o++, clone$1(a[c])))
                i = mergeKeys(
                    i,
                    a,
                    getEnumerableOwnPropertyKeys(a).filter((c) => !l.includes(c)),
                    n
                )
            }),
            i
        )
    }
function merge$2(t, e, n) {
    return n.concatArrays && Array.isArray(t) && Array.isArray(e)
        ? concatArrays(t, e, n)
        : !isOptionObject(e) || !isOptionObject(t)
        ? clone$1(e)
        : mergeKeys(t, e, getEnumerableOwnPropertyKeys(e), n)
}
var mergeOptions = function (...t) {
    const e = merge$2(clone$1(defaultMergeOptions), (this !== globalThis$1 && this) || {}, defaultMergeOptions)
    let n = { _: {} }
    for (const i of t)
        if (i !== void 0) {
            if (!isOptionObject(i)) throw new TypeError("`" + i + "` is not an Option Object")
            n = merge$2(n, { _: i }, e)
        }
    return n._
}
const isReactNative = typeof navigator != "undefined" && navigator.product === "ReactNative"
function getDefaultBase() {
    return isReactNative ? "http://localhost" : self.location ? self.location.protocol + "//" + self.location.host : ""
}
const URL$2 = self.URL,
    defaultBase$1 = getDefaultBase()
class URLWithLegacySupport$2 {
    constructor(e = "", n = defaultBase$1) {
        ;(this.super = new URL$2(e, n)),
            (this.path = this.pathname + this.search),
            (this.auth = this.username && this.password ? this.username + ":" + this.password : null),
            (this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null)
    }
    get hash() {
        return this.super.hash
    }
    get host() {
        return this.super.host
    }
    get hostname() {
        return this.super.hostname
    }
    get href() {
        return this.super.href
    }
    get origin() {
        return this.super.origin
    }
    get password() {
        return this.super.password
    }
    get pathname() {
        return this.super.pathname
    }
    get port() {
        return this.super.port
    }
    get protocol() {
        return this.super.protocol
    }
    get search() {
        return this.super.search
    }
    get searchParams() {
        return this.super.searchParams
    }
    get username() {
        return this.super.username
    }
    set hash(e) {
        this.super.hash = e
    }
    set host(e) {
        this.super.host = e
    }
    set hostname(e) {
        this.super.hostname = e
    }
    set href(e) {
        this.super.href = e
    }
    set password(e) {
        this.super.password = e
    }
    set pathname(e) {
        this.super.pathname = e
    }
    set port(e) {
        this.super.port = e
    }
    set protocol(e) {
        this.super.protocol = e
    }
    set search(e) {
        this.super.search = e
    }
    set username(e) {
        this.super.username = e
    }
    static createObjectURL(e) {
        return URL$2.createObjectURL(e)
    }
    static revokeObjectURL(e) {
        URL$2.revokeObjectURL(e)
    }
    toJSON() {
        return this.super.toJSON()
    }
    toString() {
        return this.super.toString()
    }
    format() {
        return this.toString()
    }
}
function format$2(t) {
    if (typeof t == "string") return new URL$2(t).toString()
    if (!(t instanceof URL$2)) {
        const e = t.username && t.password ? `${t.username}:${t.password}@` : "",
            n = t.auth ? t.auth + "@" : "",
            i = t.port ? ":" + t.port : "",
            o = t.protocol ? t.protocol + "//" : "",
            a = t.host || "",
            l = t.hostname || "",
            c = t.search || (t.query ? "?" + t.query : ""),
            g = t.hash || "",
            v = t.pathname || "",
            _ = t.path || v + c
        return `${o}${e || n}${a || l + i}${_}${g}`
    }
}
var urlBrowser = {
    URLWithLegacySupport: URLWithLegacySupport$2,
    URLSearchParams: self.URLSearchParams,
    defaultBase: defaultBase$1,
    format: format$2,
}
const { URLWithLegacySupport: URLWithLegacySupport$1, format: format$1 } = urlBrowser
var relative$1 = (t, e = {}, n = {}, i) => {
    let o = e.protocol ? e.protocol.replace(":", "") : "http"
    o = (n[o] || i || o) + ":"
    let a
    try {
        a = new URLWithLegacySupport$1(t)
    } catch {
        a = {}
    }
    const l = Object.assign({}, e, { protocol: o || a.protocol, host: e.host || a.host })
    return new URLWithLegacySupport$1(t, format$1(l)).toString()
}
const { URLWithLegacySupport, format, URLSearchParams: URLSearchParams$2, defaultBase } = urlBrowser,
    relative = relative$1
var isoUrl = { URL: URLWithLegacySupport, URLSearchParams: URLSearchParams$2, format, relative, defaultBase },
    anySignal$2 = { exports: {} }
function anySignal$1(t) {
    const e = new globalThis.AbortController()
    function n() {
        e.abort()
        for (const i of t) !i || !i.removeEventListener || i.removeEventListener("abort", n)
    }
    for (const i of t)
        if (!(!i || !i.addEventListener)) {
            if (i.aborted) {
                n()
                break
            }
            i.addEventListener("abort", n)
        }
    return e.signal
}
anySignal$2.exports = anySignal$1
var anySignal_2 = (anySignal$2.exports.anySignal = anySignal$1)
const { fetch: fetch$1, Request, Headers } = fetch_browser,
    { TimeoutError, HTTPError } = error,
    merge$1 = mergeOptions.bind({ ignoreUndefined: !0 }),
    { URL: URL$1, URLSearchParams: URLSearchParams$1 } = isoUrl,
    anySignal = anySignal$2.exports,
    timeout = (t, e, n) => {
        if (e === void 0) return t
        const i = Date.now(),
            o = () => Date.now() - i >= e
        return new Promise((a, l) => {
            const c = setTimeout(() => {
                    o() && (l(new TimeoutError()), n.abort())
                }, e),
                g = (v) => (A) => {
                    if ((clearTimeout(c), o())) {
                        l(new TimeoutError())
                        return
                    }
                    v(A)
                }
            t.then(g(a), g(l))
        })
    },
    defaults$1 = { throwHttpErrors: !0, credentials: "same-origin" }
class HTTP {
    constructor(e = {}) {
        this.opts = merge$1(defaults$1, e)
    }
    async fetch(e, n = {}) {
        const i = merge$1(this.opts, n),
            o = new Headers(i.headers)
        if (typeof e != "string" && !(e instanceof URL$1 || e instanceof Request))
            throw new TypeError("`resource` must be a string, URL, or Request")
        const a = new URL$1(e.toString(), i.base),
            { searchParams: l, transformSearchParams: c, json: g } = i
        l &&
            (typeof c == "function"
                ? (a.search = c(new URLSearchParams$1(i.searchParams)))
                : (a.search = new URLSearchParams$1(i.searchParams))),
            g && ((i.body = JSON.stringify(i.json)), o.set("content-type", "application/json"))
        const v = new AbortController(),
            _ = anySignal([v.signal, i.signal]),
            A = await timeout(fetch$1(a.toString(), { ...i, signal: _, timeout: void 0, headers: o }), i.timeout, v)
        if (!A.ok && i.throwHttpErrors) throw (i.handleError && (await i.handleError(A)), new HTTPError(A))
        return (
            (A.iterator = async function* () {
                yield* fromStream(A.body)
            }),
            (A.ndjson = async function* () {
                for await (const B of ndjson(A.iterator())) n.transform ? yield n.transform(B) : yield B
            }),
            A
        )
    }
    post(e, n = {}) {
        return this.fetch(e, { ...n, method: "POST" })
    }
    get(e, n = {}) {
        return this.fetch(e, { ...n, method: "GET" })
    }
    put(e, n = {}) {
        return this.fetch(e, { ...n, method: "PUT" })
    }
    delete(e, n = {}) {
        return this.fetch(e, { ...n, method: "DELETE" })
    }
    options(e, n = {}) {
        return this.fetch(e, { ...n, method: "OPTIONS" })
    }
}
const ndjson = async function* (t) {
        const e = new TextDecoder()
        let n = ""
        for await (const i of t) {
            n += e.decode(i, { stream: !0 })
            const o = n.split(/\r?\n/)
            for (let a = 0; a < o.length - 1; a++) {
                const l = o[a].trim()
                l.length > 0 && (yield JSON.parse(l))
            }
            n = o[o.length - 1]
        }
        ;(n += e.decode()), (n = n.trim()), n.length !== 0 && (yield JSON.parse(n))
    },
    fromStream = (t) => {
        if (isNodeReadableStream(t)) {
            const e = t[Symbol.asyncIterator]()
            return {
                [Symbol.asyncIterator]() {
                    return {
                        next: e.next.bind(e),
                        return(n) {
                            return t.destroy(), typeof e.return == "function" ? e.return() : Promise.resolve({ done: !0, value: n })
                        },
                    }
                },
            }
        }
        if (isWebReadableStream(t)) {
            const e = t.getReader()
            return (async function* () {
                try {
                    for (;;) {
                        const { done: n, value: i } = await e.read()
                        if (n) return
                        i && (yield i)
                    }
                } finally {
                    e.releaseLock()
                }
            })()
        }
        if (isAsyncIterable(t)) return t
        throw new TypeError("Body can't be converted to AsyncIterable")
    },
    isAsyncIterable = (t) => typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function",
    isWebReadableStream = (t) => t && typeof t.getReader == "function",
    isNodeReadableStream = (t) => Object.prototype.hasOwnProperty.call(t, "readable") && Object.prototype.hasOwnProperty.call(t, "writable")
HTTP.HTTPError = HTTPError
HTTP.TimeoutError = TimeoutError
HTTP.streamToAsyncIterator = fromStream
HTTP.post = (t, e) => new HTTP(e).post(t, e)
HTTP.get = (t, e) => new HTTP(e).get(t, e)
HTTP.put = (t, e) => new HTTP(e).put(t, e)
HTTP.delete = (t, e) => new HTTP(e).delete(t, e)
HTTP.options = (t, e) => new HTTP(e).options(t, e)
var http = HTTP
const reduceValue = (t, e) => e,
    tcpUri = (t, e, n, i) => {
        if (i != null && i.assumeHttp === !1) return `tcp://${t}:${e}`
        let o = "tcp",
            a = `:${e}`
        return (
            n[n.length - 1].protocol === "tcp" && ((o = e === "443" ? "https" : "http"), (a = e === "443" || e === "80" ? "" : a)),
            `${o}://${t}${a}`
        )
    },
    Reducers = {
        ip4: reduceValue,
        ip6: (t, e, n, i) => (i.length === 1 && i[0].protocol === "ip6" ? e : `[${e}]`),
        tcp: (t, e, n, i, o) => (i.some((a) => ["http", "https", "ws", "wss"].includes(a.protocol)) ? `${t}:${e}` : tcpUri(t, e, i, o)),
        udp: (t, e) => `udp://${t}:${e}`,
        dnsaddr: reduceValue,
        dns4: reduceValue,
        dns6: reduceValue,
        ipfs: (t, e) => `${t}/ipfs/${e}`,
        p2p: (t, e) => `${t}/p2p/${e}`,
        http: (t) => `http://${t}`,
        https: (t) => `https://${t}`,
        ws: (t) => `ws://${t}`,
        wss: (t) => `wss://${t}`,
        "p2p-websocket-star": (t) => `${t}/p2p-websocket-star`,
        "p2p-webrtc-star": (t) => `${t}/p2p-webrtc-star`,
        "p2p-webrtc-direct": (t) => `${t}/p2p-webrtc-direct`,
    }
function multiaddrToUri(t, e) {
    const n = new Multiaddr(t),
        i = t.toString().split("/").slice(1)
    return n
        .tuples()
        .map((o) => {
            var a, l
            return { protocol: (a = i.shift()) != null ? a : "", content: o[1] != null && (l = i.shift()) != null ? l : "" }
        })
        .reduce((o, a, l, c) => {
            const g = Reducers[a.protocol]
            if (g == null) throw new Error(`Unsupported protocol ${a.protocol}`)
            return g(o, a.content, l, c, e)
        }, "")
}
function toUrlString(t) {
    try {
        t = multiaddrToUri(new Multiaddr(t))
    } catch {}
    return (t = t.toString()), t
}
var getAgent = () => {}
const log$1 = logger("ipfs-http-client:lib:error-handler"),
    merge = mergeOptions.bind({ ignoreUndefined: !0 }),
    DEFAULT_PROTOCOL = env.isBrowser || env.isWebWorker ? location.protocol : "http",
    DEFAULT_HOST = env.isBrowser || env.isWebWorker ? location.hostname : "localhost",
    DEFAULT_PORT = env.isBrowser || env.isWebWorker ? location.port : "5001",
    normalizeOptions = (t = {}) => {
        let e,
            n = {},
            i
        if (typeof t == "string" || Multiaddr.isMultiaddr(t)) e = new URL(toUrlString(t))
        else if (t instanceof URL) e = t
        else if (typeof t.url == "string" || Multiaddr.isMultiaddr(t.url)) (e = new URL(toUrlString(t.url))), (n = t)
        else if (t.url instanceof URL) (e = t.url), (n = t)
        else {
            n = t || {}
            const o = (n.protocol || DEFAULT_PROTOCOL).replace(":", ""),
                a = (n.host || DEFAULT_HOST).split(":")[0],
                l = n.port || DEFAULT_PORT
            e = new URL(`${o}://${a}:${l}`)
        }
        if ((n.apiPath ? (e.pathname = n.apiPath) : (e.pathname === "/" || e.pathname === void 0) && (e.pathname = "api/v0"), env.isNode)) {
            const o = getAgent()
            i = n.agent || new o({ keepAlive: !0, maxSockets: 6 })
        }
        return { ...n, host: e.host, protocol: e.protocol.replace(":", ""), port: Number(e.port), apiPath: e.pathname, url: e, agent: i }
    },
    errorHandler = async (t) => {
        let e
        try {
            if ((t.headers.get("Content-Type") || "").startsWith("application/json")) {
                const i = await t.json()
                log$1(i), (e = i.Message || i.message)
            } else e = await t.text()
        } catch (i) {
            log$1("Failed to parse error response", i), (e = i.message)
        }
        let n = new http.HTTPError(t)
        throw (
            (e &&
                (e.includes("deadline has elapsed") && (n = new http.TimeoutError()),
                e && e.includes("context deadline exceeded") && (n = new http.TimeoutError())),
            e && e.includes("request timed out") && (n = new http.TimeoutError()),
            e && (n.message = e),
            n)
        )
    },
    KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,
    kebabCase = (t) =>
        t.replace(KEBAB_REGEX, function (e) {
            return "-" + e.toLowerCase()
        }),
    parseTimeout = (t) => (typeof t == "string" ? parse$1(t) : t)
class Client extends http {
    constructor(e = {}) {
        const n = normalizeOptions(e)
        super({
            timeout: parseTimeout(n.timeout || 0) || void 0,
            headers: n.headers,
            base: `${n.url}`,
            handleError: errorHandler,
            transformSearchParams: (o) => {
                const a = new URLSearchParams()
                for (const [l, c] of o)
                    c !== "undefined" && c !== "null" && l !== "signal" && a.append(kebabCase(l), c),
                        l === "timeout" && !isNaN(c) && a.append(kebabCase(l), c)
                return a
            },
            agent: n.agent,
        }),
            delete this.get,
            delete this.put,
            delete this.delete,
            delete this.options
        const i = this.fetch
        this.fetch = (o, a = {}) => (
            typeof o == "string" && !o.startsWith("/") && (o = `${n.url}/${o}`), i.call(this, o, merge(a, { method: "POST" }))
        )
    }
}
const configure = (t) => (e) => t(new Client(e), e)
function modeToString$1(t) {
    if (t != null) return typeof t == "string" ? t : t.toString(8).padStart(4, "0")
}
function parseMtime$1(t) {
    if (t == null) return
    let e
    if (
        (t.secs != null && (e = { secs: t.secs, nsecs: t.nsecs }),
        t.Seconds != null && (e = { secs: t.Seconds, nsecs: t.FractionalNanoseconds }),
        Array.isArray(t) && (e = { secs: t[0], nsecs: t[1] }),
        t instanceof Date)
    ) {
        const n = t.getTime(),
            i = Math.floor(n / 1e3)
        e = { secs: i, nsecs: (n - i * 1e3) * 1e3 }
    }
    if (!!Object.prototype.hasOwnProperty.call(e, "secs")) {
        if (e != null && e.nsecs != null && (e.nsecs < 0 || e.nsecs > 999999999))
            throw errCode(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS")
        return e
    }
}
function toUrlSearchParams({ arg: t, searchParams: e, hashAlg: n, mtime: i, mode: o, ...a } = {}) {
    e && (a = { ...a, ...e }),
        n && (a.hash = n),
        i != null && ((i = parseMtime$1(i)), (a.mtime = i.secs), (a.mtimeNsecs = i.nsecs)),
        o != null && (a.mode = modeToString$1(o)),
        a.timeout && !isNaN(a.timeout) && (a.timeout = `${a.timeout}ms`),
        t == null ? (t = []) : Array.isArray(t) || (t = [t])
    const l = new URLSearchParams(a)
    return t.forEach((c) => l.append("arg", c)), l
}
const createWantlist = configure((t) => {
        async function e(n = {}) {
            return (
                (await (await t.post("bitswap/wantlist", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json())
                    .Keys || []
            ).map((o) => CID.parse(o["/"]))
        }
        return e
    }),
    createWantlistForPeer = configure((t) => {
        async function e(n, i = {}) {
            return (
                (
                    await (
                        await t.post("bitswap/wantlist", {
                            signal: i.signal,
                            searchParams: toUrlSearchParams({ ...i, peer: n.toString() }),
                            headers: i.headers,
                        })
                    ).json()
                ).Keys || []
            ).map((a) => CID.parse(a["/"]))
        }
        return e
    }),
    symbol = Symbol.for("@libp2p/peer-id"),
    baseDecoder = Object.values(bases)
        .map((t) => t.decoder)
        .reduce((t, e) => t.or(e), bases.identity.decoder),
    LIBP2P_KEY_CODE = 114,
    MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36,
    MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37
class PeerIdImpl {
    constructor(e) {
        ;(this.type = e.type),
            (this.multihash = e.multihash),
            (this.privateKey = e.privateKey),
            Object.defineProperty(this, "string", { enumerable: !1, writable: !0 })
    }
    get [Symbol.toStringTag]() {
        return `PeerId(${this.toString()})`
    }
    get [symbol]() {
        return !0
    }
    toString() {
        return this.string == null && (this.string = base58btc.encode(this.multihash.bytes).slice(1)), this.string
    }
    toCID() {
        return CID.createV1(LIBP2P_KEY_CODE, this.multihash)
    }
    toBytes() {
        return this.multihash.bytes
    }
    toJSON() {
        return this.toString()
    }
    equals(e) {
        var n
        if (e instanceof Uint8Array) return equals(this.multihash.bytes, e)
        if (typeof e == "string") return peerIdFromString(e).equals(this)
        if (((n = e == null ? void 0 : e.multihash) == null ? void 0 : n.bytes) != null) return equals(this.multihash.bytes, e.multihash.bytes)
        throw new Error("not valid Id")
    }
}
class RSAPeerIdImpl extends PeerIdImpl {
    constructor(e) {
        super({ ...e, type: "RSA" }), (this.type = "RSA"), (this.publicKey = e.publicKey)
    }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
    constructor(e) {
        super({ ...e, type: "Ed25519" }), (this.type = "Ed25519"), (this.publicKey = e.multihash.digest)
    }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
    constructor(e) {
        super({ ...e, type: "secp256k1" }), (this.type = "secp256k1"), (this.publicKey = e.multihash.digest)
    }
}
function peerIdFromString(t, e) {
    if (t.charAt(0) === "1" || t.charAt(0) === "Q") {
        const n = decode$d(base58btc.decode(`z${t}`))
        return t.startsWith("12D")
            ? new Ed25519PeerIdImpl({ multihash: n })
            : t.startsWith("16U")
            ? new Secp256k1PeerIdImpl({ multihash: n })
            : new RSAPeerIdImpl({ multihash: n })
    }
    return peerIdFromBytes(baseDecoder.decode(t))
}
function peerIdFromBytes(t) {
    try {
        const e = decode$d(t)
        if (e.code === identity$1.code) {
            if (e.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) return new Ed25519PeerIdImpl({ multihash: e })
            if (e.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) return new Secp256k1PeerIdImpl({ multihash: e })
        }
        if (e.code === sha256.code) return new RSAPeerIdImpl({ multihash: e })
    } catch {
        return peerIdFromCID(CID.decode(t))
    }
    throw new Error("Supplied PeerID CID is invalid")
}
function peerIdFromCID(t) {
    if (t == null || t.multihash == null || t.version == null || (t.version === 1 && t.code !== LIBP2P_KEY_CODE))
        throw new Error("Supplied PeerID CID is invalid")
    const e = t.multihash
    if (e.code === sha256.code) return new RSAPeerIdImpl({ multihash: t.multihash })
    if (e.code === identity$1.code) {
        if (e.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) return new Ed25519PeerIdImpl({ multihash: t.multihash })
        if (e.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) return new Secp256k1PeerIdImpl({ multihash: t.multihash })
    }
    throw new Error("Supplied PeerID CID is invalid")
}
const createStat$4 = configure((t) => {
    async function e(n = {}) {
        const i = await t.post("bitswap/stat", { searchParams: toUrlSearchParams(n), signal: n.signal, headers: n.headers })
        return toCoreInterface$4(await i.json())
    }
    return e
})
function toCoreInterface$4(t) {
    return {
        provideBufLen: t.ProvideBufLen,
        wantlist: (t.Wantlist || []).map((e) => CID.parse(e["/"])),
        peers: (t.Peers || []).map((e) => peerIdFromString(e)),
        blocksReceived: BigInt(t.BlocksReceived),
        dataReceived: BigInt(t.DataReceived),
        blocksSent: BigInt(t.BlocksSent),
        dataSent: BigInt(t.DataSent),
        dupBlksReceived: BigInt(t.DupBlksReceived),
        dupDataReceived: BigInt(t.DupDataReceived),
    }
}
const createUnwant = configure((t) => {
    async function e(n, i = {}) {
        return (
            await t.post("bitswap/unwant", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n.toString(), ...i }),
                headers: i.headers,
            })
        ).json()
    }
    return e
})
function createBitswap(t) {
    return { wantlist: createWantlist(t), wantlistForPeer: createWantlistForPeer(t), unwant: createUnwant(t), stat: createStat$4(t) }
}
const createGet$5 = configure((t) => {
    async function e(n, i = {}) {
        const o = await t.post("block/get", {
            signal: i.signal,
            searchParams: toUrlSearchParams({ arg: n.toString(), ...i }),
            headers: i.headers,
        })
        return new Uint8Array(await o.arrayBuffer())
    }
    return e
})
function peekableIterator(t) {
    const [e, n] = t[Symbol.asyncIterator] ? [t[Symbol.asyncIterator](), Symbol.asyncIterator] : [t[Symbol.iterator](), Symbol.iterator],
        i = []
    return {
        peek: () => e.next(),
        push: (o) => {
            i.push(o)
        },
        next: () => (i.length ? { done: !1, value: i.shift() } : e.next()),
        [n]() {
            return this
        },
    }
}
var itPeekable = peekableIterator
async function* browserReadableStreamToIt$1(t, e = {}) {
    const n = t.getReader()
    try {
        for (;;) {
            const i = await n.read()
            if (i.done) return
            yield i.value
        }
    } finally {
        e.preventCancel !== !0 && n.cancel(), n.releaseLock()
    }
}
var browserReadablestreamToIt = browserReadableStreamToIt$1
const all = async (t) => {
    const e = []
    for await (const n of t) e.push(n)
    return e
}
var itAll = all
function isBytes(t) {
    return ArrayBuffer.isView(t) || t instanceof ArrayBuffer
}
function isBlob(t) {
    return t.constructor && (t.constructor.name === "Blob" || t.constructor.name === "File") && typeof t.stream == "function"
}
function isFileObject(t) {
    return typeof t == "object" && (t.path || t.content)
}
const isReadableStream = (t) => t && typeof t.getReader == "function"
async function normaliseContent$1(t) {
    if (isBytes(t)) return new Blob([t])
    if (typeof t == "string" || t instanceof String) return new Blob([t.toString()])
    if (isBlob(t)) return t
    if ((isReadableStream(t) && (t = browserReadablestreamToIt(t)), Symbol.iterator in t || Symbol.asyncIterator in t)) {
        const e = itPeekable(t),
            { value: n, done: i } = await e.peek()
        if (i) return itToBlob(e)
        if ((e.push(n), Number.isInteger(n))) return new Blob([Uint8Array.from(await itAll(e))])
        if (isBytes(n) || typeof n == "string" || n instanceof String) return itToBlob(e)
    }
    throw errCode(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT")
}
async function itToBlob(t) {
    const e = []
    for await (const n of t) e.push(n)
    return new Blob(e)
}
const map = async function* (t, e) {
    for await (const n of t) yield e(n)
}
var itMap = map,
    indexMinimal = {},
    minimal$1 = {},
    aspromise = asPromise
function asPromise(t, e) {
    for (var n = new Array(arguments.length - 1), i = 0, o = 2, a = !0; o < arguments.length; ) n[i++] = arguments[o++]
    return new Promise(function (c, g) {
        n[i] = function (_) {
            if (a)
                if (((a = !1), _)) g(_)
                else {
                    for (var A = new Array(arguments.length - 1), B = 0; B < A.length; ) A[B++] = arguments[B]
                    c.apply(null, A)
                }
        }
        try {
            t.apply(e || null, n)
        } catch (v) {
            a && ((a = !1), g(v))
        }
    })
}
var base64$1 = {}
;(function (t) {
    var e = t
    e.length = function (c) {
        var g = c.length
        if (!g) return 0
        for (var v = 0; --g % 4 > 1 && c.charAt(g) === "="; ) ++v
        return Math.ceil(c.length * 3) / 4 - v
    }
    for (var n = new Array(64), i = new Array(123), o = 0; o < 64; )
        i[(n[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : (o - 59) | 43)] = o++
    e.encode = function (c, g, v) {
        for (var _ = null, A = [], B = 0, D = 0, I; g < v; ) {
            var L = c[g++]
            switch (D) {
                case 0:
                    ;(A[B++] = n[L >> 2]), (I = (L & 3) << 4), (D = 1)
                    break
                case 1:
                    ;(A[B++] = n[I | (L >> 4)]), (I = (L & 15) << 2), (D = 2)
                    break
                case 2:
                    ;(A[B++] = n[I | (L >> 6)]), (A[B++] = n[L & 63]), (D = 0)
                    break
            }
            B > 8191 && ((_ || (_ = [])).push(String.fromCharCode.apply(String, A)), (B = 0))
        }
        return (
            D && ((A[B++] = n[I]), (A[B++] = 61), D === 1 && (A[B++] = 61)),
            _ ? (B && _.push(String.fromCharCode.apply(String, A.slice(0, B))), _.join("")) : String.fromCharCode.apply(String, A.slice(0, B))
        )
    }
    var a = "invalid encoding"
    ;(e.decode = function (c, g, v) {
        for (var _ = v, A = 0, B, D = 0; D < c.length; ) {
            var I = c.charCodeAt(D++)
            if (I === 61 && A > 1) break
            if ((I = i[I]) === void 0) throw Error(a)
            switch (A) {
                case 0:
                    ;(B = I), (A = 1)
                    break
                case 1:
                    ;(g[v++] = (B << 2) | ((I & 48) >> 4)), (B = I), (A = 2)
                    break
                case 2:
                    ;(g[v++] = ((B & 15) << 4) | ((I & 60) >> 2)), (B = I), (A = 3)
                    break
                case 3:
                    ;(g[v++] = ((B & 3) << 6) | I), (A = 0)
                    break
            }
        }
        if (A === 1) throw Error(a)
        return v - _
    }),
        (e.test = function (c) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c)
        })
})(base64$1)
var eventemitter = EventEmitter
function EventEmitter() {
    this._listeners = {}
}
EventEmitter.prototype.on = function (e, n, i) {
    return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: n, ctx: i || this }), this
}
EventEmitter.prototype.off = function (e, n) {
    if (e === void 0) this._listeners = {}
    else if (n === void 0) this._listeners[e] = []
    else for (var i = this._listeners[e], o = 0; o < i.length; ) i[o].fn === n ? i.splice(o, 1) : ++o
    return this
}
EventEmitter.prototype.emit = function (e) {
    var n = this._listeners[e]
    if (n) {
        for (var i = [], o = 1; o < arguments.length; ) i.push(arguments[o++])
        for (o = 0; o < n.length; ) n[o].fn.apply(n[o++].ctx, i)
    }
    return this
}
var float = factory(factory)
function factory(t) {
    return (
        typeof Float32Array != "undefined"
            ? (function () {
                  var e = new Float32Array([-0]),
                      n = new Uint8Array(e.buffer),
                      i = n[3] === 128
                  function o(g, v, _) {
                      ;(e[0] = g), (v[_] = n[0]), (v[_ + 1] = n[1]), (v[_ + 2] = n[2]), (v[_ + 3] = n[3])
                  }
                  function a(g, v, _) {
                      ;(e[0] = g), (v[_] = n[3]), (v[_ + 1] = n[2]), (v[_ + 2] = n[1]), (v[_ + 3] = n[0])
                  }
                  ;(t.writeFloatLE = i ? o : a), (t.writeFloatBE = i ? a : o)
                  function l(g, v) {
                      return (n[0] = g[v]), (n[1] = g[v + 1]), (n[2] = g[v + 2]), (n[3] = g[v + 3]), e[0]
                  }
                  function c(g, v) {
                      return (n[3] = g[v]), (n[2] = g[v + 1]), (n[1] = g[v + 2]), (n[0] = g[v + 3]), e[0]
                  }
                  ;(t.readFloatLE = i ? l : c), (t.readFloatBE = i ? c : l)
              })()
            : (function () {
                  function e(i, o, a, l) {
                      var c = o < 0 ? 1 : 0
                      if ((c && (o = -o), o === 0)) i(1 / o > 0 ? 0 : 2147483648, a, l)
                      else if (isNaN(o)) i(2143289344, a, l)
                      else if (o > 34028234663852886e22) i(((c << 31) | 2139095040) >>> 0, a, l)
                      else if (o < 11754943508222875e-54) i(((c << 31) | Math.round(o / 1401298464324817e-60)) >>> 0, a, l)
                      else {
                          var g = Math.floor(Math.log(o) / Math.LN2),
                              v = Math.round(o * Math.pow(2, -g) * 8388608) & 8388607
                          i(((c << 31) | ((g + 127) << 23) | v) >>> 0, a, l)
                      }
                  }
                  ;(t.writeFloatLE = e.bind(null, writeUintLE)), (t.writeFloatBE = e.bind(null, writeUintBE))
                  function n(i, o, a) {
                      var l = i(o, a),
                          c = (l >> 31) * 2 + 1,
                          g = (l >>> 23) & 255,
                          v = l & 8388607
                      return g === 255
                          ? v
                              ? NaN
                              : c * (1 / 0)
                          : g === 0
                          ? c * 1401298464324817e-60 * v
                          : c * Math.pow(2, g - 150) * (v + 8388608)
                  }
                  ;(t.readFloatLE = n.bind(null, readUintLE)), (t.readFloatBE = n.bind(null, readUintBE))
              })(),
        typeof Float64Array != "undefined"
            ? (function () {
                  var e = new Float64Array([-0]),
                      n = new Uint8Array(e.buffer),
                      i = n[7] === 128
                  function o(g, v, _) {
                      ;(e[0] = g),
                          (v[_] = n[0]),
                          (v[_ + 1] = n[1]),
                          (v[_ + 2] = n[2]),
                          (v[_ + 3] = n[3]),
                          (v[_ + 4] = n[4]),
                          (v[_ + 5] = n[5]),
                          (v[_ + 6] = n[6]),
                          (v[_ + 7] = n[7])
                  }
                  function a(g, v, _) {
                      ;(e[0] = g),
                          (v[_] = n[7]),
                          (v[_ + 1] = n[6]),
                          (v[_ + 2] = n[5]),
                          (v[_ + 3] = n[4]),
                          (v[_ + 4] = n[3]),
                          (v[_ + 5] = n[2]),
                          (v[_ + 6] = n[1]),
                          (v[_ + 7] = n[0])
                  }
                  ;(t.writeDoubleLE = i ? o : a), (t.writeDoubleBE = i ? a : o)
                  function l(g, v) {
                      return (
                          (n[0] = g[v]),
                          (n[1] = g[v + 1]),
                          (n[2] = g[v + 2]),
                          (n[3] = g[v + 3]),
                          (n[4] = g[v + 4]),
                          (n[5] = g[v + 5]),
                          (n[6] = g[v + 6]),
                          (n[7] = g[v + 7]),
                          e[0]
                      )
                  }
                  function c(g, v) {
                      return (
                          (n[7] = g[v]),
                          (n[6] = g[v + 1]),
                          (n[5] = g[v + 2]),
                          (n[4] = g[v + 3]),
                          (n[3] = g[v + 4]),
                          (n[2] = g[v + 5]),
                          (n[1] = g[v + 6]),
                          (n[0] = g[v + 7]),
                          e[0]
                      )
                  }
                  ;(t.readDoubleLE = i ? l : c), (t.readDoubleBE = i ? c : l)
              })()
            : (function () {
                  function e(i, o, a, l, c, g) {
                      var v = l < 0 ? 1 : 0
                      if ((v && (l = -l), l === 0)) i(0, c, g + o), i(1 / l > 0 ? 0 : 2147483648, c, g + a)
                      else if (isNaN(l)) i(0, c, g + o), i(2146959360, c, g + a)
                      else if (l > 17976931348623157e292) i(0, c, g + o), i(((v << 31) | 2146435072) >>> 0, c, g + a)
                      else {
                          var _
                          if (l < 22250738585072014e-324)
                              (_ = l / 5e-324), i(_ >>> 0, c, g + o), i(((v << 31) | (_ / 4294967296)) >>> 0, c, g + a)
                          else {
                              var A = Math.floor(Math.log(l) / Math.LN2)
                              A === 1024 && (A = 1023),
                                  (_ = l * Math.pow(2, -A)),
                                  i((_ * 4503599627370496) >>> 0, c, g + o),
                                  i(((v << 31) | ((A + 1023) << 20) | ((_ * 1048576) & 1048575)) >>> 0, c, g + a)
                          }
                      }
                  }
                  ;(t.writeDoubleLE = e.bind(null, writeUintLE, 0, 4)), (t.writeDoubleBE = e.bind(null, writeUintBE, 4, 0))
                  function n(i, o, a, l, c) {
                      var g = i(l, c + o),
                          v = i(l, c + a),
                          _ = (v >> 31) * 2 + 1,
                          A = (v >>> 20) & 2047,
                          B = 4294967296 * (v & 1048575) + g
                      return A === 2047 ? (B ? NaN : _ * (1 / 0)) : A === 0 ? _ * 5e-324 * B : _ * Math.pow(2, A - 1075) * (B + 4503599627370496)
                  }
                  ;(t.readDoubleLE = n.bind(null, readUintLE, 0, 4)), (t.readDoubleBE = n.bind(null, readUintBE, 4, 0))
              })(),
        t
    )
}
function writeUintLE(t, e, n) {
    ;(e[n] = t & 255), (e[n + 1] = (t >>> 8) & 255), (e[n + 2] = (t >>> 16) & 255), (e[n + 3] = t >>> 24)
}
function writeUintBE(t, e, n) {
    ;(e[n] = t >>> 24), (e[n + 1] = (t >>> 16) & 255), (e[n + 2] = (t >>> 8) & 255), (e[n + 3] = t & 255)
}
function readUintLE(t, e) {
    return (t[e] | (t[e + 1] << 8) | (t[e + 2] << 16) | (t[e + 3] << 24)) >>> 0
}
function readUintBE(t, e) {
    return ((t[e] << 24) | (t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3]) >>> 0
}
var inquire_1 = inquire
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName)
        if (mod && (mod.length || Object.keys(mod).length)) return mod
    } catch (t) {}
    return null
}
var utf8$2 = {}
;(function (t) {
    var e = t
    ;(e.length = function (i) {
        for (var o = 0, a = 0, l = 0; l < i.length; ++l)
            (a = i.charCodeAt(l)),
                a < 128
                    ? (o += 1)
                    : a < 2048
                    ? (o += 2)
                    : (a & 64512) === 55296 && (i.charCodeAt(l + 1) & 64512) === 56320
                    ? (++l, (o += 4))
                    : (o += 3)
        return o
    }),
        (e.read = function (i, o, a) {
            var l = a - o
            if (l < 1) return ""
            for (var c = null, g = [], v = 0, _; o < a; )
                (_ = i[o++]),
                    _ < 128
                        ? (g[v++] = _)
                        : _ > 191 && _ < 224
                        ? (g[v++] = ((_ & 31) << 6) | (i[o++] & 63))
                        : _ > 239 && _ < 365
                        ? ((_ = (((_ & 7) << 18) | ((i[o++] & 63) << 12) | ((i[o++] & 63) << 6) | (i[o++] & 63)) - 65536),
                          (g[v++] = 55296 + (_ >> 10)),
                          (g[v++] = 56320 + (_ & 1023)))
                        : (g[v++] = ((_ & 15) << 12) | ((i[o++] & 63) << 6) | (i[o++] & 63)),
                    v > 8191 && ((c || (c = [])).push(String.fromCharCode.apply(String, g)), (v = 0))
            return c
                ? (v && c.push(String.fromCharCode.apply(String, g.slice(0, v))), c.join(""))
                : String.fromCharCode.apply(String, g.slice(0, v))
        }),
        (e.write = function (i, o, a) {
            for (var l = a, c, g, v = 0; v < i.length; ++v)
                (c = i.charCodeAt(v)),
                    c < 128
                        ? (o[a++] = c)
                        : c < 2048
                        ? ((o[a++] = (c >> 6) | 192), (o[a++] = (c & 63) | 128))
                        : (c & 64512) === 55296 && ((g = i.charCodeAt(v + 1)) & 64512) === 56320
                        ? ((c = 65536 + ((c & 1023) << 10) + (g & 1023)),
                          ++v,
                          (o[a++] = (c >> 18) | 240),
                          (o[a++] = ((c >> 12) & 63) | 128),
                          (o[a++] = ((c >> 6) & 63) | 128),
                          (o[a++] = (c & 63) | 128))
                        : ((o[a++] = (c >> 12) | 224), (o[a++] = ((c >> 6) & 63) | 128), (o[a++] = (c & 63) | 128))
            return a - l
        })
})(utf8$2)
var pool_1 = pool
function pool(t, e, n) {
    var i = n || 8192,
        o = i >>> 1,
        a = null,
        l = i
    return function (g) {
        if (g < 1 || g > o) return t(g)
        l + g > i && ((a = t(i)), (l = 0))
        var v = e.call(a, l, (l += g))
        return l & 7 && (l = (l | 7) + 1), v
    }
}
var longbits = LongBits$2,
    util$5 = minimal$1
function LongBits$2(t, e) {
    ;(this.lo = t >>> 0), (this.hi = e >>> 0)
}
var zero = (LongBits$2.zero = new LongBits$2(0, 0))
zero.toNumber = function () {
    return 0
}
zero.zzEncode = zero.zzDecode = function () {
    return this
}
zero.length = function () {
    return 1
}
var zeroHash = (LongBits$2.zeroHash = "\0\0\0\0\0\0\0\0")
LongBits$2.fromNumber = function t(e) {
    if (e === 0) return zero
    var n = e < 0
    n && (e = -e)
    var i = e >>> 0,
        o = ((e - i) / 4294967296) >>> 0
    return n && ((o = ~o >>> 0), (i = ~i >>> 0), ++i > 4294967295 && ((i = 0), ++o > 4294967295 && (o = 0))), new LongBits$2(i, o)
}
LongBits$2.from = function t(e) {
    if (typeof e == "number") return LongBits$2.fromNumber(e)
    if (util$5.isString(e))
        if (util$5.Long) e = util$5.Long.fromString(e)
        else return LongBits$2.fromNumber(parseInt(e, 10))
    return e.low || e.high ? new LongBits$2(e.low >>> 0, e.high >>> 0) : zero
}
LongBits$2.prototype.toNumber = function t(e) {
    if (!e && this.hi >>> 31) {
        var n = (~this.lo + 1) >>> 0,
            i = ~this.hi >>> 0
        return n || (i = (i + 1) >>> 0), -(n + i * 4294967296)
    }
    return this.lo + this.hi * 4294967296
}
LongBits$2.prototype.toLong = function t(e) {
    return util$5.Long ? new util$5.Long(this.lo | 0, this.hi | 0, Boolean(e)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(e) }
}
var charCodeAt = String.prototype.charCodeAt
LongBits$2.fromHash = function t(e) {
    return e === zeroHash
        ? zero
        : new LongBits$2(
              (charCodeAt.call(e, 0) | (charCodeAt.call(e, 1) << 8) | (charCodeAt.call(e, 2) << 16) | (charCodeAt.call(e, 3) << 24)) >>> 0,
              (charCodeAt.call(e, 4) | (charCodeAt.call(e, 5) << 8) | (charCodeAt.call(e, 6) << 16) | (charCodeAt.call(e, 7) << 24)) >>> 0
          )
}
LongBits$2.prototype.toHash = function t() {
    return String.fromCharCode(
        this.lo & 255,
        (this.lo >>> 8) & 255,
        (this.lo >>> 16) & 255,
        this.lo >>> 24,
        this.hi & 255,
        (this.hi >>> 8) & 255,
        (this.hi >>> 16) & 255,
        this.hi >>> 24
    )
}
LongBits$2.prototype.zzEncode = function t() {
    var e = this.hi >> 31
    return (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ e) >>> 0), (this.lo = ((this.lo << 1) ^ e) >>> 0), this
}
LongBits$2.prototype.zzDecode = function t() {
    var e = -(this.lo & 1)
    return (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ e) >>> 0), (this.hi = ((this.hi >>> 1) ^ e) >>> 0), this
}
LongBits$2.prototype.length = function t() {
    var e = this.lo,
        n = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
        i = this.hi >>> 24
    return i === 0
        ? n === 0
            ? e < 16384
                ? e < 128
                    ? 1
                    : 2
                : e < 2097152
                ? 3
                : 4
            : n < 16384
            ? n < 128
                ? 5
                : 6
            : n < 2097152
            ? 7
            : 8
        : i < 128
        ? 9
        : 10
}
;(function (t) {
    var e = t
    ;(e.asPromise = aspromise),
        (e.base64 = base64$1),
        (e.EventEmitter = eventemitter),
        (e.float = float),
        (e.inquire = inquire_1),
        (e.utf8 = utf8$2),
        (e.pool = pool_1),
        (e.LongBits = longbits),
        (e.isNode = Boolean(
            typeof commonjsGlobal != "undefined" &&
                commonjsGlobal &&
                commonjsGlobal.process &&
                commonjsGlobal.process.versions &&
                commonjsGlobal.process.versions.node
        )),
        (e.global =
            (e.isNode && commonjsGlobal) || (typeof window != "undefined" && window) || (typeof self != "undefined" && self) || commonjsGlobal),
        (e.emptyArray = Object.freeze ? Object.freeze([]) : []),
        (e.emptyObject = Object.freeze ? Object.freeze({}) : {}),
        (e.isInteger =
            Number.isInteger ||
            function (a) {
                return typeof a == "number" && isFinite(a) && Math.floor(a) === a
            }),
        (e.isString = function (a) {
            return typeof a == "string" || a instanceof String
        }),
        (e.isObject = function (a) {
            return a && typeof a == "object"
        }),
        (e.isset = e.isSet =
            function (a, l) {
                var c = a[l]
                return c != null && a.hasOwnProperty(l) ? typeof c != "object" || (Array.isArray(c) ? c.length : Object.keys(c).length) > 0 : !1
            }),
        (e.Buffer = (function () {
            try {
                var o = e.inquire("buffer").Buffer
                return o.prototype.utf8Write ? o : null
            } catch {
                return null
            }
        })()),
        (e._Buffer_from = null),
        (e._Buffer_allocUnsafe = null),
        (e.newBuffer = function (a) {
            return typeof a == "number"
                ? e.Buffer
                    ? e._Buffer_allocUnsafe(a)
                    : new e.Array(a)
                : e.Buffer
                ? e._Buffer_from(a)
                : typeof Uint8Array == "undefined"
                ? a
                : new Uint8Array(a)
        }),
        (e.Array = typeof Uint8Array != "undefined" ? Uint8Array : Array),
        (e.Long = (e.global.dcodeIO && e.global.dcodeIO.Long) || e.global.Long || e.inquire("long")),
        (e.key2Re = /^true|false|0|1$/),
        (e.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
        (e.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
        (e.longToHash = function (a) {
            return a ? e.LongBits.from(a).toHash() : e.LongBits.zeroHash
        }),
        (e.longFromHash = function (a, l) {
            var c = e.LongBits.fromHash(a)
            return e.Long ? e.Long.fromBits(c.lo, c.hi, l) : c.toNumber(Boolean(l))
        })
    function n(o, a, l) {
        for (var c = Object.keys(a), g = 0; g < c.length; ++g) (o[c[g]] === void 0 || !l) && (o[c[g]] = a[c[g]])
        return o
    }
    ;(e.merge = n),
        (e.lcFirst = function (a) {
            return a.charAt(0).toLowerCase() + a.substring(1)
        })
    function i(o) {
        function a(l, c) {
            if (!(this instanceof a)) return new a(l, c)
            Object.defineProperty(this, "message", {
                get: function () {
                    return l
                },
            }),
                Error.captureStackTrace
                    ? Error.captureStackTrace(this, a)
                    : Object.defineProperty(this, "stack", { value: new Error().stack || "" }),
                c && n(this, c)
        }
        return (
            (a.prototype = Object.create(Error.prototype, {
                constructor: { value: a, writable: !0, enumerable: !1, configurable: !0 },
                name: {
                    get() {
                        return o
                    },
                    set: void 0,
                    enumerable: !1,
                    configurable: !0,
                },
                toString: {
                    value() {
                        return this.name + ": " + this.message
                    },
                    writable: !0,
                    enumerable: !1,
                    configurable: !0,
                },
            })),
            a
        )
    }
    ;(e.newError = i),
        (e.ProtocolError = i("ProtocolError")),
        (e.oneOfGetter = function (a) {
            for (var l = {}, c = 0; c < a.length; ++c) l[a[c]] = 1
            return function () {
                for (var g = Object.keys(this), v = g.length - 1; v > -1; --v)
                    if (l[g[v]] === 1 && this[g[v]] !== void 0 && this[g[v]] !== null) return g[v]
            }
        }),
        (e.oneOfSetter = function (a) {
            return function (l) {
                for (var c = 0; c < a.length; ++c) a[c] !== l && delete this[a[c]]
            }
        }),
        (e.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }),
        (e._configure = function () {
            var o = e.Buffer
            if (!o) {
                e._Buffer_from = e._Buffer_allocUnsafe = null
                return
            }
            ;(e._Buffer_from =
                (o.from !== Uint8Array.from && o.from) ||
                function (l, c) {
                    return new o(l, c)
                }),
                (e._Buffer_allocUnsafe =
                    o.allocUnsafe ||
                    function (l) {
                        return new o(l)
                    })
        })
})(minimal$1)
var writer = Writer$1,
    util$4 = minimal$1,
    BufferWriter$1,
    LongBits$1 = util$4.LongBits,
    base64 = util$4.base64,
    utf8$1 = util$4.utf8
function Op(t, e, n) {
    ;(this.fn = t), (this.len = e), (this.next = void 0), (this.val = n)
}
function noop() {}
function State(t) {
    ;(this.head = t.head), (this.tail = t.tail), (this.len = t.len), (this.next = t.states)
}
function Writer$1() {
    ;(this.len = 0), (this.head = new Op(noop, 0, 0)), (this.tail = this.head), (this.states = null)
}
var create$2 = function t() {
    return util$4.Buffer
        ? function () {
              return (Writer$1.create = function () {
                  return new BufferWriter$1()
              })()
          }
        : function () {
              return new Writer$1()
          }
}
Writer$1.create = create$2()
Writer$1.alloc = function t(e) {
    return new util$4.Array(e)
}
util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray))
Writer$1.prototype._push = function t(e, n, i) {
    return (this.tail = this.tail.next = new Op(e, n, i)), (this.len += n), this
}
function writeByte(t, e, n) {
    e[n] = t & 255
}
function writeVarint32(t, e, n) {
    for (; t > 127; ) (e[n++] = (t & 127) | 128), (t >>>= 7)
    e[n] = t
}
function VarintOp(t, e) {
    ;(this.len = t), (this.next = void 0), (this.val = e)
}
VarintOp.prototype = Object.create(Op.prototype)
VarintOp.prototype.fn = writeVarint32
Writer$1.prototype.uint32 = function t(e) {
    return (
        (this.len += (this.tail = this.tail.next =
            new VarintOp((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len),
        this
    )
}
Writer$1.prototype.int32 = function t(e) {
    return e < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(e)) : this.uint32(e)
}
Writer$1.prototype.sint32 = function t(e) {
    return this.uint32(((e << 1) ^ (e >> 31)) >>> 0)
}
function writeVarint64(t, e, n) {
    for (; t.hi; ) (e[n++] = (t.lo & 127) | 128), (t.lo = ((t.lo >>> 7) | (t.hi << 25)) >>> 0), (t.hi >>>= 7)
    for (; t.lo > 127; ) (e[n++] = (t.lo & 127) | 128), (t.lo = t.lo >>> 7)
    e[n++] = t.lo
}
Writer$1.prototype.uint64 = function t(e) {
    var n = LongBits$1.from(e)
    return this._push(writeVarint64, n.length(), n)
}
Writer$1.prototype.int64 = Writer$1.prototype.uint64
Writer$1.prototype.sint64 = function t(e) {
    var n = LongBits$1.from(e).zzEncode()
    return this._push(writeVarint64, n.length(), n)
}
Writer$1.prototype.bool = function t(e) {
    return this._push(writeByte, 1, e ? 1 : 0)
}
function writeFixed32(t, e, n) {
    ;(e[n] = t & 255), (e[n + 1] = (t >>> 8) & 255), (e[n + 2] = (t >>> 16) & 255), (e[n + 3] = t >>> 24)
}
Writer$1.prototype.fixed32 = function t(e) {
    return this._push(writeFixed32, 4, e >>> 0)
}
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32
Writer$1.prototype.fixed64 = function t(e) {
    var n = LongBits$1.from(e)
    return this._push(writeFixed32, 4, n.lo)._push(writeFixed32, 4, n.hi)
}
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64
Writer$1.prototype.float = function t(e) {
    return this._push(util$4.float.writeFloatLE, 4, e)
}
Writer$1.prototype.double = function t(e) {
    return this._push(util$4.float.writeDoubleLE, 8, e)
}
var writeBytes = util$4.Array.prototype.set
    ? function t(e, n, i) {
          n.set(e, i)
      }
    : function t(e, n, i) {
          for (var o = 0; o < e.length; ++o) n[i + o] = e[o]
      }
Writer$1.prototype.bytes = function t(e) {
    var n = e.length >>> 0
    if (!n) return this._push(writeByte, 1, 0)
    if (util$4.isString(e)) {
        var i = Writer$1.alloc((n = base64.length(e)))
        base64.decode(e, i, 0), (e = i)
    }
    return this.uint32(n)._push(writeBytes, n, e)
}
Writer$1.prototype.string = function t(e) {
    var n = utf8$1.length(e)
    return n ? this.uint32(n)._push(utf8$1.write, n, e) : this._push(writeByte, 1, 0)
}
Writer$1.prototype.fork = function t() {
    return (this.states = new State(this)), (this.head = this.tail = new Op(noop, 0, 0)), (this.len = 0), this
}
Writer$1.prototype.reset = function t() {
    return (
        this.states
            ? ((this.head = this.states.head), (this.tail = this.states.tail), (this.len = this.states.len), (this.states = this.states.next))
            : ((this.head = this.tail = new Op(noop, 0, 0)), (this.len = 0)),
        this
    )
}
Writer$1.prototype.ldelim = function t() {
    var e = this.head,
        n = this.tail,
        i = this.len
    return this.reset().uint32(i), i && ((this.tail.next = e.next), (this.tail = n), (this.len += i)), this
}
Writer$1.prototype.finish = function t() {
    for (var e = this.head.next, n = this.constructor.alloc(this.len), i = 0; e; ) e.fn(e.val, n, i), (i += e.len), (e = e.next)
    return n
}
Writer$1._configure = function (t) {
    ;(BufferWriter$1 = t), (Writer$1.create = create$2()), BufferWriter$1._configure()
}
var writer_buffer = BufferWriter,
    Writer = writer
;(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter
var util$3 = minimal$1
function BufferWriter() {
    Writer.call(this)
}
BufferWriter._configure = function () {
    ;(BufferWriter.alloc = util$3._Buffer_allocUnsafe),
        (BufferWriter.writeBytesBuffer =
            util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set"
                ? function (e, n, i) {
                      n.set(e, i)
                  }
                : function (e, n, i) {
                      if (e.copy) e.copy(n, i, 0, e.length)
                      else for (var o = 0; o < e.length; ) n[i++] = e[o++]
                  })
}
BufferWriter.prototype.bytes = function t(e) {
    util$3.isString(e) && (e = util$3._Buffer_from(e, "base64"))
    var n = e.length >>> 0
    return this.uint32(n), n && this._push(BufferWriter.writeBytesBuffer, n, e), this
}
function writeStringBuffer(t, e, n) {
    t.length < 40 ? util$3.utf8.write(t, e, n) : e.utf8Write ? e.utf8Write(t, n) : e.write(t, n)
}
BufferWriter.prototype.string = function t(e) {
    var n = util$3.Buffer.byteLength(e)
    return this.uint32(n), n && this._push(writeStringBuffer, n, e), this
}
BufferWriter._configure()
var reader = Reader$1,
    util$2 = minimal$1,
    BufferReader$1,
    LongBits = util$2.LongBits,
    utf8 = util$2.utf8
function indexOutOfRange(t, e) {
    return RangeError("index out of range: " + t.pos + " + " + (e || 1) + " > " + t.len)
}
function Reader$1(t) {
    ;(this.buf = t), (this.pos = 0), (this.len = t.length)
}
var create_array =
        typeof Uint8Array != "undefined"
            ? function t(e) {
                  if (e instanceof Uint8Array || Array.isArray(e)) return new Reader$1(e)
                  throw Error("illegal buffer")
              }
            : function t(e) {
                  if (Array.isArray(e)) return new Reader$1(e)
                  throw Error("illegal buffer")
              },
    create$1 = function t() {
        return util$2.Buffer
            ? function (n) {
                  return (Reader$1.create = function (o) {
                      return util$2.Buffer.isBuffer(o) ? new BufferReader$1(o) : create_array(o)
                  })(n)
              }
            : create_array
    }
Reader$1.create = create$1()
Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice
Reader$1.prototype.uint32 = (function t() {
    var e = 4294967295
    return function () {
        if (
            ((e = (this.buf[this.pos] & 127) >>> 0),
            this.buf[this.pos++] < 128 ||
                ((e = (e | ((this.buf[this.pos] & 127) << 7)) >>> 0), this.buf[this.pos++] < 128) ||
                ((e = (e | ((this.buf[this.pos] & 127) << 14)) >>> 0), this.buf[this.pos++] < 128) ||
                ((e = (e | ((this.buf[this.pos] & 127) << 21)) >>> 0), this.buf[this.pos++] < 128) ||
                ((e = (e | ((this.buf[this.pos] & 15) << 28)) >>> 0), this.buf[this.pos++] < 128))
        )
            return e
        if ((this.pos += 5) > this.len) throw ((this.pos = this.len), indexOutOfRange(this, 10))
        return e
    }
})()
Reader$1.prototype.int32 = function t() {
    return this.uint32() | 0
}
Reader$1.prototype.sint32 = function t() {
    var e = this.uint32()
    return ((e >>> 1) ^ -(e & 1)) | 0
}
function readLongVarint() {
    var t = new LongBits(0, 0),
        e = 0
    if (this.len - this.pos > 4) {
        for (; e < 4; ++e) if (((t.lo = (t.lo | ((this.buf[this.pos] & 127) << (e * 7))) >>> 0), this.buf[this.pos++] < 128)) return t
        if (
            ((t.lo = (t.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0),
            (t.hi = (t.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0),
            this.buf[this.pos++] < 128)
        )
            return t
        e = 0
    } else {
        for (; e < 3; ++e) {
            if (this.pos >= this.len) throw indexOutOfRange(this)
            if (((t.lo = (t.lo | ((this.buf[this.pos] & 127) << (e * 7))) >>> 0), this.buf[this.pos++] < 128)) return t
        }
        return (t.lo = (t.lo | ((this.buf[this.pos++] & 127) << (e * 7))) >>> 0), t
    }
    if (this.len - this.pos > 4) {
        for (; e < 5; ++e) if (((t.hi = (t.hi | ((this.buf[this.pos] & 127) << (e * 7 + 3))) >>> 0), this.buf[this.pos++] < 128)) return t
    } else
        for (; e < 5; ++e) {
            if (this.pos >= this.len) throw indexOutOfRange(this)
            if (((t.hi = (t.hi | ((this.buf[this.pos] & 127) << (e * 7 + 3))) >>> 0), this.buf[this.pos++] < 128)) return t
        }
    throw Error("invalid varint encoding")
}
Reader$1.prototype.bool = function t() {
    return this.uint32() !== 0
}
function readFixed32_end(t, e) {
    return (t[e - 4] | (t[e - 3] << 8) | (t[e - 2] << 16) | (t[e - 1] << 24)) >>> 0
}
Reader$1.prototype.fixed32 = function t() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)
    return readFixed32_end(this.buf, (this.pos += 4))
}
Reader$1.prototype.sfixed32 = function t() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)
    return readFixed32_end(this.buf, (this.pos += 4)) | 0
}
function readFixed64() {
    if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8)
    return new LongBits(readFixed32_end(this.buf, (this.pos += 4)), readFixed32_end(this.buf, (this.pos += 4)))
}
Reader$1.prototype.float = function t() {
    if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4)
    var e = util$2.float.readFloatLE(this.buf, this.pos)
    return (this.pos += 4), e
}
Reader$1.prototype.double = function t() {
    if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4)
    var e = util$2.float.readDoubleLE(this.buf, this.pos)
    return (this.pos += 8), e
}
Reader$1.prototype.bytes = function t() {
    var e = this.uint32(),
        n = this.pos,
        i = this.pos + e
    if (i > this.len) throw indexOutOfRange(this, e)
    return (
        (this.pos += e),
        Array.isArray(this.buf) ? this.buf.slice(n, i) : n === i ? new this.buf.constructor(0) : this._slice.call(this.buf, n, i)
    )
}
Reader$1.prototype.string = function t() {
    var e = this.bytes()
    return utf8.read(e, 0, e.length)
}
Reader$1.prototype.skip = function t(e) {
    if (typeof e == "number") {
        if (this.pos + e > this.len) throw indexOutOfRange(this, e)
        this.pos += e
    } else
        do if (this.pos >= this.len) throw indexOutOfRange(this)
        while (this.buf[this.pos++] & 128)
    return this
}
Reader$1.prototype.skipType = function (t) {
    switch (t) {
        case 0:
            this.skip()
            break
        case 1:
            this.skip(8)
            break
        case 2:
            this.skip(this.uint32())
            break
        case 3:
            for (; (t = this.uint32() & 7) !== 4; ) this.skipType(t)
            break
        case 5:
            this.skip(4)
            break
        default:
            throw Error("invalid wire type " + t + " at offset " + this.pos)
    }
    return this
}
Reader$1._configure = function (t) {
    ;(BufferReader$1 = t), (Reader$1.create = create$1()), BufferReader$1._configure()
    var e = util$2.Long ? "toLong" : "toNumber"
    util$2.merge(Reader$1.prototype, {
        int64: function () {
            return readLongVarint.call(this)[e](!1)
        },
        uint64: function () {
            return readLongVarint.call(this)[e](!0)
        },
        sint64: function () {
            return readLongVarint.call(this).zzDecode()[e](!1)
        },
        fixed64: function () {
            return readFixed64.call(this)[e](!0)
        },
        sfixed64: function () {
            return readFixed64.call(this)[e](!1)
        },
    })
}
var reader_buffer = BufferReader,
    Reader = reader
;(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader
var util$1 = minimal$1
function BufferReader(t) {
    Reader.call(this, t)
}
BufferReader._configure = function () {
    util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice)
}
BufferReader.prototype.string = function t() {
    var e = this.uint32()
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, (this.pos = Math.min(this.pos + e, this.len)))
        : this.buf.toString("utf-8", this.pos, (this.pos = Math.min(this.pos + e, this.len)))
}
BufferReader._configure()
var rpc = {},
    service = Service,
    util = minimal$1
;(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service
function Service(t, e, n) {
    if (typeof t != "function") throw TypeError("rpcImpl must be a function")
    util.EventEmitter.call(this), (this.rpcImpl = t), (this.requestDelimited = Boolean(e)), (this.responseDelimited = Boolean(n))
}
Service.prototype.rpcCall = function t(e, n, i, o, a) {
    if (!o) throw TypeError("request must be specified")
    var l = this
    if (!a) return util.asPromise(t, l, e, n, i, o)
    if (!l.rpcImpl) {
        setTimeout(function () {
            a(Error("already ended"))
        }, 0)
        return
    }
    try {
        return l.rpcImpl(e, n[l.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function (g, v) {
            if (g) return l.emit("error", g, e), a(g)
            if (v === null) {
                l.end(!0)
                return
            }
            if (!(v instanceof i))
                try {
                    v = i[l.responseDelimited ? "decodeDelimited" : "decode"](v)
                } catch (_) {
                    return l.emit("error", _, e), a(_)
                }
            return l.emit("data", v, e), a(null, v)
        })
    } catch (c) {
        l.emit("error", c, e),
            setTimeout(function () {
                a(c)
            }, 0)
        return
    }
}
Service.prototype.end = function t(e) {
    return this.rpcImpl && (e || this.rpcImpl(null, null, null), (this.rpcImpl = null), this.emit("end").off()), this
}
;(function (t) {
    var e = t
    e.Service = service
})(rpc)
var roots = {}
;(function (t) {
    var e = t
    ;(e.build = "minimal"),
        (e.Writer = writer),
        (e.BufferWriter = writer_buffer),
        (e.Reader = reader),
        (e.BufferReader = reader_buffer),
        (e.util = minimal$1),
        (e.rpc = rpc),
        (e.roots = roots),
        (e.configure = n)
    function n() {
        e.util._configure(), e.Writer._configure(e.BufferWriter), e.Reader._configure(e.BufferReader)
    }
    n()
})(indexMinimal)
var minimal = indexMinimal
const $Reader = minimal.Reader,
    $Writer = minimal.Writer,
    $util = minimal.util,
    $root = minimal.roots["ipfs-unixfs"] || (minimal.roots["ipfs-unixfs"] = {})
$root.Data = (() => {
    function t(e) {
        if (((this.blocksizes = []), e)) for (var n = Object.keys(e), i = 0; i < n.length; ++i) e[n[i]] != null && (this[n[i]] = e[n[i]])
    }
    return (
        (t.prototype.Type = 0),
        (t.prototype.Data = $util.newBuffer([])),
        (t.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0),
        (t.prototype.blocksizes = $util.emptyArray),
        (t.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0),
        (t.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0),
        (t.prototype.mode = 0),
        (t.prototype.mtime = null),
        (t.encode = function (n, i) {
            if (
                (i || (i = $Writer.create()),
                i.uint32(8).int32(n.Type),
                n.Data != null && Object.hasOwnProperty.call(n, "Data") && i.uint32(18).bytes(n.Data),
                n.filesize != null && Object.hasOwnProperty.call(n, "filesize") && i.uint32(24).uint64(n.filesize),
                n.blocksizes != null && n.blocksizes.length)
            )
                for (var o = 0; o < n.blocksizes.length; ++o) i.uint32(32).uint64(n.blocksizes[o])
            return (
                n.hashType != null && Object.hasOwnProperty.call(n, "hashType") && i.uint32(40).uint64(n.hashType),
                n.fanout != null && Object.hasOwnProperty.call(n, "fanout") && i.uint32(48).uint64(n.fanout),
                n.mode != null && Object.hasOwnProperty.call(n, "mode") && i.uint32(56).uint32(n.mode),
                n.mtime != null && Object.hasOwnProperty.call(n, "mtime") && $root.UnixTime.encode(n.mtime, i.uint32(66).fork()).ldelim(),
                i
            )
        }),
        (t.decode = function (n, i) {
            n instanceof $Reader || (n = $Reader.create(n))
            for (var o = i === void 0 ? n.len : n.pos + i, a = new $root.Data(); n.pos < o; ) {
                var l = n.uint32()
                switch (l >>> 3) {
                    case 1:
                        a.Type = n.int32()
                        break
                    case 2:
                        a.Data = n.bytes()
                        break
                    case 3:
                        a.filesize = n.uint64()
                        break
                    case 4:
                        if (((a.blocksizes && a.blocksizes.length) || (a.blocksizes = []), (l & 7) === 2))
                            for (var c = n.uint32() + n.pos; n.pos < c; ) a.blocksizes.push(n.uint64())
                        else a.blocksizes.push(n.uint64())
                        break
                    case 5:
                        a.hashType = n.uint64()
                        break
                    case 6:
                        a.fanout = n.uint64()
                        break
                    case 7:
                        a.mode = n.uint32()
                        break
                    case 8:
                        a.mtime = $root.UnixTime.decode(n, n.uint32())
                        break
                    default:
                        n.skipType(l & 7)
                        break
                }
            }
            if (!a.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", { instance: a })
            return a
        }),
        (t.fromObject = function (n) {
            if (n instanceof $root.Data) return n
            var i = new $root.Data()
            switch (n.Type) {
                case "Raw":
                case 0:
                    i.Type = 0
                    break
                case "Directory":
                case 1:
                    i.Type = 1
                    break
                case "File":
                case 2:
                    i.Type = 2
                    break
                case "Metadata":
                case 3:
                    i.Type = 3
                    break
                case "Symlink":
                case 4:
                    i.Type = 4
                    break
                case "HAMTShard":
                case 5:
                    i.Type = 5
                    break
            }
            if (
                (n.Data != null &&
                    (typeof n.Data == "string"
                        ? $util.base64.decode(n.Data, (i.Data = $util.newBuffer($util.base64.length(n.Data))), 0)
                        : n.Data.length && (i.Data = n.Data)),
                n.filesize != null &&
                    ($util.Long
                        ? ((i.filesize = $util.Long.fromValue(n.filesize)).unsigned = !0)
                        : typeof n.filesize == "string"
                        ? (i.filesize = parseInt(n.filesize, 10))
                        : typeof n.filesize == "number"
                        ? (i.filesize = n.filesize)
                        : typeof n.filesize == "object" &&
                          (i.filesize = new $util.LongBits(n.filesize.low >>> 0, n.filesize.high >>> 0).toNumber(!0))),
                n.blocksizes)
            ) {
                if (!Array.isArray(n.blocksizes)) throw TypeError(".Data.blocksizes: array expected")
                i.blocksizes = []
                for (var o = 0; o < n.blocksizes.length; ++o)
                    $util.Long
                        ? ((i.blocksizes[o] = $util.Long.fromValue(n.blocksizes[o])).unsigned = !0)
                        : typeof n.blocksizes[o] == "string"
                        ? (i.blocksizes[o] = parseInt(n.blocksizes[o], 10))
                        : typeof n.blocksizes[o] == "number"
                        ? (i.blocksizes[o] = n.blocksizes[o])
                        : typeof n.blocksizes[o] == "object" &&
                          (i.blocksizes[o] = new $util.LongBits(n.blocksizes[o].low >>> 0, n.blocksizes[o].high >>> 0).toNumber(!0))
            }
            if (
                (n.hashType != null &&
                    ($util.Long
                        ? ((i.hashType = $util.Long.fromValue(n.hashType)).unsigned = !0)
                        : typeof n.hashType == "string"
                        ? (i.hashType = parseInt(n.hashType, 10))
                        : typeof n.hashType == "number"
                        ? (i.hashType = n.hashType)
                        : typeof n.hashType == "object" &&
                          (i.hashType = new $util.LongBits(n.hashType.low >>> 0, n.hashType.high >>> 0).toNumber(!0))),
                n.fanout != null &&
                    ($util.Long
                        ? ((i.fanout = $util.Long.fromValue(n.fanout)).unsigned = !0)
                        : typeof n.fanout == "string"
                        ? (i.fanout = parseInt(n.fanout, 10))
                        : typeof n.fanout == "number"
                        ? (i.fanout = n.fanout)
                        : typeof n.fanout == "object" && (i.fanout = new $util.LongBits(n.fanout.low >>> 0, n.fanout.high >>> 0).toNumber(!0))),
                n.mode != null && (i.mode = n.mode >>> 0),
                n.mtime != null)
            ) {
                if (typeof n.mtime != "object") throw TypeError(".Data.mtime: object expected")
                i.mtime = $root.UnixTime.fromObject(n.mtime)
            }
            return i
        }),
        (t.toObject = function (n, i) {
            i || (i = {})
            var o = {}
            if (((i.arrays || i.defaults) && (o.blocksizes = []), i.defaults)) {
                if (
                    ((o.Type = i.enums === String ? "Raw" : 0),
                    i.bytes === String ? (o.Data = "") : ((o.Data = []), i.bytes !== Array && (o.Data = $util.newBuffer(o.Data))),
                    $util.Long)
                ) {
                    var a = new $util.Long(0, 0, !0)
                    o.filesize = i.longs === String ? a.toString() : i.longs === Number ? a.toNumber() : a
                } else o.filesize = i.longs === String ? "0" : 0
                if ($util.Long) {
                    var a = new $util.Long(0, 0, !0)
                    o.hashType = i.longs === String ? a.toString() : i.longs === Number ? a.toNumber() : a
                } else o.hashType = i.longs === String ? "0" : 0
                if ($util.Long) {
                    var a = new $util.Long(0, 0, !0)
                    o.fanout = i.longs === String ? a.toString() : i.longs === Number ? a.toNumber() : a
                } else o.fanout = i.longs === String ? "0" : 0
                ;(o.mode = 0), (o.mtime = null)
            }
            if (
                (n.Type != null && n.hasOwnProperty("Type") && (o.Type = i.enums === String ? $root.Data.DataType[n.Type] : n.Type),
                n.Data != null &&
                    n.hasOwnProperty("Data") &&
                    (o.Data =
                        i.bytes === String
                            ? $util.base64.encode(n.Data, 0, n.Data.length)
                            : i.bytes === Array
                            ? Array.prototype.slice.call(n.Data)
                            : n.Data),
                n.filesize != null &&
                    n.hasOwnProperty("filesize") &&
                    (typeof n.filesize == "number"
                        ? (o.filesize = i.longs === String ? String(n.filesize) : n.filesize)
                        : (o.filesize =
                              i.longs === String
                                  ? $util.Long.prototype.toString.call(n.filesize)
                                  : i.longs === Number
                                  ? new $util.LongBits(n.filesize.low >>> 0, n.filesize.high >>> 0).toNumber(!0)
                                  : n.filesize)),
                n.blocksizes && n.blocksizes.length)
            ) {
                o.blocksizes = []
                for (var l = 0; l < n.blocksizes.length; ++l)
                    typeof n.blocksizes[l] == "number"
                        ? (o.blocksizes[l] = i.longs === String ? String(n.blocksizes[l]) : n.blocksizes[l])
                        : (o.blocksizes[l] =
                              i.longs === String
                                  ? $util.Long.prototype.toString.call(n.blocksizes[l])
                                  : i.longs === Number
                                  ? new $util.LongBits(n.blocksizes[l].low >>> 0, n.blocksizes[l].high >>> 0).toNumber(!0)
                                  : n.blocksizes[l])
            }
            return (
                n.hashType != null &&
                    n.hasOwnProperty("hashType") &&
                    (typeof n.hashType == "number"
                        ? (o.hashType = i.longs === String ? String(n.hashType) : n.hashType)
                        : (o.hashType =
                              i.longs === String
                                  ? $util.Long.prototype.toString.call(n.hashType)
                                  : i.longs === Number
                                  ? new $util.LongBits(n.hashType.low >>> 0, n.hashType.high >>> 0).toNumber(!0)
                                  : n.hashType)),
                n.fanout != null &&
                    n.hasOwnProperty("fanout") &&
                    (typeof n.fanout == "number"
                        ? (o.fanout = i.longs === String ? String(n.fanout) : n.fanout)
                        : (o.fanout =
                              i.longs === String
                                  ? $util.Long.prototype.toString.call(n.fanout)
                                  : i.longs === Number
                                  ? new $util.LongBits(n.fanout.low >>> 0, n.fanout.high >>> 0).toNumber(!0)
                                  : n.fanout)),
                n.mode != null && n.hasOwnProperty("mode") && (o.mode = n.mode),
                n.mtime != null && n.hasOwnProperty("mtime") && (o.mtime = $root.UnixTime.toObject(n.mtime, i)),
                o
            )
        }),
        (t.prototype.toJSON = function () {
            return this.constructor.toObject(this, minimal.util.toJSONOptions)
        }),
        (t.DataType = (function () {
            const e = {},
                n = Object.create(e)
            return (
                (n[(e[0] = "Raw")] = 0),
                (n[(e[1] = "Directory")] = 1),
                (n[(e[2] = "File")] = 2),
                (n[(e[3] = "Metadata")] = 3),
                (n[(e[4] = "Symlink")] = 4),
                (n[(e[5] = "HAMTShard")] = 5),
                n
            )
        })()),
        t
    )
})()
$root.UnixTime = (() => {
    function t(e) {
        if (e) for (var n = Object.keys(e), i = 0; i < n.length; ++i) e[n[i]] != null && (this[n[i]] = e[n[i]])
    }
    return (
        (t.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0),
        (t.prototype.FractionalNanoseconds = 0),
        (t.encode = function (n, i) {
            return (
                i || (i = $Writer.create()),
                i.uint32(8).int64(n.Seconds),
                n.FractionalNanoseconds != null &&
                    Object.hasOwnProperty.call(n, "FractionalNanoseconds") &&
                    i.uint32(21).fixed32(n.FractionalNanoseconds),
                i
            )
        }),
        (t.decode = function (n, i) {
            n instanceof $Reader || (n = $Reader.create(n))
            for (var o = i === void 0 ? n.len : n.pos + i, a = new $root.UnixTime(); n.pos < o; ) {
                var l = n.uint32()
                switch (l >>> 3) {
                    case 1:
                        a.Seconds = n.int64()
                        break
                    case 2:
                        a.FractionalNanoseconds = n.fixed32()
                        break
                    default:
                        n.skipType(l & 7)
                        break
                }
            }
            if (!a.hasOwnProperty("Seconds")) throw $util.ProtocolError("missing required 'Seconds'", { instance: a })
            return a
        }),
        (t.fromObject = function (n) {
            if (n instanceof $root.UnixTime) return n
            var i = new $root.UnixTime()
            return (
                n.Seconds != null &&
                    ($util.Long
                        ? ((i.Seconds = $util.Long.fromValue(n.Seconds)).unsigned = !1)
                        : typeof n.Seconds == "string"
                        ? (i.Seconds = parseInt(n.Seconds, 10))
                        : typeof n.Seconds == "number"
                        ? (i.Seconds = n.Seconds)
                        : typeof n.Seconds == "object" &&
                          (i.Seconds = new $util.LongBits(n.Seconds.low >>> 0, n.Seconds.high >>> 0).toNumber())),
                n.FractionalNanoseconds != null && (i.FractionalNanoseconds = n.FractionalNanoseconds >>> 0),
                i
            )
        }),
        (t.toObject = function (n, i) {
            i || (i = {})
            var o = {}
            if (i.defaults) {
                if ($util.Long) {
                    var a = new $util.Long(0, 0, !1)
                    o.Seconds = i.longs === String ? a.toString() : i.longs === Number ? a.toNumber() : a
                } else o.Seconds = i.longs === String ? "0" : 0
                o.FractionalNanoseconds = 0
            }
            return (
                n.Seconds != null &&
                    n.hasOwnProperty("Seconds") &&
                    (typeof n.Seconds == "number"
                        ? (o.Seconds = i.longs === String ? String(n.Seconds) : n.Seconds)
                        : (o.Seconds =
                              i.longs === String
                                  ? $util.Long.prototype.toString.call(n.Seconds)
                                  : i.longs === Number
                                  ? new $util.LongBits(n.Seconds.low >>> 0, n.Seconds.high >>> 0).toNumber()
                                  : n.Seconds)),
                n.FractionalNanoseconds != null &&
                    n.hasOwnProperty("FractionalNanoseconds") &&
                    (o.FractionalNanoseconds = n.FractionalNanoseconds),
                o
            )
        }),
        (t.prototype.toJSON = function () {
            return this.constructor.toObject(this, minimal.util.toJSONOptions)
        }),
        t
    )
})()
$root.Metadata = (() => {
    function t(e) {
        if (e) for (var n = Object.keys(e), i = 0; i < n.length; ++i) e[n[i]] != null && (this[n[i]] = e[n[i]])
    }
    return (
        (t.prototype.MimeType = ""),
        (t.encode = function (n, i) {
            return (
                i || (i = $Writer.create()),
                n.MimeType != null && Object.hasOwnProperty.call(n, "MimeType") && i.uint32(10).string(n.MimeType),
                i
            )
        }),
        (t.decode = function (n, i) {
            n instanceof $Reader || (n = $Reader.create(n))
            for (var o = i === void 0 ? n.len : n.pos + i, a = new $root.Metadata(); n.pos < o; ) {
                var l = n.uint32()
                switch (l >>> 3) {
                    case 1:
                        a.MimeType = n.string()
                        break
                    default:
                        n.skipType(l & 7)
                        break
                }
            }
            return a
        }),
        (t.fromObject = function (n) {
            if (n instanceof $root.Metadata) return n
            var i = new $root.Metadata()
            return n.MimeType != null && (i.MimeType = String(n.MimeType)), i
        }),
        (t.toObject = function (n, i) {
            i || (i = {})
            var o = {}
            return i.defaults && (o.MimeType = ""), n.MimeType != null && n.hasOwnProperty("MimeType") && (o.MimeType = n.MimeType), o
        }),
        (t.prototype.toJSON = function () {
            return this.constructor.toObject(this, minimal.util.toJSONOptions)
        }),
        t
    )
})()
function parseMode(t) {
    if (t != null)
        return typeof t == "number" ? t & 4095 : ((t = t.toString()), t.substring(0, 1) === "0" ? parseInt(t, 8) & 4095 : parseInt(t, 10) & 4095)
}
function parseMtime(t) {
    if (t == null) return
    let e
    if (
        (t.secs != null && (e = { secs: t.secs, nsecs: t.nsecs }),
        t.Seconds != null && (e = { secs: t.Seconds, nsecs: t.FractionalNanoseconds }),
        Array.isArray(t) && (e = { secs: t[0], nsecs: t[1] }),
        t instanceof Date)
    ) {
        const n = t.getTime(),
            i = Math.floor(n / 1e3)
        e = { secs: i, nsecs: (n - i * 1e3) * 1e3 }
    }
    if (!!Object.prototype.hasOwnProperty.call(e, "secs")) {
        if (e != null && e.nsecs != null && (e.nsecs < 0 || e.nsecs > 999999999))
            throw errCode(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS")
        return e
    }
}
async function* normaliseCandidateMultiple(t, e) {
    if (typeof t == "string" || t instanceof String || isBytes(t) || isBlob(t) || t._readableState)
        throw errCode(
            new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),
            "ERR_UNEXPECTED_INPUT"
        )
    if ((isReadableStream(t) && (t = browserReadablestreamToIt(t)), Symbol.iterator in t || Symbol.asyncIterator in t)) {
        const n = itPeekable(t),
            { value: i, done: o } = await n.peek()
        if (o) {
            yield* []
            return
        }
        if ((n.push(i), Number.isInteger(i)))
            throw errCode(
                new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),
                "ERR_UNEXPECTED_INPUT"
            )
        if (i._readableState) {
            yield* itMap(n, (a) => toFileObject$1({ content: a }, e))
            return
        }
        if (isBytes(i)) {
            yield toFileObject$1({ content: n }, e)
            return
        }
        if (isFileObject(i) || i[Symbol.iterator] || i[Symbol.asyncIterator] || isReadableStream(i) || isBlob(i)) {
            yield* itMap(n, (a) => toFileObject$1(a, e))
            return
        }
    }
    throw isFileObject(t)
        ? errCode(
              new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),
              "ERR_UNEXPECTED_INPUT"
          )
        : errCode(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT")
}
async function toFileObject$1(t, e) {
    const { path: n, mode: i, mtime: o, content: a } = t,
        l = { path: n || "", mode: parseMode(i), mtime: parseMtime(o) }
    return a ? (l.content = await e(a)) : n || (l.content = await e(t)), l
}
function normaliseInput$2(t) {
    return normaliseCandidateMultiple(t, normaliseContent$1)
}
function modeToString(t) {
    if (t != null) return typeof t == "string" ? t : t.toString(8).padStart(4, "0")
}
async function multipartRequest(t, e, n = {}) {
    const i = [],
        o = new FormData()
    let a = 0,
        l = 0
    for await (const { content: c, path: g, mode: v, mtime: _ } of normaliseInput$2(t)) {
        let A = ""
        const B = c ? "file" : "dir"
        a > 0 && (A = `-${a}`)
        let D = B + A
        const I = []
        if ((v != null && I.push(`mode=${modeToString(v)}`), _ != null)) {
            const { secs: L, nsecs: G } = _
            I.push(`mtime=${L}`), G != null && I.push(`mtime-nsecs=${G}`)
        }
        if ((I.length && (D = `${D}?${I.join("&")}`), c)) {
            o.set(D, c, g != null ? encodeURIComponent(g) : void 0)
            const L = l + c.size
            i.push({ name: g, start: l, end: L }), (l = L)
        } else if (g != null) o.set(D, new File([""], encodeURIComponent(g), { type: "application/x-directory" }))
        else throw new Error("path or content or both must be set")
        a++
    }
    return { total: l, parts: i, headers: n, body: o }
}
function filter(t) {
    return t.filter(Boolean)
}
function abortSignal(...t) {
    return anySignal_2(filter(t))
}
const createPut$3 = configure((t) => {
        async function e(n, i = {}) {
            const o = new AbortController(),
                a = abortSignal(o.signal, i.signal)
            let l
            try {
                l = await (
                    await t.post("block/put", { signal: a, searchParams: toUrlSearchParams(i), ...(await multipartRequest([n], o, i.headers)) })
                ).json()
            } catch (c) {
                if (i.format === "dag-pb") return e(n, { ...i, format: "protobuf" })
                if (i.format === "dag-cbor") return e(n, { ...i, format: "cbor" })
                throw c
            }
            return CID.parse(l.Key)
        }
        return e
    }),
    createRm$6 = configure((t) => {
        async function* e(n, i = {}) {
            Array.isArray(n) || (n = [n])
            const o = await t.post("block/rm", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n.map((a) => a.toString()), "stream-channels": !0, ...i }),
                headers: i.headers,
            })
            for await (const a of o.ndjson()) yield toCoreInterface$3(a)
        }
        return e
    })
function toCoreInterface$3(t) {
    const e = { cid: CID.parse(t.Hash) }
    return t.Error && (e.error = new Error(t.Error)), e
}
const createStat$3 = configure((t) => {
    async function e(n, i = {}) {
        const a = await (
            await t.post("block/stat", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n.toString(), ...i }), headers: i.headers })
        ).json()
        return { cid: CID.parse(a.Key), size: a.Size }
    }
    return e
})
function createBlock(t) {
    return { get: createGet$5(t), put: createPut$3(t), rm: createRm$6(t), stat: createStat$3(t) }
}
const createAdd$4 = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("bootstrap/add", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers }),
                { Peers: a } = await o.json()
            return { Peers: a.map((l) => new Multiaddr(l)) }
        }
        return e
    }),
    createClear = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("bootstrap/rm", { signal: n.signal, searchParams: toUrlSearchParams({ ...n, all: !0 }), headers: n.headers }),
                { Peers: o } = await i.json()
            return { Peers: o.map((a) => new Multiaddr(a)) }
        }
        return e
    }),
    createList$2 = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("bootstrap/list", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers }),
                { Peers: o } = await i.json()
            return { Peers: o.map((a) => new Multiaddr(a)) }
        }
        return e
    }),
    createReset = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("bootstrap/add", {
                    signal: n.signal,
                    searchParams: toUrlSearchParams({ ...n, default: !0 }),
                    headers: n.headers,
                }),
                { Peers: o } = await i.json()
            return { Peers: o.map((a) => new Multiaddr(a)) }
        }
        return e
    }),
    createRm$5 = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("bootstrap/rm", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers }),
                { Peers: a } = await o.json()
            return { Peers: a.map((l) => new Multiaddr(l)) }
        }
        return e
    })
function createBootstrap(t) {
    return { add: createAdd$4(t), clear: createClear(t), list: createList$2(t), reset: createReset(t), rm: createRm$5(t) }
}
const createApply = configure((t) => {
    async function e(n, i = {}) {
        const a = await (
            await t.post("config/profile/apply", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
        ).json()
        return { original: a.OldCfg, updated: a.NewCfg }
    }
    return e
})
function objectToCamel(t) {
    if (t == null) return t
    const e = /^[A-Z]+$/,
        n = {}
    return Object.keys(t).reduce(
        (i, o) => (e.test(o) ? (i[o.toLowerCase()] = t[o]) : e.test(o[0]) ? (i[o[0].toLowerCase() + o.slice(1)] = t[o]) : (i[o] = t[o]), i),
        n
    )
}
const createList$1 = configure((t) => {
    async function e(n = {}) {
        return (
            await (await t.post("config/profile/list", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
        ).map((a) => objectToCamel(a))
    }
    return e
})
function createProfiles(t) {
    return { apply: createApply(t), list: createList$1(t) }
}
const createGet$4 = configure((t) => async (n, i = {}) => {
        if (!n) throw new Error("key argument is required")
        return (
            await (await t.post("config", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })).json()
        ).Value
    }),
    createGetAll = configure(
        (t) =>
            async (n = {}) =>
                await (await t.post("config/show", { signal: n.signal, searchParams: toUrlSearchParams({ ...n }), headers: n.headers })).json()
    ),
    createReplace = configure((t) => async (n, i = {}) => {
        const o = new AbortController(),
            a = abortSignal(o.signal, i.signal)
        await (
            await t.post("config/replace", {
                signal: a,
                searchParams: toUrlSearchParams(i),
                ...(await multipartRequest([fromString$1(JSON.stringify(n))], o, i.headers)),
            })
        ).text()
    }),
    createSet = configure((t) => async (n, i, o = {}) => {
        if (typeof n != "string") throw new Error("Invalid key type")
        const a = { ...o, ...encodeParam(n, i) }
        await (await t.post("config", { signal: o.signal, searchParams: toUrlSearchParams(a), headers: o.headers })).text()
    }),
    encodeParam = (t, e) => {
        switch (typeof e) {
            case "boolean":
                return { arg: [t, e.toString()], bool: !0 }
            case "string":
                return { arg: [t, e] }
            default:
                return { arg: [t, JSON.stringify(e)], json: !0 }
        }
    }
function createConfig(t) {
    return { getAll: createGetAll(t), get: createGet$4(t), set: createSet(t), replace: createReplace(t), profiles: createProfiles(t) }
}
const createExport$1 = configure((t) => {
    async function* e(n, i = {}) {
        yield* (
            await t.post("dag/export", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n.toString() }), headers: i.headers })
        ).iterator()
    }
    return e
})
async function* resolve(t, e, n, i, o) {
    const a = async (v) => {
            const _ = await n.getCodec(v.code),
                A = await i(v, o)
            return _.decode(A)
        },
        l = e.split("/").filter(Boolean)
    let c = await a(t),
        g = t
    for (; l.length; ) {
        const v = l.shift()
        if (!v) throw errCode(new Error(`Could not resolve path "${e}"`), "ERR_INVALID_PATH")
        if (Object.prototype.hasOwnProperty.call(c, v)) (c = c[v]), yield { value: c, remainderPath: l.join("/") }
        else throw errCode(new Error(`no link named "${v}" under ${g}`), "ERR_NO_LINK")
        const _ = CID.asCID(c)
        _ && ((g = _), (c = await a(c)))
    }
    yield { value: c, remainderPath: "" }
}
const first = async (t) => {
    for await (const e of t) return e
}
var itFirst = first
const last = async (t) => {
    let e
    for await (const n of t) e = n
    return e
}
var itLast = last
const createGet$3 = (t, e) =>
        configure((i, o) => {
            const a = createGet$5(o)
            return async (c, g = {}) => {
                if (g.path) {
                    const D = g.localResolve ? await itFirst(resolve(c, g.path, t, a, g)) : await itLast(resolve(c, g.path, t, a, g))
                    if (!D) throw errCode(new Error("Not found"), "ERR_NOT_FOUND")
                    return D
                }
                const v = await t.getCodec(c.code),
                    _ = await a(c, g)
                return { value: v.decode(_), remainderPath: "" }
            }
        })(e),
    createImport$1 = configure((t) => {
        async function* e(n, i = {}) {
            const o = new AbortController(),
                a = abortSignal(o.signal, i.signal),
                { headers: l, body: c } = await multipartRequest(n, o, i.headers),
                g = await t.post("dag/import", { signal: a, headers: l, body: c, searchParams: toUrlSearchParams({ "pin-roots": i.pinRoots }) })
            for await (const { Root: v } of g.ndjson())
                if (v !== void 0) {
                    const {
                        Cid: { "/": _ },
                        PinErrorMsg: A,
                    } = v
                    yield { root: { cid: CID.parse(_), pinErrorMsg: A } }
                }
        }
        return e
    }),
    createPut$2 = (t, e) =>
        configure((i) => async (a, l = {}) => {
            const c = { storeCodec: "dag-cbor", hashAlg: "sha2-256", ...l }
            let g
            if (c.inputCodec) {
                if (!(a instanceof Uint8Array)) throw new Error("Can only inputCodec on raw bytes that can be decoded")
                g = a
            } else (g = (await t.getCodec(c.storeCodec)).encode(a)), (c.inputCodec = c.storeCodec)
            const v = new AbortController(),
                _ = abortSignal(v.signal, c.signal),
                B = await (
                    await i.post("dag/put", {
                        timeout: c.timeout,
                        signal: _,
                        searchParams: toUrlSearchParams(c),
                        ...(await multipartRequest([g], v, c.headers)),
                    })
                ).json()
            return CID.parse(B.Cid["/"])
        })(e),
    createResolve$2 = configure((t) => async (n, i = {}) => {
        const a = await (
            await t.post("dag/resolve", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: `${n}${i.path ? `/${i.path}`.replace(/\/[/]+/g, "/") : ""}`, ...i }),
                headers: i.headers,
            })
        ).json()
        return { cid: CID.parse(a.Cid["/"]), remainderPath: a.RemPath }
    })
function createDag(t, e) {
    return { export: createExport$1(e), get: createGet$3(t, e), import: createImport$1(e), put: createPut$2(t, e), resolve: createResolve$2(e) }
}
const SendingQuery = 0,
    PeerResponse = 1,
    FinalPeer = 2,
    QueryError = 3,
    Provider = 4,
    Value = 5,
    AddingPeer = 6,
    DialingPeer = 7,
    mapEvent = (t) => {
        var e
        if (t.Type === SendingQuery) return { name: "SENDING_QUERY", type: t.Type }
        if (t.Type === PeerResponse)
            return {
                from: peerIdFromString(t.ID),
                name: "PEER_RESPONSE",
                type: t.Type,
                messageType: 0,
                messageName: "PUT_VALUE",
                closer: (t.Responses || []).map(({ ID: n, Addrs: i }) => ({
                    id: peerIdFromString(n),
                    multiaddrs: i.map((o) => new Multiaddr(o)),
                    protocols: [],
                })),
                providers: (t.Responses || []).map(({ ID: n, Addrs: i }) => ({
                    id: peerIdFromString(n),
                    multiaddrs: i.map((o) => new Multiaddr(o)),
                    protocols: [],
                })),
            }
        if (t.Type === FinalPeer) {
            let n = { id: (e = t.ID) != null ? e : peerIdFromString(t.ID), multiaddrs: [], protocols: [] }
            return (
                t.Responses &&
                    t.Responses.length &&
                    (n = {
                        id: peerIdFromString(t.Responses[0].ID),
                        multiaddrs: t.Responses[0].Addrs.map((i) => new Multiaddr(i)),
                        protocols: [],
                    }),
                { name: "FINAL_PEER", type: t.Type, peer: n }
            )
        }
        if (t.Type === QueryError) return { name: "QUERY_ERROR", type: t.Type, error: new Error(t.Extra) }
        if (t.Type === Provider)
            return {
                name: "PROVIDER",
                type: t.Type,
                providers: t.Responses.map(({ ID: n, Addrs: i }) => ({
                    id: peerIdFromString(n),
                    multiaddrs: i.map((o) => new Multiaddr(o)),
                    protocols: [],
                })),
            }
        if (t.Type === Value) return { name: "VALUE", type: t.Type, value: fromString$1(t.Extra, "base64pad") }
        if (t.Type === AddingPeer) {
            const n = t.Responses.map(({ ID: i }) => peerIdFromString(i))
            if (!n.length) throw new Error("No peer found")
            return { name: "ADDING_PEER", type: t.Type, peer: n[0] }
        }
        if (t.Type === DialingPeer) return { name: "DIALING_PEER", type: t.Type, peer: peerIdFromString(t.ID) }
        throw new Error("Unknown DHT event type")
    },
    createFindPeer = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("dht/findpeer", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            for await (const a of o.ndjson()) yield mapEvent(a)
        }
        return e
    }),
    createFindProvs = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("dht/findprovs", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n.toString(), ...i }),
                headers: i.headers,
            })
            for await (const a of o.ndjson()) yield mapEvent(a)
        }
        return e
    }),
    createGet$2 = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("dht/get", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n instanceof Uint8Array ? toString$2(n) : n.toString(), ...i }),
                headers: i.headers,
            })
            for await (const a of o.ndjson()) yield mapEvent(a)
        }
        return e
    }),
    createProvide = configure((t) => {
        async function* e(n, i = { recursive: !1 }) {
            const o = Array.isArray(n) ? n : [n],
                a = await t.post("dht/provide", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: o.map((l) => l.toString()), ...i }),
                    headers: i.headers,
                })
            for await (const l of a.ndjson()) yield mapEvent(l)
        }
        return e
    }),
    createPut$1 = configure((t) => {
        async function* e(n, i, o = {}) {
            const a = new AbortController(),
                l = abortSignal(a.signal, o.signal),
                c = await t.post("dht/put", {
                    signal: l,
                    searchParams: toUrlSearchParams({ arg: n instanceof Uint8Array ? toString$2(n) : n.toString(), ...o }),
                    ...(await multipartRequest([i], a, o.headers)),
                })
            for await (const g of c.ndjson()) yield mapEvent(g)
        }
        return e
    }),
    createQuery = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("dht/query", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n.toString(), ...i }),
                headers: i.headers,
            })
            for await (const a of o.ndjson()) yield mapEvent(a)
        }
        return e
    })
function createDht(t) {
    return {
        findPeer: createFindPeer(t),
        findProvs: createFindProvs(t),
        get: createGet$2(t),
        provide: createProvide(t),
        put: createPut$1(t),
        query: createQuery(t),
    }
}
const createCmds = configure((t) => {
        async function e(n = {}) {
            return (await t.post("diag/cmds", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
        }
        return e
    }),
    createNet = configure((t) => {
        async function e(n = {}) {
            return (await t.post("diag/net", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
        }
        return e
    }),
    createSys = configure((t) => {
        async function e(n = {}) {
            return (await t.post("diag/sys", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
        }
        return e
    })
function createDiag(t) {
    return { cmds: createCmds(t), net: createNet(t), sys: createSys(t) }
}
const createChmod = configure((t) => {
        async function e(n, i, o = {}) {
            await (
                await t.post("files/chmod", { signal: o.signal, searchParams: toUrlSearchParams({ arg: n, mode: i, ...o }), headers: o.headers })
            ).text()
        }
        return e
    }),
    createCp = configure((t) => {
        async function e(n, i, o = {}) {
            const a = Array.isArray(n) ? n : [n]
            await (
                await t.post("files/cp", {
                    signal: o.signal,
                    searchParams: toUrlSearchParams({ arg: a.concat(i).map((c) => (CID.asCID(c) ? `/ipfs/${c}` : c)), ...o }),
                    headers: o.headers,
                })
            ).text()
        }
        return e
    }),
    createFlush = configure((t) => {
        async function e(n, i = {}) {
            if (!n || typeof n != "string") throw new Error("ipfs.files.flush requires a path")
            const a = await (
                await t.post("files/flush", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).json()
            return CID.parse(a.Cid)
        }
        return e
    })
function objectToCamelWithMetadata(t) {
    const e = objectToCamel(t)
    return (
        Object.prototype.hasOwnProperty.call(e, "mode") && (e.mode = parseInt(e.mode, 8)),
        Object.prototype.hasOwnProperty.call(e, "mtime") && ((e.mtime = { secs: e.mtime, nsecs: e.mtimeNsecs || 0 }), delete e.mtimeNsecs),
        e
    )
}
const createLs$6 = configure((t) => {
    async function* e(n, i = {}) {
        if (!n) throw new Error("ipfs.files.ls requires a path")
        const o = await t.post("files/ls", {
            signal: i.signal,
            searchParams: toUrlSearchParams({ arg: CID.asCID(n) ? `/ipfs/${n}` : n, long: !0, ...i, stream: !0 }),
            headers: i.headers,
        })
        for await (const a of o.ndjson())
            if ("Entries" in a) for (const l of a.Entries || []) yield toCoreInterface$2(objectToCamelWithMetadata(l))
            else yield toCoreInterface$2(objectToCamelWithMetadata(a))
    }
    return e
})
function toCoreInterface$2(t) {
    return t.hash && (t.cid = CID.parse(t.hash)), delete t.hash, (t.type = t.type === 1 ? "directory" : "file"), t
}
const createMkdir = configure((t) => {
        async function e(n, i = {}) {
            await (
                await t.post("files/mkdir", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).text()
        }
        return e
    }),
    createMv = configure((t) => {
        async function e(n, i, o = {}) {
            Array.isArray(n) || (n = [n]),
                await (
                    await t.post("files/mv", {
                        signal: o.signal,
                        searchParams: toUrlSearchParams({ arg: n.concat(i), ...o }),
                        headers: o.headers,
                    })
                ).text()
        }
        return e
    })
var source = (t) => {
    if (t[Symbol.asyncIterator]) return t
    if (t.getReader)
        return (async function* () {
            const e = t.getReader()
            try {
                for (;;) {
                    const { done: n, value: i } = await e.read()
                    if (n) return
                    yield i
                }
            } finally {
                e.releaseLock()
            }
        })()
    throw new Error("unknown stream")
}
const createRead = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("files/read", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n, count: i.length, ...i }),
                headers: i.headers,
            })
            yield* source(o.body)
        }
        return e
    }),
    createRm$4 = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("files/rm", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers }),
                a = await o.text()
            if (a !== "") {
                const l = new http.HTTPError(o)
                throw ((l.message = a), l)
            }
        }
        return e
    }),
    createStat$2 = configure((t) => {
        async function e(n, i = {}) {
            const a = await (
                await t.post("files/stat", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).json()
            return (a.WithLocality = a.WithLocality || !1), toCoreInterface$1(objectToCamelWithMetadata(a))
        }
        return e
    })
function toCoreInterface$1(t) {
    return (t.cid = CID.parse(t.hash)), delete t.hash, t
}
const createTouch = configure((t) => {
        async function e(n, i = {}) {
            await (
                await t.post("files/touch", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).text()
        }
        return e
    }),
    createWrite = configure((t) => {
        async function e(n, i, o = {}) {
            const a = new AbortController(),
                l = abortSignal(a.signal, o.signal)
            await (
                await t.post("files/write", {
                    signal: l,
                    searchParams: toUrlSearchParams({ arg: n, streamChannels: !0, count: o.length, ...o }),
                    ...(await multipartRequest(
                        [{ content: i, path: "arg", mode: modeToString$1(o.mode), mtime: parseMtime$1(o.mtime) }],
                        a,
                        o.headers
                    )),
                })
            ).text()
        }
        return e
    })
function createFiles(t) {
    return {
        chmod: createChmod(t),
        cp: createCp(t),
        flush: createFlush(t),
        ls: createLs$6(t),
        mkdir: createMkdir(t),
        mv: createMv(t),
        read: createRead(t),
        rm: createRm$4(t),
        stat: createStat$2(t),
        touch: createTouch(t),
        write: createWrite(t),
    }
}
const createExport = configure((t) => async (n, i, o = {}) => {
        throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")
    }),
    createGen = configure((t) => {
        async function e(n, i = { type: "Ed25519" }) {
            const a = await (
                await t.post("key/gen", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).json()
            return objectToCamel(a)
        }
        return e
    }),
    createImport = configure((t) => {
        async function e(n, i, o, a = {}) {
            const c = await (
                await t.post("key/import", {
                    signal: a.signal,
                    searchParams: toUrlSearchParams({ arg: n, pem: i, password: o, ...a }),
                    headers: a.headers,
                })
            ).json()
            return objectToCamel(c)
        }
        return e
    }),
    createInfo = configure((t) => async (n, i = {}) => {
        throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")
    }),
    createList = configure((t) => {
        async function e(n = {}) {
            return (
                (await (await t.post("key/list", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()).Keys ||
                []
            ).map((a) => objectToCamel(a))
        }
        return e
    }),
    createRename = configure((t) => {
        async function e(n, i, o = {}) {
            const a = await t.post("key/rename", {
                signal: o.signal,
                searchParams: toUrlSearchParams({ arg: [n, i], ...o }),
                headers: o.headers,
            })
            return objectToCamel(await a.json())
        }
        return e
    }),
    createRm$3 = configure((t) => {
        async function e(n, i = {}) {
            const a = await (
                await t.post("key/rm", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })
            ).json()
            return objectToCamel(a.Keys[0])
        }
        return e
    })
function createKey(t) {
    return {
        export: createExport(t),
        gen: createGen(t),
        import: createImport(t),
        info: createInfo(t),
        list: createList(t),
        rename: createRename(t),
        rm: createRm$3(t),
    }
}
const createLevel = configure((t) => {
        async function e(n, i, o = {}) {
            const a = await t.post("log/level", { signal: o.signal, searchParams: toUrlSearchParams({ arg: [n, i], ...o }), headers: o.headers })
            return objectToCamel(await a.json())
        }
        return e
    }),
    createLs$5 = configure((t) => {
        async function e(n = {}) {
            return (await (await t.post("log/ls", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()).Strings
        }
        return e
    }),
    createTail = configure((t) => {
        async function* e(n = {}) {
            yield* (await t.post("log/tail", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).ndjson()
        }
        return e
    })
function createLog(t) {
    return { level: createLevel(t), ls: createLs$5(t), tail: createTail(t) }
}
const createPublish$1 = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("name/publish", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: `${n}`, ...i }),
                headers: i.headers,
            })
            return objectToCamel(await o.json())
        }
        return e
    }),
    createResolve$1 = configure((t) => {
        async function* e(n, i = {}) {
            const o = await t.post("name/resolve", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n, stream: !0, ...i }),
                headers: i.headers,
            })
            for await (const a of o.ndjson()) yield a.Path
        }
        return e
    }),
    createCancel = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("name/pubsub/cancel", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ arg: n, ...i }),
                headers: i.headers,
            })
            return objectToCamel(await o.json())
        }
        return e
    }),
    createState = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("name/pubsub/state", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })
            return objectToCamel(await i.json())
        }
        return e
    }),
    createSubs = configure((t) => {
        async function e(n = {}) {
            return (
                (await (await t.post("name/pubsub/subs", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json())
                    .Strings || []
            )
        }
        return e
    })
function createPubsub$1(t) {
    return { cancel: createCancel(t), state: createState(t), subs: createSubs(t) }
}
function createName(t) {
    return { publish: createPublish$1(t), resolve: createResolve$1(t), pubsub: createPubsub$1(t) }
}
const createData = configure((t) => {
        async function e(n, i = {}) {
            const a = await (
                await t.post("object/data", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: `${n instanceof Uint8Array ? CID.decode(n) : n}`, ...i }),
                    headers: i.headers,
                })
            ).arrayBuffer()
            return new Uint8Array(a, 0, a.byteLength)
        }
        return e
    }),
    createGet$1 = configure((t) => {
        async function e(n, i = {}) {
            const a = await (
                await t.post("object/get", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: `${n instanceof Uint8Array ? CID.decode(n) : n}`, dataEncoding: "base64", ...i }),
                    headers: i.headers,
                })
            ).json()
            return {
                Data: fromString$1(a.Data, "base64pad"),
                Links: (a.Links || []).map((l) => ({ Name: l.Name, Hash: CID.parse(l.Hash), Tsize: l.Size })),
            }
        }
        return e
    }),
    createLinks = configure((t) => {
        async function e(n, i = {}) {
            return (
                (
                    await (
                        await t.post("object/links", {
                            signal: i.signal,
                            searchParams: toUrlSearchParams({ arg: `${n instanceof Uint8Array ? CID.decode(n) : n}`, ...i }),
                            headers: i.headers,
                        })
                    ).json()
                ).Links || []
            ).map((l) => ({ Name: l.Name, Tsize: l.Size, Hash: CID.parse(l.Hash) }))
        }
        return e
    }),
    createNew = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("object/new", {
                    signal: n.signal,
                    searchParams: toUrlSearchParams({ arg: n.template, ...n }),
                    headers: n.headers,
                }),
                { Hash: o } = await i.json()
            return CID.parse(o)
        }
        return e
    }),
    createPut = (t, e) =>
        configure((i) => {
            const o = createPut$2(t, e)
            async function a(l, c = {}) {
                return o(l, { ...c, storeCodec: "dag-pb", hashAlg: "sha2-256", version: 1 })
            }
            return a
        })(e),
    createStat$1 = configure((t) => {
        async function e(n, i = {}) {
            const a = await (
                await t.post("object/stat", { signal: i.signal, searchParams: toUrlSearchParams({ arg: `${n}`, ...i }), headers: i.headers })
            ).json()
            return { ...a, Hash: CID.parse(a.Hash) }
        }
        return e
    }),
    createAddLink = configure((t) => {
        async function e(n, i, o = {}) {
            const a = await t.post("object/patch/add-link", {
                    signal: o.signal,
                    searchParams: toUrlSearchParams({ arg: [`${n}`, i.Name || i.name || "", (i.Hash || i.cid || "").toString() || null], ...o }),
                    headers: o.headers,
                }),
                { Hash: l } = await a.json()
            return CID.parse(l)
        }
        return e
    }),
    createAppendData = configure((t) => {
        async function e(n, i, o = {}) {
            const a = new AbortController(),
                l = abortSignal(a.signal, o.signal),
                c = await t.post("object/patch/append-data", {
                    signal: l,
                    searchParams: toUrlSearchParams({ arg: `${n}`, ...o }),
                    ...(await multipartRequest([i], a, o.headers)),
                }),
                { Hash: g } = await c.json()
            return CID.parse(g)
        }
        return e
    }),
    createRmLink = configure((t) => {
        async function e(n, i, o = {}) {
            const a = await t.post("object/patch/rm-link", {
                    signal: o.signal,
                    searchParams: toUrlSearchParams({ arg: [`${n}`, i.Name || i.name || null], ...o }),
                    headers: o.headers,
                }),
                { Hash: l } = await a.json()
            return CID.parse(l)
        }
        return e
    }),
    createSetData = configure((t) => {
        async function e(n, i, o = {}) {
            const a = new AbortController(),
                l = abortSignal(a.signal, o.signal),
                c = await t.post("object/patch/set-data", {
                    signal: l,
                    searchParams: toUrlSearchParams({ arg: [`${n}`], ...o }),
                    ...(await multipartRequest([i], a, o.headers)),
                }),
                { Hash: g } = await c.json()
            return CID.parse(g)
        }
        return e
    })
function createPatch(t) {
    return { addLink: createAddLink(t), appendData: createAppendData(t), rmLink: createRmLink(t), setData: createSetData(t) }
}
function createObject(t, e) {
    return {
        data: createData(e),
        get: createGet$1(e),
        links: createLinks(e),
        new: createNew(e),
        put: createPut(t, e),
        stat: createStat$1(e),
        patch: createPatch(e),
    }
}
async function* normaliseInput$1(t) {
    if (t == null) throw errCode(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT")
    const e = CID.asCID(t)
    if (e) {
        yield toPin$1({ cid: e })
        return
    }
    if (t instanceof String || typeof t == "string") {
        yield toPin$1({ path: t })
        return
    }
    if (t.cid != null || t.path != null) return yield toPin$1(t)
    if (Symbol.iterator in t) {
        const n = t[Symbol.iterator](),
            i = n.next()
        if (i.done) return n
        if (CID.asCID(i.value) || i.value instanceof String || typeof i.value == "string") {
            yield toPin$1({ cid: i.value })
            for (const o of n) yield toPin$1({ cid: o })
            return
        }
        if (i.value.cid != null || i.value.path != null) {
            yield toPin$1(i.value)
            for (const o of n) yield toPin$1(o)
            return
        }
        throw errCode(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT")
    }
    if (Symbol.asyncIterator in t) {
        const n = t[Symbol.asyncIterator](),
            i = await n.next()
        if (i.done) return n
        if (CID.asCID(i.value) || i.value instanceof String || typeof i.value == "string") {
            yield toPin$1({ cid: i.value })
            for await (const o of n) yield toPin$1({ cid: o })
            return
        }
        if (i.value.cid != null || i.value.path != null) {
            yield toPin$1(i.value)
            for await (const o of n) yield toPin$1(o)
            return
        }
        throw errCode(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT")
    }
    throw errCode(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT")
}
function toPin$1(t) {
    const e = t.cid || `${t.path}`
    if (!e) throw errCode(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT")
    const n = { path: e, recursive: t.recursive !== !1 }
    return t.metadata != null && (n.metadata = t.metadata), n
}
const createAddAll$1 = configure((t) => {
    async function* e(n, i = {}) {
        for await (const { path: o, recursive: a, metadata: l } of normaliseInput$1(n)) {
            const c = await t.post("pin/add", {
                signal: i.signal,
                searchParams: toUrlSearchParams({ ...i, arg: o, recursive: a, metadata: l ? JSON.stringify(l) : void 0, stream: !0 }),
                headers: i.headers,
            })
            for await (const g of c.ndjson()) {
                if (g.Pins) {
                    for (const v of g.Pins) yield CID.parse(v)
                    continue
                }
                yield CID.parse(g)
            }
        }
    }
    return e
})
function createAdd$3(t) {
    const e = createAddAll$1(t)
    return configure(() => {
        async function n(i, o = {}) {
            return itLast(e([{ path: i, ...o }], o))
        }
        return n
    })(t)
}
function toPin(t, e, n) {
    const i = { type: t, cid: CID.parse(e) }
    return n && (i.metadata = n), i
}
const createLs$4 = configure((t) => {
        async function* e(n = {}) {
            let i = []
            n.paths && (i = Array.isArray(n.paths) ? n.paths : [n.paths])
            const o = await t.post("pin/ls", {
                signal: n.signal,
                searchParams: toUrlSearchParams({ ...n, arg: i.map((a) => `${a}`), stream: !0 }),
                headers: n.headers,
            })
            for await (const a of o.ndjson()) {
                if (a.Keys) {
                    for (const l of Object.keys(a.Keys)) yield toPin(a.Keys[l].Type, l, a.Keys[l].Metadata)
                    return
                }
                yield toPin(a.Type, a.Cid, a.Metadata)
            }
        }
        return e
    }),
    createRmAll$1 = configure((t) => {
        async function* e(n, i = {}) {
            for await (const { path: o, recursive: a } of normaliseInput$1(n)) {
                const l = new URLSearchParams(i.searchParams)
                l.append("arg", `${o}`), a != null && l.set("recursive", String(a))
                const c = await t.post("pin/rm", {
                    signal: i.signal,
                    headers: i.headers,
                    searchParams: toUrlSearchParams({ ...i, arg: `${o}`, recursive: a }),
                })
                for await (const g of c.ndjson()) {
                    if (g.Pins) {
                        yield* g.Pins.map((v) => CID.parse(v))
                        continue
                    }
                    yield CID.parse(g)
                }
            }
        }
        return e
    }),
    createRm$2 = (t) => {
        const e = createRmAll$1(t)
        return configure(() => {
            async function n(i, o = {}) {
                return itLast(e([{ path: i, ...o }], o))
            }
            return n
        })(t)
    },
    decodePin = ({ Name: t, Status: e, Cid: n }) => ({ cid: CID.parse(n), name: t, status: e }),
    encodeService = (t) => {
        if (typeof t == "string" && t !== "") return t
        throw new TypeError("service name must be passed")
    },
    encodeCID = (t) => {
        if (CID.asCID(t)) return t.toString()
        throw new TypeError(`CID instance expected instead of ${typeof t}`)
    },
    encodeQuery = ({ service: t, cid: e, name: n, status: i, all: o }) => {
        const a = toUrlSearchParams({ service: encodeService(t), name: n, force: o ? !0 : void 0 })
        if (e) for (const l of e) a.append("cid", encodeCID(l))
        if (i) for (const l of i) a.append("status", l)
        return a
    },
    encodeAddParams = ({ cid: t, service: e, background: n, name: i, origins: o }) => {
        const a = toUrlSearchParams({ arg: encodeCID(t), service: encodeService(e), name: i, background: n ? !0 : void 0 })
        if (o) for (const l of o) a.append("origin", l.toString())
        return a
    }
function createAdd$2(t) {
    async function e(n, { timeout: i, signal: o, headers: a, ...l }) {
        const c = await t.post("pin/remote/add", { timeout: i, signal: o, headers: a, searchParams: encodeAddParams({ cid: n, ...l }) })
        return decodePin(await c.json())
    }
    return e
}
function createLs$3(t) {
    async function* e({ timeout: n, signal: i, headers: o, ...a }) {
        const l = await t.post("pin/remote/ls", { timeout: n, signal: i, headers: o, searchParams: encodeQuery(a) })
        for await (const c of l.ndjson()) yield decodePin(c)
    }
    return e
}
function createRm$1(t) {
    async function e({ timeout: n, signal: i, headers: o, ...a }) {
        await t.post("pin/remote/rm", { timeout: n, signal: i, headers: o, searchParams: encodeQuery({ ...a, all: !1 }) })
    }
    return e
}
function createRmAll(t) {
    async function e({ timeout: n, signal: i, headers: o, ...a }) {
        await t.post("pin/remote/rm", { timeout: n, signal: i, headers: o, searchParams: encodeQuery({ ...a, all: !0 }) })
    }
    return e
}
function encodeEndpoint(t) {
    const e = String(t)
    if (e === "undefined") throw Error("endpoint is required")
    return e[e.length - 1] === "/" ? e.slice(0, -1) : e
}
function decodeRemoteService(t) {
    return { service: t.Service, endpoint: new URL(t.ApiEndpoint), ...(t.Stat && { stat: decodeStat(t.Stat) }) }
}
function decodeStat(t) {
    switch (t.Status) {
        case "valid": {
            const { Pinning: e, Pinned: n, Queued: i, Failed: o } = t.PinCount
            return { status: "valid", pinCount: { queued: i, pinning: e, pinned: n, failed: o } }
        }
        case "invalid":
            return { status: "invalid" }
        default:
            return { status: t.Status }
    }
}
function createAdd$1(t) {
    async function e(n, i) {
        const { endpoint: o, key: a, headers: l, timeout: c, signal: g } = i
        await t.post("pin/remote/service/add", {
            timeout: c,
            signal: g,
            searchParams: toUrlSearchParams({ arg: [n, encodeEndpoint(o), a] }),
            headers: l,
        })
    }
    return e
}
function createLs$2(t) {
    async function e(n = {}) {
        const { stat: i, headers: o, timeout: a, signal: l } = n,
            c = await t.post("pin/remote/service/ls", {
                timeout: a,
                signal: l,
                headers: o,
                searchParams: i === !0 ? toUrlSearchParams({ stat: i }) : void 0,
            }),
            { RemoteServices: g } = await c.json()
        return g.map(decodeRemoteService)
    }
    return e
}
function createRm(t) {
    async function e(n, i = {}) {
        await t.post("pin/remote/service/rm", { signal: i.signal, headers: i.headers, searchParams: toUrlSearchParams({ arg: n }) })
    }
    return e
}
function createService(t) {
    const e = new Client(t)
    return { add: createAdd$1(e), ls: createLs$2(e), rm: createRm(e) }
}
function createRemote(t) {
    const e = new Client(t)
    return { add: createAdd$2(e), ls: createLs$3(e), rm: createRm$1(e), rmAll: createRmAll(e), service: createService(t) }
}
function createPin(t) {
    return {
        addAll: createAddAll$1(t),
        add: createAdd$3(t),
        ls: createLs$4(t),
        rmAll: createRmAll$1(t),
        rm: createRm$2(t),
        remote: createRemote(t),
    }
}
const rpcArrayToTextArray = (t) => (Array.isArray(t) ? t.map(rpcToText) : t),
    rpcToText = (t) => toString$2(rpcToBytes(t)),
    rpcToBytes = (t) => base64url.decode(t),
    rpcToBigInt = (t) => BigInt(`0x${toString$2(base64url.decode(t), "base16")}`),
    textToUrlSafeRpc = (t) => base64url.encode(fromString$1(t)),
    createLs$1 = configure((t) => {
        async function e(n = {}) {
            const { Strings: i } = await (
                await t.post("pubsub/ls", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })
            ).json()
            return rpcArrayToTextArray(i) || []
        }
        return e
    }),
    createPeers$1 = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("pubsub/peers", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: textToUrlSafeRpc(n), ...i }),
                    headers: i.headers,
                }),
                { Strings: a } = await o.json()
            return a || []
        }
        return e
    }),
    createPublish = configure((t) => {
        async function e(n, i, o = {}) {
            const a = toUrlSearchParams({ arg: textToUrlSafeRpc(n), ...o }),
                l = new AbortController(),
                c = abortSignal(l.signal, o.signal)
            await (await t.post("pubsub/pub", { signal: c, searchParams: a, ...(await multipartRequest([i], l, o.headers)) })).text()
        }
        return e
    }),
    log = logger("ipfs-http-client:pubsub:subscribe"),
    createSubscribe = (t, e) =>
        configure((n) => {
            async function i(o, a, l = {}) {
                l.signal = e.subscribe(o, a, l.signal)
                let c, g
                const v = new Promise((A, B) => {
                        ;(c = A), (g = B)
                    }),
                    _ = setTimeout(() => c(), 1e3)
                return (
                    n
                        .post("pubsub/sub", {
                            signal: l.signal,
                            searchParams: toUrlSearchParams({ arg: textToUrlSafeRpc(o), ...l }),
                            headers: l.headers,
                        })
                        .catch((A) => {
                            e.unsubscribe(o, a), g(A)
                        })
                        .then((A) => {
                            clearTimeout(_),
                                A &&
                                    (readMessages(A, {
                                        onMessage: (B) => {
                                            if (!!a) {
                                                if (typeof a == "function") {
                                                    a(B)
                                                    return
                                                }
                                                typeof a.handleEvent == "function" && a.handleEvent(B)
                                            }
                                        },
                                        onEnd: () => e.unsubscribe(o, a),
                                        onError: l.onError,
                                    }),
                                    c())
                        }),
                    v
                )
            }
            return i
        })(t)
async function readMessages(t, { onMessage: e, onEnd: n, onError: i }) {
    var o, a
    i = i || log
    try {
        for await (const l of t.ndjson())
            try {
                if (!l.from) continue
                l.from != null && l.seqno != null
                    ? e({
                          type: "signed",
                          from: peerIdFromString(l.from),
                          data: rpcToBytes(l.data),
                          sequenceNumber: rpcToBigInt(l.seqno),
                          topic: rpcToText(l.topicIDs[0]),
                          key: rpcToBytes((o = l.key) != null ? o : "u"),
                          signature: rpcToBytes((a = l.signature) != null ? a : "u"),
                      })
                    : e({ type: "unsigned", data: rpcToBytes(l.data), topic: rpcToText(l.topicIDs[0]) })
            } catch (c) {
                ;(c.message = `Failed to parse pubsub message: ${c.message}`), i(c, !1, l)
            }
    } catch (l) {
        isAbortError(l) || i(l, !0)
    } finally {
        n()
    }
}
const isAbortError = (t) => {
        switch (t.type) {
            case "aborted":
                return !0
            case "abort":
                return !0
            default:
                return t.name === "AbortError"
        }
    },
    createUnsubscribe = (t, e) => {
        async function n(i, o) {
            e.unsubscribe(i, o)
        }
        return n
    }
class SubscriptionTracker {
    constructor() {
        this._subs = new Map()
    }
    subscribe(e, n, i) {
        const o = this._subs.get(e) || []
        if (o.find((l) => l.handler === n)) throw new Error(`Already subscribed to ${e} with this handler`)
        const a = new AbortController()
        return (
            this._subs.set(e, [{ handler: n, controller: a }].concat(o)),
            i && i.addEventListener("abort", () => this.unsubscribe(e, n)),
            a.signal
        )
    }
    unsubscribe(e, n) {
        const i = this._subs.get(e) || []
        let o
        n
            ? (this._subs.set(
                  e,
                  i.filter((a) => a.handler !== n)
              ),
              (o = i.filter((a) => a.handler === n)))
            : (this._subs.set(e, []), (o = i)),
            (this._subs.get(e) || []).length || this._subs.delete(e),
            o.forEach((a) => a.controller.abort())
    }
}
function createPubsub(t) {
    const e = new SubscriptionTracker()
    return {
        ls: createLs$1(t),
        peers: createPeers$1(t),
        publish: createPublish(t),
        subscribe: createSubscribe(t, e),
        unsubscribe: createUnsubscribe(t, e),
    }
}
const createLocal = configure((t) => {
        async function* e(n = {}) {
            yield* (
                await t.post("refs/local", {
                    signal: n.signal,
                    transform: objectToCamel,
                    searchParams: toUrlSearchParams(n),
                    headers: n.headers,
                })
            ).ndjson()
        }
        return e
    }),
    createRefs = configure((t, e) =>
        Object.assign(
            async function* (i, o = {}) {
                const a = Array.isArray(i) ? i : [i]
                yield* (
                    await t.post("refs", {
                        signal: o.signal,
                        searchParams: toUrlSearchParams({ arg: a.map((c) => `${c instanceof Uint8Array ? CID.decode(c) : c}`), ...o }),
                        headers: o.headers,
                        transform: objectToCamel,
                    })
                ).ndjson()
            },
            { local: createLocal(e) }
        )
    ),
    createGc = configure((t) => {
        async function* e(n = {}) {
            yield* (
                await t.post("repo/gc", {
                    signal: n.signal,
                    searchParams: toUrlSearchParams(n),
                    headers: n.headers,
                    transform: (o) => ({ err: o.Error ? new Error(o.Error) : null, cid: (o.Key || {})["/"] ? CID.parse(o.Key["/"]) : null }),
                })
            ).ndjson()
        }
        return e
    }),
    createStat = configure((t) => {
        async function e(n = {}) {
            const o = await (await t.post("repo/stat", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
            return {
                numObjects: BigInt(o.NumObjects),
                repoSize: BigInt(o.RepoSize),
                repoPath: o.RepoPath,
                version: o.Version,
                storageMax: BigInt(o.StorageMax),
            }
        }
        return e
    }),
    createVersion$1 = configure((t) => {
        async function e(n = {}) {
            return (await (await t.post("repo/version", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json())
                .Version
        }
        return e
    })
function createRepo(t) {
    return { gc: createGc(t), stat: createStat(t), version: createVersion$1(t) }
}
const createBw = configure((t) => {
    async function* e(n = {}) {
        yield* (
            await t.post("stats/bw", {
                signal: n.signal,
                searchParams: toUrlSearchParams(n),
                headers: n.headers,
                transform: (o) => ({
                    totalIn: BigInt(o.TotalIn),
                    totalOut: BigInt(o.TotalOut),
                    rateIn: parseFloat(o.RateIn),
                    rateOut: parseFloat(o.RateOut),
                }),
            })
        ).ndjson()
    }
    return e
})
function createStats(t) {
    return { bitswap: createStat$4(t), repo: createStat(t), bw: createBw(t) }
}
const createAddrs = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("swarm/addrs", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers }),
                { Addrs: o } = await i.json()
            return Object.keys(o).map((a) => ({ id: peerIdFromString(a), addrs: (o[a] || []).map((l) => new Multiaddr(l)) }))
        }
        return e
    }),
    createConnect = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("swarm/connect", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers }),
                { Strings: a } = await o.json()
            return a || []
        }
        return e
    }),
    createDisconnect = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("swarm/disconnect", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: n, ...i }),
                    headers: i.headers,
                }),
                { Strings: a } = await o.json()
            return a || []
        }
        return e
    }),
    createLocalAddrs = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("swarm/addrs/local", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers }),
                { Strings: o } = await i.json()
            return (o || []).map((a) => new Multiaddr(a))
        }
        return e
    }),
    createPeers = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("swarm/peers", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers }),
                { Peers: o } = await i.json()
            return (o || []).map((a) => ({
                addr: new Multiaddr(a.Addr),
                peer: peerIdFromString(a.Peer),
                muxer: a.Muxer,
                latency: a.Latency,
                streams: a.Streams,
                direction: a.Direction == null ? void 0 : a.Direction === 0 ? "inbound" : "outbound",
            }))
        }
        return e
    })
function createSwarm(t) {
    return {
        addrs: createAddrs(t),
        connect: createConnect(t),
        disconnect: createDisconnect(t),
        localAddrs: createLocalAddrs(t),
        peers: createPeers(t),
    }
}
const createAddAll = configure((t) => {
        async function* e(n, i = {}) {
            const o = new AbortController(),
                a = abortSignal(o.signal, i.signal),
                { headers: l, body: c, total: g, parts: v } = await multipartRequest(n, o, i.headers),
                [_, A] = typeof i.progress == "function" ? createProgressHandler(g, v, i.progress) : [void 0, void 0],
                B = await t.post("add", {
                    searchParams: toUrlSearchParams({ "stream-channels": !0, ...i, progress: Boolean(_) }),
                    onUploadProgress: A,
                    signal: a,
                    headers: l,
                    body: c,
                })
            for await (let D of B.ndjson()) (D = objectToCamel(D)), D.hash !== void 0 ? yield toCoreInterface(D) : _ && _(D.bytes || 0, D.name)
        }
        return e
    }),
    createProgressHandler = (t, e, n) => (e ? [void 0, createOnUploadProgress(t, e, n)] : [n, void 0]),
    createOnUploadProgress = (t, e, n) => {
        let i = 0
        const o = e.length
        return ({ loaded: a, total: l }) => {
            const c = Math.floor((a / l) * t)
            for (; i < o; ) {
                const { start: g, end: v, name: _ } = e[i]
                if (c < v) {
                    n(c - g, _)
                    break
                } else n(v - g, _), (i += 1)
            }
        }
    }
function toCoreInterface({ name: t, hash: e, size: n, mode: i, mtime: o, mtimeNsecs: a }) {
    const l = { path: t, cid: CID.parse(e), size: parseInt(n) }
    return i != null && (l.mode = parseInt(i, 8)), o != null && (l.mtime = { secs: o, nsecs: a || 0 }), l
}
const browserReadableStreamToIt = browserReadablestreamToIt
function blobToIt(t) {
    return typeof t.stream == "function" ? browserReadableStreamToIt(t.stream()) : browserReadableStreamToIt(new Response(t).body)
}
var blobToIt_1 = blobToIt
async function* toAsyncIterable(t) {
    yield t
}
async function normaliseContent(t) {
    if (isBytes(t)) return toAsyncIterable(toBytes(t))
    if (typeof t == "string" || t instanceof String) return toAsyncIterable(toBytes(t.toString()))
    if (isBlob(t)) return blobToIt_1(t)
    if ((isReadableStream(t) && (t = browserReadablestreamToIt(t)), Symbol.iterator in t || Symbol.asyncIterator in t)) {
        const e = itPeekable(t),
            { value: n, done: i } = await e.peek()
        if (i) return toAsyncIterable(new Uint8Array(0))
        if ((e.push(n), Number.isInteger(n))) return toAsyncIterable(Uint8Array.from(await itAll(e)))
        if (isBytes(n) || typeof n == "string" || n instanceof String) return itMap(e, toBytes)
    }
    throw errCode(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT")
}
function toBytes(t) {
    return t instanceof Uint8Array
        ? t
        : ArrayBuffer.isView(t)
        ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
        : t instanceof ArrayBuffer
        ? new Uint8Array(t)
        : Array.isArray(t)
        ? Uint8Array.from(t)
        : fromString$1(t.toString())
}
async function* normaliseCandidateSingle(t, e) {
    if (t == null) throw errCode(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT")
    if (typeof t == "string" || t instanceof String) {
        yield toFileObject(t.toString(), e)
        return
    }
    if (isBytes(t) || isBlob(t)) {
        yield toFileObject(t, e)
        return
    }
    if ((isReadableStream(t) && (t = browserReadablestreamToIt(t)), Symbol.iterator in t || Symbol.asyncIterator in t)) {
        const n = itPeekable(t),
            { value: i, done: o } = await n.peek()
        if (o) {
            yield { content: [] }
            return
        }
        if ((n.push(i), Number.isInteger(i) || isBytes(i) || typeof i == "string" || i instanceof String)) {
            yield toFileObject(n, e)
            return
        }
        throw errCode(
            new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),
            "ERR_UNEXPECTED_INPUT"
        )
    }
    if (isFileObject(t)) {
        yield toFileObject(t, e)
        return
    }
    throw errCode(new Error('Unexpected input: cannot convert "' + typeof t + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT")
}
async function toFileObject(t, e) {
    const { path: n, mode: i, mtime: o, content: a } = t,
        l = { path: n || "", mode: parseMode(i), mtime: parseMtime(o) }
    return a ? (l.content = await e(a)) : n || (l.content = await e(t)), l
}
function normaliseInput(t) {
    return normaliseCandidateSingle(t, normaliseContent)
}
function createAdd(t) {
    const e = createAddAll(t)
    return configure(() => {
        async function n(i, o = {}) {
            return await itLast(e(normaliseInput(i), o))
        }
        return n
    })(t)
}
const createCat = configure((t) => {
        async function* e(n, i = {}) {
            yield* (
                await t.post("cat", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n.toString(), ...i }), headers: i.headers })
            ).iterator()
        }
        return e
    }),
    createCommands = configure(
        (t) =>
            async (n = {}) =>
                (await t.post("commands", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).json()
    ),
    createDns = configure(
        (t) =>
            async (n, i = {}) =>
                (await (await t.post("dns", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers })).json())
                    .Path
    ),
    createGetEndpointConfig = configure((t) => () => {
        const e = new URL(t.opts.base || "")
        return { host: e.hostname, port: e.port, protocol: e.protocol, pathname: e.pathname, "api-path": e.pathname }
    }),
    createGet = configure((t) => {
        async function* e(n, i = {}) {
            const o = { arg: `${n instanceof Uint8Array ? CID.decode(n) : n}`, ...i }
            o.compressionLevel && ((o["compression-level"] = o.compressionLevel), delete o.compressionLevel),
                yield* (await t.post("get", { signal: i.signal, searchParams: toUrlSearchParams(o), headers: i.headers })).iterator()
        }
        return e
    }),
    createId = configure((t) => {
        async function e(n = {}) {
            const o = await (
                    await t.post("id", {
                        signal: n.signal,
                        searchParams: toUrlSearchParams({ arg: n.peerId ? n.peerId.toString() : void 0, ...n }),
                        headers: n.headers,
                    })
                ).json(),
                a = { ...objectToCamel(o) }
            return (a.id = peerIdFromString(a.id)), a.addresses && (a.addresses = a.addresses.map((l) => new Multiaddr(l))), a
        }
        return e
    }),
    createIsOnline = (t) => {
        const e = createId(t)
        async function n(i = {}) {
            const o = await e(i)
            return Boolean(o && o.addresses && o.addresses.length)
        }
        return n
    },
    createLs = configure((t, e) => {
        async function* n(i, o = {}) {
            const a = `${i instanceof Uint8Array ? CID.decode(i) : i}`
            async function l(g) {
                let v = g.Hash
                if (v.includes("/")) {
                    const A = v.startsWith("/ipfs/") ? v : `/ipfs/${v}`
                    v = (await createStat$2(e)(A)).cid
                } else v = CID.parse(v)
                const _ = { name: g.Name, path: a + (g.Name ? `/${g.Name}` : ""), size: g.Size, cid: v, type: typeOf(g) }
                return (
                    g.Mode && (_.mode = parseInt(g.Mode, 8)),
                    g.Mtime !== void 0 &&
                        g.Mtime !== null &&
                        ((_.mtime = { secs: g.Mtime }), g.MtimeNsecs !== void 0 && g.MtimeNsecs !== null && (_.mtime.nsecs = g.MtimeNsecs)),
                    _
                )
            }
            const c = await t.post("ls", { signal: o.signal, searchParams: toUrlSearchParams({ arg: a, ...o }), headers: o.headers })
            for await (let g of c.ndjson()) {
                if (((g = g.Objects), !g)) throw new Error("expected .Objects in results")
                if (((g = g[0]), !g)) throw new Error("expected one array in results.Objects")
                const v = g.Links
                if (!Array.isArray(v)) throw new Error("expected one array in results.Objects[0].Links")
                if (!v.length) {
                    yield l(g)
                    return
                }
                yield* v.map(l)
            }
        }
        return n
    })
function typeOf(t) {
    switch (t.Type) {
        case 1:
        case 5:
            return "dir"
        case 2:
            return "file"
        default:
            return "file"
    }
}
const createMount = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("dns", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })
            return objectToCamel(await i.json())
        }
        return e
    }),
    createPing = configure((t) => {
        async function* e(n, i = {}) {
            yield* (
                await t.post("ping", {
                    signal: i.signal,
                    searchParams: toUrlSearchParams({ arg: `${n}`, ...i }),
                    headers: i.headers,
                    transform: objectToCamel,
                })
            ).ndjson()
        }
        return e
    }),
    createResolve = configure((t) => {
        async function e(n, i = {}) {
            const o = await t.post("resolve", { signal: i.signal, searchParams: toUrlSearchParams({ arg: n, ...i }), headers: i.headers }),
                { Path: a } = await o.json()
            return a
        }
        return e
    }),
    createStart = configure((t) => async (n = {}) => {
        throw errCode(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")
    }),
    createStop = configure((t) => {
        async function e(n = {}) {
            await (await t.post("shutdown", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })).text()
        }
        return e
    }),
    createVersion = configure((t) => {
        async function e(n = {}) {
            const i = await t.post("version", { signal: n.signal, searchParams: toUrlSearchParams(n), headers: n.headers })
            return { ...objectToCamel(await i.json()), "ipfs-http-client": "1.0.0" }
        }
        return e
    })
function create(t = {}) {
    const e = { name: identity$1.name, code: identity$1.code, encode: (v) => v, decode: (v) => v },
        n = Object.values(bases)
    ;(t.ipld && t.ipld.bases ? t.ipld.bases : []).forEach((v) => n.push(v))
    const i = new Multibases({ bases: n, loadBase: t.ipld && t.ipld.loadBase }),
        o = Object.values(codecs)
    ;[dagPB, dagCBOR, dagJSON, dagJOSE, e].concat((t.ipld && t.ipld.codecs) || []).forEach((v) => o.push(v))
    const a = new Multicodecs({ codecs: o, loadCodec: t.ipld && t.ipld.loadCodec }),
        l = Object.values(hashes)
    ;(t.ipld && t.ipld.hashers ? t.ipld.hashers : []).forEach((v) => l.push(v))
    const c = new Multihashes({ hashers: l, loadHasher: t.ipld && t.ipld.loadHasher })
    return {
        add: createAdd(t),
        addAll: createAddAll(t),
        bitswap: createBitswap(t),
        block: createBlock(t),
        bootstrap: createBootstrap(t),
        cat: createCat(t),
        commands: createCommands(t),
        config: createConfig(t),
        dag: createDag(a, t),
        dht: createDht(t),
        diag: createDiag(t),
        dns: createDns(t),
        files: createFiles(t),
        get: createGet(t),
        getEndpointConfig: createGetEndpointConfig(t),
        id: createId(t),
        isOnline: createIsOnline(t),
        key: createKey(t),
        log: createLog(t),
        ls: createLs(t),
        mount: createMount(t),
        name: createName(t),
        object: createObject(a, t),
        pin: createPin(t),
        ping: createPing(t),
        pubsub: createPubsub(t),
        refs: createRefs(t),
        repo: createRepo(t),
        resolve: createResolve(t),
        start: createStart(t),
        stats: createStats(t),
        stop: createStop(t),
        swarm: createSwarm(t),
        version: createVersion(t),
        bases: i,
        codecs: a,
        hashers: c,
    }
}
/*! js-cookie v3.0.1 | MIT */ function assign(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e]
        for (var i in n) t[i] = n[i]
    }
    return t
}
var defaultConverter = {
    read: function (t) {
        return t[0] === '"' && (t = t.slice(1, -1)), t.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function (t) {
        return encodeURIComponent(t).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
    },
}
function init(t, e) {
    function n(o, a, l) {
        if (typeof document != "undefined") {
            ;(l = assign({}, e, l)),
                typeof l.expires == "number" && (l.expires = new Date(Date.now() + l.expires * 864e5)),
                l.expires && (l.expires = l.expires.toUTCString()),
                (o = encodeURIComponent(o)
                    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
                    .replace(/[()]/g, escape))
            var c = ""
            for (var g in l) !l[g] || ((c += "; " + g), l[g] !== !0 && (c += "=" + l[g].split(";")[0]))
            return (document.cookie = o + "=" + t.write(a, o) + c)
        }
    }
    function i(o) {
        if (!(typeof document == "undefined" || (arguments.length && !o))) {
            for (var a = document.cookie ? document.cookie.split("; ") : [], l = {}, c = 0; c < a.length; c++) {
                var g = a[c].split("="),
                    v = g.slice(1).join("=")
                try {
                    var _ = decodeURIComponent(g[0])
                    if (((l[_] = t.read(v, _)), o === _)) break
                } catch {}
            }
            return o ? l[o] : l
        }
    }
    return Object.create(
        {
            set: n,
            get: i,
            remove: function (o, a) {
                n(o, "", assign({}, a, { expires: -1 }))
            },
            withAttributes: function (o) {
                return init(this.converter, assign({}, this.attributes, o))
            },
            withConverter: function (o) {
                return init(assign({}, this.converter, o), this.attributes)
            },
        },
        { attributes: { value: Object.freeze(e) }, converter: { value: Object.freeze(t) } }
    )
}
var api = init(defaultConverter, { path: "/" })
const _hoisted_1$7 = { class: "h-100" },
    _hoisted_2$6 = createTextVNode(" Loading... "),
    _sfc_main$7 = defineComponent({
        __name: "App",
        setup(t) {
            const e = inject("app"),
                n = useRoute()
            watch(
                () => n.query,
                () => {
                    n.query.g && isAddress(n.query.g) && api.set("g", n.query.g)
                    const g = api.get("g")
                    g && (e.gallery = g)
                }
            )
            const i = api.get("g")
            i && (e.gallery = i)
            const o = new connectors[Network.ETHEREUM](),
                a = UnRealArt__factory.connect("0x8d41Bd479622B68ecF5E59d68B1a2400bE465052", o.provider),
                l = ref(!1)
            return (
                watch(
                    () => e.web3.active.length,
                    (g) => {
                        l.value = g > 0
                    }
                ),
                (async () => {
                    const g = "2EM0rRSPLVa1Tz9VokxlzHYdwR6",
                        v = "88b89157de2c00f3a2e75ff31f71d0d7"
                    e.ipfs = await create({
                        host: "ipfs.infura.io",
                        port: 5001,
                        protocol: "https",
                        headers: { Authorization: "Basic " + btoa(g + ":" + v) },
                    })
                    const _ = (await a.seriesCount()).toNumber()
                    for (let A = e.series.length; A < _; A++) {
                        console.log("Loading series " + A)
                        const B = await a.getSerie(A)
                        e.series.push({
                            creator: B.creator,
                            author: B.author,
                            name: B.name,
                            description: B.description,
                            process: B.process,
                            price: B.price,
                            images: B.artworks,
                        })
                    }
                })(),
                (g, v) => {
                    const _ = resolveComponent("router-view"),
                        A = resolveComponent("b-modal")
                    return (
                        openBlock(),
                        createElementBlock(
                            Fragment$1,
                            null,
                            [
                                createVNode(
                                    _,
                                    { style: { height: "100%" } },
                                    {
                                        default: withCtx(({ Component: B }) => [
                                            (openBlock(),
                                            createBlock$1(
                                                Suspense,
                                                null,
                                                {
                                                    fallback: withCtx(() => [_hoisted_2$6]),
                                                    default: withCtx(() => [
                                                        createBaseVNode("div", _hoisted_1$7, [
                                                            (openBlock(), createBlock$1(resolveDynamicComponent(B), { class: "h-100" })),
                                                        ]),
                                                    ]),
                                                    _: 2,
                                                },
                                                1024
                                            )),
                                        ]),
                                        _: 1,
                                    }
                                ),
                                createVNode(
                                    A,
                                    {
                                        modelValue: l.value,
                                        "onUpdate:modelValue": v[0] || (v[0] = (B) => (l.value = B)),
                                        title: "Transactions",
                                        hideFooter: "",
                                        centered: "",
                                    },
                                    {
                                        default: withCtx(() => [
                                            (openBlock(!0),
                                            createElementBlock(
                                                Fragment$1,
                                                null,
                                                renderList(
                                                    unref(e).web3.active,
                                                    (B) => (
                                                        openBlock(),
                                                        createElementBlock(
                                                            "div",
                                                            null,
                                                            toDisplayString(B.description) + " - " + toDisplayString(B.status),
                                                            1
                                                        )
                                                    )
                                                ),
                                                256
                                            )),
                                        ]),
                                        _: 1,
                                    },
                                    8,
                                    ["modelValue"]
                                ),
                            ],
                            64
                        )
                    )
                }
            )
        },
    })
var _imports_0 = "/frame.jpg",
    lib = { exports: {} },
    require$$0 = getAugmentedNamespace(vue_runtime_esmBundler)
;(function (t, e) {
    ;(function (n, i) {
        t.exports = i(require$$0)
    })(self, function (n) {
        return (() => {
            var i = {
                    192: (c, g) => {
                        var v,
                            _,
                            A = (function () {
                                var B = function (E, $) {
                                    var N = E,
                                        M = F[$],
                                        R = null,
                                        C = 0,
                                        S = null,
                                        b = [],
                                        T = {},
                                        Q = function (H, j) {
                                            ;(R = (function (q) {
                                                for (var ae = new Array(q), te = 0; te < q; te += 1) {
                                                    ae[te] = new Array(q)
                                                    for (var fe = 0; fe < q; fe += 1) ae[te][fe] = null
                                                }
                                                return ae
                                            })((C = 4 * N + 17))),
                                                k(0, 0),
                                                k(C - 7, 0),
                                                k(0, C - 7),
                                                J(),
                                                W(),
                                                ne(H, j),
                                                N >= 7 && ee(H),
                                                S == null && (S = ce(N, M, b)),
                                                xe(S, j)
                                        },
                                        k = function (H, j) {
                                            for (var q = -1; q <= 7; q += 1)
                                                if (!(H + q <= -1 || C <= H + q))
                                                    for (var ae = -1; ae <= 7; ae += 1)
                                                        j + ae <= -1 ||
                                                            C <= j + ae ||
                                                            (R[H + q][j + ae] =
                                                                (0 <= q && q <= 6 && (ae == 0 || ae == 6)) ||
                                                                (0 <= ae && ae <= 6 && (q == 0 || q == 6)) ||
                                                                (2 <= q && q <= 4 && 2 <= ae && ae <= 4))
                                        },
                                        W = function () {
                                            for (var H = 8; H < C - 8; H += 1) R[H][6] == null && (R[H][6] = H % 2 == 0)
                                            for (var j = 8; j < C - 8; j += 1) R[6][j] == null && (R[6][j] = j % 2 == 0)
                                        },
                                        J = function () {
                                            for (var H = Z.getPatternPosition(N), j = 0; j < H.length; j += 1)
                                                for (var q = 0; q < H.length; q += 1) {
                                                    var ae = H[j],
                                                        te = H[q]
                                                    if (R[ae][te] == null)
                                                        for (var fe = -2; fe <= 2; fe += 1)
                                                            for (var Se = -2; Se <= 2; Se += 1)
                                                                R[ae + fe][te + Se] =
                                                                    fe == -2 || fe == 2 || Se == -2 || Se == 2 || (fe == 0 && Se == 0)
                                                }
                                        },
                                        ee = function (H) {
                                            for (var j = Z.getBCHTypeNumber(N), q = 0; q < 18; q += 1) {
                                                var ae = !H && ((j >> q) & 1) == 1
                                                R[Math.floor(q / 3)][(q % 3) + C - 8 - 3] = ae
                                            }
                                            for (q = 0; q < 18; q += 1)
                                                (ae = !H && ((j >> q) & 1) == 1), (R[(q % 3) + C - 8 - 3][Math.floor(q / 3)] = ae)
                                        },
                                        ne = function (H, j) {
                                            for (var q = (M << 3) | j, ae = Z.getBCHTypeInfo(q), te = 0; te < 15; te += 1) {
                                                var fe = !H && ((ae >> te) & 1) == 1
                                                te < 6 ? (R[te][8] = fe) : te < 8 ? (R[te + 1][8] = fe) : (R[C - 15 + te][8] = fe)
                                            }
                                            for (te = 0; te < 15; te += 1)
                                                (fe = !H && ((ae >> te) & 1) == 1),
                                                    te < 8
                                                        ? (R[8][C - te - 1] = fe)
                                                        : te < 9
                                                        ? (R[8][15 - te - 1 + 1] = fe)
                                                        : (R[8][15 - te - 1] = fe)
                                            R[C - 8][8] = !H
                                        },
                                        xe = function (H, j) {
                                            for (var q = -1, ae = C - 1, te = 7, fe = 0, Se = Z.getMaskFunction(j), ue = C - 1; ue > 0; ue -= 2)
                                                for (ue == 6 && (ue -= 1); ; ) {
                                                    for (var me = 0; me < 2; me += 1)
                                                        if (R[ae][ue - me] == null) {
                                                            var _e = !1
                                                            fe < H.length && (_e = ((H[fe] >>> te) & 1) == 1),
                                                                Se(ae, ue - me) && (_e = !_e),
                                                                (R[ae][ue - me] = _e),
                                                                (te -= 1) == -1 && ((fe += 1), (te = 7))
                                                        }
                                                    if ((ae += q) < 0 || C <= ae) {
                                                        ;(ae -= q), (q = -q)
                                                        break
                                                    }
                                                }
                                        },
                                        ce = function (H, j, q) {
                                            for (var ae = ie.getRSBlocks(H, j), te = he(), fe = 0; fe < q.length; fe += 1) {
                                                var Se = q[fe]
                                                te.put(Se.getMode(), 4), te.put(Se.getLength(), Z.getLengthInBits(Se.getMode(), H)), Se.write(te)
                                            }
                                            var ue = 0
                                            for (fe = 0; fe < ae.length; fe += 1) ue += ae[fe].dataCount
                                            if (te.getLengthInBits() > 8 * ue)
                                                throw "code length overflow. (" + te.getLengthInBits() + ">" + 8 * ue + ")"
                                            for (te.getLengthInBits() + 4 <= 8 * ue && te.put(0, 4); te.getLengthInBits() % 8 != 0; )
                                                te.putBit(!1)
                                            for (; !(te.getLengthInBits() >= 8 * ue || (te.put(236, 8), te.getLengthInBits() >= 8 * ue)); )
                                                te.put(17, 8)
                                            return (function (me, _e) {
                                                for (
                                                    var Ce = 0, ke = 0, Re = 0, Ne = new Array(_e.length), Me = new Array(_e.length), He = 0;
                                                    He < _e.length;
                                                    He += 1
                                                ) {
                                                    var Fe = _e[He].dataCount,
                                                        Le = _e[He].totalCount - Fe
                                                    ;(ke = Math.max(ke, Fe)), (Re = Math.max(Re, Le)), (Ne[He] = new Array(Fe))
                                                    for (var $t = 0; $t < Ne[He].length; $t += 1) Ne[He][$t] = 255 & me.getBuffer()[$t + Ce]
                                                    Ce += Fe
                                                    var nt = Z.getErrorCorrectPolynomial(Le),
                                                        lt = X(Ne[He], nt.getLength() - 1).mod(nt)
                                                    for (Me[He] = new Array(nt.getLength() - 1), $t = 0; $t < Me[He].length; $t += 1) {
                                                        var Zr = $t + lt.getLength() - Me[He].length
                                                        Me[He][$t] = Zr >= 0 ? lt.getAt(Zr) : 0
                                                    }
                                                }
                                                var kt = 0
                                                for ($t = 0; $t < _e.length; $t += 1) kt += _e[$t].totalCount
                                                var Ze = new Array(kt),
                                                    Xr = 0
                                                for ($t = 0; $t < ke; $t += 1)
                                                    for (He = 0; He < _e.length; He += 1)
                                                        $t < Ne[He].length && ((Ze[Xr] = Ne[He][$t]), (Xr += 1))
                                                for ($t = 0; $t < Re; $t += 1)
                                                    for (He = 0; He < _e.length; He += 1)
                                                        $t < Me[He].length && ((Ze[Xr] = Me[He][$t]), (Xr += 1))
                                                return Ze
                                            })(te, ae)
                                        }
                                    ;(T.addData = function (H, j) {
                                        var q = null
                                        switch ((j = j || "Byte")) {
                                            case "Numeric":
                                                q = oe(H)
                                                break
                                            case "Alphanumeric":
                                                q = le(H)
                                                break
                                            case "Byte":
                                                q = Te(H)
                                                break
                                            case "Kanji":
                                                q = ye(H)
                                                break
                                            default:
                                                throw "mode:" + j
                                        }
                                        b.push(q), (S = null)
                                    }),
                                        (T.isDark = function (H, j) {
                                            if (H < 0 || C <= H || j < 0 || C <= j) throw H + "," + j
                                            return R[H][j]
                                        }),
                                        (T.getModuleCount = function () {
                                            return C
                                        }),
                                        (T.make = function () {
                                            if (N < 1) {
                                                for (var H = 1; H < 40; H++) {
                                                    for (var j = ie.getRSBlocks(H, M), q = he(), ae = 0; ae < b.length; ae++) {
                                                        var te = b[ae]
                                                        q.put(te.getMode(), 4),
                                                            q.put(te.getLength(), Z.getLengthInBits(te.getMode(), H)),
                                                            te.write(q)
                                                    }
                                                    var fe = 0
                                                    for (ae = 0; ae < j.length; ae++) fe += j[ae].dataCount
                                                    if (q.getLengthInBits() <= 8 * fe) break
                                                }
                                                N = H
                                            }
                                            Q(
                                                !1,
                                                (function () {
                                                    for (var Se = 0, ue = 0, me = 0; me < 8; me += 1) {
                                                        Q(!0, me)
                                                        var _e = Z.getLostPoint(T)
                                                        ;(me == 0 || Se > _e) && ((Se = _e), (ue = me))
                                                    }
                                                    return ue
                                                })()
                                            )
                                        }),
                                        (T.createTableTag = function (H, j) {
                                            H = H || 2
                                            var q = ""
                                            ;(q += '<table style="'),
                                                (q += " border-width: 0px; border-style: none;"),
                                                (q += " border-collapse: collapse;"),
                                                (q += " padding: 0px; margin: " + (j = j === void 0 ? 4 * H : j) + "px;"),
                                                (q += '">'),
                                                (q += "<tbody>")
                                            for (var ae = 0; ae < T.getModuleCount(); ae += 1) {
                                                q += "<tr>"
                                                for (var te = 0; te < T.getModuleCount(); te += 1)
                                                    (q += '<td style="'),
                                                        (q += " border-width: 0px; border-style: none;"),
                                                        (q += " border-collapse: collapse;"),
                                                        (q += " padding: 0px; margin: 0px;"),
                                                        (q += " width: " + H + "px;"),
                                                        (q += " height: " + H + "px;"),
                                                        (q += " background-color: "),
                                                        (q += T.isDark(ae, te) ? "#000000" : "#ffffff"),
                                                        (q += ";"),
                                                        (q += '"/>')
                                                q += "</tr>"
                                            }
                                            return (q += "</tbody>") + "</table>"
                                        }),
                                        (T.createSvgTag = function (H, j, q, ae) {
                                            var te = {}
                                            typeof arguments[0] == "object" &&
                                                ((H = (te = arguments[0]).cellSize), (j = te.margin), (q = te.alt), (ae = te.title)),
                                                (H = H || 2),
                                                (j = j === void 0 ? 4 * H : j),
                                                ((q = typeof q == "string" ? { text: q } : q || {}).text = q.text || null),
                                                (q.id = q.text ? q.id || "qrcode-description" : null),
                                                ((ae = typeof ae == "string" ? { text: ae } : ae || {}).text = ae.text || null),
                                                (ae.id = ae.text ? ae.id || "qrcode-title" : null)
                                            var fe,
                                                Se,
                                                ue,
                                                me,
                                                _e = T.getModuleCount() * H + 2 * j,
                                                Ce = ""
                                            for (
                                                me = "l" + H + ",0 0," + H + " -" + H + ",0 0,-" + H + "z ",
                                                    Ce += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                                                    Ce += te.scalable ? "" : ' width="' + _e + 'px" height="' + _e + 'px"',
                                                    Ce += ' viewBox="0 0 ' + _e + " " + _e + '" ',
                                                    Ce += ' preserveAspectRatio="xMinYMin meet"',
                                                    Ce +=
                                                        ae.text || q.text
                                                            ? ' role="img" aria-labelledby="' + de([ae.id, q.id].join(" ").trim()) + '"'
                                                            : "",
                                                    Ce += ">",
                                                    Ce += ae.text ? '<title id="' + de(ae.id) + '">' + de(ae.text) + "</title>" : "",
                                                    Ce += q.text ? '<description id="' + de(q.id) + '">' + de(q.text) + "</description>" : "",
                                                    Ce += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                                                    Ce += '<path d="',
                                                    Se = 0;
                                                Se < T.getModuleCount();
                                                Se += 1
                                            )
                                                for (ue = Se * H + j, fe = 0; fe < T.getModuleCount(); fe += 1)
                                                    T.isDark(Se, fe) && (Ce += "M" + (fe * H + j) + "," + ue + me)
                                            return (Ce += '" stroke="transparent" fill="black"/>') + "</svg>"
                                        }),
                                        (T.createDataURL = function (H, j) {
                                            ;(H = H || 2), (j = j === void 0 ? 4 * H : j)
                                            var q = T.getModuleCount() * H + 2 * j,
                                                ae = j,
                                                te = q - j
                                            return u(q, q, function (fe, Se) {
                                                if (ae <= fe && fe < te && ae <= Se && Se < te) {
                                                    var ue = Math.floor((fe - ae) / H),
                                                        me = Math.floor((Se - ae) / H)
                                                    return T.isDark(me, ue) ? 0 : 1
                                                }
                                                return 1
                                            })
                                        }),
                                        (T.createImgTag = function (H, j, q) {
                                            ;(H = H || 2), (j = j === void 0 ? 4 * H : j)
                                            var ae = T.getModuleCount() * H + 2 * j,
                                                te = ""
                                            return (
                                                (te += "<img"),
                                                (te += ' src="'),
                                                (te += T.createDataURL(H, j)),
                                                (te += '"'),
                                                (te += ' width="'),
                                                (te += ae),
                                                (te += '"'),
                                                (te += ' height="'),
                                                (te += ae),
                                                (te += '"'),
                                                q && ((te += ' alt="'), (te += de(q)), (te += '"')),
                                                te + "/>"
                                            )
                                        })
                                    var de = function (H) {
                                        for (var j = "", q = 0; q < H.length; q += 1) {
                                            var ae = H.charAt(q)
                                            switch (ae) {
                                                case "<":
                                                    j += "&lt;"
                                                    break
                                                case ">":
                                                    j += "&gt;"
                                                    break
                                                case "&":
                                                    j += "&amp;"
                                                    break
                                                case '"':
                                                    j += "&quot;"
                                                    break
                                                default:
                                                    j += ae
                                            }
                                        }
                                        return j
                                    }
                                    return (
                                        (T.createASCII = function (H, j) {
                                            if ((H = H || 1) < 2)
                                                return (function (Ne) {
                                                    Ne = Ne === void 0 ? 2 : Ne
                                                    var Me,
                                                        He,
                                                        Fe,
                                                        Le,
                                                        $t,
                                                        nt = 1 * T.getModuleCount() + 2 * Ne,
                                                        lt = Ne,
                                                        Zr = nt - Ne,
                                                        kt = { "\u2588\u2588": "\u2588", "\u2588 ": "\u2580", " \u2588": "\u2584", "  ": " " },
                                                        Ze = { "\u2588\u2588": "\u2580", "\u2588 ": "\u2580", " \u2588": " ", "  ": " " },
                                                        Xr = ""
                                                    for (Me = 0; Me < nt; Me += 2) {
                                                        for (
                                                            Fe = Math.floor((Me - lt) / 1), Le = Math.floor((Me + 1 - lt) / 1), He = 0;
                                                            He < nt;
                                                            He += 1
                                                        )
                                                            ($t = "\u2588"),
                                                                lt <= He &&
                                                                    He < Zr &&
                                                                    lt <= Me &&
                                                                    Me < Zr &&
                                                                    T.isDark(Fe, Math.floor((He - lt) / 1)) &&
                                                                    ($t = " "),
                                                                lt <= He &&
                                                                He < Zr &&
                                                                lt <= Me + 1 &&
                                                                Me + 1 < Zr &&
                                                                T.isDark(Le, Math.floor((He - lt) / 1))
                                                                    ? ($t += " ")
                                                                    : ($t += "\u2588"),
                                                                (Xr += Ne < 1 && Me + 1 >= Zr ? Ze[$t] : kt[$t])
                                                        Xr += `
`
                                                    }
                                                    return nt % 2 && Ne > 0
                                                        ? Xr.substring(0, Xr.length - nt - 1) + Array(nt + 1).join("\u2580")
                                                        : Xr.substring(0, Xr.length - 1)
                                                })(j)
                                            ;(H -= 1), (j = j === void 0 ? 2 * H : j)
                                            var q,
                                                ae,
                                                te,
                                                fe,
                                                Se = T.getModuleCount() * H + 2 * j,
                                                ue = j,
                                                me = Se - j,
                                                _e = Array(H + 1).join("\u2588\u2588"),
                                                Ce = Array(H + 1).join("  "),
                                                ke = "",
                                                Re = ""
                                            for (q = 0; q < Se; q += 1) {
                                                for (te = Math.floor((q - ue) / H), Re = "", ae = 0; ae < Se; ae += 1)
                                                    (fe = 1),
                                                        ue <= ae &&
                                                            ae < me &&
                                                            ue <= q &&
                                                            q < me &&
                                                            T.isDark(te, Math.floor((ae - ue) / H)) &&
                                                            (fe = 0),
                                                        (Re += fe ? _e : Ce)
                                                for (te = 0; te < H; te += 1)
                                                    ke +=
                                                        Re +
                                                        `
`
                                            }
                                            return ke.substring(0, ke.length - 1)
                                        }),
                                        (T.renderTo2dContext = function (H, j) {
                                            j = j || 2
                                            for (var q = T.getModuleCount(), ae = 0; ae < q; ae++)
                                                for (var te = 0; te < q; te++)
                                                    (H.fillStyle = T.isDark(ae, te) ? "black" : "white"), H.fillRect(ae * j, te * j, j, j)
                                        }),
                                        T
                                    )
                                }
                                ;(B.stringToBytes = (B.stringToBytesFuncs = {
                                    default: function (E) {
                                        for (var $ = [], N = 0; N < E.length; N += 1) {
                                            var M = E.charCodeAt(N)
                                            $.push(255 & M)
                                        }
                                        return $
                                    },
                                }).default),
                                    (B.createStringToBytes = function (E, $) {
                                        var N = (function () {
                                                for (
                                                    var R = O(E),
                                                        C = function () {
                                                            var W = R.read()
                                                            if (W == -1) throw "eof"
                                                            return W
                                                        },
                                                        S = 0,
                                                        b = {};
                                                    ;

                                                ) {
                                                    var T = R.read()
                                                    if (T == -1) break
                                                    var Q = C(),
                                                        k = (C() << 8) | C()
                                                    ;(b[String.fromCharCode((T << 8) | Q)] = k), (S += 1)
                                                }
                                                if (S != $) throw S + " != " + $
                                                return b
                                            })(),
                                            M = "?".charCodeAt(0)
                                        return function (R) {
                                            for (var C = [], S = 0; S < R.length; S += 1) {
                                                var b = R.charCodeAt(S)
                                                if (b < 128) C.push(b)
                                                else {
                                                    var T = N[R.charAt(S)]
                                                    typeof T == "number"
                                                        ? (255 & T) == T
                                                            ? C.push(T)
                                                            : (C.push(T >>> 8), C.push(255 & T))
                                                        : C.push(M)
                                                }
                                            }
                                            return C
                                        }
                                    })
                                var D,
                                    I,
                                    L,
                                    G,
                                    U,
                                    F = { L: 1, M: 0, Q: 3, H: 2 },
                                    Z =
                                        ((D = [
                                            [],
                                            [6, 18],
                                            [6, 22],
                                            [6, 26],
                                            [6, 30],
                                            [6, 34],
                                            [6, 22, 38],
                                            [6, 24, 42],
                                            [6, 26, 46],
                                            [6, 28, 50],
                                            [6, 30, 54],
                                            [6, 32, 58],
                                            [6, 34, 62],
                                            [6, 26, 46, 66],
                                            [6, 26, 48, 70],
                                            [6, 26, 50, 74],
                                            [6, 30, 54, 78],
                                            [6, 30, 56, 82],
                                            [6, 30, 58, 86],
                                            [6, 34, 62, 90],
                                            [6, 28, 50, 72, 94],
                                            [6, 26, 50, 74, 98],
                                            [6, 30, 54, 78, 102],
                                            [6, 28, 54, 80, 106],
                                            [6, 32, 58, 84, 110],
                                            [6, 30, 58, 86, 114],
                                            [6, 34, 62, 90, 118],
                                            [6, 26, 50, 74, 98, 122],
                                            [6, 30, 54, 78, 102, 126],
                                            [6, 26, 52, 78, 104, 130],
                                            [6, 30, 56, 82, 108, 134],
                                            [6, 34, 60, 86, 112, 138],
                                            [6, 30, 58, 86, 114, 142],
                                            [6, 34, 62, 90, 118, 146],
                                            [6, 30, 54, 78, 102, 126, 150],
                                            [6, 24, 50, 76, 102, 128, 154],
                                            [6, 28, 54, 80, 106, 132, 158],
                                            [6, 32, 58, 84, 110, 136, 162],
                                            [6, 26, 54, 82, 110, 138, 166],
                                            [6, 30, 58, 86, 114, 142, 170],
                                        ]),
                                        (I = 1335),
                                        (L = 7973),
                                        (U = function (E) {
                                            for (var $ = 0; E != 0; ) ($ += 1), (E >>>= 1)
                                            return $
                                        }),
                                        ((G = {}).getBCHTypeInfo = function (E) {
                                            for (var $ = E << 10; U($) - U(I) >= 0; ) $ ^= I << (U($) - U(I))
                                            return 21522 ^ ((E << 10) | $)
                                        }),
                                        (G.getBCHTypeNumber = function (E) {
                                            for (var $ = E << 12; U($) - U(L) >= 0; ) $ ^= L << (U($) - U(L))
                                            return (E << 12) | $
                                        }),
                                        (G.getPatternPosition = function (E) {
                                            return D[E - 1]
                                        }),
                                        (G.getMaskFunction = function (E) {
                                            switch (E) {
                                                case 0:
                                                    return function ($, N) {
                                                        return ($ + N) % 2 == 0
                                                    }
                                                case 1:
                                                    return function ($, N) {
                                                        return $ % 2 == 0
                                                    }
                                                case 2:
                                                    return function ($, N) {
                                                        return N % 3 == 0
                                                    }
                                                case 3:
                                                    return function ($, N) {
                                                        return ($ + N) % 3 == 0
                                                    }
                                                case 4:
                                                    return function ($, N) {
                                                        return (Math.floor($ / 2) + Math.floor(N / 3)) % 2 == 0
                                                    }
                                                case 5:
                                                    return function ($, N) {
                                                        return (($ * N) % 2) + (($ * N) % 3) == 0
                                                    }
                                                case 6:
                                                    return function ($, N) {
                                                        return ((($ * N) % 2) + (($ * N) % 3)) % 2 == 0
                                                    }
                                                case 7:
                                                    return function ($, N) {
                                                        return ((($ * N) % 3) + (($ + N) % 2)) % 2 == 0
                                                    }
                                                default:
                                                    throw "bad maskPattern:" + E
                                            }
                                        }),
                                        (G.getErrorCorrectPolynomial = function (E) {
                                            for (var $ = X([1], 0), N = 0; N < E; N += 1) $ = $.multiply(X([1, Y.gexp(N)], 0))
                                            return $
                                        }),
                                        (G.getLengthInBits = function (E, $) {
                                            if (1 <= $ && $ < 10)
                                                switch (E) {
                                                    case 1:
                                                        return 10
                                                    case 2:
                                                        return 9
                                                    case 4:
                                                    case 8:
                                                        return 8
                                                    default:
                                                        throw "mode:" + E
                                                }
                                            else if ($ < 27)
                                                switch (E) {
                                                    case 1:
                                                        return 12
                                                    case 2:
                                                        return 11
                                                    case 4:
                                                        return 16
                                                    case 8:
                                                        return 10
                                                    default:
                                                        throw "mode:" + E
                                                }
                                            else {
                                                if (!($ < 41)) throw "type:" + $
                                                switch (E) {
                                                    case 1:
                                                        return 14
                                                    case 2:
                                                        return 13
                                                    case 4:
                                                        return 16
                                                    case 8:
                                                        return 12
                                                    default:
                                                        throw "mode:" + E
                                                }
                                            }
                                        }),
                                        (G.getLostPoint = function (E) {
                                            for (var $ = E.getModuleCount(), N = 0, M = 0; M < $; M += 1)
                                                for (var R = 0; R < $; R += 1) {
                                                    for (var C = 0, S = E.isDark(M, R), b = -1; b <= 1; b += 1)
                                                        if (!(M + b < 0 || $ <= M + b))
                                                            for (var T = -1; T <= 1; T += 1)
                                                                R + T < 0 ||
                                                                    $ <= R + T ||
                                                                    (b == 0 && T == 0) ||
                                                                    (S == E.isDark(M + b, R + T) && (C += 1))
                                                    C > 5 && (N += 3 + C - 5)
                                                }
                                            for (M = 0; M < $ - 1; M += 1)
                                                for (R = 0; R < $ - 1; R += 1) {
                                                    var Q = 0
                                                    E.isDark(M, R) && (Q += 1),
                                                        E.isDark(M + 1, R) && (Q += 1),
                                                        E.isDark(M, R + 1) && (Q += 1),
                                                        E.isDark(M + 1, R + 1) && (Q += 1),
                                                        (Q != 0 && Q != 4) || (N += 3)
                                                }
                                            for (M = 0; M < $; M += 1)
                                                for (R = 0; R < $ - 6; R += 1)
                                                    E.isDark(M, R) &&
                                                        !E.isDark(M, R + 1) &&
                                                        E.isDark(M, R + 2) &&
                                                        E.isDark(M, R + 3) &&
                                                        E.isDark(M, R + 4) &&
                                                        !E.isDark(M, R + 5) &&
                                                        E.isDark(M, R + 6) &&
                                                        (N += 40)
                                            for (R = 0; R < $; R += 1)
                                                for (M = 0; M < $ - 6; M += 1)
                                                    E.isDark(M, R) &&
                                                        !E.isDark(M + 1, R) &&
                                                        E.isDark(M + 2, R) &&
                                                        E.isDark(M + 3, R) &&
                                                        E.isDark(M + 4, R) &&
                                                        !E.isDark(M + 5, R) &&
                                                        E.isDark(M + 6, R) &&
                                                        (N += 40)
                                            var k = 0
                                            for (R = 0; R < $; R += 1) for (M = 0; M < $; M += 1) E.isDark(M, R) && (k += 1)
                                            return N + (Math.abs((100 * k) / $ / $ - 50) / 5) * 10
                                        }),
                                        G),
                                    Y = (function () {
                                        for (var E = new Array(256), $ = new Array(256), N = 0; N < 8; N += 1) E[N] = 1 << N
                                        for (N = 8; N < 256; N += 1) E[N] = E[N - 4] ^ E[N - 5] ^ E[N - 6] ^ E[N - 8]
                                        for (N = 0; N < 255; N += 1) $[E[N]] = N
                                        return {
                                            glog: function (M) {
                                                if (M < 1) throw "glog(" + M + ")"
                                                return $[M]
                                            },
                                            gexp: function (M) {
                                                for (; M < 0; ) M += 255
                                                for (; M >= 256; ) M -= 255
                                                return E[M]
                                            },
                                        }
                                    })()
                                function X(E, $) {
                                    if (E.length === void 0) throw E.length + "/" + $
                                    var N = (function () {
                                            for (var R = 0; R < E.length && E[R] == 0; ) R += 1
                                            for (var C = new Array(E.length - R + $), S = 0; S < E.length - R; S += 1) C[S] = E[S + R]
                                            return C
                                        })(),
                                        M = {
                                            getAt: function (R) {
                                                return N[R]
                                            },
                                            getLength: function () {
                                                return N.length
                                            },
                                            multiply: function (R) {
                                                for (var C = new Array(M.getLength() + R.getLength() - 1), S = 0; S < M.getLength(); S += 1)
                                                    for (var b = 0; b < R.getLength(); b += 1)
                                                        C[S + b] ^= Y.gexp(Y.glog(M.getAt(S)) + Y.glog(R.getAt(b)))
                                                return X(C, 0)
                                            },
                                            mod: function (R) {
                                                if (M.getLength() - R.getLength() < 0) return M
                                                for (
                                                    var C = Y.glog(M.getAt(0)) - Y.glog(R.getAt(0)), S = new Array(M.getLength()), b = 0;
                                                    b < M.getLength();
                                                    b += 1
                                                )
                                                    S[b] = M.getAt(b)
                                                for (b = 0; b < R.getLength(); b += 1) S[b] ^= Y.gexp(Y.glog(R.getAt(b)) + C)
                                                return X(S, 0).mod(R)
                                            },
                                        }
                                    return M
                                }
                                var ie = (function () {
                                        var E = [
                                                [1, 26, 19],
                                                [1, 26, 16],
                                                [1, 26, 13],
                                                [1, 26, 9],
                                                [1, 44, 34],
                                                [1, 44, 28],
                                                [1, 44, 22],
                                                [1, 44, 16],
                                                [1, 70, 55],
                                                [1, 70, 44],
                                                [2, 35, 17],
                                                [2, 35, 13],
                                                [1, 100, 80],
                                                [2, 50, 32],
                                                [2, 50, 24],
                                                [4, 25, 9],
                                                [1, 134, 108],
                                                [2, 67, 43],
                                                [2, 33, 15, 2, 34, 16],
                                                [2, 33, 11, 2, 34, 12],
                                                [2, 86, 68],
                                                [4, 43, 27],
                                                [4, 43, 19],
                                                [4, 43, 15],
                                                [2, 98, 78],
                                                [4, 49, 31],
                                                [2, 32, 14, 4, 33, 15],
                                                [4, 39, 13, 1, 40, 14],
                                                [2, 121, 97],
                                                [2, 60, 38, 2, 61, 39],
                                                [4, 40, 18, 2, 41, 19],
                                                [4, 40, 14, 2, 41, 15],
                                                [2, 146, 116],
                                                [3, 58, 36, 2, 59, 37],
                                                [4, 36, 16, 4, 37, 17],
                                                [4, 36, 12, 4, 37, 13],
                                                [2, 86, 68, 2, 87, 69],
                                                [4, 69, 43, 1, 70, 44],
                                                [6, 43, 19, 2, 44, 20],
                                                [6, 43, 15, 2, 44, 16],
                                                [4, 101, 81],
                                                [1, 80, 50, 4, 81, 51],
                                                [4, 50, 22, 4, 51, 23],
                                                [3, 36, 12, 8, 37, 13],
                                                [2, 116, 92, 2, 117, 93],
                                                [6, 58, 36, 2, 59, 37],
                                                [4, 46, 20, 6, 47, 21],
                                                [7, 42, 14, 4, 43, 15],
                                                [4, 133, 107],
                                                [8, 59, 37, 1, 60, 38],
                                                [8, 44, 20, 4, 45, 21],
                                                [12, 33, 11, 4, 34, 12],
                                                [3, 145, 115, 1, 146, 116],
                                                [4, 64, 40, 5, 65, 41],
                                                [11, 36, 16, 5, 37, 17],
                                                [11, 36, 12, 5, 37, 13],
                                                [5, 109, 87, 1, 110, 88],
                                                [5, 65, 41, 5, 66, 42],
                                                [5, 54, 24, 7, 55, 25],
                                                [11, 36, 12, 7, 37, 13],
                                                [5, 122, 98, 1, 123, 99],
                                                [7, 73, 45, 3, 74, 46],
                                                [15, 43, 19, 2, 44, 20],
                                                [3, 45, 15, 13, 46, 16],
                                                [1, 135, 107, 5, 136, 108],
                                                [10, 74, 46, 1, 75, 47],
                                                [1, 50, 22, 15, 51, 23],
                                                [2, 42, 14, 17, 43, 15],
                                                [5, 150, 120, 1, 151, 121],
                                                [9, 69, 43, 4, 70, 44],
                                                [17, 50, 22, 1, 51, 23],
                                                [2, 42, 14, 19, 43, 15],
                                                [3, 141, 113, 4, 142, 114],
                                                [3, 70, 44, 11, 71, 45],
                                                [17, 47, 21, 4, 48, 22],
                                                [9, 39, 13, 16, 40, 14],
                                                [3, 135, 107, 5, 136, 108],
                                                [3, 67, 41, 13, 68, 42],
                                                [15, 54, 24, 5, 55, 25],
                                                [15, 43, 15, 10, 44, 16],
                                                [4, 144, 116, 4, 145, 117],
                                                [17, 68, 42],
                                                [17, 50, 22, 6, 51, 23],
                                                [19, 46, 16, 6, 47, 17],
                                                [2, 139, 111, 7, 140, 112],
                                                [17, 74, 46],
                                                [7, 54, 24, 16, 55, 25],
                                                [34, 37, 13],
                                                [4, 151, 121, 5, 152, 122],
                                                [4, 75, 47, 14, 76, 48],
                                                [11, 54, 24, 14, 55, 25],
                                                [16, 45, 15, 14, 46, 16],
                                                [6, 147, 117, 4, 148, 118],
                                                [6, 73, 45, 14, 74, 46],
                                                [11, 54, 24, 16, 55, 25],
                                                [30, 46, 16, 2, 47, 17],
                                                [8, 132, 106, 4, 133, 107],
                                                [8, 75, 47, 13, 76, 48],
                                                [7, 54, 24, 22, 55, 25],
                                                [22, 45, 15, 13, 46, 16],
                                                [10, 142, 114, 2, 143, 115],
                                                [19, 74, 46, 4, 75, 47],
                                                [28, 50, 22, 6, 51, 23],
                                                [33, 46, 16, 4, 47, 17],
                                                [8, 152, 122, 4, 153, 123],
                                                [22, 73, 45, 3, 74, 46],
                                                [8, 53, 23, 26, 54, 24],
                                                [12, 45, 15, 28, 46, 16],
                                                [3, 147, 117, 10, 148, 118],
                                                [3, 73, 45, 23, 74, 46],
                                                [4, 54, 24, 31, 55, 25],
                                                [11, 45, 15, 31, 46, 16],
                                                [7, 146, 116, 7, 147, 117],
                                                [21, 73, 45, 7, 74, 46],
                                                [1, 53, 23, 37, 54, 24],
                                                [19, 45, 15, 26, 46, 16],
                                                [5, 145, 115, 10, 146, 116],
                                                [19, 75, 47, 10, 76, 48],
                                                [15, 54, 24, 25, 55, 25],
                                                [23, 45, 15, 25, 46, 16],
                                                [13, 145, 115, 3, 146, 116],
                                                [2, 74, 46, 29, 75, 47],
                                                [42, 54, 24, 1, 55, 25],
                                                [23, 45, 15, 28, 46, 16],
                                                [17, 145, 115],
                                                [10, 74, 46, 23, 75, 47],
                                                [10, 54, 24, 35, 55, 25],
                                                [19, 45, 15, 35, 46, 16],
                                                [17, 145, 115, 1, 146, 116],
                                                [14, 74, 46, 21, 75, 47],
                                                [29, 54, 24, 19, 55, 25],
                                                [11, 45, 15, 46, 46, 16],
                                                [13, 145, 115, 6, 146, 116],
                                                [14, 74, 46, 23, 75, 47],
                                                [44, 54, 24, 7, 55, 25],
                                                [59, 46, 16, 1, 47, 17],
                                                [12, 151, 121, 7, 152, 122],
                                                [12, 75, 47, 26, 76, 48],
                                                [39, 54, 24, 14, 55, 25],
                                                [22, 45, 15, 41, 46, 16],
                                                [6, 151, 121, 14, 152, 122],
                                                [6, 75, 47, 34, 76, 48],
                                                [46, 54, 24, 10, 55, 25],
                                                [2, 45, 15, 64, 46, 16],
                                                [17, 152, 122, 4, 153, 123],
                                                [29, 74, 46, 14, 75, 47],
                                                [49, 54, 24, 10, 55, 25],
                                                [24, 45, 15, 46, 46, 16],
                                                [4, 152, 122, 18, 153, 123],
                                                [13, 74, 46, 32, 75, 47],
                                                [48, 54, 24, 14, 55, 25],
                                                [42, 45, 15, 32, 46, 16],
                                                [20, 147, 117, 4, 148, 118],
                                                [40, 75, 47, 7, 76, 48],
                                                [43, 54, 24, 22, 55, 25],
                                                [10, 45, 15, 67, 46, 16],
                                                [19, 148, 118, 6, 149, 119],
                                                [18, 75, 47, 31, 76, 48],
                                                [34, 54, 24, 34, 55, 25],
                                                [20, 45, 15, 61, 46, 16],
                                            ],
                                            $ = function (M, R) {
                                                var C = {}
                                                return (C.totalCount = M), (C.dataCount = R), C
                                            },
                                            N = {
                                                getRSBlocks: function (M, R) {
                                                    var C = (function (ee, ne) {
                                                        switch (ne) {
                                                            case F.L:
                                                                return E[4 * (ee - 1) + 0]
                                                            case F.M:
                                                                return E[4 * (ee - 1) + 1]
                                                            case F.Q:
                                                                return E[4 * (ee - 1) + 2]
                                                            case F.H:
                                                                return E[4 * (ee - 1) + 3]
                                                            default:
                                                                return
                                                        }
                                                    })(M, R)
                                                    if (C === void 0) throw "bad rs block @ typeNumber:" + M + "/errorCorrectionLevel:" + R
                                                    for (var S = C.length / 3, b = [], T = 0; T < S; T += 1)
                                                        for (var Q = C[3 * T + 0], k = C[3 * T + 1], W = C[3 * T + 2], J = 0; J < Q; J += 1)
                                                            b.push($(k, W))
                                                    return b
                                                },
                                            }
                                        return N
                                    })(),
                                    he = function () {
                                        var E = [],
                                            $ = 0,
                                            N = {
                                                getBuffer: function () {
                                                    return E
                                                },
                                                getAt: function (M) {
                                                    var R = Math.floor(M / 8)
                                                    return ((E[R] >>> (7 - (M % 8))) & 1) == 1
                                                },
                                                put: function (M, R) {
                                                    for (var C = 0; C < R; C += 1) N.putBit(((M >>> (R - C - 1)) & 1) == 1)
                                                },
                                                getLengthInBits: function () {
                                                    return $
                                                },
                                                putBit: function (M) {
                                                    var R = Math.floor($ / 8)
                                                    E.length <= R && E.push(0), M && (E[R] |= 128 >>> $ % 8), ($ += 1)
                                                },
                                            }
                                        return N
                                    },
                                    oe = function (E) {
                                        var $ = E,
                                            N = {
                                                getMode: function () {
                                                    return 1
                                                },
                                                getLength: function (C) {
                                                    return $.length
                                                },
                                                write: function (C) {
                                                    for (var S = $, b = 0; b + 2 < S.length; ) C.put(M(S.substring(b, b + 3)), 10), (b += 3)
                                                    b < S.length &&
                                                        (S.length - b == 1
                                                            ? C.put(M(S.substring(b, b + 1)), 4)
                                                            : S.length - b == 2 && C.put(M(S.substring(b, b + 2)), 7))
                                                },
                                            },
                                            M = function (C) {
                                                for (var S = 0, b = 0; b < C.length; b += 1) S = 10 * S + R(C.charAt(b))
                                                return S
                                            },
                                            R = function (C) {
                                                if ("0" <= C && C <= "9") return C.charCodeAt(0) - "0".charCodeAt(0)
                                                throw "illegal char :" + C
                                            }
                                        return N
                                    },
                                    le = function (E) {
                                        var $ = E,
                                            N = {
                                                getMode: function () {
                                                    return 2
                                                },
                                                getLength: function (R) {
                                                    return $.length
                                                },
                                                write: function (R) {
                                                    for (var C = $, S = 0; S + 1 < C.length; )
                                                        R.put(45 * M(C.charAt(S)) + M(C.charAt(S + 1)), 11), (S += 2)
                                                    S < C.length && R.put(M(C.charAt(S)), 6)
                                                },
                                            },
                                            M = function (R) {
                                                if ("0" <= R && R <= "9") return R.charCodeAt(0) - "0".charCodeAt(0)
                                                if ("A" <= R && R <= "Z") return R.charCodeAt(0) - "A".charCodeAt(0) + 10
                                                switch (R) {
                                                    case " ":
                                                        return 36
                                                    case "$":
                                                        return 37
                                                    case "%":
                                                        return 38
                                                    case "*":
                                                        return 39
                                                    case "+":
                                                        return 40
                                                    case "-":
                                                        return 41
                                                    case ".":
                                                        return 42
                                                    case "/":
                                                        return 43
                                                    case ":":
                                                        return 44
                                                    default:
                                                        throw "illegal char :" + R
                                                }
                                            }
                                        return N
                                    },
                                    Te = function (E) {
                                        var $ = B.stringToBytes(E)
                                        return {
                                            getMode: function () {
                                                return 4
                                            },
                                            getLength: function (N) {
                                                return $.length
                                            },
                                            write: function (N) {
                                                for (var M = 0; M < $.length; M += 1) N.put($[M], 8)
                                            },
                                        }
                                    },
                                    ye = function (E) {
                                        var $ = B.stringToBytesFuncs.SJIS
                                        if (!$) throw "sjis not supported."
                                        ;(function (M, R) {
                                            var C = $("\u53CB")
                                            if (C.length != 2 || ((C[0] << 8) | C[1]) != 38726) throw "sjis not supported."
                                        })()
                                        var N = $(E)
                                        return {
                                            getMode: function () {
                                                return 8
                                            },
                                            getLength: function (M) {
                                                return ~~(N.length / 2)
                                            },
                                            write: function (M) {
                                                for (var R = N, C = 0; C + 1 < R.length; ) {
                                                    var S = ((255 & R[C]) << 8) | (255 & R[C + 1])
                                                    if (33088 <= S && S <= 40956) S -= 33088
                                                    else {
                                                        if (!(57408 <= S && S <= 60351)) throw "illegal char at " + (C + 1) + "/" + S
                                                        S -= 49472
                                                    }
                                                    ;(S = 192 * ((S >>> 8) & 255) + (255 & S)), M.put(S, 13), (C += 2)
                                                }
                                                if (C < R.length) throw "illegal char at " + (C + 1)
                                            },
                                        }
                                    },
                                    Ae = function () {
                                        var E = [],
                                            $ = {
                                                writeByte: function (N) {
                                                    E.push(255 & N)
                                                },
                                                writeShort: function (N) {
                                                    $.writeByte(N), $.writeByte(N >>> 8)
                                                },
                                                writeBytes: function (N, M, R) {
                                                    ;(M = M || 0), (R = R || N.length)
                                                    for (var C = 0; C < R; C += 1) $.writeByte(N[C + M])
                                                },
                                                writeString: function (N) {
                                                    for (var M = 0; M < N.length; M += 1) $.writeByte(N.charCodeAt(M))
                                                },
                                                toByteArray: function () {
                                                    return E
                                                },
                                                toString: function () {
                                                    var N = ""
                                                    N += "["
                                                    for (var M = 0; M < E.length; M += 1) M > 0 && (N += ","), (N += E[M])
                                                    return N + "]"
                                                },
                                            }
                                        return $
                                    },
                                    O = function (E) {
                                        var $ = E,
                                            N = 0,
                                            M = 0,
                                            R = 0,
                                            C = {
                                                read: function () {
                                                    for (; R < 8; ) {
                                                        if (N >= $.length) {
                                                            if (R == 0) return -1
                                                            throw "unexpected end of file./" + R
                                                        }
                                                        var b = $.charAt(N)
                                                        if (((N += 1), b == "=")) return (R = 0), -1
                                                        b.match(/^\s$/) || ((M = (M << 6) | S(b.charCodeAt(0))), (R += 6))
                                                    }
                                                    var T = (M >>> (R - 8)) & 255
                                                    return (R -= 8), T
                                                },
                                            },
                                            S = function (b) {
                                                if (65 <= b && b <= 90) return b - 65
                                                if (97 <= b && b <= 122) return b - 97 + 26
                                                if (48 <= b && b <= 57) return b - 48 + 52
                                                if (b == 43) return 62
                                                if (b == 47) return 63
                                                throw "c:" + b
                                            }
                                        return C
                                    },
                                    u = function (E, $, N) {
                                        for (
                                            var M = (function (k, W) {
                                                    var J = k,
                                                        ee = W,
                                                        ne = new Array(k * W),
                                                        xe = {
                                                            setPixel: function (H, j, q) {
                                                                ne[j * J + H] = q
                                                            },
                                                            write: function (H) {
                                                                H.writeString("GIF87a"),
                                                                    H.writeShort(J),
                                                                    H.writeShort(ee),
                                                                    H.writeByte(128),
                                                                    H.writeByte(0),
                                                                    H.writeByte(0),
                                                                    H.writeByte(0),
                                                                    H.writeByte(0),
                                                                    H.writeByte(0),
                                                                    H.writeByte(255),
                                                                    H.writeByte(255),
                                                                    H.writeByte(255),
                                                                    H.writeString(","),
                                                                    H.writeShort(0),
                                                                    H.writeShort(0),
                                                                    H.writeShort(J),
                                                                    H.writeShort(ee),
                                                                    H.writeByte(0)
                                                                var j = ce(2)
                                                                H.writeByte(2)
                                                                for (var q = 0; j.length - q > 255; )
                                                                    H.writeByte(255), H.writeBytes(j, q, 255), (q += 255)
                                                                H.writeByte(j.length - q),
                                                                    H.writeBytes(j, q, j.length - q),
                                                                    H.writeByte(0),
                                                                    H.writeString(";")
                                                            },
                                                        },
                                                        ce = function (H) {
                                                            for (
                                                                var j = 1 << H, q = 1 + (1 << H), ae = H + 1, te = de(), fe = 0;
                                                                fe < j;
                                                                fe += 1
                                                            )
                                                                te.add(String.fromCharCode(fe))
                                                            te.add(String.fromCharCode(j)), te.add(String.fromCharCode(q))
                                                            var Se,
                                                                ue,
                                                                me,
                                                                _e = Ae(),
                                                                Ce =
                                                                    ((Se = _e),
                                                                    (ue = 0),
                                                                    (me = 0),
                                                                    {
                                                                        write: function (Me, He) {
                                                                            if (Me >>> He != 0) throw "length over"
                                                                            for (; ue + He >= 8; )
                                                                                Se.writeByte(255 & ((Me << ue) | me)),
                                                                                    (He -= 8 - ue),
                                                                                    (Me >>>= 8 - ue),
                                                                                    (me = 0),
                                                                                    (ue = 0)
                                                                            ;(me |= Me << ue), (ue += He)
                                                                        },
                                                                        flush: function () {
                                                                            ue > 0 && Se.writeByte(me)
                                                                        },
                                                                    })
                                                            Ce.write(j, ae)
                                                            var ke = 0,
                                                                Re = String.fromCharCode(ne[ke])
                                                            for (ke += 1; ke < ne.length; ) {
                                                                var Ne = String.fromCharCode(ne[ke])
                                                                ;(ke += 1),
                                                                    te.contains(Re + Ne)
                                                                        ? (Re += Ne)
                                                                        : (Ce.write(te.indexOf(Re), ae),
                                                                          te.size() < 4095 &&
                                                                              (te.size() == 1 << ae && (ae += 1), te.add(Re + Ne)),
                                                                          (Re = Ne))
                                                            }
                                                            return Ce.write(te.indexOf(Re), ae), Ce.write(q, ae), Ce.flush(), _e.toByteArray()
                                                        },
                                                        de = function () {
                                                            var H = {},
                                                                j = 0,
                                                                q = {
                                                                    add: function (ae) {
                                                                        if (q.contains(ae)) throw "dup key:" + ae
                                                                        ;(H[ae] = j), (j += 1)
                                                                    },
                                                                    size: function () {
                                                                        return j
                                                                    },
                                                                    indexOf: function (ae) {
                                                                        return H[ae]
                                                                    },
                                                                    contains: function (ae) {
                                                                        return H[ae] !== void 0
                                                                    },
                                                                }
                                                            return q
                                                        }
                                                    return xe
                                                })(E, $),
                                                R = 0;
                                            R < $;
                                            R += 1
                                        )
                                            for (var C = 0; C < E; C += 1) M.setPixel(C, R, N(C, R))
                                        var S = Ae()
                                        M.write(S)
                                        for (
                                            var b = (function () {
                                                    var k = 0,
                                                        W = 0,
                                                        J = 0,
                                                        ee = "",
                                                        ne = {},
                                                        xe = function (de) {
                                                            ee += String.fromCharCode(ce(63 & de))
                                                        },
                                                        ce = function (de) {
                                                            if (!(de < 0)) {
                                                                if (de < 26) return 65 + de
                                                                if (de < 52) return de - 26 + 97
                                                                if (de < 62) return de - 52 + 48
                                                                if (de == 62) return 43
                                                                if (de == 63) return 47
                                                            }
                                                            throw "n:" + de
                                                        }
                                                    return (
                                                        (ne.writeByte = function (de) {
                                                            for (k = (k << 8) | (255 & de), W += 8, J += 1; W >= 6; ) xe(k >>> (W - 6)), (W -= 6)
                                                        }),
                                                        (ne.flush = function () {
                                                            if ((W > 0 && (xe(k << (6 - W)), (k = 0), (W = 0)), J % 3 != 0))
                                                                for (var de = 3 - (J % 3), H = 0; H < de; H += 1) ee += "="
                                                        }),
                                                        (ne.toString = function () {
                                                            return ee
                                                        }),
                                                        ne
                                                    )
                                                })(),
                                                T = S.toByteArray(),
                                                Q = 0;
                                            Q < T.length;
                                            Q += 1
                                        )
                                            b.writeByte(T[Q])
                                        return b.flush(), "data:image/gif;base64," + b
                                    }
                                return B
                            })()
                        ;(A.stringToBytesFuncs["UTF-8"] = function (B) {
                            return (function (D) {
                                for (var I = [], L = 0; L < D.length; L++) {
                                    var G = D.charCodeAt(L)
                                    G < 128
                                        ? I.push(G)
                                        : G < 2048
                                        ? I.push(192 | (G >> 6), 128 | (63 & G))
                                        : G < 55296 || G >= 57344
                                        ? I.push(224 | (G >> 12), 128 | ((G >> 6) & 63), 128 | (63 & G))
                                        : (L++,
                                          (G = 65536 + (((1023 & G) << 10) | (1023 & D.charCodeAt(L)))),
                                          I.push(240 | (G >> 18), 128 | ((G >> 12) & 63), 128 | ((G >> 6) & 63), 128 | (63 & G)))
                                }
                                return I
                            })(B)
                        }),
                            (_ =
                                typeof (v = function () {
                                    return A
                                }) == "function"
                                    ? v.apply(g, [])
                                    : v) === void 0 || (c.exports = _)
                    },
                    103: (c) => {
                        c.exports = n
                    },
                },
                o = {}
            function a(c) {
                var g = o[c]
                if (g !== void 0) return g.exports
                var v = (o[c] = { exports: {} })
                return i[c](v, v.exports, a), v.exports
            }
            ;(a.n = (c) => {
                var g = c && c.__esModule ? () => c.default : () => c
                return a.d(g, { a: g }), g
            }),
                (a.d = (c, g) => {
                    for (var v in g) a.o(g, v) && !a.o(c, v) && Object.defineProperty(c, v, { enumerable: !0, get: g[v] })
                }),
                (a.o = (c, g) => Object.prototype.hasOwnProperty.call(c, g))
            var l = {}
            return (
                (() => {
                    a.d(l, { default: () => M })
                    var c = a(103)
                    const g = { key: 1 }
                    var v = function () {
                            return (v =
                                Object.assign ||
                                function (R) {
                                    for (var C, S = 1, b = arguments.length; S < b; S++)
                                        for (var T in (C = arguments[S])) Object.prototype.hasOwnProperty.call(C, T) && (R[T] = C[T])
                                    return R
                                }).apply(this, arguments)
                        },
                        _ = function (R, C) {
                            for (var S = 0, b = C.length, T = R.length; S < b; S++, T++) R[T] = C[S]
                            return R
                        },
                        A = function (R) {
                            return !!R && typeof R == "object" && !Array.isArray(R)
                        }
                    function B(R) {
                        for (var C = [], S = 1; S < arguments.length; S++) C[S - 1] = arguments[S]
                        if (!C.length) return R
                        var b = C.shift()
                        return b !== void 0 && A(R) && A(b)
                            ? ((R = v({}, R)),
                              Object.keys(b).forEach(function (T) {
                                  var Q = R[T],
                                      k = b[T]
                                  Array.isArray(Q) && Array.isArray(k)
                                      ? (R[T] = k)
                                      : A(Q) && A(k)
                                      ? (R[T] = B(Object.assign({}, Q), k))
                                      : (R[T] = k)
                              }),
                              B.apply(void 0, _([R], C)))
                            : R
                    }
                    const D = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 }
                    var I = function () {
                        return (I =
                            Object.assign ||
                            function (R) {
                                for (var C, S = 1, b = arguments.length; S < b; S++)
                                    for (var T in (C = arguments[S])) Object.prototype.hasOwnProperty.call(C, T) && (R[T] = C[T])
                                return R
                            }).apply(this, arguments)
                    }
                    const L = (function () {
                        function R(C) {
                            var S = C.context,
                                b = C.type
                            ;(this._context = S), (this._type = b)
                        }
                        return (
                            (R.prototype.draw = function (C, S, b, T) {
                                var Q,
                                    k = this._context
                                switch (this._type) {
                                    case "dots":
                                        Q = this._drawDot
                                        break
                                    case "classy":
                                        Q = this._drawClassy
                                        break
                                    case "classy-rounded":
                                        Q = this._drawClassyRounded
                                        break
                                    case "rounded":
                                        Q = this._drawRounded
                                        break
                                    case "extra-rounded":
                                        Q = this._drawExtraRounded
                                        break
                                    case "square":
                                    default:
                                        Q = this._drawSquare
                                }
                                Q.call(this, { x: C, y: S, size: b, context: k, getNeighbor: T })
                            }),
                            (R.prototype._rotateFigure = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation,
                                    W = C.draw,
                                    J = S + T / 2,
                                    ee = b + T / 2
                                Q.translate(J, ee), k && Q.rotate(k), W(), Q.closePath(), k && Q.rotate(-k), Q.translate(-J, -ee)
                            }),
                            (R.prototype._basicDot = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicSquare = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.rect(-S / 2, -S / 2, S, S)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicSideRounded = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, -Math.PI / 2, Math.PI / 2),
                                                b.lineTo(-S / 2, S / 2),
                                                b.lineTo(-S / 2, -S / 2),
                                                b.lineTo(0, -S / 2)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicCornerRounded = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, -Math.PI / 2, 0),
                                                b.lineTo(S / 2, S / 2),
                                                b.lineTo(-S / 2, S / 2),
                                                b.lineTo(-S / 2, -S / 2),
                                                b.lineTo(0, -S / 2)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicCornerExtraRounded = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(-S / 2, S / 2, S, -Math.PI / 2, 0), b.lineTo(-S / 2, S / 2), b.lineTo(-S / 2, -S / 2)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicCornersRounded = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, -Math.PI / 2, 0),
                                                b.lineTo(S / 2, S / 2),
                                                b.lineTo(0, S / 2),
                                                b.arc(0, 0, S / 2, Math.PI / 2, Math.PI),
                                                b.lineTo(-S / 2, -S / 2),
                                                b.lineTo(0, -S / 2)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicCornersExtraRounded = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    I(I({}, C), {
                                        draw: function () {
                                            b.arc(-S / 2, S / 2, S, -Math.PI / 2, 0), b.arc(S / 2, -S / 2, S, Math.PI / 2, Math.PI)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._drawDot = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context
                                this._basicDot({ x: S, y: b, size: T, context: Q, rotation: 0 })
                            }),
                            (R.prototype._drawSquare = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context
                                this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: 0 })
                            }),
                            (R.prototype._drawRounded = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.getNeighbor,
                                    W = +k(-1, 0),
                                    J = +k(1, 0),
                                    ee = +k(0, -1),
                                    ne = +k(0, 1),
                                    xe = W + J + ee + ne
                                if (xe !== 0)
                                    if (xe > 2 || (W && J) || (ee && ne)) this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: 0 })
                                    else {
                                        if (xe === 2) {
                                            var ce = 0
                                            return (
                                                W && ee ? (ce = Math.PI / 2) : ee && J ? (ce = Math.PI) : J && ne && (ce = -Math.PI / 2),
                                                void this._basicCornerRounded({ x: S, y: b, size: T, context: Q, rotation: ce })
                                            )
                                        }
                                        xe === 1 &&
                                            ((ce = 0),
                                            ee ? (ce = Math.PI / 2) : J ? (ce = Math.PI) : ne && (ce = -Math.PI / 2),
                                            this._basicSideRounded({ x: S, y: b, size: T, context: Q, rotation: ce }))
                                    }
                                else this._basicDot({ x: S, y: b, size: T, context: Q, rotation: 0 })
                            }),
                            (R.prototype._drawExtraRounded = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.getNeighbor,
                                    W = +k(-1, 0),
                                    J = +k(1, 0),
                                    ee = +k(0, -1),
                                    ne = +k(0, 1),
                                    xe = W + J + ee + ne
                                if (xe !== 0)
                                    if (xe > 2 || (W && J) || (ee && ne)) this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: 0 })
                                    else {
                                        if (xe === 2) {
                                            var ce = 0
                                            return (
                                                W && ee ? (ce = Math.PI / 2) : ee && J ? (ce = Math.PI) : J && ne && (ce = -Math.PI / 2),
                                                void this._basicCornerExtraRounded({ x: S, y: b, size: T, context: Q, rotation: ce })
                                            )
                                        }
                                        xe === 1 &&
                                            ((ce = 0),
                                            ee ? (ce = Math.PI / 2) : J ? (ce = Math.PI) : ne && (ce = -Math.PI / 2),
                                            this._basicSideRounded({ x: S, y: b, size: T, context: Q, rotation: ce }))
                                    }
                                else this._basicDot({ x: S, y: b, size: T, context: Q, rotation: 0 })
                            }),
                            (R.prototype._drawClassy = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.getNeighbor,
                                    W = +k(-1, 0),
                                    J = +k(1, 0),
                                    ee = +k(0, -1),
                                    ne = +k(0, 1)
                                W + J + ee + ne !== 0
                                    ? W || ee
                                        ? J || ne
                                            ? this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: 0 })
                                            : this._basicCornerRounded({ x: S, y: b, size: T, context: Q, rotation: Math.PI / 2 })
                                        : this._basicCornerRounded({ x: S, y: b, size: T, context: Q, rotation: -Math.PI / 2 })
                                    : this._basicCornersRounded({ x: S, y: b, size: T, context: Q, rotation: Math.PI / 2 })
                            }),
                            (R.prototype._drawClassyRounded = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.getNeighbor,
                                    W = +k(-1, 0),
                                    J = +k(1, 0),
                                    ee = +k(0, -1),
                                    ne = +k(0, 1)
                                W + J + ee + ne !== 0
                                    ? W || ee
                                        ? J || ne
                                            ? this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: 0 })
                                            : this._basicCornerExtraRounded({ x: S, y: b, size: T, context: Q, rotation: Math.PI / 2 })
                                        : this._basicCornerExtraRounded({ x: S, y: b, size: T, context: Q, rotation: -Math.PI / 2 })
                                    : this._basicCornersRounded({ x: S, y: b, size: T, context: Q, rotation: Math.PI / 2 })
                            }),
                            R
                        )
                    })()
                    var G = function () {
                        return (G =
                            Object.assign ||
                            function (R) {
                                for (var C, S = 1, b = arguments.length; S < b; S++)
                                    for (var T in (C = arguments[S])) Object.prototype.hasOwnProperty.call(C, T) && (R[T] = C[T])
                                return R
                            }).apply(this, arguments)
                    }
                    const U = (function () {
                        function R(C) {
                            var S = C.context,
                                b = C.type
                            ;(this._context = S), (this._type = b)
                        }
                        return (
                            (R.prototype.draw = function (C, S, b, T) {
                                var Q,
                                    k = this._context
                                switch (this._type) {
                                    case "square":
                                        Q = this._drawSquare
                                        break
                                    case "extra-rounded":
                                        Q = this._drawExtraRounded
                                        break
                                    case "dot":
                                    default:
                                        Q = this._drawDot
                                }
                                Q.call(this, { x: C, y: S, size: b, context: k, rotation: T })
                            }),
                            (R.prototype._rotateFigure = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation,
                                    W = C.draw,
                                    J = S + T / 2,
                                    ee = b + T / 2
                                Q.translate(J, ee), k && Q.rotate(k), W(), Q.closePath(), k && Q.rotate(-k), Q.translate(-J, -ee)
                            }),
                            (R.prototype._basicDot = function (C) {
                                var S = C.size,
                                    b = C.context,
                                    T = S / 7
                                this._rotateFigure(
                                    G(G({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, 0, 2 * Math.PI), b.arc(0, 0, S / 2 - T, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicSquare = function (C) {
                                var S = C.size,
                                    b = C.context,
                                    T = S / 7
                                this._rotateFigure(
                                    G(G({}, C), {
                                        draw: function () {
                                            b.rect(-S / 2, -S / 2, S, S), b.rect(-S / 2 + T, -S / 2 + T, S - 2 * T, S - 2 * T)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicExtraRounded = function (C) {
                                var S = C.size,
                                    b = C.context,
                                    T = S / 7
                                this._rotateFigure(
                                    G(G({}, C), {
                                        draw: function () {
                                            b.arc(-T, -T, 2.5 * T, Math.PI, -Math.PI / 2),
                                                b.lineTo(T, -3.5 * T),
                                                b.arc(T, -T, 2.5 * T, -Math.PI / 2, 0),
                                                b.lineTo(3.5 * T, -T),
                                                b.arc(T, T, 2.5 * T, 0, Math.PI / 2),
                                                b.lineTo(-T, 3.5 * T),
                                                b.arc(-T, T, 2.5 * T, Math.PI / 2, Math.PI),
                                                b.lineTo(-3.5 * T, -T),
                                                b.arc(-T, -T, 1.5 * T, Math.PI, -Math.PI / 2),
                                                b.lineTo(T, -2.5 * T),
                                                b.arc(T, -T, 1.5 * T, -Math.PI / 2, 0),
                                                b.lineTo(2.5 * T, -T),
                                                b.arc(T, T, 1.5 * T, 0, Math.PI / 2),
                                                b.lineTo(-T, 2.5 * T),
                                                b.arc(-T, T, 1.5 * T, Math.PI / 2, Math.PI),
                                                b.lineTo(-2.5 * T, -T)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._drawDot = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation
                                this._basicDot({ x: S, y: b, size: T, context: Q, rotation: k })
                            }),
                            (R.prototype._drawSquare = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation
                                this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: k })
                            }),
                            (R.prototype._drawExtraRounded = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation
                                this._basicExtraRounded({ x: S, y: b, size: T, context: Q, rotation: k })
                            }),
                            R
                        )
                    })()
                    var F = function () {
                        return (F =
                            Object.assign ||
                            function (R) {
                                for (var C, S = 1, b = arguments.length; S < b; S++)
                                    for (var T in (C = arguments[S])) Object.prototype.hasOwnProperty.call(C, T) && (R[T] = C[T])
                                return R
                            }).apply(this, arguments)
                    }
                    const Z = (function () {
                        function R(C) {
                            var S = C.context,
                                b = C.type
                            ;(this._context = S), (this._type = b)
                        }
                        return (
                            (R.prototype.draw = function (C, S, b, T) {
                                var Q,
                                    k = this._context
                                switch (this._type) {
                                    case "square":
                                        Q = this._drawSquare
                                        break
                                    case "dot":
                                    default:
                                        Q = this._drawDot
                                }
                                Q.call(this, { x: C, y: S, size: b, context: k, rotation: T })
                            }),
                            (R.prototype._rotateFigure = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation,
                                    W = C.draw,
                                    J = S + T / 2,
                                    ee = b + T / 2
                                Q.translate(J, ee), k && Q.rotate(k), W(), Q.closePath(), k && Q.rotate(-k), Q.translate(-J, -ee)
                            }),
                            (R.prototype._basicDot = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    F(F({}, C), {
                                        draw: function () {
                                            b.arc(0, 0, S / 2, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._basicSquare = function (C) {
                                var S = C.size,
                                    b = C.context
                                this._rotateFigure(
                                    F(F({}, C), {
                                        draw: function () {
                                            b.rect(-S / 2, -S / 2, S, S)
                                        },
                                    })
                                )
                            }),
                            (R.prototype._drawDot = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation
                                this._basicDot({ x: S, y: b, size: T, context: Q, rotation: k })
                            }),
                            (R.prototype._drawSquare = function (C) {
                                var S = C.x,
                                    b = C.y,
                                    T = C.size,
                                    Q = C.context,
                                    k = C.rotation
                                this._basicSquare({ x: S, y: b, size: T, context: Q, rotation: k })
                            }),
                            R
                        )
                    })()
                    var Y = [
                            [1, 1, 1, 1, 1, 1, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 1, 1, 1, 1, 1, 1],
                        ],
                        X = [
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                        ]
                    const ie = (function () {
                        function R(C) {
                            ;(this._canvas = document.createElement("canvas")),
                                (this._canvas.width = C.width),
                                (this._canvas.height = C.height),
                                (this._options = C)
                        }
                        return (
                            Object.defineProperty(R.prototype, "context", {
                                get: function () {
                                    return this._canvas.getContext("2d")
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            Object.defineProperty(R.prototype, "width", {
                                get: function () {
                                    return this._canvas.width
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            Object.defineProperty(R.prototype, "height", {
                                get: function () {
                                    return this._canvas.height
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            (R.prototype.getCanvas = function () {
                                return this._canvas
                            }),
                            (R.prototype.clear = function () {
                                var C = this.context
                                C && C.clearRect(0, 0, this._canvas.width, this._canvas.height)
                            }),
                            (R.prototype.drawQR = function (C) {
                                return (
                                    (S = this),
                                    (b = void 0),
                                    (Q = function () {
                                        var k,
                                            W,
                                            J,
                                            ee,
                                            ne,
                                            xe,
                                            ce,
                                            de,
                                            H,
                                            j = this
                                        return (function (q, ae) {
                                            var te,
                                                fe,
                                                Se,
                                                ue,
                                                me = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & Se[0]) throw Se[1]
                                                        return Se[1]
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                }
                                            return (
                                                (ue = { next: _e(0), throw: _e(1), return: _e(2) }),
                                                typeof Symbol == "function" &&
                                                    (ue[Symbol.iterator] = function () {
                                                        return this
                                                    }),
                                                ue
                                            )
                                            function _e(Ce) {
                                                return function (ke) {
                                                    return (function (Re) {
                                                        if (te) throw new TypeError("Generator is already executing.")
                                                        for (; me; )
                                                            try {
                                                                if (
                                                                    ((te = 1),
                                                                    fe &&
                                                                        (Se =
                                                                            2 & Re[0]
                                                                                ? fe.return
                                                                                : Re[0]
                                                                                ? fe.throw || ((Se = fe.return) && Se.call(fe), 0)
                                                                                : fe.next) &&
                                                                        !(Se = Se.call(fe, Re[1])).done)
                                                                )
                                                                    return Se
                                                                switch (((fe = 0), Se && (Re = [2 & Re[0], Se.value]), Re[0])) {
                                                                    case 0:
                                                                    case 1:
                                                                        Se = Re
                                                                        break
                                                                    case 4:
                                                                        return me.label++, { value: Re[1], done: !1 }
                                                                    case 5:
                                                                        me.label++, (fe = Re[1]), (Re = [0])
                                                                        continue
                                                                    case 7:
                                                                        ;(Re = me.ops.pop()), me.trys.pop()
                                                                        continue
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (Se = (Se = me.trys).length > 0 && Se[Se.length - 1]) ||
                                                                                (Re[0] !== 6 && Re[0] !== 2)
                                                                            )
                                                                        ) {
                                                                            me = 0
                                                                            continue
                                                                        }
                                                                        if (Re[0] === 3 && (!Se || (Re[1] > Se[0] && Re[1] < Se[3]))) {
                                                                            me.label = Re[1]
                                                                            break
                                                                        }
                                                                        if (Re[0] === 6 && me.label < Se[1]) {
                                                                            ;(me.label = Se[1]), (Se = Re)
                                                                            break
                                                                        }
                                                                        if (Se && me.label < Se[2]) {
                                                                            ;(me.label = Se[2]), me.ops.push(Re)
                                                                            break
                                                                        }
                                                                        Se[2] && me.ops.pop(), me.trys.pop()
                                                                        continue
                                                                }
                                                                Re = ae.call(q, me)
                                                            } catch (Ne) {
                                                                ;(Re = [6, Ne]), (fe = 0)
                                                            } finally {
                                                                te = Se = 0
                                                            }
                                                        if (5 & Re[0]) throw Re[1]
                                                        return { value: Re[0] ? Re[1] : void 0, done: !0 }
                                                    })([Ce, ke])
                                                }
                                            }
                                        })(this, function (q) {
                                            switch (q.label) {
                                                case 0:
                                                    return (
                                                        (k = C.getModuleCount()),
                                                        (W = Math.min(this._options.width, this._options.height) - 2 * this._options.margin),
                                                        (J = Math.floor(W / k)),
                                                        (ee = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }),
                                                        (this._qr = C),
                                                        this._options.image ? [4, this.loadImage()] : [3, 2]
                                                    )
                                                case 1:
                                                    if ((q.sent(), !this._image)) return [2]
                                                    ;(ne = this._options),
                                                        (xe = ne.imageOptions),
                                                        (ce = ne.qrOptions),
                                                        (de = xe.imageSize * D[ce.errorCorrectionLevel]),
                                                        (H = Math.floor(de * k * k)),
                                                        (ee = (function (ae) {
                                                            var te = ae.originalHeight,
                                                                fe = ae.originalWidth,
                                                                Se = ae.maxHiddenDots,
                                                                ue = ae.maxHiddenAxisDots,
                                                                me = ae.dotSize,
                                                                _e = { x: 0, y: 0 },
                                                                Ce = { x: 0, y: 0 }
                                                            if (te <= 0 || fe <= 0 || Se <= 0 || me <= 0)
                                                                return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 }
                                                            var ke = te / fe
                                                            return (
                                                                (_e.x = Math.floor(Math.sqrt(Se / ke))),
                                                                _e.x <= 0 && (_e.x = 1),
                                                                ue && ue < _e.x && (_e.x = ue),
                                                                _e.x % 2 == 0 && _e.x--,
                                                                (Ce.x = _e.x * me),
                                                                (_e.y = 1 + 2 * Math.ceil((_e.x * ke - 1) / 2)),
                                                                (Ce.y = Math.round(Ce.x * ke)),
                                                                (_e.y * _e.x > Se || (ue && ue < _e.y)) &&
                                                                    (ue && ue < _e.y ? ((_e.y = ue), _e.y % 2 == 0 && _e.x--) : (_e.y -= 2),
                                                                    (Ce.y = _e.y * me),
                                                                    (_e.x = 1 + 2 * Math.ceil((_e.y / ke - 1) / 2)),
                                                                    (Ce.x = Math.round(Ce.y / ke))),
                                                                { height: Ce.y, width: Ce.x, hideYDots: _e.y, hideXDots: _e.x }
                                                            )
                                                        })({
                                                            originalWidth: this._image.width,
                                                            originalHeight: this._image.height,
                                                            maxHiddenDots: H,
                                                            maxHiddenAxisDots: k - 14,
                                                            dotSize: J,
                                                        })),
                                                        (q.label = 2)
                                                case 2:
                                                    return (
                                                        this.clear(),
                                                        this.drawBackground(),
                                                        this.drawDots(function (ae, te) {
                                                            var fe, Se, ue, me, _e, Ce
                                                            return !(
                                                                (j._options.imageOptions.hideBackgroundDots &&
                                                                    ae >= (k - ee.hideXDots) / 2 &&
                                                                    ae < (k + ee.hideXDots) / 2 &&
                                                                    te >= (k - ee.hideYDots) / 2 &&
                                                                    te < (k + ee.hideYDots) / 2) ||
                                                                ((fe = Y[ae]) === null || fe === void 0 ? void 0 : fe[te]) ||
                                                                ((Se = Y[ae - k + 7]) === null || Se === void 0 ? void 0 : Se[te]) ||
                                                                ((ue = Y[ae]) === null || ue === void 0 ? void 0 : ue[te - k + 7]) ||
                                                                ((me = X[ae]) === null || me === void 0 ? void 0 : me[te]) ||
                                                                ((_e = X[ae - k + 7]) === null || _e === void 0 ? void 0 : _e[te]) ||
                                                                ((Ce = X[ae]) === null || Ce === void 0 ? void 0 : Ce[te - k + 7])
                                                            )
                                                        }),
                                                        this.drawCorners(),
                                                        this._options.image &&
                                                            this.drawImage({ width: ee.width, height: ee.height, count: k, dotSize: J }),
                                                        [2]
                                                    )
                                            }
                                        })
                                    }),
                                    new ((T = void 0) || (T = Promise))(function (k, W) {
                                        function J(xe) {
                                            try {
                                                ne(Q.next(xe))
                                            } catch (ce) {
                                                W(ce)
                                            }
                                        }
                                        function ee(xe) {
                                            try {
                                                ne(Q.throw(xe))
                                            } catch (ce) {
                                                W(ce)
                                            }
                                        }
                                        function ne(xe) {
                                            var ce
                                            xe.done
                                                ? k(xe.value)
                                                : ((ce = xe.value),
                                                  ce instanceof T
                                                      ? ce
                                                      : new T(function (de) {
                                                            de(ce)
                                                        })).then(J, ee)
                                        }
                                        ne((Q = Q.apply(S, b || [])).next())
                                    })
                                )
                                var S, b, T, Q
                            }),
                            (R.prototype.drawBackground = function () {
                                var C = this.context,
                                    S = this._options
                                if (C) {
                                    if (S.backgroundOptions.gradient) {
                                        var b = S.backgroundOptions.gradient,
                                            T = this._createGradient({
                                                context: C,
                                                options: b,
                                                additionalRotation: 0,
                                                x: 0,
                                                y: 0,
                                                size: this._canvas.width > this._canvas.height ? this._canvas.width : this._canvas.height,
                                            })
                                        b.colorStops.forEach(function (Q) {
                                            var k = Q.offset,
                                                W = Q.color
                                            T.addColorStop(k, W)
                                        }),
                                            (C.fillStyle = T)
                                    } else S.backgroundOptions.color && (C.fillStyle = S.backgroundOptions.color)
                                    C.fillRect(0, 0, this._canvas.width, this._canvas.height)
                                }
                            }),
                            (R.prototype.drawDots = function (C) {
                                var S = this
                                if (!this._qr) throw "QR code is not defined"
                                var b = this.context
                                if (!b) throw "QR code is not defined"
                                var T = this._options,
                                    Q = this._qr.getModuleCount()
                                if (Q > T.width || Q > T.height) throw "The canvas is too small."
                                var k = Math.min(T.width, T.height) - 2 * T.margin,
                                    W = Math.floor(k / Q),
                                    J = Math.floor((T.width - Q * W) / 2),
                                    ee = Math.floor((T.height - Q * W) / 2),
                                    ne = new L({ context: b, type: T.dotsOptions.type })
                                b.beginPath()
                                for (
                                    var xe = function (q) {
                                            for (
                                                var ae = function (fe) {
                                                        return C && !C(q, fe)
                                                            ? "continue"
                                                            : ce._qr.isDark(q, fe)
                                                            ? void ne.draw(J + q * W, ee + fe * W, W, function (Se, ue) {
                                                                  return (
                                                                      !(q + Se < 0 || fe + ue < 0 || q + Se >= Q || fe + ue >= Q) &&
                                                                      !(C && !C(q + Se, fe + ue)) &&
                                                                      !!S._qr &&
                                                                      S._qr.isDark(q + Se, fe + ue)
                                                                  )
                                                              })
                                                            : "continue"
                                                    },
                                                    te = 0;
                                                te < Q;
                                                te++
                                            )
                                                ae(te)
                                        },
                                        ce = this,
                                        de = 0;
                                    de < Q;
                                    de++
                                )
                                    xe(de)
                                if (T.dotsOptions.gradient) {
                                    var H = T.dotsOptions.gradient,
                                        j = this._createGradient({ context: b, options: H, additionalRotation: 0, x: J, y: ee, size: Q * W })
                                    H.colorStops.forEach(function (q) {
                                        var ae = q.offset,
                                            te = q.color
                                        j.addColorStop(ae, te)
                                    }),
                                        (b.fillStyle = b.strokeStyle = j)
                                } else T.dotsOptions.color && (b.fillStyle = b.strokeStyle = T.dotsOptions.color)
                                b.fill("evenodd")
                            }),
                            (R.prototype.drawCorners = function (C) {
                                var S = this
                                if (!this._qr) throw "QR code is not defined"
                                var b = this.context
                                if (!b) throw "QR code is not defined"
                                var T = this._options,
                                    Q = this._qr.getModuleCount(),
                                    k = Math.min(T.width, T.height) - 2 * T.margin,
                                    W = Math.floor(k / Q),
                                    J = 7 * W,
                                    ee = 3 * W,
                                    ne = Math.floor((T.width - Q * W) / 2),
                                    xe = Math.floor((T.height - Q * W) / 2)
                                ;[
                                    [0, 0, 0],
                                    [1, 0, Math.PI / 2],
                                    [0, 1, -Math.PI / 2],
                                ].forEach(function (ce) {
                                    var de,
                                        H,
                                        j,
                                        q,
                                        ae,
                                        te,
                                        fe,
                                        Se,
                                        ue,
                                        me,
                                        _e = ce[0],
                                        Ce = ce[1],
                                        ke = ce[2]
                                    if (!C || C(_e, Ce)) {
                                        var Re = ne + _e * W * (Q - 7),
                                            Ne = xe + Ce * W * (Q - 7)
                                        if (!((de = T.cornersSquareOptions) === null || de === void 0) && de.type) {
                                            var Me = new U({
                                                context: b,
                                                type: (H = T.cornersSquareOptions) === null || H === void 0 ? void 0 : H.type,
                                            })
                                            b.beginPath(), Me.draw(Re, Ne, J, ke)
                                        } else {
                                            var He = new L({ context: b, type: T.dotsOptions.type })
                                            b.beginPath()
                                            for (
                                                var Fe = function (Ze) {
                                                        for (
                                                            var Xr = function (Bt) {
                                                                    if (!(!((j = Y[Ze]) === null || j === void 0) && j[Bt])) return "continue"
                                                                    He.draw(Re + Ze * W, Ne + Bt * W, W, function (Ya, Gt) {
                                                                        var Vt
                                                                        return !!(!((Vt = Y[Ze + Ya]) === null || Vt === void 0) && Vt[Bt + Gt])
                                                                    })
                                                                },
                                                                dt = 0;
                                                            dt < Y[Ze].length;
                                                            dt++
                                                        )
                                                            Xr(dt)
                                                    },
                                                    Le = 0;
                                                Le < Y.length;
                                                Le++
                                            )
                                                Fe(Le)
                                        }
                                        if (!((q = T.cornersSquareOptions) === null || q === void 0) && q.gradient) {
                                            var $t = T.cornersSquareOptions.gradient,
                                                nt = S._createGradient({
                                                    context: b,
                                                    options: $t,
                                                    additionalRotation: ke,
                                                    x: Re,
                                                    y: Ne,
                                                    size: J,
                                                })
                                            $t.colorStops.forEach(function (Ze) {
                                                var Xr = Ze.offset,
                                                    dt = Ze.color
                                                nt.addColorStop(Xr, dt)
                                            }),
                                                (b.fillStyle = b.strokeStyle = nt)
                                        } else
                                            !((ae = T.cornersSquareOptions) === null || ae === void 0) &&
                                                ae.color &&
                                                (b.fillStyle = b.strokeStyle = T.cornersSquareOptions.color)
                                        if ((b.fill("evenodd"), (te = T.cornersDotOptions) === null || te === void 0 ? void 0 : te.type)) {
                                            var lt = new Z({
                                                context: b,
                                                type: (fe = T.cornersDotOptions) === null || fe === void 0 ? void 0 : fe.type,
                                            })
                                            b.beginPath(), lt.draw(Re + 2 * W, Ne + 2 * W, ee, ke)
                                        } else {
                                            ;(He = new L({ context: b, type: T.dotsOptions.type })), b.beginPath()
                                            var Zr = function (Ze) {
                                                for (
                                                    var Xr = function (Bt) {
                                                            if (!(!((Se = X[Ze]) === null || Se === void 0) && Se[Bt])) return "continue"
                                                            He.draw(Re + Ze * W, Ne + Bt * W, W, function (Ya, Gt) {
                                                                var Vt
                                                                return !!(!((Vt = X[Ze + Ya]) === null || Vt === void 0) && Vt[Bt + Gt])
                                                            })
                                                        },
                                                        dt = 0;
                                                    dt < X[Ze].length;
                                                    dt++
                                                )
                                                    Xr(dt)
                                            }
                                            for (Le = 0; Le < X.length; Le++) Zr(Le)
                                        }
                                        if (!((ue = T.cornersDotOptions) === null || ue === void 0) && ue.gradient) {
                                            $t = T.cornersDotOptions.gradient
                                            var kt = S._createGradient({
                                                context: b,
                                                options: $t,
                                                additionalRotation: ke,
                                                x: Re + 2 * W,
                                                y: Ne + 2 * W,
                                                size: ee,
                                            })
                                            $t.colorStops.forEach(function (Ze) {
                                                var Xr = Ze.offset,
                                                    dt = Ze.color
                                                kt.addColorStop(Xr, dt)
                                            }),
                                                (b.fillStyle = b.strokeStyle = kt)
                                        } else
                                            !((me = T.cornersDotOptions) === null || me === void 0) &&
                                                me.color &&
                                                (b.fillStyle = b.strokeStyle = T.cornersDotOptions.color)
                                        b.fill("evenodd")
                                    }
                                })
                            }),
                            (R.prototype.loadImage = function () {
                                var C = this
                                return new Promise(function (S, b) {
                                    var T = C._options,
                                        Q = new Image()
                                    if (!T.image) return b("Image is not defined")
                                    typeof T.imageOptions.crossOrigin == "string" && (Q.crossOrigin = T.imageOptions.crossOrigin),
                                        (C._image = Q),
                                        (Q.onload = function () {
                                            S()
                                        }),
                                        (Q.src = T.image)
                                })
                            }),
                            (R.prototype.drawImage = function (C) {
                                var S = C.width,
                                    b = C.height,
                                    T = C.count,
                                    Q = C.dotSize,
                                    k = this.context
                                if (!k) throw "canvasContext is not defined"
                                if (!this._image) throw "image is not defined"
                                var W = this._options,
                                    J = Math.floor((W.width - T * Q) / 2),
                                    ee = Math.floor((W.height - T * Q) / 2),
                                    ne = J + W.imageOptions.margin + (T * Q - S) / 2,
                                    xe = ee + W.imageOptions.margin + (T * Q - b) / 2,
                                    ce = S - 2 * W.imageOptions.margin,
                                    de = b - 2 * W.imageOptions.margin
                                k.drawImage(this._image, ne, xe, ce < 0 ? 0 : ce, de < 0 ? 0 : de)
                            }),
                            (R.prototype._createGradient = function (C) {
                                var S,
                                    b = C.context,
                                    T = C.options,
                                    Q = C.additionalRotation,
                                    k = C.x,
                                    W = C.y,
                                    J = C.size
                                if (T.type === "radial") S = b.createRadialGradient(k + J / 2, W + J / 2, 0, k + J / 2, W + J / 2, J / 2)
                                else {
                                    var ee = ((T.rotation || 0) + Q) % (2 * Math.PI),
                                        ne = (ee + 2 * Math.PI) % (2 * Math.PI),
                                        xe = k + J / 2,
                                        ce = W + J / 2,
                                        de = k + J / 2,
                                        H = W + J / 2
                                    ;(ne >= 0 && ne <= 0.25 * Math.PI) || (ne > 1.75 * Math.PI && ne <= 2 * Math.PI)
                                        ? ((xe -= J / 2), (ce -= (J / 2) * Math.tan(ee)), (de += J / 2), (H += (J / 2) * Math.tan(ee)))
                                        : ne > 0.25 * Math.PI && ne <= 0.75 * Math.PI
                                        ? ((ce -= J / 2), (xe -= J / 2 / Math.tan(ee)), (H += J / 2), (de += J / 2 / Math.tan(ee)))
                                        : ne > 0.75 * Math.PI && ne <= 1.25 * Math.PI
                                        ? ((xe += J / 2), (ce += (J / 2) * Math.tan(ee)), (de -= J / 2), (H -= (J / 2) * Math.tan(ee)))
                                        : ne > 1.25 * Math.PI &&
                                          ne <= 1.75 * Math.PI &&
                                          ((ce += J / 2), (xe += J / 2 / Math.tan(ee)), (H -= J / 2), (de -= J / 2 / Math.tan(ee))),
                                        (S = b.createLinearGradient(Math.round(xe), Math.round(ce), Math.round(de), Math.round(H)))
                                }
                                return S
                            }),
                            R
                        )
                    })()
                    for (var he = {}, oe = 0; oe <= 40; oe++) he[oe] = oe
                    const le = {
                        width: 300,
                        height: 300,
                        data: "",
                        margin: 0,
                        qrOptions: { typeNumber: he[0], mode: void 0, errorCorrectionLevel: "Q" },
                        imageOptions: { hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 },
                        dotsOptions: { type: "square", color: "#000" },
                        backgroundOptions: { color: "#fff" },
                    }
                    var Te = function () {
                        return (Te =
                            Object.assign ||
                            function (R) {
                                for (var C, S = 1, b = arguments.length; S < b; S++)
                                    for (var T in (C = arguments[S])) Object.prototype.hasOwnProperty.call(C, T) && (R[T] = C[T])
                                return R
                            }).apply(this, arguments)
                    }
                    function ye(R) {
                        var C = Te({}, R)
                        if (!C.colorStops || !C.colorStops.length) throw "Field 'colorStops' is required in gradient"
                        return (
                            C.rotation ? (C.rotation = Number(C.rotation)) : (C.rotation = 0),
                            (C.colorStops = C.colorStops.map(function (S) {
                                return Te(Te({}, S), { offset: Number(S.offset) })
                            })),
                            C
                        )
                    }
                    function Ae(R) {
                        var C = Te({}, R)
                        return (
                            (C.width = Number(C.width)),
                            (C.height = Number(C.height)),
                            (C.margin = Number(C.margin)),
                            (C.imageOptions = Te(Te({}, C.imageOptions), {
                                hideBackgroundDots: Boolean(C.imageOptions.hideBackgroundDots),
                                imageSize: Number(C.imageOptions.imageSize),
                                margin: Number(C.imageOptions.margin),
                            })),
                            C.margin > Math.min(C.width, C.height) && (C.margin = Math.min(C.width, C.height)),
                            (C.dotsOptions = Te({}, C.dotsOptions)),
                            C.dotsOptions.gradient && (C.dotsOptions.gradient = ye(C.dotsOptions.gradient)),
                            C.cornersSquareOptions &&
                                ((C.cornersSquareOptions = Te({}, C.cornersSquareOptions)),
                                C.cornersSquareOptions.gradient && (C.cornersSquareOptions.gradient = ye(C.cornersSquareOptions.gradient))),
                            C.cornersDotOptions &&
                                ((C.cornersDotOptions = Te({}, C.cornersDotOptions)),
                                C.cornersDotOptions.gradient && (C.cornersDotOptions.gradient = ye(C.cornersDotOptions.gradient))),
                            C.backgroundOptions &&
                                ((C.backgroundOptions = Te({}, C.backgroundOptions)),
                                C.backgroundOptions.gradient && (C.backgroundOptions.gradient = ye(C.backgroundOptions.gradient))),
                            C
                        )
                    }
                    var O = a(192),
                        u = a.n(O)
                    const E = (function () {
                        function R(C) {
                            ;(this._options = C ? Ae(B(le, C)) : le), this.update()
                        }
                        return (
                            (R._clearContainer = function (C) {
                                C && (C.innerHTML = "")
                            }),
                            (R.prototype.update = function (C) {
                                R._clearContainer(this._container),
                                    (this._options = C ? Ae(B(this._options, C)) : this._options),
                                    this._options.data &&
                                        ((this._qr = u()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel)),
                                        this._qr.addData(
                                            this._options.data,
                                            this._options.qrOptions.mode ||
                                                (function (S) {
                                                    switch (!0) {
                                                        case /^[0-9]*$/.test(S):
                                                            return "Numeric"
                                                        case /^[0-9A-Z $%*+\-./:]*$/.test(S):
                                                            return "Alphanumeric"
                                                        default:
                                                            return "Byte"
                                                    }
                                                })(this._options.data)
                                        ),
                                        this._qr.make(),
                                        (this._canvas = new ie(this._options)),
                                        (this._drawingPromise = this._canvas.drawQR(this._qr)),
                                        this.append(this._container))
                            }),
                            (R.prototype.append = function (C) {
                                if (C) {
                                    if (typeof C.appendChild != "function") throw "Container should be a single DOM node"
                                    this._canvas && C.appendChild(this._canvas.getCanvas()), (this._container = C)
                                }
                            }),
                            (R.prototype.getImageUrl = function (C) {
                                return (
                                    (S = this),
                                    (b = void 0),
                                    (Q = function () {
                                        return (function (k, W) {
                                            var J,
                                                ee,
                                                ne,
                                                xe,
                                                ce = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & ne[0]) throw ne[1]
                                                        return ne[1]
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                }
                                            return (
                                                (xe = { next: de(0), throw: de(1), return: de(2) }),
                                                typeof Symbol == "function" &&
                                                    (xe[Symbol.iterator] = function () {
                                                        return this
                                                    }),
                                                xe
                                            )
                                            function de(H) {
                                                return function (j) {
                                                    return (function (q) {
                                                        if (J) throw new TypeError("Generator is already executing.")
                                                        for (; ce; )
                                                            try {
                                                                if (
                                                                    ((J = 1),
                                                                    ee &&
                                                                        (ne =
                                                                            2 & q[0]
                                                                                ? ee.return
                                                                                : q[0]
                                                                                ? ee.throw || ((ne = ee.return) && ne.call(ee), 0)
                                                                                : ee.next) &&
                                                                        !(ne = ne.call(ee, q[1])).done)
                                                                )
                                                                    return ne
                                                                switch (((ee = 0), ne && (q = [2 & q[0], ne.value]), q[0])) {
                                                                    case 0:
                                                                    case 1:
                                                                        ne = q
                                                                        break
                                                                    case 4:
                                                                        return ce.label++, { value: q[1], done: !1 }
                                                                    case 5:
                                                                        ce.label++, (ee = q[1]), (q = [0])
                                                                        continue
                                                                    case 7:
                                                                        ;(q = ce.ops.pop()), ce.trys.pop()
                                                                        continue
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (ne = (ne = ce.trys).length > 0 && ne[ne.length - 1]) ||
                                                                                (q[0] !== 6 && q[0] !== 2)
                                                                            )
                                                                        ) {
                                                                            ce = 0
                                                                            continue
                                                                        }
                                                                        if (q[0] === 3 && (!ne || (q[1] > ne[0] && q[1] < ne[3]))) {
                                                                            ce.label = q[1]
                                                                            break
                                                                        }
                                                                        if (q[0] === 6 && ce.label < ne[1]) {
                                                                            ;(ce.label = ne[1]), (ne = q)
                                                                            break
                                                                        }
                                                                        if (ne && ce.label < ne[2]) {
                                                                            ;(ce.label = ne[2]), ce.ops.push(q)
                                                                            break
                                                                        }
                                                                        ne[2] && ce.ops.pop(), ce.trys.pop()
                                                                        continue
                                                                }
                                                                q = W.call(k, ce)
                                                            } catch (ae) {
                                                                ;(q = [6, ae]), (ee = 0)
                                                            } finally {
                                                                J = ne = 0
                                                            }
                                                        if (5 & q[0]) throw q[1]
                                                        return { value: q[0] ? q[1] : void 0, done: !0 }
                                                    })([H, j])
                                                }
                                            }
                                        })(this, function (k) {
                                            switch (k.label) {
                                                case 0:
                                                    return this._drawingPromise ? [4, this._drawingPromise] : [2, ""]
                                                case 1:
                                                    return k.sent() === void 0 && this._canvas
                                                        ? [2, this._canvas.getCanvas().toDataURL("image/" + C)]
                                                        : [2, ""]
                                            }
                                        })
                                    }),
                                    new ((T = void 0) || (T = Promise))(function (k, W) {
                                        function J(xe) {
                                            try {
                                                ne(Q.next(xe))
                                            } catch (ce) {
                                                W(ce)
                                            }
                                        }
                                        function ee(xe) {
                                            try {
                                                ne(Q.throw(xe))
                                            } catch (ce) {
                                                W(ce)
                                            }
                                        }
                                        function ne(xe) {
                                            var ce
                                            xe.done
                                                ? k(xe.value)
                                                : ((ce = xe.value),
                                                  ce instanceof T
                                                      ? ce
                                                      : new T(function (de) {
                                                            de(ce)
                                                        })).then(J, ee)
                                        }
                                        ne((Q = Q.apply(S, b || [])).next())
                                    })
                                )
                                var S, b, T, Q
                            }),
                            (R.prototype.download = function (C) {
                                var S = this
                                this._drawingPromise &&
                                    this._drawingPromise.then(function () {
                                        if (S._canvas) {
                                            var b = C,
                                                T = b.extension || "png",
                                                Q = b.name || "qr"
                                            ;(function (k, W) {
                                                var J = document.createElement("a")
                                                ;(J.download = W),
                                                    (J.href = k),
                                                    document.body.appendChild(J),
                                                    J.click(),
                                                    document.body.removeChild(J)
                                            })(S._canvas.getCanvas().toDataURL("image/" + T), Q + "." + T)
                                        }
                                    })
                            }),
                            R
                        )
                    })()
                    var $ = function (R, C, S, b) {
                            return new (S || (S = Promise))(function (T, Q) {
                                function k(ee) {
                                    try {
                                        J(b.next(ee))
                                    } catch (ne) {
                                        Q(ne)
                                    }
                                }
                                function W(ee) {
                                    try {
                                        J(b.throw(ee))
                                    } catch (ne) {
                                        Q(ne)
                                    }
                                }
                                function J(ee) {
                                    var ne
                                    ee.done
                                        ? T(ee.value)
                                        : ((ne = ee.value),
                                          ne instanceof S
                                              ? ne
                                              : new S(function (xe) {
                                                    xe(ne)
                                                })).then(k, W)
                                }
                                J((b = b.apply(R, C || [])).next())
                            })
                        },
                        N = function (R, C) {
                            var S,
                                b,
                                T,
                                Q,
                                k = {
                                    label: 0,
                                    sent: function () {
                                        if (1 & T[0]) throw T[1]
                                        return T[1]
                                    },
                                    trys: [],
                                    ops: [],
                                }
                            return (
                                (Q = { next: W(0), throw: W(1), return: W(2) }),
                                typeof Symbol == "function" &&
                                    (Q[Symbol.iterator] = function () {
                                        return this
                                    }),
                                Q
                            )
                            function W(J) {
                                return function (ee) {
                                    return (function (ne) {
                                        if (S) throw new TypeError("Generator is already executing.")
                                        for (; k; )
                                            try {
                                                if (
                                                    ((S = 1),
                                                    b &&
                                                        (T =
                                                            2 & ne[0]
                                                                ? b.return
                                                                : ne[0]
                                                                ? b.throw || ((T = b.return) && T.call(b), 0)
                                                                : b.next) &&
                                                        !(T = T.call(b, ne[1])).done)
                                                )
                                                    return T
                                                switch (((b = 0), T && (ne = [2 & ne[0], T.value]), ne[0])) {
                                                    case 0:
                                                    case 1:
                                                        T = ne
                                                        break
                                                    case 4:
                                                        return k.label++, { value: ne[1], done: !1 }
                                                    case 5:
                                                        k.label++, (b = ne[1]), (ne = [0])
                                                        continue
                                                    case 7:
                                                        ;(ne = k.ops.pop()), k.trys.pop()
                                                        continue
                                                    default:
                                                        if (
                                                            !((T = (T = k.trys).length > 0 && T[T.length - 1]) || (ne[0] !== 6 && ne[0] !== 2))
                                                        ) {
                                                            k = 0
                                                            continue
                                                        }
                                                        if (ne[0] === 3 && (!T || (ne[1] > T[0] && ne[1] < T[3]))) {
                                                            k.label = ne[1]
                                                            break
                                                        }
                                                        if (ne[0] === 6 && k.label < T[1]) {
                                                            ;(k.label = T[1]), (T = ne)
                                                            break
                                                        }
                                                        if (T && k.label < T[2]) {
                                                            ;(k.label = T[2]), k.ops.push(ne)
                                                            break
                                                        }
                                                        T[2] && k.ops.pop(), k.trys.pop()
                                                        continue
                                                }
                                                ne = C.call(R, k)
                                            } catch (xe) {
                                                ;(ne = [6, xe]), (b = 0)
                                            } finally {
                                                S = T = 0
                                            }
                                        if (5 & ne[0]) throw ne[1]
                                        return { value: ne[0] ? ne[1] : void 0, done: !0 }
                                    })([J, ee])
                                }
                            }
                        }
                    const M = {
                        name: "QRCodeVue3",
                        props: {
                            width: { type: Number, default: 300 },
                            imgclass: { type: String, default: "" },
                            myclass: { type: String, default: "" },
                            downloadButton: { type: String, default: "" },
                            ButtonName: { type: String, default: "Download3" },
                            height: { type: Number, default: 300 },
                            value: { type: String, required: !0 },
                            image: { type: String, default: "" },
                            qrOptions: {
                                type: Object,
                                default: function () {
                                    return { typeNumber: 0, mode: "Byte", errorCorrectionLevel: "Q" }
                                },
                            },
                            imageOptions: {
                                type: Object,
                                default: function () {
                                    return { hideBackgroundDots: !0, imageSize: 0.4, margin: 0 }
                                },
                            },
                            dotsOptions: {
                                type: Object,
                                default: function () {
                                    return {
                                        type: "dots",
                                        color: "#6a1a4c",
                                        gradient: {
                                            type: "linear",
                                            rotation: 0,
                                            colorStops: [
                                                { offset: 0, color: "#6a1a4c" },
                                                { offset: 1, color: "#6a1a4c" },
                                            ],
                                        },
                                    }
                                },
                            },
                            backgroundOptions: {
                                type: Object,
                                default: function () {
                                    return { color: "#ffffff" }
                                },
                            },
                            cornersSquareOptions: {
                                type: Object,
                                default: function () {
                                    return { type: "dot", color: "#000000" }
                                },
                            },
                            cornersDotOptions: {
                                type: Object,
                                default: function () {
                                    return { type: void 0, color: "#000000" }
                                },
                            },
                            fileExt: { type: String, default: "png" },
                            download: { type: Boolean, default: !1 },
                            downloadOptions: {
                                type: Object,
                                default: function () {
                                    return { name: "vqr", extension: "png" }
                                },
                            },
                        },
                        data: function () {
                            return {
                                imageUrl: "",
                                qrCode: new E({
                                    data: this.value,
                                    width: this.width,
                                    height: this.height,
                                    qrOptions: this.qrOptions,
                                    imageOptions: this.imageOptions,
                                    dotsOptions: this.dotsOptions,
                                    backgroundOptions: this.backgroundOptions,
                                    image: this.image,
                                    cornersSquareOptions: this.cornersSquareOptions,
                                    cornersDotOptions: this.cornersDotOptions,
                                }),
                            }
                        },
                        watch: {
                            value: function () {
                                return $(this, void 0, void 0, function () {
                                    var R
                                    return N(this, function (C) {
                                        switch (C.label) {
                                            case 0:
                                                return (
                                                    (this.qrCode = new E({
                                                        data: this.value,
                                                        width: this.width,
                                                        height: this.height,
                                                        qrOptions: this.qrOptions,
                                                        imageOptions: this.imageOptions,
                                                        dotsOptions: this.dotsOptions,
                                                        backgroundOptions: this.backgroundOptions,
                                                        image: this.image,
                                                        cornersSquareOptions: this.cornersSquareOptions,
                                                        cornersDotOptions: this.cornersDotOptions,
                                                    })),
                                                    (R = this),
                                                    [4, this.qrCode.getImageUrl(this.fileExt)]
                                                )
                                            case 1:
                                                return (R.imageUrl = C.sent()), [2]
                                        }
                                    })
                                })
                            },
                        },
                        mounted: function () {
                            return $(this, void 0, void 0, function () {
                                var R
                                return N(this, function (C) {
                                    switch (C.label) {
                                        case 0:
                                            return (R = this), [4, this.qrCode.getImageUrl(this.fileExt)]
                                        case 1:
                                            return (R.imageUrl = C.sent()), [2]
                                    }
                                })
                            })
                        },
                        render: function (R, C, S, b, T, Q) {
                            return (
                                (0, c.openBlock)(),
                                (0, c.createBlock)("div", null, [
                                    T.imageUrl
                                        ? ((0, c.openBlock)(),
                                          (0, c.createBlock)(
                                              "div",
                                              { key: 0, class: S.myclass },
                                              [
                                                  (0, c.createVNode)(
                                                      "img",
                                                      { src: T.imageUrl, class: S.imgclass, crossorigin: "anonymous" },
                                                      null,
                                                      10,
                                                      ["src"]
                                                  ),
                                              ],
                                              2
                                          ))
                                        : (0, c.createCommentVNode)("v-if", !0),
                                    S.download
                                        ? ((0, c.openBlock)(),
                                          (0, c.createBlock)("div", g, [
                                              (0, c.createVNode)(
                                                  "button",
                                                  {
                                                      onClick: C[1] || (C[1] = (...k) => R.onDownloadClick && R.onDownloadClick(...k)),
                                                      class: S.downloadButton,
                                                  },
                                                  (0, c.toDisplayString)(S.ButtonName),
                                                  3
                                              ),
                                          ]))
                                        : (0, c.createCommentVNode)("v-if", !0),
                                ])
                            )
                        },
                    }
                })(),
                l.default
            )
        })()
    })
})(lib)
var QRCodeVue3 = getDefaultExportFromCjs(lib.exports)
const _hoisted_1$6 = { key: 0, class: "h-100", style: { position: "relative" } },
    _hoisted_2$5 = ["src", "alt"],
    _hoisted_3$5 = ["src", "alt"],
    _sfc_main$6 = defineComponent({
        __name: "Image",
        props: { series: null, image: null, gallery: null, isLink: { type: Boolean }, hideQR: { type: Boolean } },
        setup(t) {
            const e = t,
                n = inject("app"),
                i = computed(() => n.series[e.series]),
                o = computed(() => "https://unrealart.infura-ipfs.io/ipfs/" + i.value.images[e.image]),
                a = e.gallery ? "?g=" + e.gallery : "",
                l = computed(() => location.protocol + "//" + location.host + "/image/" + e.series + "/" + e.image + a)
            return (c, g) => {
                const v = resolveComponent("router-link")
                return (
                    openBlock(),
                    createElementBlock("div", null, [
                        unref(i)
                            ? (openBlock(),
                              createElementBlock("div", _hoisted_1$6, [
                                  t.isLink
                                      ? (openBlock(),
                                        createBlock$1(
                                            v,
                                            { key: 0, to: "/image/" + e.series + "/" + e.image },
                                            {
                                                default: withCtx(() => [
                                                    createBaseVNode(
                                                        "img",
                                                        {
                                                            style: {
                                                                position: "relative",
                                                                height: "100%",
                                                                width: "100%",
                                                                "object-fit": "contain",
                                                            },
                                                            src: unref(o),
                                                            class: "d-block",
                                                            alt: unref(i).name + " " + t.image,
                                                        },
                                                        null,
                                                        8,
                                                        _hoisted_2$5
                                                    ),
                                                ]),
                                                _: 1,
                                            },
                                            8,
                                            ["to"]
                                        ))
                                      : (openBlock(),
                                        createElementBlock(
                                            "img",
                                            {
                                                key: 1,
                                                style: { position: "relative", height: "100%", width: "100%", "object-fit": "contain" },
                                                src: unref(o),
                                                class: "d-block",
                                                alt: unref(i).name + " " + t.image,
                                            },
                                            null,
                                            8,
                                            _hoisted_3$5
                                        )),
                                  t.hideQR
                                      ? createCommentVNode("", !0)
                                      : (openBlock(),
                                        createBlock$1(
                                            unref(QRCodeVue3),
                                            {
                                                key: 2,
                                                class: "d-none d-md-block",
                                                style: { position: "absolute", bottom: "20px", right: "20px" },
                                                value: unref(l),
                                                width: 150,
                                                height: 150,
                                                backgroundOptions: { color: "#bbb" },
                                                dotsOptions: { type: "rounded", color: "#000" },
                                            },
                                            null,
                                            8,
                                            ["value"]
                                        )),
                              ]))
                            : createCommentVNode("", !0),
                    ])
                )
            }
        },
    }),
    _hoisted_1$5 = { class: "mx-md-3" },
    _hoisted_2$4 = createBaseVNode("div", { class: "text-center my-5" }, [createBaseVNode("h1", null, "UnRealArt")], -1),
    _hoisted_3$4 = { style: { position: "relative" }, class: "d-block d-md-none" },
    _hoisted_4$4 = { style: { position: "relative" }, class: "d-none d-md-block" },
    _hoisted_5$4 = createBaseVNode("img", { class: "w-100", style: { position: "relative" }, src: _imports_0 }, null, -1),
    _hoisted_6$4 = { class: "mt-3 mb-5 text-center" },
    _hoisted_7$4 = createTextVNode("<<"),
    _hoisted_8$4 = createTextVNode("<"),
    _hoisted_9$4 = createTextVNode(">"),
    _hoisted_10$3 = createTextVNode(">>"),
    _hoisted_11$3 = createStaticVNode(
        '<div class="text-center mb-5"><h2>What&#39;s this?</h2><p style="max-width:600px;" class="mx-auto"> UnRealArt is a fully decentralized platform that lets anyone upload AI art series to sell as NFTs. Anyone can sell these in real-world &quot;galleries&quot; (one or more screens) and receive a 10% commission.<br></p><h2>Pop-up gallery in Amsterdam (NDSM Treehouse)</h2><p style="max-width:600px;" class="mx-auto"> The UnrealArt exhibition showcases a wide variety of AI art. Every few minutes a new series of artworks is shown. Explore the boundaries of creativity and the latest technology in this one-of-a-kind exhibition.<br><br> Try your hand at creating your own AI art on the spot. By providing a few prompts you will create your own artworks. We may even include them in the exhibition.<br><br> Opening Event: 16th of September 4pm-9pm<br> Dates: 17-25 September 1pm-7pm<br> Location: <a href="https://www.treehousendsm.com/pages/contact" target="_blank" class="me-1">NDSM Treehouse unit M3</a><a href="https://goo.gl/maps/N7xmUoshiVvYUKBR9" target="_blank">Google Maps</a><br></p></div><h2 class="text-center">Series</h2>',
        2
    ),
    _hoisted_13$3 = { class: "mb-5" },
    _hoisted_14$3 = { class: "row" },
    _hoisted_15$3 = { class: "text-center" },
    _hoisted_16$3 = createBaseVNode("h2", { class: "text-center" }, "Add your own artworks", -1),
    _hoisted_17$3 = createTextVNode(
        " You can add your own series of AI artworks. These may be shown in galleries, including the one at NDSM Treehouse in Amsterdam."
    ),
    _hoisted_18$3 = createBaseVNode("br", null, null, -1),
    _hoisted_19$3 = createTextVNode("Add Artwork"),
    _hoisted_20$2 = { class: "text-center" },
    _hoisted_21$2 = createBaseVNode("h2", { class: "text-center" }, "Run a Gallery", -1),
    _hoisted_22$2 = createBaseVNode(
        "p",
        null,
        "Got a spare screen? Display AI art and get 10% commission on sales made through the QR code.",
        -1
    ),
    _hoisted_23$1 = createTextVNode("One"),
    _hoisted_24$1 = createTextVNode("Two"),
    _hoisted_25 = createTextVNode("Three"),
    _hoisted_26 = createTextVNode("Four"),
    _hoisted_27 = createTextVNode("Five"),
    _hoisted_28 = createBaseVNode("br", null, null, -1),
    _sfc_main$5 = defineComponent({
        __name: "Home",
        setup(t) {
            const e = inject("app"),
                n = ref(""),
                i = () => {
                    e.image--, e.image < 0 && (e.serie--, (e.image = e.series[e.serie].images.length - 1))
                },
                o = () => {
                    e.image++, e.image >= e.series[e.serie].images.length && (e.serie++, (e.image = 0))
                },
                a = () => {
                    e.serie--, (e.image = 0)
                },
                l = () => {
                    e.serie++, (e.image = 0)
                }
            return (c, g) => {
                const v = resolveComponent("b-button"),
                    _ = resolveComponent("router-link"),
                    A = resolveComponent("b-form-input")
                return (
                    openBlock(),
                    createElementBlock("div", _hoisted_1$5, [
                        _hoisted_2$4,
                        createBaseVNode("div", _hoisted_3$4, [
                            createVNode(_sfc_main$6, { series: unref(e).serie, image: unref(e).image, isLink: "", "hide-q-r": "" }, null, 8, [
                                "series",
                                "image",
                            ]),
                        ]),
                        createBaseVNode("div", _hoisted_4$4, [
                            _hoisted_5$4,
                            createVNode(
                                _sfc_main$6,
                                {
                                    style: {
                                        position: "absolute",
                                        top: "18%",
                                        right: "20%",
                                        left: "20%",
                                        bottom: "29%",
                                        "background-color": "black",
                                    },
                                    series: unref(e).serie,
                                    image: unref(e).image,
                                    isLink: "",
                                    "hide-q-r": "",
                                },
                                null,
                                8,
                                ["series", "image"]
                            ),
                        ]),
                        createBaseVNode("div", _hoisted_6$4, [
                            createVNode(v, { onClick: a, disabled: unref(e).serie == 0 }, { default: withCtx(() => [_hoisted_7$4]), _: 1 }, 8, [
                                "disabled",
                            ]),
                            createVNode(
                                v,
                                { class: "ms-2", onClick: i, disabled: unref(e).image == 0 && unref(e).serie == 0 },
                                { default: withCtx(() => [_hoisted_8$4]), _: 1 },
                                8,
                                ["disabled"]
                            ),
                            createVNode(
                                v,
                                {
                                    class: "ms-2",
                                    onClick: o,
                                    disabled:
                                        unref(e).serie == unref(e).series.length - 1 &&
                                        unref(e).image == unref(e).series[unref(e).serie].images.length - 1,
                                },
                                { default: withCtx(() => [_hoisted_9$4]), _: 1 },
                                8,
                                ["disabled"]
                            ),
                            createVNode(
                                v,
                                { class: "ms-2", onClick: l, disabled: unref(e).serie == unref(e).series.length - 1 },
                                { default: withCtx(() => [_hoisted_10$3]), _: 1 },
                                8,
                                ["disabled"]
                            ),
                        ]),
                        _hoisted_11$3,
                        (openBlock(!0),
                        createElementBlock(
                            Fragment$1,
                            null,
                            renderList(
                                unref(e).series,
                                (B, D) => (
                                    openBlock(),
                                    createElementBlock("div", _hoisted_13$3, [
                                        createBaseVNode("div", _hoisted_14$3, [
                                            createVNode(
                                                _sfc_main$6,
                                                { class: "col", style: { width: "25%" }, series: D, image: 1, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                            createVNode(
                                                _sfc_main$6,
                                                { class: "col", style: { width: "25%" }, series: D, image: 2, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                            createVNode(
                                                _sfc_main$6,
                                                { class: "col", style: { width: "25%" }, series: D, image: 3, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                        ]),
                                        createBaseVNode(
                                            "h3",
                                            null,
                                            toDisplayString(B.name) + " (" + toDisplayString(B.images.length) + " works)",
                                            1
                                        ),
                                    ])
                                )
                            ),
                            256
                        )),
                        createBaseVNode("div", _hoisted_15$3, [
                            _hoisted_16$3,
                            _hoisted_17$3,
                            _hoisted_18$3,
                            createVNode(
                                _,
                                { to: "/manager" },
                                {
                                    default: withCtx(() => [
                                        createVNode(v, { class: "my-3" }, { default: withCtx(() => [_hoisted_19$3]), _: 1 }),
                                    ]),
                                    _: 1,
                                }
                            ),
                        ]),
                        createBaseVNode("div", _hoisted_20$2, [
                            _hoisted_21$2,
                            _hoisted_22$2,
                            createVNode(
                                A,
                                {
                                    class: "mx-auto my-3",
                                    type: "text",
                                    modelValue: n.value,
                                    "onUpdate:modelValue": g[0] || (g[0] = (B) => (n.value = B)),
                                    placeholder: "Gallery ETH address",
                                    style: { "max-width": "600px" },
                                },
                                null,
                                8,
                                ["modelValue"]
                            ),
                            createVNode(
                                _,
                                { to: "/slide/1/" + n.value },
                                { default: withCtx(() => [createVNode(v, null, { default: withCtx(() => [_hoisted_23$1]), _: 1 })]), _: 1 },
                                8,
                                ["to"]
                            ),
                            createVNode(
                                _,
                                { class: "ms-2", to: "/slide/2/" + n.value },
                                { default: withCtx(() => [createVNode(v, null, { default: withCtx(() => [_hoisted_24$1]), _: 1 })]), _: 1 },
                                8,
                                ["to"]
                            ),
                            createVNode(
                                _,
                                { class: "ms-2", to: "/slide/3/" + n.value },
                                { default: withCtx(() => [createVNode(v, null, { default: withCtx(() => [_hoisted_25]), _: 1 })]), _: 1 },
                                8,
                                ["to"]
                            ),
                            createVNode(
                                _,
                                { class: "ms-2", to: "/slide/4/" + n.value },
                                { default: withCtx(() => [createVNode(v, null, { default: withCtx(() => [_hoisted_26]), _: 1 })]), _: 1 },
                                8,
                                ["to"]
                            ),
                            createVNode(
                                _,
                                { class: "ms-2", to: "/slide/5/" + n.value },
                                { default: withCtx(() => [createVNode(v, null, { default: withCtx(() => [_hoisted_27]), _: 1 })]), _: 1 },
                                8,
                                ["to"]
                            ),
                        ]),
                        _hoisted_28,
                    ])
                )
            }
        },
    }),
    _hoisted_1$4 = { key: 0 },
    _hoisted_2$3 = { class: "m-3" },
    _hoisted_3$3 = { style: { "max-width": "480px" }, class: "ms-3 ms-lg-auto me-3" },
    _hoisted_4$3 = { class: "float-end" },
    _hoisted_5$3 = { key: 0 },
    _hoisted_6$3 = { key: 0 },
    _hoisted_7$3 = createTextVNode("Buy"),
    _hoisted_8$3 = { key: 1 },
    _hoisted_9$3 = createTextVNode("Connect"),
    _hoisted_10$2 = { key: 0 },
    _hoisted_11$2 = createBaseVNode("br", null, null, -1),
    _hoisted_12$2 = { key: 0 },
    _hoisted_13$2 = { key: 1 },
    _hoisted_14$2 = { key: 2 },
    _hoisted_15$2 = { key: 3 },
    _hoisted_16$2 = { key: 0 },
    _hoisted_17$2 = { key: 1 },
    _hoisted_18$2 = { key: 2 },
    _hoisted_19$2 = { key: 4 },
    _hoisted_20$1 = createTextVNode(" To buy this artwork, please install an Ethereum wallet such as "),
    _hoisted_21$1 = createBaseVNode("a", { href: "https://metamask.io/download/", target: "_blank" }, "MetaMask", -1),
    _hoisted_22$1 = [_hoisted_20$1, _hoisted_21$1],
    _sfc_main$4 = defineComponent({
        __name: "ImageDetail",
        setup(t) {
            const e = inject("app"),
                n = computed(() =>
                    e.web3.provider
                        ? UnRealArt__factory.connect("0x8d41Bd479622B68ecF5E59d68B1a2400bE465052", e.web3.provider.getSigner())
                        : null
                ),
                i = useRoute(),
                o = ref(parseInt(i.params.series)),
                a = ref(parseInt(i.params.image)),
                l = computed(() => e.series[o.value]),
                c = ref(!0),
                g = ref(!1),
                v = (A) => {
                    if (
                        ((o.value = parseInt(A.series)),
                        (a.value = parseInt(A.image)),
                        console.log(l.value, o.value, o.value >= 0),
                        l.value && o.value >= 0)
                    ) {
                        const B = BigNumber.from(o.value).mul("1000000000000000000").add(a.value)
                        e.contract.balanceOf(l.value.creator, B).then((D) => {
                            c.value = D.eq("1")
                        }),
                            e.web3.address &&
                                e.contract.balanceOf(e.web3.address, B).then((D) => {
                                    g.value = D.eq("1")
                                }),
                            e.contract.uri(B).then((D) => console.log(D))
                    }
                }
            v(i.params),
                watch(
                    () => [i.params, e.series.length, e.web3.update],
                    (A) => v(A[0])
                )
            const _ = async () => {
                await n.value.buy(o.value, a.value, "0x0000000000000000000000000000000000000000", { value: l.value.price })
            }
            return (A, B) => {
                const D = resolveComponent("b-button")
                return unref(l)
                    ? (openBlock(),
                      createElementBlock("div", _hoisted_1$4, [
                          createBaseVNode("div", _hoisted_2$3, [
                              createVNode(_sfc_main$6, { series: o.value, image: a.value, "hide-q-r": "" }, null, 8, ["series", "image"]),
                          ]),
                          createBaseVNode("div", _hoisted_3$3, [
                              createBaseVNode("div", _hoisted_4$3, [
                                  unref(e).web3.chainId == 1 && unref(e).web3.connector
                                      ? (openBlock(),
                                        createElementBlock("div", _hoisted_5$3, [
                                            unref(e).web3.address
                                                ? (openBlock(),
                                                  createElementBlock("div", _hoisted_6$3, [
                                                      unref(e).web3.address != unref(l).creator && c.value
                                                          ? (openBlock(),
                                                            createBlock$1(
                                                                D,
                                                                { key: 0, onClick: _ },
                                                                { default: withCtx(() => [_hoisted_7$3]), _: 1 }
                                                            ))
                                                          : createCommentVNode("", !0),
                                                  ]))
                                                : (openBlock(),
                                                  createElementBlock("div", _hoisted_8$3, [
                                                      createVNode(
                                                          D,
                                                          { onClick: unref(e).web3.connect },
                                                          { default: withCtx(() => [_hoisted_9$3]), _: 1 },
                                                          8,
                                                          ["onClick"]
                                                      ),
                                                  ])),
                                        ]))
                                      : createCommentVNode("", !0),
                              ]),
                              createBaseVNode("h5", null, [
                                  createBaseVNode(
                                      "strong",
                                      null,
                                      toDisplayString(unref(l).name || "Untitled") + " " + toDisplayString(a.value + 1),
                                      1
                                  ),
                                  unref(l).author
                                      ? (openBlock(),
                                        createElementBlock("span", _hoisted_10$2, [
                                            _hoisted_11$2,
                                            createBaseVNode("small", null, "by " + toDisplayString(unref(l).author), 1),
                                        ]))
                                      : createCommentVNode("", !0),
                              ]),
                              createBaseVNode(
                                  "p",
                                  null,
                                  "This is part of a series of " + toDisplayString(unref(l).images.length) + " artworks.",
                                  1
                              ),
                              unref(l).description
                                  ? (openBlock(),
                                    createElementBlock("p", _hoisted_12$2, toDisplayString(unref(e).series[o.value].description), 1))
                                  : createCommentVNode("", !0),
                              unref(l).process
                                  ? (openBlock(), createElementBlock("p", _hoisted_13$2, "Process: " + toDisplayString(unref(l).process), 1))
                                  : createCommentVNode("", !0),
                              c.value
                                  ? (openBlock(),
                                    createElementBlock(
                                        "p",
                                        _hoisted_14$2,
                                        "Price: " + toDisplayString(unref(l).price.div("1000000000000").toNumber() / 1e6) + " ETH",
                                        1
                                    ))
                                  : createCommentVNode("", !0),
                              unref(e).web3.connected
                                  ? (openBlock(),
                                    createElementBlock("div", _hoisted_15$2, [
                                        unref(e).web3.chainId != 1 && unref(e).web3.connector
                                            ? (openBlock(),
                                              createElementBlock(
                                                  "div",
                                                  _hoisted_16$2,
                                                  " To buy this artwork, please switch your wallet to the Ethereum mainnet. "
                                              ))
                                            : unref(e).web3.address == unref(l).creator
                                            ? (openBlock(), createElementBlock("div", _hoisted_17$2, "You are the creator of this artwork."))
                                            : g.value
                                            ? (openBlock(), createElementBlock("div", _hoisted_18$2, "You are the owner of this artwork."))
                                            : createCommentVNode("", !0),
                                    ]))
                                  : (openBlock(), createElementBlock("div", _hoisted_19$2, _hoisted_22$1)),
                          ]),
                      ]))
                    : createCommentVNode("", !0)
            }
        },
    }),
    _hoisted_1$3 = { class: "h-100" },
    _sfc_main$3 = defineComponent({
        __name: "SlideShow",
        setup(t) {
            const e = inject("app"),
                n = useRoute(),
                i = ref(parseInt(n.params.screen)),
                o = n.params.gallery || AddressZero,
                a = ref(Date.now()),
                l = computed$1(() => Math.floor((a.value / 3e4) % e.series.length)),
                c = computed$1(() => i.value)
            return (
                setInterval(() => {
                    a.value = Date.now()
                }),
                (g, v) => (
                    openBlock(),
                    createElementBlock("div", _hoisted_1$3, [
                        createVNode(_sfc_main$6, { series: unref(l), image: unref(c), gallery: unref(o), class: "h-100" }, null, 8, [
                            "series",
                            "image",
                            "gallery",
                        ]),
                    ])
                )
            )
        },
    })
var vueUploadDropImages_vue_vue_type_style_index_0_scoped_true_lang = "",
    _export_sfc = (t, e) => {
        const n = t.__vccOpts || t
        for (const [i, o] of e) n[i] = o
        return n
    }
const _sfc_main$2 = {
        name: "VueUploadImages",
        data() {
            return { error: "", files: [], dropped: 0, Imgs: [] }
        },
        props: { max: Number, uploadMsg: String, maxError: String, fileError: String, clearAll: String },
        methods: {
            dragOver() {
                this.dropped = 2
            },
            dragLeave() {},
            drop(t) {
                let e = !0,
                    n = Array.from(t.dataTransfer.files)
                t &&
                    n &&
                    (n.forEach((i) => {
                        i.type.startsWith("image") === !1 && (e = !1)
                    }),
                    e == !0
                        ? this.$props.max && n.length + this.files.length > this.$props.max
                            ? (this.error = this.$props.maxError ? this.$props.maxError : "Maximum files is" + this.$props.max)
                            : (this.files.push(...n), this.previewImgs())
                        : (this.error = this.$props.fileError ? this.$props.fileError : "Unsupported file type")),
                    (this.dropped = 0)
            },
            append() {
                this.$refs.uploadInput.click()
            },
            readAsDataURL(t) {
                return new Promise(function (e, n) {
                    let i = new FileReader()
                    ;(i.onload = function () {
                        e(i.result)
                    }),
                        (i.onerror = function () {
                            n(i)
                        }),
                        i.readAsDataURL(t)
                })
            },
            deleteImg(t) {
                this.Imgs.splice(t, 1), this.files.splice(t, 1), this.$emit("changed", this.files), (this.$refs.uploadInput.value = null)
            },
            previewImgs(t) {
                if (this.$props.max && t && t.currentTarget.files.length + this.files.length > this.$props.max) {
                    this.error = this.$props.maxError ? this.$props.maxError : "Maximum files is" + this.$props.max
                    return
                }
                this.dropped == 0 && this.files.push(...t.currentTarget.files), (this.error = ""), this.$emit("changed", this.files)
                let e = []
                if (!!this.files.length) {
                    for (let n = 0; n < this.files.length; n++) e.push(this.readAsDataURL(this.files[n]))
                    Promise.all(e).then((n) => {
                        this.Imgs = n
                    })
                }
            },
            reset() {
                ;(this.$refs.uploadInput.value = null), (this.Imgs = []), (this.files = []), this.$emit("changed", this.files)
            },
        },
    },
    _withScopeId = (t) => (pushScopeId("data-v-3cee12e9"), (t = t()), popScopeId(), t),
    _hoisted_1$2 = { class: "drop" },
    _hoisted_2$2 = { class: "beforeUpload" },
    _hoisted_3$2 = createStaticVNode(
        '<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-v-3cee12e9><title data-v-3cee12e9>Upload Image</title><g id="Upload_Image" data-name="Upload Image" data-v-3cee12e9><g id="_Group_" data-name="&lt;Group&gt;" data-v-3cee12e9><g id="_Group_2" data-name="&lt;Group&gt;" data-v-3cee12e9><g id="_Group_3" data-name="&lt;Group&gt;" data-v-3cee12e9><circle id="_Path_" data-name="&lt;Path&gt;" cx="18.5" cy="16.5" r="5" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></circle></g><polyline id="_Path_2" data-name="&lt;Path&gt;" points="16.5 15.5 18.5 13.5 20.5 15.5" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></polyline><line id="_Path_3" data-name="&lt;Path&gt;" x1="18.5" y1="13.5" x2="18.5" y2="19.5" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></line></g><g id="_Group_4" data-name="&lt;Group&gt;" data-v-3cee12e9><polyline id="_Path_4" data-name="&lt;Path&gt;" points="0.6 15.42 6 10.02 8.98 13" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></polyline><polyline id="_Path_5" data-name="&lt;Path&gt;" points="17.16 11.68 12.5 7.02 7.77 11.79" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></polyline><circle id="_Path_6" data-name="&lt;Path&gt;" cx="8" cy="6.02" r="1.5" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></circle><path id="_Path_7" data-name="&lt;Path&gt;" d="M19.5,11.6V4A1.5,1.5,0,0,0,18,2.5H2A1.5,1.5,0,0,0,.5,4V15A1.5,1.5,0,0,0,2,16.5H13.5" style="fill:none;stroke:#303c42;stroke-linecap:round;stroke-linejoin:round;" data-v-3cee12e9></path></g></g></g></svg>',
        1
    ),
    _hoisted_4$2 = { class: "mainMessage" },
    _hoisted_5$2 = { class: "imgsPreview" },
    _hoisted_6$2 = ["src"],
    _hoisted_7$2 = ["onClick"],
    _hoisted_8$2 = _withScopeId(() =>
        createBaseVNode(
            "svg",
            { class: "icon", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" },
            [
                createBaseVNode("path", {
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round",
                    "stroke-width": "2",
                    d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16",
                }),
            ],
            -1
        )
    ),
    _hoisted_9$2 = [_hoisted_8$2]
function _sfc_render(t, e, n, i, o, a) {
    return (
        openBlock(),
        createElementBlock(
            "div",
            {
                class: "container",
                onDragover: e[3] || (e[3] = withModifiers((...l) => a.dragOver && a.dragOver(...l), ["prevent"])),
                onDragleave: e[4] || (e[4] = withModifiers((...l) => a.dragLeave && a.dragLeave(...l), ["prevent"])),
                onDrop: e[5] || (e[5] = withModifiers((l) => a.drop(l), ["prevent"])),
            },
            [
                withDirectives(createBaseVNode("div", _hoisted_1$2, null, 512), [[vShow, o.dropped == 2]]),
                withDirectives(createBaseVNode("div", { class: "error" }, toDisplayString(o.error), 513), [[vShow, o.error]]),
                withDirectives(
                    createBaseVNode(
                        "div",
                        _hoisted_2$2,
                        [
                            createBaseVNode(
                                "input",
                                {
                                    type: "file",
                                    style: { "z-index": "1" },
                                    accept: "image/*",
                                    ref: "uploadInput",
                                    onChange: e[0] || (e[0] = (...l) => a.previewImgs && a.previewImgs(...l)),
                                    multiple: "",
                                },
                                null,
                                544
                            ),
                            _hoisted_3$2,
                            createBaseVNode(
                                "p",
                                _hoisted_4$2,
                                toDisplayString(n.uploadMsg ? n.uploadMsg : "Click to upload or drop your images here"),
                                1
                            ),
                        ],
                        512
                    ),
                    [[vShow, o.Imgs.length == 0]]
                ),
                withDirectives(
                    createBaseVNode(
                        "div",
                        _hoisted_5$2,
                        [
                            createBaseVNode(
                                "button",
                                { type: "button", class: "clearButton", onClick: e[1] || (e[1] = (...l) => a.reset && a.reset(...l)) },
                                toDisplayString(n.clearAll ? n.clearAll : "clear All"),
                                1
                            ),
                            (openBlock(!0),
                            createElementBlock(
                                Fragment$1,
                                null,
                                renderList(
                                    o.Imgs,
                                    (l, c) => (
                                        openBlock(),
                                        createElementBlock("div", { class: "imageHolder", key: c }, [
                                            createBaseVNode("img", { src: l }, null, 8, _hoisted_6$2),
                                            createBaseVNode(
                                                "span",
                                                { class: "delete", style: { color: "white" }, onClick: (g) => a.deleteImg(--c) },
                                                _hoisted_9$2,
                                                8,
                                                _hoisted_7$2
                                            ),
                                            ++c == o.Imgs.length
                                                ? (openBlock(),
                                                  createElementBlock(
                                                      "div",
                                                      { key: 0, class: "plus", onClick: e[2] || (e[2] = (...g) => a.append && a.append(...g)) },
                                                      "+"
                                                  ))
                                                : createCommentVNode("", !0),
                                        ])
                                    )
                                ),
                                128
                            )),
                        ],
                        512
                    ),
                    [[vShow, o.Imgs.length > 0]]
                ),
            ],
            32
        )
    )
}
var UploadImages = _export_sfc(_sfc_main$2, [
    ["render", _sfc_render],
    ["__scopeId", "data-v-3cee12e9"],
])
const _hoisted_1$1 = { key: 0 },
    _hoisted_2$1 = createBaseVNode("h1", null, "Create Series", -1),
    _hoisted_3$1 = { class: "mb-2" },
    _hoisted_4$1 = createBaseVNode("h3", null, "Author", -1),
    _hoisted_5$1 = createTextVNode("For twitter handles, use the @ notation (@Boring_Crypto). You can also use just a name/handle."),
    _hoisted_6$1 = { class: "mb-2" },
    _hoisted_7$1 = createBaseVNode("h3", null, "Name", -1),
    _hoisted_8$1 = createTextVNode("A short name for the series."),
    _hoisted_9$1 = { class: "mb-2" },
    _hoisted_10$1 = createBaseVNode("h3", null, [createTextVNode("Description "), createBaseVNode("small", null, "(optional)")], -1),
    _hoisted_11$1 = createTextVNode("A description for the series, such as the inspiration or meaning behind it."),
    _hoisted_12$1 = { class: "mb-2" },
    _hoisted_13$1 = createBaseVNode("h3", null, [createTextVNode("Process "), createBaseVNode("small", null, "(optional)")], -1),
    _hoisted_14$1 = createTextVNode("What tools were used? DALL-E, midjourney, etc. What prompts were used? Any after editing?"),
    _hoisted_15$1 = { class: "mb-2" },
    _hoisted_16$1 = createBaseVNode("h3", null, "Price", -1),
    _hoisted_17$1 = createTextVNode("The price in ETH of each artwork."),
    _hoisted_18$1 = createBaseVNode("h2", null, "Images", -1),
    _hoisted_19$1 = createTextVNode("You need at least 5 artworks."),
    _hoisted_20 = createTextVNode("Create Series"),
    _hoisted_21 = { key: 1, class: "row" },
    _hoisted_22 = createBaseVNode("h3", null, "Uploading to IPFS and generating minting transaction", -1),
    _hoisted_23 = { class: "col" },
    _hoisted_24 = ["src"],
    _sfc_main$1 = defineComponent({
        __name: "CreateSeries",
        setup(t) {
            const e = inject("app"),
                n = UnRealArt__factory.connect("0x8d41Bd479622B68ecF5E59d68B1a2400bE465052", e.web3.provider.getSigner()),
                i = ref(""),
                o = ref(""),
                a = ref(""),
                l = ref(""),
                c = ref(0.1),
                g = ref([]),
                v = ref([]),
                _ = (B) => {
                    g.value = B
                },
                A = async () => {
                    console.log("huh"), (v.value = [])
                    for (let B in g.value) {
                        const D = g.value[B],
                            I = await e.ipfs.add(D)
                        v.value.push(I.path)
                    }
                    try {
                        const B = await n.createSeries(
                            i.value.replaceAll('"', "'"),
                            o.value.replaceAll('"', "'"),
                            a.value.replaceAll('"', "'"),
                            l.value.replaceAll('"', "'"),
                            BigNumber.from(c.value * 1e6).mul("1000000000000"),
                            v.value
                        )
                        console.log(B)
                        const D = await B.wait()
                        console.log(D), D.status == 1 && useRouter().push("/")
                    } catch {
                        v.value = []
                    }
                }
            return (B, D) => {
                const I = resolveComponent("b-form-input"),
                    L = resolveComponent("b-form-text"),
                    G = resolveComponent("b-form-textarea"),
                    U = resolveComponent("b-button")
                return (
                    openBlock(),
                    createElementBlock("div", null, [
                        v.value.length
                            ? (openBlock(),
                              createElementBlock("div", _hoisted_21, [
                                  _hoisted_22,
                                  (openBlock(!0),
                                  createElementBlock(
                                      Fragment$1,
                                      null,
                                      renderList(
                                          v.value,
                                          (F, Z) => (
                                              openBlock(),
                                              createElementBlock("div", _hoisted_23, [
                                                  createBaseVNode(
                                                      "img",
                                                      { src: "https://unrealart.infura-ipfs.io/ipfs/" + F, style: { "max-width": "180px" } },
                                                      null,
                                                      8,
                                                      _hoisted_24
                                                  ),
                                              ])
                                          )
                                      ),
                                      256
                                  )),
                              ]))
                            : (openBlock(),
                              createElementBlock("div", _hoisted_1$1, [
                                  _hoisted_2$1,
                                  createBaseVNode("p", null, "Connected with " + toDisplayString(unref(e).web3.address), 1),
                                  createBaseVNode("div", _hoisted_3$1, [
                                      _hoisted_4$1,
                                      createVNode(
                                          I,
                                          {
                                              type: "text",
                                              size: "lg",
                                              modelValue: i.value,
                                              "onUpdate:modelValue": D[0] || (D[0] = (F) => (i.value = F)),
                                          },
                                          null,
                                          8,
                                          ["modelValue"]
                                      ),
                                      createVNode(L, null, { default: withCtx(() => [_hoisted_5$1]), _: 1 }),
                                  ]),
                                  createBaseVNode("div", _hoisted_6$1, [
                                      _hoisted_7$1,
                                      createVNode(
                                          I,
                                          {
                                              type: "text",
                                              size: "lg",
                                              modelValue: o.value,
                                              "onUpdate:modelValue": D[1] || (D[1] = (F) => (o.value = F)),
                                          },
                                          null,
                                          8,
                                          ["modelValue"]
                                      ),
                                      createVNode(L, null, { default: withCtx(() => [_hoisted_8$1]), _: 1 }),
                                  ]),
                                  createBaseVNode("div", _hoisted_9$1, [
                                      _hoisted_10$1,
                                      createVNode(
                                          G,
                                          { size: "lg", modelValue: a.value, "onUpdate:modelValue": D[2] || (D[2] = (F) => (a.value = F)) },
                                          null,
                                          8,
                                          ["modelValue"]
                                      ),
                                      createVNode(L, null, { default: withCtx(() => [_hoisted_11$1]), _: 1 }),
                                  ]),
                                  createBaseVNode("div", _hoisted_12$1, [
                                      _hoisted_13$1,
                                      createVNode(
                                          G,
                                          { size: "lg", modelValue: l.value, "onUpdate:modelValue": D[3] || (D[3] = (F) => (l.value = F)) },
                                          null,
                                          8,
                                          ["modelValue"]
                                      ),
                                      createVNode(L, null, { default: withCtx(() => [_hoisted_14$1]), _: 1 }),
                                  ]),
                                  createBaseVNode("div", _hoisted_15$1, [
                                      _hoisted_16$1,
                                      createVNode(
                                          I,
                                          {
                                              type: "number",
                                              size: "lg",
                                              modelValue: c.value,
                                              "onUpdate:modelValue": D[4] || (D[4] = (F) => (c.value = F)),
                                          },
                                          null,
                                          8,
                                          ["modelValue"]
                                      ),
                                      createVNode(L, null, { default: withCtx(() => [_hoisted_17$1]), _: 1 }),
                                  ]),
                                  _hoisted_18$1,
                                  createVNode(unref(UploadImages), { class: "ms-0", onChanged: _ }),
                                  g.value.length && g.value.length < 5
                                      ? (openBlock(),
                                        createBlock$1(
                                            L,
                                            { key: 0, style: { color: "red !important" } },
                                            { default: withCtx(() => [_hoisted_19$1]), _: 1 }
                                        ))
                                      : createCommentVNode("", !0),
                                  createVNode(
                                      U,
                                      { class: "my-3 w-100", onClick: A, size: "lg", disabled: !i.value || !o.value || g.value.length < 5 },
                                      { default: withCtx(() => [_hoisted_20]), _: 1 },
                                      8,
                                      ["disabled"]
                                  ),
                              ])),
                    ])
                )
            }
        },
    }),
    _hoisted_1 = { style: { "max-width": "800px" }, class: "mx-auto mt-3" },
    _hoisted_2 = { key: 0 },
    _hoisted_3 = { key: 0 },
    _hoisted_4 = { key: 0 },
    _hoisted_5 = { key: 1 },
    _hoisted_6 = createBaseVNode("h3", null, "Not connected", -1),
    _hoisted_7 = createTextVNode(" Your ethereum wallet (such as MetaMask) isn't jet connected. Press the connect button to connect."),
    _hoisted_8 = createBaseVNode("br", null, null, -1),
    _hoisted_9 = createBaseVNode("br", null, null, -1),
    _hoisted_10 = createTextVNode("Connect"),
    _hoisted_11 = { key: 1 },
    _hoisted_12 = createBaseVNode("h3", null, "Wrong network", -1),
    _hoisted_13 = createTextVNode(" Please connect to Ethereum "),
    _hoisted_14 = [_hoisted_12, _hoisted_13],
    _hoisted_15 = { key: 1 },
    _hoisted_16 = createBaseVNode("h3", null, "No wallet", -1),
    _hoisted_17 = createTextVNode(" To create series, please install an Ethereum wallet such as "),
    _hoisted_18 = createBaseVNode("a", { href: "https://metamask.io/download/", target: "_blank" }, "MetaMask", -1),
    _hoisted_19 = [_hoisted_16, _hoisted_17, _hoisted_18],
    _sfc_main = defineComponent({
        __name: "Manager",
        setup(t) {
            const e = inject("app")
            return (n, i) => {
                const o = resolveComponent("b-button")
                return (
                    openBlock(),
                    createElementBlock("div", _hoisted_1, [
                        unref(e).web3.connected
                            ? (openBlock(),
                              createElementBlock("div", _hoisted_2, [
                                  unref(e).web3.chainId == 1 && unref(e).web3.connector
                                      ? (openBlock(),
                                        createElementBlock("div", _hoisted_3, [
                                            unref(e).web3.address
                                                ? (openBlock(), createElementBlock("div", _hoisted_4, [createVNode(_sfc_main$1)]))
                                                : (openBlock(),
                                                  createElementBlock("div", _hoisted_5, [
                                                      _hoisted_6,
                                                      _hoisted_7,
                                                      _hoisted_8,
                                                      _hoisted_9,
                                                      createVNode(
                                                          o,
                                                          { onClick: unref(e).web3.connect, class: "w-100" },
                                                          { default: withCtx(() => [_hoisted_10]), _: 1 },
                                                          8,
                                                          ["onClick"]
                                                      ),
                                                  ])),
                                        ]))
                                      : (openBlock(), createElementBlock("div", _hoisted_11, _hoisted_14)),
                              ]))
                            : (openBlock(), createElementBlock("div", _hoisted_15, _hoisted_19)),
                    ])
                )
            }
        },
    })
class Web3 {
    constructor() {
        ;(this.name = "Loading..."),
            (this.walletProvider = 1),
            (this.connected = !1),
            (this.chainId = Network.NONE),
            (this.address = ""),
            (this.addresses = []),
            (this.block = 0),
            (this.queue = reactive([])),
            (this.active = computed(() => this.queue.filter((e) => e.status === "Signing" || e.status === "Sending" || e.status === "Pending")))
    }
    connect() {
        window.ethereum.request && window.ethereum.request({ method: "eth_requestAccounts" })
    }
    switch(e) {
        window.ethereum &&
            window.ethereum.request &&
            window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: hexStripZeros(hexlify(e)) }] }).catch((n) => {
                console.log(n),
                    n.code == 4902 &&
                        window.ethereum &&
                        window.ethereum.request &&
                        window.ethereum.request({ method: "wallet_addEthereumChain", params: [connectors[e].chainParams] })
            })
    }
    setup() {
        if (
            ((this.update = computed(() => this.chainId + "|" + this.block + "|" + this.address)),
            (this.connector = computed(() => (this.provider ? new connectors[this.chainId](this.provider) : null))),
            window.ethereum && window.ethereum.request)
        ) {
            ;(this.provider = markRaw(new Web3Provider(window.ethereum))),
                window.ethereum.isMetaMask ? (this.name = "MetaMask") : (this.name = "Other"),
                (window.ethereum.autoRefreshOnNetworkChange = !1)
            const e = (a) => {
                    console.log(a), (this.block = a)
                },
                n = (a) => {
                    var l
                    ;(this.chainId = Number(BigNumber.from(a))),
                        (this.connected = !0),
                        (l = this.provider) == null || l.off("block"),
                        (this.provider = markRaw(new Web3Provider(window.ethereum))),
                        this.provider.on("block", e),
                        this.onAccountChanged && this.onAccountChanged(this.address)
                },
                i = (a) => {
                    n(a.chainId)
                },
                o = (a) => {
                    ;(this.addresses = a || []),
                        a && a.length
                            ? ((this.address = getAddress(a[0])), this.onAccountChanged && this.onAccountChanged(this.address))
                            : ((this.address = ""), this.onAccountChanged && this.onAccountChanged(this.address))
                }
            window.ethereum.on("accountsChanged", o),
                window.ethereum.on("chainChanged", n),
                window.ethereum.on("connect", i),
                window.ethereum.on("disconnect", (a) => {
                    ;(this.connected = !1), (this.block = 0)
                }),
                this.provider.on("block", e),
                window.ethereum
                    .request({ method: "eth_accounts" })
                    .then((a) => {
                        o(a), i({ chainId: window.ethereum.chainId })
                    })
                    .catch((a) => {
                        console.log("Error", a)
                    })
        } else this.name = "None"
    }
    async send(e, n, i) {
        const o = reactive({ status: "Signing", description: n })
        this.queue.push(o)
        try {
            ;(o.tx = await e),
                (o.status = "Pending"),
                (o.result = await o.tx.wait()),
                (o.status = "Confirmed"),
                (this.nonce = o.tx.nonce),
                i && i(o)
        } catch (a) {
            a.code == 4001 ? (o.status = "Cancelled") : (o.status = "Error"), console.log(a)
        }
    }
}
const network = new connectors[Network.ETHEREUM]()
var Data = reactive({
        title: "UnRealArt",
        name: "UnRealArt",
        web3: new Web3(),
        contract: markRaw(UnRealArt__factory.connect("0x8d41Bd479622B68ecF5E59d68B1a2400bE465052", network.provider)),
        ipfs: null,
        series: [],
        serie: 0,
        image: 0,
        gallery: "0x0000000000000000000000000000000000000000",
    }),
    MAX_DIGITS = 1e9,
    defaults = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
    },
    Decimal,
    external = !0,
    decimalError = "[DecimalError] ",
    invalidArgument = decimalError + "Invalid argument: ",
    exponentOutOfRange = decimalError + "Exponent out of range: ",
    mathfloor = Math.floor,
    mathpow = Math.pow,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    ONE,
    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE),
    P = {}
P.absoluteValue = P.abs = function () {
    var t = new this.constructor(this)
    return t.s && (t.s = 1), t
}
P.comparedTo = P.cmp = function (t) {
    var e,
        n,
        i,
        o,
        a = this
    if (((t = new a.constructor(t)), a.s !== t.s)) return a.s || -t.s
    if (a.e !== t.e) return (a.e > t.e) ^ (a.s < 0) ? 1 : -1
    for (i = a.d.length, o = t.d.length, e = 0, n = i < o ? i : o; e < n; ++e)
        if (a.d[e] !== t.d[e]) return (a.d[e] > t.d[e]) ^ (a.s < 0) ? 1 : -1
    return i === o ? 0 : (i > o) ^ (a.s < 0) ? 1 : -1
}
P.decimalPlaces = P.dp = function () {
    var t = this,
        e = t.d.length - 1,
        n = (e - t.e) * LOG_BASE
    if (((e = t.d[e]), e)) for (; e % 10 == 0; e /= 10) n--
    return n < 0 ? 0 : n
}
P.dividedBy = P.div = function (t) {
    return divide(this, new this.constructor(t))
}
P.dividedToIntegerBy = P.idiv = function (t) {
    var e = this,
        n = e.constructor
    return round(divide(e, new n(t), 0, 1), n.precision)
}
P.equals = P.eq = function (t) {
    return !this.cmp(t)
}
P.exponent = function () {
    return getBase10Exponent(this)
}
P.greaterThan = P.gt = function (t) {
    return this.cmp(t) > 0
}
P.greaterThanOrEqualTo = P.gte = function (t) {
    return this.cmp(t) >= 0
}
P.isInteger = P.isint = function () {
    return this.e > this.d.length - 2
}
P.isNegative = P.isneg = function () {
    return this.s < 0
}
P.isPositive = P.ispos = function () {
    return this.s > 0
}
P.isZero = function () {
    return this.s === 0
}
P.lessThan = P.lt = function (t) {
    return this.cmp(t) < 0
}
P.lessThanOrEqualTo = P.lte = function (t) {
    return this.cmp(t) < 1
}
P.logarithm = P.log = function (t) {
    var e,
        n = this,
        i = n.constructor,
        o = i.precision,
        a = o + 5
    if (t === void 0) t = new i(10)
    else if (((t = new i(t)), t.s < 1 || t.eq(ONE))) throw Error(decimalError + "NaN")
    if (n.s < 1) throw Error(decimalError + (n.s ? "NaN" : "-Infinity"))
    return n.eq(ONE) ? new i(0) : ((external = !1), (e = divide(ln(n, a), ln(t, a), a)), (external = !0), round(e, o))
}
P.minus = P.sub = function (t) {
    var e = this
    return (t = new e.constructor(t)), e.s == t.s ? subtract(e, t) : add(e, ((t.s = -t.s), t))
}
P.modulo = P.mod = function (t) {
    var e,
        n = this,
        i = n.constructor,
        o = i.precision
    if (((t = new i(t)), !t.s)) throw Error(decimalError + "NaN")
    return n.s ? ((external = !1), (e = divide(n, t, 0, 1).times(t)), (external = !0), n.minus(e)) : round(new i(n), o)
}
P.naturalExponential = P.exp = function () {
    return exp(this)
}
P.naturalLogarithm = P.ln = function () {
    return ln(this)
}
P.negated = P.neg = function () {
    var t = new this.constructor(this)
    return (t.s = -t.s || 0), t
}
P.plus = P.add = function (t) {
    var e = this
    return (t = new e.constructor(t)), e.s == t.s ? add(e, t) : subtract(e, ((t.s = -t.s), t))
}
P.precision = P.sd = function (t) {
    var e,
        n,
        i,
        o = this
    if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(invalidArgument + t)
    if (((e = getBase10Exponent(o) + 1), (i = o.d.length - 1), (n = i * LOG_BASE + 1), (i = o.d[i]), i)) {
        for (; i % 10 == 0; i /= 10) n--
        for (i = o.d[0]; i >= 10; i /= 10) n++
    }
    return t && e > n ? e : n
}
P.squareRoot = P.sqrt = function () {
    var t,
        e,
        n,
        i,
        o,
        a,
        l,
        c = this,
        g = c.constructor
    if (c.s < 1) {
        if (!c.s) return new g(0)
        throw Error(decimalError + "NaN")
    }
    for (
        t = getBase10Exponent(c),
            external = !1,
            o = Math.sqrt(+c),
            o == 0 || o == 1 / 0
                ? ((e = digitsToString(c.d)),
                  (e.length + t) % 2 == 0 && (e += "0"),
                  (o = Math.sqrt(e)),
                  (t = mathfloor((t + 1) / 2) - (t < 0 || t % 2)),
                  o == 1 / 0 ? (e = "5e" + t) : ((e = o.toExponential()), (e = e.slice(0, e.indexOf("e") + 1) + t)),
                  (i = new g(e)))
                : (i = new g(o.toString())),
            n = g.precision,
            o = l = n + 3;
        ;

    )
        if (((a = i), (i = a.plus(divide(c, a, l + 2)).times(0.5)), digitsToString(a.d).slice(0, l) === (e = digitsToString(i.d)).slice(0, l))) {
            if (((e = e.slice(l - 3, l + 1)), o == l && e == "4999")) {
                if ((round(a, n + 1, 0), a.times(a).eq(c))) {
                    i = a
                    break
                }
            } else if (e != "9999") break
            l += 4
        }
    return (external = !0), round(i, n)
}
P.times = P.mul = function (t) {
    var e,
        n,
        i,
        o,
        a,
        l,
        c,
        g,
        v,
        _ = this,
        A = _.constructor,
        B = _.d,
        D = (t = new A(t)).d
    if (!_.s || !t.s) return new A(0)
    for (
        t.s *= _.s,
            n = _.e + t.e,
            g = B.length,
            v = D.length,
            g < v && ((a = B), (B = D), (D = a), (l = g), (g = v), (v = l)),
            a = [],
            l = g + v,
            i = l;
        i--;

    )
        a.push(0)
    for (i = v; --i >= 0; ) {
        for (e = 0, o = g + i; o > i; ) (c = a[o] + D[i] * B[o - i - 1] + e), (a[o--] = c % BASE | 0), (e = (c / BASE) | 0)
        a[o] = (a[o] + e) % BASE | 0
    }
    for (; !a[--l]; ) a.pop()
    return e ? ++n : a.shift(), (t.d = a), (t.e = n), external ? round(t, A.precision) : t
}
P.toDecimalPlaces = P.todp = function (t, e) {
    var n = this,
        i = n.constructor
    return (
        (n = new i(n)),
        t === void 0
            ? n
            : (checkInt32(t, 0, MAX_DIGITS), e === void 0 ? (e = i.rounding) : checkInt32(e, 0, 8), round(n, t + getBase10Exponent(n) + 1, e))
    )
}
P.toExponential = function (t, e) {
    var n,
        i = this,
        o = i.constructor
    return (
        t === void 0
            ? (n = toString(i, !0))
            : (checkInt32(t, 0, MAX_DIGITS),
              e === void 0 ? (e = o.rounding) : checkInt32(e, 0, 8),
              (i = round(new o(i), t + 1, e)),
              (n = toString(i, !0, t + 1))),
        n
    )
}
P.toFixed = function (t, e) {
    var n,
        i,
        o = this,
        a = o.constructor
    return t === void 0
        ? toString(o)
        : (checkInt32(t, 0, MAX_DIGITS),
          e === void 0 ? (e = a.rounding) : checkInt32(e, 0, 8),
          (i = round(new a(o), t + getBase10Exponent(o) + 1, e)),
          (n = toString(i.abs(), !1, t + getBase10Exponent(i) + 1)),
          o.isneg() && !o.isZero() ? "-" + n : n)
}
P.toInteger = P.toint = function () {
    var t = this,
        e = t.constructor
    return round(new e(t), getBase10Exponent(t) + 1, e.rounding)
}
P.toNumber = function () {
    return +this
}
P.toPower = P.pow = function (t) {
    var e,
        n,
        i,
        o,
        a,
        l,
        c = this,
        g = c.constructor,
        v = 12,
        _ = +(t = new g(t))
    if (!t.s) return new g(ONE)
    if (((c = new g(c)), !c.s)) {
        if (t.s < 1) throw Error(decimalError + "Infinity")
        return c
    }
    if (c.eq(ONE)) return c
    if (((i = g.precision), t.eq(ONE))) return round(c, i)
    if (((e = t.e), (n = t.d.length - 1), (l = e >= n), (a = c.s), l)) {
        if ((n = _ < 0 ? -_ : _) <= MAX_SAFE_INTEGER) {
            for (
                o = new g(ONE), e = Math.ceil(i / LOG_BASE + 4), external = !1;
                n % 2 && ((o = o.times(c)), truncate(o.d, e)), (n = mathfloor(n / 2)), n !== 0;

            )
                (c = c.times(c)), truncate(c.d, e)
            return (external = !0), t.s < 0 ? new g(ONE).div(o) : round(o, i)
        }
    } else if (a < 0) throw Error(decimalError + "NaN")
    return (
        (a = a < 0 && t.d[Math.max(e, n)] & 1 ? -1 : 1),
        (c.s = 1),
        (external = !1),
        (o = t.times(ln(c, i + v))),
        (external = !0),
        (o = exp(o)),
        (o.s = a),
        o
    )
}
P.toPrecision = function (t, e) {
    var n,
        i,
        o = this,
        a = o.constructor
    return (
        t === void 0
            ? ((n = getBase10Exponent(o)), (i = toString(o, n <= a.toExpNeg || n >= a.toExpPos)))
            : (checkInt32(t, 1, MAX_DIGITS),
              e === void 0 ? (e = a.rounding) : checkInt32(e, 0, 8),
              (o = round(new a(o), t, e)),
              (n = getBase10Exponent(o)),
              (i = toString(o, t <= n || n <= a.toExpNeg, t))),
        i
    )
}
P.toSignificantDigits = P.tosd = function (t, e) {
    var n = this,
        i = n.constructor
    return (
        t === void 0
            ? ((t = i.precision), (e = i.rounding))
            : (checkInt32(t, 1, MAX_DIGITS), e === void 0 ? (e = i.rounding) : checkInt32(e, 0, 8)),
        round(new i(n), t, e)
    )
}
P.toString =
    P.valueOf =
    P.val =
    P.toJSON =
    P[Symbol.for("nodejs.util.inspect.custom")] =
        function () {
            var t = this,
                e = getBase10Exponent(t),
                n = t.constructor
            return toString(t, e <= n.toExpNeg || e >= n.toExpPos)
        }
function add(t, e) {
    var n,
        i,
        o,
        a,
        l,
        c,
        g,
        v,
        _ = t.constructor,
        A = _.precision
    if (!t.s || !e.s) return e.s || (e = new _(t)), external ? round(e, A) : e
    if (((g = t.d), (v = e.d), (l = t.e), (o = e.e), (g = g.slice()), (a = l - o), a)) {
        for (
            a < 0 ? ((i = g), (a = -a), (c = v.length)) : ((i = v), (o = l), (c = g.length)),
                l = Math.ceil(A / LOG_BASE),
                c = l > c ? l + 1 : c + 1,
                a > c && ((a = c), (i.length = 1)),
                i.reverse();
            a--;

        )
            i.push(0)
        i.reverse()
    }
    for (c = g.length, a = v.length, c - a < 0 && ((a = c), (i = v), (v = g), (g = i)), n = 0; a; )
        (n = ((g[--a] = g[a] + v[a] + n) / BASE) | 0), (g[a] %= BASE)
    for (n && (g.unshift(n), ++o), c = g.length; g[--c] == 0; ) g.pop()
    return (e.d = g), (e.e = o), external ? round(e, A) : e
}
function checkInt32(t, e, n) {
    if (t !== ~~t || t < e || t > n) throw Error(invalidArgument + t)
}
function digitsToString(t) {
    var e,
        n,
        i,
        o = t.length - 1,
        a = "",
        l = t[0]
    if (o > 0) {
        for (a += l, e = 1; e < o; e++) (i = t[e] + ""), (n = LOG_BASE - i.length), n && (a += getZeroString(n)), (a += i)
        ;(l = t[e]), (i = l + ""), (n = LOG_BASE - i.length), n && (a += getZeroString(n))
    } else if (l === 0) return "0"
    for (; l % 10 === 0; ) l /= 10
    return a + l
}
var divide = (function () {
    function t(i, o) {
        var a,
            l = 0,
            c = i.length
        for (i = i.slice(); c--; ) (a = i[c] * o + l), (i[c] = a % BASE | 0), (l = (a / BASE) | 0)
        return l && i.unshift(l), i
    }
    function e(i, o, a, l) {
        var c, g
        if (a != l) g = a > l ? 1 : -1
        else
            for (c = g = 0; c < a; c++)
                if (i[c] != o[c]) {
                    g = i[c] > o[c] ? 1 : -1
                    break
                }
        return g
    }
    function n(i, o, a) {
        for (var l = 0; a--; ) (i[a] -= l), (l = i[a] < o[a] ? 1 : 0), (i[a] = l * BASE + i[a] - o[a])
        for (; !i[0] && i.length > 1; ) i.shift()
    }
    return function (i, o, a, l) {
        var c,
            g,
            v,
            _,
            A,
            B,
            D,
            I,
            L,
            G,
            U,
            F,
            Z,
            Y,
            X,
            ie,
            he,
            oe,
            le = i.constructor,
            Te = i.s == o.s ? 1 : -1,
            ye = i.d,
            Ae = o.d
        if (!i.s) return new le(i)
        if (!o.s) throw Error(decimalError + "Division by zero")
        for (g = i.e - o.e, he = Ae.length, X = ye.length, D = new le(Te), I = D.d = [], v = 0; Ae[v] == (ye[v] || 0); ) ++v
        if (
            (Ae[v] > (ye[v] || 0) && --g,
            a == null ? (F = a = le.precision) : l ? (F = a + (getBase10Exponent(i) - getBase10Exponent(o)) + 1) : (F = a),
            F < 0)
        )
            return new le(0)
        if (((F = (F / LOG_BASE + 2) | 0), (v = 0), he == 1))
            for (_ = 0, Ae = Ae[0], F++; (v < X || _) && F--; v++) (Z = _ * BASE + (ye[v] || 0)), (I[v] = (Z / Ae) | 0), (_ = Z % Ae | 0)
        else {
            for (
                _ = (BASE / (Ae[0] + 1)) | 0,
                    _ > 1 && ((Ae = t(Ae, _)), (ye = t(ye, _)), (he = Ae.length), (X = ye.length)),
                    Y = he,
                    L = ye.slice(0, he),
                    G = L.length;
                G < he;

            )
                L[G++] = 0
            ;(oe = Ae.slice()), oe.unshift(0), (ie = Ae[0]), Ae[1] >= BASE / 2 && ++ie
            do
                (_ = 0),
                    (c = e(Ae, L, he, G)),
                    c < 0
                        ? ((U = L[0]),
                          he != G && (U = U * BASE + (L[1] || 0)),
                          (_ = (U / ie) | 0),
                          _ > 1
                              ? (_ >= BASE && (_ = BASE - 1),
                                (A = t(Ae, _)),
                                (B = A.length),
                                (G = L.length),
                                (c = e(A, L, B, G)),
                                c == 1 && (_--, n(A, he < B ? oe : Ae, B)))
                              : (_ == 0 && (c = _ = 1), (A = Ae.slice())),
                          (B = A.length),
                          B < G && A.unshift(0),
                          n(L, A, G),
                          c == -1 && ((G = L.length), (c = e(Ae, L, he, G)), c < 1 && (_++, n(L, he < G ? oe : Ae, G))),
                          (G = L.length))
                        : c === 0 && (_++, (L = [0])),
                    (I[v++] = _),
                    c && L[0] ? (L[G++] = ye[Y] || 0) : ((L = [ye[Y]]), (G = 1))
            while ((Y++ < X || L[0] !== void 0) && F--)
        }
        return I[0] || I.shift(), (D.e = g), round(D, l ? a + getBase10Exponent(D) + 1 : a)
    }
})()
function exp(t, e) {
    var n,
        i,
        o,
        a,
        l,
        c,
        g = 0,
        v = 0,
        _ = t.constructor,
        A = _.precision
    if (getBase10Exponent(t) > 16) throw Error(exponentOutOfRange + getBase10Exponent(t))
    if (!t.s) return new _(ONE)
    for (e == null ? ((external = !1), (c = A)) : (c = e), l = new _(0.03125); t.abs().gte(0.1); ) (t = t.times(l)), (v += 5)
    for (i = ((Math.log(mathpow(2, v)) / Math.LN10) * 2 + 5) | 0, c += i, n = o = a = new _(ONE), _.precision = c; ; ) {
        if (
            ((o = round(o.times(t), c)),
            (n = n.times(++g)),
            (l = a.plus(divide(o, n, c))),
            digitsToString(l.d).slice(0, c) === digitsToString(a.d).slice(0, c))
        ) {
            for (; v--; ) a = round(a.times(a), c)
            return (_.precision = A), e == null ? ((external = !0), round(a, A)) : a
        }
        a = l
    }
}
function getBase10Exponent(t) {
    for (var e = t.e * LOG_BASE, n = t.d[0]; n >= 10; n /= 10) e++
    return e
}
function getLn10(t, e, n) {
    if (e > t.LN10.sd()) throw ((external = !0), n && (t.precision = n), Error(decimalError + "LN10 precision limit exceeded"))
    return round(new t(t.LN10), e)
}
function getZeroString(t) {
    for (var e = ""; t--; ) e += "0"
    return e
}
function ln(t, e) {
    var n,
        i,
        o,
        a,
        l,
        c,
        g,
        v,
        _,
        A = 1,
        B = 10,
        D = t,
        I = D.d,
        L = D.constructor,
        G = L.precision
    if (D.s < 1) throw Error(decimalError + (D.s ? "NaN" : "-Infinity"))
    if (D.eq(ONE)) return new L(0)
    if ((e == null ? ((external = !1), (v = G)) : (v = e), D.eq(10))) return e == null && (external = !0), getLn10(L, v)
    if (((v += B), (L.precision = v), (n = digitsToString(I)), (i = n.charAt(0)), (a = getBase10Exponent(D)), Math.abs(a) < 15e14)) {
        for (; (i < 7 && i != 1) || (i == 1 && n.charAt(1) > 3); ) (D = D.times(t)), (n = digitsToString(D.d)), (i = n.charAt(0)), A++
        ;(a = getBase10Exponent(D)), i > 1 ? ((D = new L("0." + n)), a++) : (D = new L(i + "." + n.slice(1)))
    } else
        return (
            (g = getLn10(L, v + 2, G).times(a + "")),
            (D = ln(new L(i + "." + n.slice(1)), v - B).plus(g)),
            (L.precision = G),
            e == null ? ((external = !0), round(D, G)) : D
        )
    for (c = l = D = divide(D.minus(ONE), D.plus(ONE), v), _ = round(D.times(D), v), o = 3; ; ) {
        if (
            ((l = round(l.times(_), v)),
            (g = c.plus(divide(l, new L(o), v))),
            digitsToString(g.d).slice(0, v) === digitsToString(c.d).slice(0, v))
        )
            return (
                (c = c.times(2)),
                a !== 0 && (c = c.plus(getLn10(L, v + 2, G).times(a + ""))),
                (c = divide(c, new L(A), v)),
                (L.precision = G),
                e == null ? ((external = !0), round(c, G)) : c
            )
        ;(c = g), (o += 2)
    }
}
function parseDecimal(t, e) {
    var n, i, o
    for (
        (n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
            (i = e.search(/e/i)) > 0 ? (n < 0 && (n = i), (n += +e.slice(i + 1)), (e = e.substring(0, i))) : n < 0 && (n = e.length),
            i = 0;
        e.charCodeAt(i) === 48;

    )
        ++i
    for (o = e.length; e.charCodeAt(o - 1) === 48; ) --o
    if (((e = e.slice(i, o)), e)) {
        if (
            ((o -= i), (n = n - i - 1), (t.e = mathfloor(n / LOG_BASE)), (t.d = []), (i = (n + 1) % LOG_BASE), n < 0 && (i += LOG_BASE), i < o)
        ) {
            for (i && t.d.push(+e.slice(0, i)), o -= LOG_BASE; i < o; ) t.d.push(+e.slice(i, (i += LOG_BASE)))
            ;(e = e.slice(i)), (i = LOG_BASE - e.length)
        } else i -= o
        for (; i--; ) e += "0"
        if ((t.d.push(+e), external && (t.e > MAX_E || t.e < -MAX_E))) throw Error(exponentOutOfRange + n)
    } else (t.s = 0), (t.e = 0), (t.d = [0])
    return t
}
function round(t, e, n) {
    var i,
        o,
        a,
        l,
        c,
        g,
        v,
        _,
        A = t.d
    for (l = 1, a = A[0]; a >= 10; a /= 10) l++
    if (((i = e - l), i < 0)) (i += LOG_BASE), (o = e), (v = A[(_ = 0)])
    else {
        if (((_ = Math.ceil((i + 1) / LOG_BASE)), (a = A.length), _ >= a)) return t
        for (v = a = A[_], l = 1; a >= 10; a /= 10) l++
        ;(i %= LOG_BASE), (o = i - LOG_BASE + l)
    }
    if (
        (n !== void 0 &&
            ((a = mathpow(10, l - o - 1)),
            (c = (v / a) % 10 | 0),
            (g = e < 0 || A[_ + 1] !== void 0 || v % a),
            (g =
                n < 4
                    ? (c || g) && (n == 0 || n == (t.s < 0 ? 3 : 2))
                    : c > 5 ||
                      (c == 5 &&
                          (n == 4 ||
                              g ||
                              (n == 6 && (i > 0 ? (o > 0 ? v / mathpow(10, l - o) : 0) : A[_ - 1]) % 10 & 1) ||
                              n == (t.s < 0 ? 8 : 7))))),
        e < 1 || !A[0])
    )
        return (
            g
                ? ((a = getBase10Exponent(t)),
                  (A.length = 1),
                  (e = e - a - 1),
                  (A[0] = mathpow(10, (LOG_BASE - (e % LOG_BASE)) % LOG_BASE)),
                  (t.e = mathfloor(-e / LOG_BASE) || 0))
                : ((A.length = 1), (A[0] = t.e = t.s = 0)),
            t
        )
    if (
        (i == 0
            ? ((A.length = _), (a = 1), _--)
            : ((A.length = _ + 1), (a = mathpow(10, LOG_BASE - i)), (A[_] = o > 0 ? ((v / mathpow(10, l - o)) % mathpow(10, o) | 0) * a : 0)),
        g)
    )
        for (;;)
            if (_ == 0) {
                ;(A[0] += a) == BASE && ((A[0] = 1), ++t.e)
                break
            } else {
                if (((A[_] += a), A[_] != BASE)) break
                ;(A[_--] = 0), (a = 1)
            }
    for (i = A.length; A[--i] === 0; ) A.pop()
    if (external && (t.e > MAX_E || t.e < -MAX_E)) throw Error(exponentOutOfRange + getBase10Exponent(t))
    return t
}
function subtract(t, e) {
    var n,
        i,
        o,
        a,
        l,
        c,
        g,
        v,
        _,
        A,
        B = t.constructor,
        D = B.precision
    if (!t.s || !e.s) return e.s ? (e.s = -e.s) : (e = new B(t)), external ? round(e, D) : e
    if (((g = t.d), (A = e.d), (i = e.e), (v = t.e), (g = g.slice()), (l = v - i), l)) {
        for (
            _ = l < 0,
                _ ? ((n = g), (l = -l), (c = A.length)) : ((n = A), (i = v), (c = g.length)),
                o = Math.max(Math.ceil(D / LOG_BASE), c) + 2,
                l > o && ((l = o), (n.length = 1)),
                n.reverse(),
                o = l;
            o--;

        )
            n.push(0)
        n.reverse()
    } else {
        for (o = g.length, c = A.length, _ = o < c, _ && (c = o), o = 0; o < c; o++)
            if (g[o] != A[o]) {
                _ = g[o] < A[o]
                break
            }
        l = 0
    }
    for (_ && ((n = g), (g = A), (A = n), (e.s = -e.s)), c = g.length, o = A.length - c; o > 0; --o) g[c++] = 0
    for (o = A.length; o > l; ) {
        if (g[--o] < A[o]) {
            for (a = o; a && g[--a] === 0; ) g[a] = BASE - 1
            --g[a], (g[o] += BASE)
        }
        g[o] -= A[o]
    }
    for (; g[--c] === 0; ) g.pop()
    for (; g[0] === 0; g.shift()) --i
    return g[0] ? ((e.d = g), (e.e = i), external ? round(e, D) : e) : new B(0)
}
function toString(t, e, n) {
    var i,
        o = getBase10Exponent(t),
        a = digitsToString(t.d),
        l = a.length
    return (
        e
            ? (n && (i = n - l) > 0 ? (a = a.charAt(0) + "." + a.slice(1) + getZeroString(i)) : l > 1 && (a = a.charAt(0) + "." + a.slice(1)),
              (a = a + (o < 0 ? "e" : "e+") + o))
            : o < 0
            ? ((a = "0." + getZeroString(-o - 1) + a), n && (i = n - l) > 0 && (a += getZeroString(i)))
            : o >= l
            ? ((a += getZeroString(o + 1 - l)), n && (i = n - o - 1) > 0 && (a = a + "." + getZeroString(i)))
            : ((i = o + 1) < l && (a = a.slice(0, i) + "." + a.slice(i)),
              n && (i = n - l) > 0 && (o + 1 === l && (a += "."), (a += getZeroString(i)))),
        t.s < 0 ? "-" + a : a
    )
}
function truncate(t, e) {
    if (t.length > e) return (t.length = e), !0
}
function clone(t) {
    var e, n, i
    function o(a) {
        var l = this
        if (!(l instanceof o)) return new o(a)
        if (((l.constructor = o), a instanceof o)) {
            ;(l.s = a.s), (l.e = a.e), (l.d = (a = a.d) ? a.slice() : a)
            return
        }
        if (typeof a == "number") {
            if (a * 0 !== 0) throw Error(invalidArgument + a)
            if (a > 0) l.s = 1
            else if (a < 0) (a = -a), (l.s = -1)
            else {
                ;(l.s = 0), (l.e = 0), (l.d = [0])
                return
            }
            if (a === ~~a && a < 1e7) {
                ;(l.e = 0), (l.d = [a])
                return
            }
            return parseDecimal(l, a.toString())
        } else if (typeof a != "string") throw Error(invalidArgument + a)
        if ((a.charCodeAt(0) === 45 ? ((a = a.slice(1)), (l.s = -1)) : (l.s = 1), isDecimal.test(a))) parseDecimal(l, a)
        else throw Error(invalidArgument + a)
    }
    if (
        ((o.prototype = P),
        (o.ROUND_UP = 0),
        (o.ROUND_DOWN = 1),
        (o.ROUND_CEIL = 2),
        (o.ROUND_FLOOR = 3),
        (o.ROUND_HALF_UP = 4),
        (o.ROUND_HALF_DOWN = 5),
        (o.ROUND_HALF_EVEN = 6),
        (o.ROUND_HALF_CEIL = 7),
        (o.ROUND_HALF_FLOOR = 8),
        (o.clone = clone),
        (o.config = o.set = config),
        t === void 0 && (t = {}),
        t)
    )
        for (i = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < i.length; )
            t.hasOwnProperty((n = i[e++])) || (t[n] = this[n])
    return o.config(t), o
}
function config(t) {
    if (!t || typeof t != "object") throw Error(decimalError + "Object expected")
    var e,
        n,
        i,
        o = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0]
    for (e = 0; e < o.length; e += 3)
        if ((i = t[(n = o[e])]) !== void 0)
            if (mathfloor(i) === i && i >= o[e + 1] && i <= o[e + 2]) this[n] = i
            else throw Error(invalidArgument + n + ": " + i)
    if ((i = t[(n = "LN10")]) !== void 0)
        if (i == Math.LN10) this[n] = new this(i)
        else throw Error(invalidArgument + n + ": " + i)
    return this
}
var Decimal = clone(defaults)
ONE = new Decimal(1)
var Decimal$1 = Decimal
Decimal$1.config({ precision: 36 })
Decimal$1.config({ toExpNeg: -1e3 })
Decimal$1.config({ toExpPos: 1e3 })
Decimal$1.prototype.toInt = function (t) {
    return BigNumber.from(
        this.times(new Decimal$1("10").pow(new Decimal$1(t.toString())))
            .todp(0)
            .toString()
    )
}
BigNumber.prototype.toDec = function (t) {
    return new Decimal$1(this.toString()).dividedBy(new Decimal$1(10).toPower((t || 0).toString()))
}
async function main() {
    const t = createApp(_sfc_main$7)
    ;(Data.web3.onAccountChanged = (e) => {}),
        await Data.web3.setup(),
        (window.data = Data),
        (t.config.globalProperties.app = reactive(Data)),
        t.provide("app", t.config.globalProperties.app),
        t.use(
            createRouter({
                history: createWebHistory(),
                routes: [
                    { path: "/", component: _sfc_main$5 },
                    { path: "/image/:series/:image", component: _sfc_main$4 },
                    { path: "/slide/:screen/:gallery", component: _sfc_main$3 },
                    { path: "/manager", component: _sfc_main },
                ],
            })
        ),
        t.use(Rr),
        t.mount("#app")
}
main()
