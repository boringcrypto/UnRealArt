const Ny = function () {
    const t = document.createElement("link").relList
    if (t && t.supports && t.supports("modulepreload")) return
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i)
    new MutationObserver((i) => {
        for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }).observe(document, { childList: !0, subtree: !0 })
    function r(i) {
        const s = {}
        return (
            i.integrity && (s.integrity = i.integrity),
            i.referrerpolicy && (s.referrerPolicy = i.referrerpolicy),
            i.crossorigin === "use-credentials"
                ? (s.credentials = "include")
                : i.crossorigin === "anonymous"
                ? (s.credentials = "omit")
                : (s.credentials = "same-origin"),
            s
        )
    }
    function n(i) {
        if (i.ep) return
        i.ep = !0
        const s = r(i)
        fetch(i.href, s)
    }
}
Ny()
function Mu(e, t) {
    const r = Object.create(null),
        n = e.split(",")
    for (let i = 0; i < n.length; i++) r[n[i]] = !0
    return t ? (i) => !!r[i.toLowerCase()] : (i) => !!r[i]
}
const Oy =
        "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",
    Iy = Mu(Oy),
    By = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    Py = Mu(By)
function hg(e) {
    return !!e || e === ""
}
function hn(e) {
    if ($t(e)) {
        const t = {}
        for (let r = 0; r < e.length; r++) {
            const n = e[r],
                i = Fe(n) ? Dy(n) : hn(n)
            if (i) for (const s in i) t[s] = i[s]
        }
        return t
    } else {
        if (Fe(e)) return e
        if (ze(e)) return e
    }
}
const Ry = /;(?![^(]*\))/g,
    Ly = /:(.+)/
function Dy(e) {
    const t = {}
    return (
        e.split(Ry).forEach((r) => {
            if (r) {
                const n = r.split(Ly)
                n.length > 1 && (t[n[0].trim()] = n[1].trim())
            }
        }),
        t
    )
}
function wt(e) {
    let t = ""
    if (Fe(e)) t = e
    else if ($t(e))
        for (let r = 0; r < e.length; r++) {
            const n = wt(e[r])
            n && (t += n + " ")
        }
    else if (ze(e)) for (const r in e) e[r] && (t += r + " ")
    return t.trim()
}
function Ga(e) {
    if (!e) return null
    let { class: t, style: r } = e
    return t && !Fe(t) && (e.class = wt(t)), r && (e.style = hn(r)), e
}
function $y(e, t) {
    if (e.length !== t.length) return !1
    let r = !0
    for (let n = 0; r && n < e.length; n++) r = Vi(e[n], t[n])
    return r
}
function Vi(e, t) {
    if (e === t) return !0
    let r = bh(e),
        n = bh(t)
    if (r || n) return r && n ? e.getTime() === t.getTime() : !1
    if (((r = Na(e)), (n = Na(t)), r || n)) return e === t
    if (((r = $t(e)), (n = $t(t)), r || n)) return r && n ? $y(e, t) : !1
    if (((r = ze(e)), (n = ze(t)), r || n)) {
        if (!r || !n) return !1
        const i = Object.keys(e).length,
            s = Object.keys(t).length
        if (i !== s) return !1
        for (const o in e) {
            const l = e.hasOwnProperty(o),
                f = t.hasOwnProperty(o)
            if ((l && !f) || (!l && f) || !Vi(e[o], t[o])) return !1
        }
    }
    return String(e) === String(t)
}
function Su(e, t) {
    return e.findIndex((r) => Vi(r, t))
}
const jt = (e) =>
        Fe(e) ? e : e == null ? "" : $t(e) || (ze(e) && (e.toString === gg || !fe(e.toString))) ? JSON.stringify(e, pg, 2) : String(e),
    pg = (e, t) =>
        t && t.__v_isRef
            ? pg(e, t.value)
            : go(t)
            ? { [`Map(${t.size})`]: [...t.entries()].reduce((r, [n, i]) => ((r[`${n} =>`] = i), r), {}) }
            : Fs(t)
            ? { [`Set(${t.size})`]: [...t.values()] }
            : ze(t) && !$t(t) && !mg(t)
            ? String(t)
            : t,
    Ce = {},
    po = [],
    fn = () => {},
    Fy = () => !1,
    Vy = /^on[^a-z]/,
    Wa = (e) => Vy.test(e),
    id = (e) => e.startsWith("onUpdate:"),
    qe = Object.assign,
    sd = (e, t) => {
        const r = e.indexOf(t)
        r > -1 && e.splice(r, 1)
    },
    Uy = Object.prototype.hasOwnProperty,
    Ee = (e, t) => Uy.call(e, t),
    $t = Array.isArray,
    go = (e) => Ya(e) === "[object Map]",
    Fs = (e) => Ya(e) === "[object Set]",
    bh = (e) => Ya(e) === "[object Date]",
    fe = (e) => typeof e == "function",
    Fe = (e) => typeof e == "string",
    Na = (e) => typeof e == "symbol",
    ze = (e) => e !== null && typeof e == "object",
    od = (e) => ze(e) && fe(e.then) && fe(e.catch),
    gg = Object.prototype.toString,
    Ya = (e) => gg.call(e),
    Hy = (e) => Ya(e).slice(8, -1),
    mg = (e) => Ya(e) === "[object Object]",
    ad = (e) => Fe(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    ma = Mu(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    ku = (e) => {
        const t = Object.create(null)
        return (r) => t[r] || (t[r] = e(r))
    },
    qy = /-(\w)/g,
    Pr = ku((e) => e.replace(qy, (t, r) => (r ? r.toUpperCase() : ""))),
    zy = /\B([A-Z])/g,
    Bn = ku((e) => e.replace(zy, "-$1").toLowerCase()),
    Ja = ku((e) => e.charAt(0).toUpperCase() + e.slice(1)),
    va = ku((e) => (e ? `on${Ja(e)}` : "")),
    _o = (e, t) => !Object.is(e, t),
    mo = (e, t) => {
        for (let r = 0; r < e.length; r++) e[r](t)
    },
    Zl = (e, t, r) => {
        Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: r })
    },
    Ui = (e) => {
        const t = parseFloat(e)
        return isNaN(t) ? e : t
    }
let yh
const jy = () =>
    yh ||
    (yh =
        typeof globalThis != "undefined"
            ? globalThis
            : typeof self != "undefined"
            ? self
            : typeof window != "undefined"
            ? window
            : typeof global != "undefined"
            ? global
            : {})
let Tr
class ld {
    constructor(t = !1) {
        ;(this.active = !0),
            (this.effects = []),
            (this.cleanups = []),
            !t && Tr && ((this.parent = Tr), (this.index = (Tr.scopes || (Tr.scopes = [])).push(this) - 1))
    }
    run(t) {
        if (this.active) {
            const r = Tr
            try {
                return (Tr = this), t()
            } finally {
                Tr = r
            }
        }
    }
    on() {
        Tr = this
    }
    off() {
        Tr = this.parent
    }
    stop(t) {
        if (this.active) {
            let r, n
            for (r = 0, n = this.effects.length; r < n; r++) this.effects[r].stop()
            for (r = 0, n = this.cleanups.length; r < n; r++) this.cleanups[r]()
            if (this.scopes) for (r = 0, n = this.scopes.length; r < n; r++) this.scopes[r].stop(!0)
            if (this.parent && !t) {
                const i = this.parent.scopes.pop()
                i && i !== this && ((this.parent.scopes[this.index] = i), (i.index = this.index))
            }
            this.active = !1
        }
    }
}
function Ky(e) {
    return new ld(e)
}
function vg(e, t = Tr) {
    t && t.active && t.effects.push(e)
}
function Gy() {
    return Tr
}
function Wy(e) {
    Tr && Tr.cleanups.push(e)
}
const ud = (e) => {
        const t = new Set(e)
        return (t.w = 0), (t.n = 0), t
    },
    bg = (e) => (e.w & Hi) > 0,
    yg = (e) => (e.n & Hi) > 0,
    Yy = ({ deps: e }) => {
        if (e.length) for (let t = 0; t < e.length; t++) e[t].w |= Hi
    },
    Jy = (e) => {
        const { deps: t } = e
        if (t.length) {
            let r = 0
            for (let n = 0; n < t.length; n++) {
                const i = t[n]
                bg(i) && !yg(i) ? i.delete(e) : (t[r++] = i), (i.w &= ~Hi), (i.n &= ~Hi)
            }
            t.length = r
        }
    },
    ac = new WeakMap()
let ca = 0,
    Hi = 1
const lc = 30
let ln
const Ts = Symbol(""),
    uc = Symbol("")
class Qa {
    constructor(t, r = null, n) {
        ;(this.fn = t), (this.scheduler = r), (this.active = !0), (this.deps = []), (this.parent = void 0), vg(this, n)
    }
    run() {
        if (!this.active) return this.fn()
        let t = ln,
            r = Li
        for (; t; ) {
            if (t === this) return
            t = t.parent
        }
        try {
            return (this.parent = ln), (ln = this), (Li = !0), (Hi = 1 << ++ca), ca <= lc ? Yy(this) : _h(this), this.fn()
        } finally {
            ca <= lc && Jy(this), (Hi = 1 << --ca), (ln = this.parent), (Li = r), (this.parent = void 0), this.deferStop && this.stop()
        }
    }
    stop() {
        ln === this ? (this.deferStop = !0) : this.active && (_h(this), this.onStop && this.onStop(), (this.active = !1))
    }
}
function _h(e) {
    const { deps: t } = e
    if (t.length) {
        for (let r = 0; r < t.length; r++) t[r].delete(e)
        t.length = 0
    }
}
function Qy(e, t) {
    e.effect && (e = e.effect.fn)
    const r = new Qa(e)
    t && (qe(r, t), t.scope && vg(r, t.scope)), (!t || !t.lazy) && r.run()
    const n = r.run.bind(r)
    return (n.effect = r), n
}
function Xy(e) {
    e.effect.stop()
}
let Li = !0
const _g = []
function Vs() {
    _g.push(Li), (Li = !1)
}
function Us() {
    const e = _g.pop()
    Li = e === void 0 ? !0 : e
}
function Rr(e, t, r) {
    if (Li && ln) {
        let n = ac.get(e)
        n || ac.set(e, (n = new Map()))
        let i = n.get(r)
        i || n.set(r, (i = ud())), wg(i)
    }
}
function wg(e, t) {
    let r = !1
    ca <= lc ? yg(e) || ((e.n |= Hi), (r = !bg(e))) : (r = !e.has(ln)), r && (e.add(ln), ln.deps.push(e))
}
function li(e, t, r, n, i, s) {
    const o = ac.get(e)
    if (!o) return
    let l = []
    if (t === "clear") l = [...o.values()]
    else if (r === "length" && $t(e))
        o.forEach((f, d) => {
            ;(d === "length" || d >= n) && l.push(f)
        })
    else
        switch ((r !== void 0 && l.push(o.get(r)), t)) {
            case "add":
                $t(e) ? ad(r) && l.push(o.get("length")) : (l.push(o.get(Ts)), go(e) && l.push(o.get(uc)))
                break
            case "delete":
                $t(e) || (l.push(o.get(Ts)), go(e) && l.push(o.get(uc)))
                break
            case "set":
                go(e) && l.push(o.get(Ts))
                break
        }
    if (l.length === 1) l[0] && fc(l[0])
    else {
        const f = []
        for (const d of l) d && f.push(...d)
        fc(ud(f))
    }
}
function fc(e, t) {
    const r = $t(e) ? e : [...e]
    for (const n of r) n.computed && wh(n)
    for (const n of r) n.computed || wh(n)
}
function wh(e, t) {
    ;(e !== ln || e.allowRecurse) && (e.scheduler ? e.scheduler() : e.run())
}
const Zy = Mu("__proto__,__v_isRef,__isVue"),
    Ag = new Set(
        Object.getOwnPropertyNames(Symbol)
            .filter((e) => e !== "arguments" && e !== "caller")
            .map((e) => Symbol[e])
            .filter(Na)
    ),
    t_ = Nu(),
    e_ = Nu(!1, !0),
    r_ = Nu(!0),
    n_ = Nu(!0, !0),
    Ah = i_()
function i_() {
    const e = {}
    return (
        ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
            e[t] = function (...r) {
                const n = Ae(this)
                for (let s = 0, o = this.length; s < o; s++) Rr(n, "get", s + "")
                const i = n[t](...r)
                return i === -1 || i === !1 ? n[t](...r.map(Ae)) : i
            }
        }),
        ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
            e[t] = function (...r) {
                Vs()
                const n = Ae(this)[t].apply(this, r)
                return Us(), n
            }
        }),
        e
    )
}
function Nu(e = !1, t = !1) {
    return function (n, i, s) {
        if (i === "__v_isReactive") return !e
        if (i === "__v_isReadonly") return e
        if (i === "__v_isShallow") return t
        if (i === "__v_raw" && s === (e ? (t ? kg : Sg) : t ? Mg : Cg).get(n)) return n
        const o = $t(n)
        if (!e && o && Ee(Ah, i)) return Reflect.get(Ah, i, s)
        const l = Reflect.get(n, i, s)
        return (Na(i) ? Ag.has(i) : Zy(i)) || (e || Rr(n, "get", i), t)
            ? l
            : Re(l)
            ? o && ad(i)
                ? l
                : l.value
            : ze(l)
            ? e
                ? cd(l)
                : Ze(l)
            : l
    }
}
const s_ = Eg(),
    o_ = Eg(!0)
function Eg(e = !1) {
    return function (r, n, i, s) {
        let o = r[n]
        if (wo(o) && Re(o) && !Re(i)) return !1
        if (!e && !wo(i) && (tu(i) || ((i = Ae(i)), (o = Ae(o))), !$t(r) && Re(o) && !Re(i))) return (o.value = i), !0
        const l = $t(r) && ad(n) ? Number(n) < r.length : Ee(r, n),
            f = Reflect.set(r, n, i, s)
        return r === Ae(s) && (l ? _o(i, o) && li(r, "set", n, i) : li(r, "add", n, i)), f
    }
}
function a_(e, t) {
    const r = Ee(e, t)
    e[t]
    const n = Reflect.deleteProperty(e, t)
    return n && r && li(e, "delete", t, void 0), n
}
function l_(e, t) {
    const r = Reflect.has(e, t)
    return (!Na(t) || !Ag.has(t)) && Rr(e, "has", t), r
}
function u_(e) {
    return Rr(e, "iterate", $t(e) ? "length" : Ts), Reflect.ownKeys(e)
}
const xg = { get: t_, set: s_, deleteProperty: a_, has: l_, ownKeys: u_ },
    Tg = {
        get: r_,
        set(e, t) {
            return !0
        },
        deleteProperty(e, t) {
            return !0
        },
    },
    f_ = qe({}, xg, { get: e_, set: o_ }),
    c_ = qe({}, Tg, { get: n_ }),
    fd = (e) => e,
    Ou = (e) => Reflect.getPrototypeOf(e)
function hl(e, t, r = !1, n = !1) {
    e = e.__v_raw
    const i = Ae(e),
        s = Ae(t)
    r || (t !== s && Rr(i, "get", t), Rr(i, "get", s))
    const { has: o } = Ou(i),
        l = n ? fd : r ? hd : Ia
    if (o.call(i, t)) return l(e.get(t))
    if (o.call(i, s)) return l(e.get(s))
    e !== i && e.get(t)
}
function pl(e, t = !1) {
    const r = this.__v_raw,
        n = Ae(r),
        i = Ae(e)
    return t || (e !== i && Rr(n, "has", e), Rr(n, "has", i)), e === i ? r.has(e) : r.has(e) || r.has(i)
}
function gl(e, t = !1) {
    return (e = e.__v_raw), !t && Rr(Ae(e), "iterate", Ts), Reflect.get(e, "size", e)
}
function Eh(e) {
    e = Ae(e)
    const t = Ae(this)
    return Ou(t).has.call(t, e) || (t.add(e), li(t, "add", e, e)), this
}
function xh(e, t) {
    t = Ae(t)
    const r = Ae(this),
        { has: n, get: i } = Ou(r)
    let s = n.call(r, e)
    s || ((e = Ae(e)), (s = n.call(r, e)))
    const o = i.call(r, e)
    return r.set(e, t), s ? _o(t, o) && li(r, "set", e, t) : li(r, "add", e, t), this
}
function Th(e) {
    const t = Ae(this),
        { has: r, get: n } = Ou(t)
    let i = r.call(t, e)
    i || ((e = Ae(e)), (i = r.call(t, e))), n && n.call(t, e)
    const s = t.delete(e)
    return i && li(t, "delete", e, void 0), s
}
function Ch() {
    const e = Ae(this),
        t = e.size !== 0,
        r = e.clear()
    return t && li(e, "clear", void 0, void 0), r
}
function ml(e, t) {
    return function (n, i) {
        const s = this,
            o = s.__v_raw,
            l = Ae(o),
            f = t ? fd : e ? hd : Ia
        return !e && Rr(l, "iterate", Ts), o.forEach((d, h) => n.call(i, f(d), f(h), s))
    }
}
function vl(e, t, r) {
    return function (...n) {
        const i = this.__v_raw,
            s = Ae(i),
            o = go(s),
            l = e === "entries" || (e === Symbol.iterator && o),
            f = e === "keys" && o,
            d = i[e](...n),
            h = r ? fd : t ? hd : Ia
        return (
            !t && Rr(s, "iterate", f ? uc : Ts),
            {
                next() {
                    const { value: y, done: E } = d.next()
                    return E ? { value: y, done: E } : { value: l ? [h(y[0]), h(y[1])] : h(y), done: E }
                },
                [Symbol.iterator]() {
                    return this
                },
            }
        )
    }
}
function wi(e) {
    return function (...t) {
        return e === "delete" ? !1 : this
    }
}
function d_() {
    const e = {
            get(s) {
                return hl(this, s)
            },
            get size() {
                return gl(this)
            },
            has: pl,
            add: Eh,
            set: xh,
            delete: Th,
            clear: Ch,
            forEach: ml(!1, !1),
        },
        t = {
            get(s) {
                return hl(this, s, !1, !0)
            },
            get size() {
                return gl(this)
            },
            has: pl,
            add: Eh,
            set: xh,
            delete: Th,
            clear: Ch,
            forEach: ml(!1, !0),
        },
        r = {
            get(s) {
                return hl(this, s, !0)
            },
            get size() {
                return gl(this, !0)
            },
            has(s) {
                return pl.call(this, s, !0)
            },
            add: wi("add"),
            set: wi("set"),
            delete: wi("delete"),
            clear: wi("clear"),
            forEach: ml(!0, !1),
        },
        n = {
            get(s) {
                return hl(this, s, !0, !0)
            },
            get size() {
                return gl(this, !0)
            },
            has(s) {
                return pl.call(this, s, !0)
            },
            add: wi("add"),
            set: wi("set"),
            delete: wi("delete"),
            clear: wi("clear"),
            forEach: ml(!0, !0),
        }
    return (
        ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
            ;(e[s] = vl(s, !1, !1)), (r[s] = vl(s, !0, !1)), (t[s] = vl(s, !1, !0)), (n[s] = vl(s, !0, !0))
        }),
        [e, r, t, n]
    )
}
const [h_, p_, g_, m_] = d_()
function Iu(e, t) {
    const r = t ? (e ? m_ : g_) : e ? p_ : h_
    return (n, i, s) =>
        i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? n : Reflect.get(Ee(r, i) && i in n ? r : n, i, s)
}
const v_ = { get: Iu(!1, !1) },
    b_ = { get: Iu(!1, !0) },
    y_ = { get: Iu(!0, !1) },
    __ = { get: Iu(!0, !0) },
    Cg = new WeakMap(),
    Mg = new WeakMap(),
    Sg = new WeakMap(),
    kg = new WeakMap()
function w_(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2
        default:
            return 0
    }
}
function A_(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : w_(Hy(e))
}
function Ze(e) {
    return wo(e) ? e : Bu(e, !1, xg, v_, Cg)
}
function Ng(e) {
    return Bu(e, !1, f_, b_, Mg)
}
function cd(e) {
    return Bu(e, !0, Tg, y_, Sg)
}
function E_(e) {
    return Bu(e, !0, c_, __, kg)
}
function Bu(e, t, r, n, i) {
    if (!ze(e) || (e.__v_raw && !(t && e.__v_isReactive))) return e
    const s = i.get(e)
    if (s) return s
    const o = A_(e)
    if (o === 0) return e
    const l = new Proxy(e, o === 2 ? n : r)
    return i.set(e, l), l
}
function Di(e) {
    return wo(e) ? Di(e.__v_raw) : !!(e && e.__v_isReactive)
}
function wo(e) {
    return !!(e && e.__v_isReadonly)
}
function tu(e) {
    return !!(e && e.__v_isShallow)
}
function dd(e) {
    return Di(e) || wo(e)
}
function Ae(e) {
    const t = e && e.__v_raw
    return t ? Ae(t) : e
}
function Oa(e) {
    return Zl(e, "__v_skip", !0), e
}
const Ia = (e) => (ze(e) ? Ze(e) : e),
    hd = (e) => (ze(e) ? cd(e) : e)
function pd(e) {
    Li && ln && ((e = Ae(e)), wg(e.dep || (e.dep = ud())))
}
function Pu(e, t) {
    ;(e = Ae(e)), e.dep && fc(e.dep)
}
function Re(e) {
    return !!(e && e.__v_isRef === !0)
}
function Ht(e) {
    return Ig(e, !1)
}
function Og(e) {
    return Ig(e, !0)
}
function Ig(e, t) {
    return Re(e) ? e : new x_(e, t)
}
class x_ {
    constructor(t, r) {
        ;(this.__v_isShallow = r), (this.dep = void 0), (this.__v_isRef = !0), (this._rawValue = r ? t : Ae(t)), (this._value = r ? t : Ia(t))
    }
    get value() {
        return pd(this), this._value
    }
    set value(t) {
        ;(t = this.__v_isShallow ? t : Ae(t)),
            _o(t, this._rawValue) && ((this._rawValue = t), (this._value = this.__v_isShallow ? t : Ia(t)), Pu(this))
    }
}
function T_(e) {
    Pu(e)
}
function V(e) {
    return Re(e) ? e.value : e
}
const C_ = {
    get: (e, t, r) => V(Reflect.get(e, t, r)),
    set: (e, t, r, n) => {
        const i = e[t]
        return Re(i) && !Re(r) ? ((i.value = r), !0) : Reflect.set(e, t, r, n)
    },
}
function gd(e) {
    return Di(e) ? e : new Proxy(e, C_)
}
class M_ {
    constructor(t) {
        ;(this.dep = void 0), (this.__v_isRef = !0)
        const { get: r, set: n } = t(
            () => pd(this),
            () => Pu(this)
        )
        ;(this._get = r), (this._set = n)
    }
    get value() {
        return this._get()
    }
    set value(t) {
        this._set(t)
    }
}
function S_(e) {
    return new M_(e)
}
function k_(e) {
    const t = $t(e) ? new Array(e.length) : {}
    for (const r in e) t[r] = L(e, r)
    return t
}
class N_ {
    constructor(t, r, n) {
        ;(this._object = t), (this._key = r), (this._defaultValue = n), (this.__v_isRef = !0)
    }
    get value() {
        const t = this._object[this._key]
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
}
function L(e, t, r) {
    const n = e[t]
    return Re(n) ? n : new N_(e, t, r)
}
class O_ {
    constructor(t, r, n, i) {
        ;(this._setter = r),
            (this.dep = void 0),
            (this.__v_isRef = !0),
            (this._dirty = !0),
            (this.effect = new Qa(t, () => {
                this._dirty || ((this._dirty = !0), Pu(this))
            })),
            (this.effect.computed = this),
            (this.effect.active = this._cacheable = !i),
            (this.__v_isReadonly = n)
    }
    get value() {
        const t = Ae(this)
        return pd(t), (t._dirty || !t._cacheable) && ((t._dirty = !1), (t._value = t.effect.run())), t._value
    }
    set value(t) {
        this._setter(t)
    }
}
function cc(e, t, r = !1) {
    let n, i
    const s = fe(e)
    return s ? ((n = e), (i = fn)) : ((n = e.get), (i = e.set)), new O_(n, i, s || !i, r)
}
const ba = []
function Bg(e, ...t) {
    Vs()
    const r = ba.length ? ba[ba.length - 1].component : null,
        n = r && r.appContext.config.warnHandler,
        i = I_()
    if (n)
        Pn(n, r, 11, [
            e + t.join(""),
            r && r.proxy,
            i.map(({ vnode: s }) => `at <${xm(r, s.type)}>`).join(`
`),
            i,
        ])
    else {
        const s = [`[Vue warn]: ${e}`, ...t]
        i.length &&
            s.push(
                `
`,
                ...B_(i)
            ),
            console.warn(...s)
    }
    Us()
}
function I_() {
    let e = ba[ba.length - 1]
    if (!e) return []
    const t = []
    for (; e; ) {
        const r = t[0]
        r && r.vnode === e ? r.recurseCount++ : t.push({ vnode: e, recurseCount: 0 })
        const n = e.component && e.component.parent
        e = n && n.vnode
    }
    return t
}
function B_(e) {
    const t = []
    return (
        e.forEach((r, n) => {
            t.push(
                ...(n === 0
                    ? []
                    : [
                          `
`,
                      ]),
                ...P_(r)
            )
        }),
        t
    )
}
function P_({ vnode: e, recurseCount: t }) {
    const r = t > 0 ? `... (${t} recursive calls)` : "",
        n = e.component ? e.component.parent == null : !1,
        i = ` at <${xm(e.component, e.type, n)}`,
        s = ">" + r
    return e.props ? [i, ...R_(e.props), s] : [i + s]
}
function R_(e) {
    const t = [],
        r = Object.keys(e)
    return (
        r.slice(0, 3).forEach((n) => {
            t.push(...Pg(n, e[n]))
        }),
        r.length > 3 && t.push(" ..."),
        t
    )
}
function Pg(e, t, r) {
    return Fe(t)
        ? ((t = JSON.stringify(t)), r ? t : [`${e}=${t}`])
        : typeof t == "number" || typeof t == "boolean" || t == null
        ? r
            ? t
            : [`${e}=${t}`]
        : Re(t)
        ? ((t = Pg(e, Ae(t.value), !0)), r ? t : [`${e}=Ref<`, t, ">"])
        : fe(t)
        ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`]
        : ((t = Ae(t)), r ? t : [`${e}=`, t])
}
function Pn(e, t, r, n) {
    let i
    try {
        i = n ? e(...n) : e()
    } catch (s) {
        Hs(s, t, r)
    }
    return i
}
function Br(e, t, r, n) {
    if (fe(e)) {
        const s = Pn(e, t, r, n)
        return (
            s &&
                od(s) &&
                s.catch((o) => {
                    Hs(o, t, r)
                }),
            s
        )
    }
    const i = []
    for (let s = 0; s < e.length; s++) i.push(Br(e[s], t, r, n))
    return i
}
function Hs(e, t, r, n = !0) {
    const i = t ? t.vnode : null
    if (t) {
        let s = t.parent
        const o = t.proxy,
            l = r
        for (; s; ) {
            const d = s.ec
            if (d) {
                for (let h = 0; h < d.length; h++) if (d[h](e, o, l) === !1) return
            }
            s = s.parent
        }
        const f = t.appContext.config.errorHandler
        if (f) {
            Pn(f, null, 10, [e, o, l])
            return
        }
    }
    L_(e, r, i, n)
}
function L_(e, t, r, n = !0) {
    console.error(e)
}
let eu = !1,
    dc = !1
const kr = []
let Qn = 0
const ya = []
let da = null,
    to = 0
const _a = []
let Si = null,
    eo = 0
const Rg = Promise.resolve()
let md = null,
    hc = null
function Wr(e) {
    const t = md || Rg
    return e ? t.then(this ? e.bind(this) : e) : t
}
function D_(e) {
    let t = Qn + 1,
        r = kr.length
    for (; t < r; ) {
        const n = (t + r) >>> 1
        Ba(kr[n]) < e ? (t = n + 1) : (r = n)
    }
    return t
}
function vd(e) {
    ;(!kr.length || !kr.includes(e, eu && e.allowRecurse ? Qn + 1 : Qn)) &&
        e !== hc &&
        (e.id == null ? kr.push(e) : kr.splice(D_(e.id), 0, e), Lg())
}
function Lg() {
    !eu && !dc && ((dc = !0), (md = Rg.then($g)))
}
function $_(e) {
    const t = kr.indexOf(e)
    t > Qn && kr.splice(t, 1)
}
function Dg(e, t, r, n) {
    $t(e) ? r.push(...e) : (!t || !t.includes(e, e.allowRecurse ? n + 1 : n)) && r.push(e), Lg()
}
function F_(e) {
    Dg(e, da, ya, to)
}
function bd(e) {
    Dg(e, Si, _a, eo)
}
function Ru(e, t = null) {
    if (ya.length) {
        for (hc = t, da = [...new Set(ya)], ya.length = 0, to = 0; to < da.length; to++) da[to]()
        ;(da = null), (to = 0), (hc = null), Ru(e, t)
    }
}
function ru(e) {
    if ((Ru(), _a.length)) {
        const t = [...new Set(_a)]
        if (((_a.length = 0), Si)) {
            Si.push(...t)
            return
        }
        for (Si = t, Si.sort((r, n) => Ba(r) - Ba(n)), eo = 0; eo < Si.length; eo++) Si[eo]()
        ;(Si = null), (eo = 0)
    }
}
const Ba = (e) => (e.id == null ? 1 / 0 : e.id)
function $g(e) {
    ;(dc = !1), (eu = !0), Ru(e), kr.sort((r, n) => Ba(r) - Ba(n))
    const t = fn
    try {
        for (Qn = 0; Qn < kr.length; Qn++) {
            const r = kr[Qn]
            r && r.active !== !1 && Pn(r, null, 14)
        }
    } finally {
        ;(Qn = 0), (kr.length = 0), ru(), (eu = !1), (md = null), (kr.length || ya.length || _a.length) && $g(e)
    }
}
let ro,
    bl = []
function Fg(e, t) {
    var r, n
    ;(ro = e),
        ro
            ? ((ro.enabled = !0), bl.forEach(({ event: i, args: s }) => ro.emit(i, ...s)), (bl = []))
            : typeof window != "undefined" &&
              window.HTMLElement &&
              !(!((n = (r = window.navigator) === null || r === void 0 ? void 0 : r.userAgent) === null || n === void 0) && n.includes("jsdom"))
            ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {
                  Fg(s, t)
              }),
              setTimeout(() => {
                  ro || ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (bl = []))
              }, 3e3))
            : (bl = [])
}
function V_(e, t, ...r) {
    if (e.isUnmounted) return
    const n = e.vnode.props || Ce
    let i = r
    const s = t.startsWith("update:"),
        o = s && t.slice(7)
    if (o && o in n) {
        const h = `${o === "modelValue" ? "model" : o}Modifiers`,
            { number: y, trim: E } = n[h] || Ce
        E && (i = r.map((T) => T.trim())), y && (i = r.map(Ui))
    }
    let l,
        f = n[(l = va(t))] || n[(l = va(Pr(t)))]
    !f && s && (f = n[(l = va(Bn(t)))]), f && Br(f, e, 6, i)
    const d = n[l + "Once"]
    if (d) {
        if (!e.emitted) e.emitted = {}
        else if (e.emitted[l]) return
        ;(e.emitted[l] = !0), Br(d, e, 6, i)
    }
}
function Vg(e, t, r = !1) {
    const n = t.emitsCache,
        i = n.get(e)
    if (i !== void 0) return i
    const s = e.emits
    let o = {},
        l = !1
    if (!fe(e)) {
        const f = (d) => {
            const h = Vg(d, t, !0)
            h && ((l = !0), qe(o, h))
        }
        !r && t.mixins.length && t.mixins.forEach(f), e.extends && f(e.extends), e.mixins && e.mixins.forEach(f)
    }
    return !s && !l ? (n.set(e, null), null) : ($t(s) ? s.forEach((f) => (o[f] = null)) : qe(o, s), n.set(e, o), o)
}
function Lu(e, t) {
    return !e || !Wa(t) ? !1 : ((t = t.slice(2).replace(/Once$/, "")), Ee(e, t[0].toLowerCase() + t.slice(1)) || Ee(e, Bn(t)) || Ee(e, t))
}
let dr = null,
    Du = null
function Pa(e) {
    const t = dr
    return (dr = e), (Du = (e && e.type.__scopeId) || null), t
}
function U_(e) {
    Du = e
}
function H_() {
    Du = null
}
const q_ = (e) => Ct
function Ct(e, t = dr, r) {
    if (!t || e._n) return e
    const n = (...i) => {
        n._d && _c(-1)
        const s = Pa(t),
            o = e(...i)
        return Pa(s), n._d && _c(1), o
    }
    return (n._n = !0), (n._c = !0), (n._d = !0), n
}
function $l(e) {
    const {
        type: t,
        vnode: r,
        proxy: n,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: l,
        attrs: f,
        emit: d,
        render: h,
        renderCache: y,
        data: E,
        setupState: T,
        ctx: S,
        inheritAttrs: N,
    } = e
    let P, M
    const k = Pa(e)
    try {
        if (r.shapeFlag & 4) {
            const $ = i || n
            ;(P = Sr(h.call($, $, y, s, T, E, S))), (M = f)
        } else {
            const $ = t
            ;(P = Sr($.length > 1 ? $(s, { attrs: f, slots: l, emit: d }) : $(s, null))), (M = t.props ? f : j_(f))
        }
    } catch ($) {
        ;(Aa.length = 0), Hs($, e, 1), (P = Ut(or))
    }
    let F = P
    if (M && N !== !1) {
        const $ = Object.keys(M),
            { shapeFlag: R } = F
        $.length && R & 7 && (o && $.some(id) && (M = K_(M, o)), (F = Fn(F, M)))
    }
    return (
        r.dirs && ((F = Fn(F)), (F.dirs = F.dirs ? F.dirs.concat(r.dirs) : r.dirs)),
        r.transition && (F.transition = r.transition),
        (P = F),
        Pa(k),
        P
    )
}
function z_(e) {
    let t
    for (let r = 0; r < e.length; r++) {
        const n = e[r]
        if (zi(n)) {
            if (n.type !== or || n.children === "v-if") {
                if (t) return
                t = n
            }
        } else return
    }
    return t
}
const j_ = (e) => {
        let t
        for (const r in e) (r === "class" || r === "style" || Wa(r)) && ((t || (t = {}))[r] = e[r])
        return t
    },
    K_ = (e, t) => {
        const r = {}
        for (const n in e) (!id(n) || !(n.slice(9) in t)) && (r[n] = e[n])
        return r
    }
function G_(e, t, r) {
    const { props: n, children: i, component: s } = e,
        { props: o, children: l, patchFlag: f } = t,
        d = s.emitsOptions
    if (t.dirs || t.transition) return !0
    if (r && f >= 0) {
        if (f & 1024) return !0
        if (f & 16) return n ? Mh(n, o, d) : !!o
        if (f & 8) {
            const h = t.dynamicProps
            for (let y = 0; y < h.length; y++) {
                const E = h[y]
                if (o[E] !== n[E] && !Lu(d, E)) return !0
            }
        }
    } else return (i || l) && (!l || !l.$stable) ? !0 : n === o ? !1 : n ? (o ? Mh(n, o, d) : !0) : !!o
    return !1
}
function Mh(e, t, r) {
    const n = Object.keys(t)
    if (n.length !== Object.keys(e).length) return !0
    for (let i = 0; i < n.length; i++) {
        const s = n[i]
        if (t[s] !== e[s] && !Lu(r, s)) return !0
    }
    return !1
}
function yd({ vnode: e, parent: t }, r) {
    for (; t && t.subTree === e; ) ((e = t.vnode).el = r), (t = t.parent)
}
const Ug = (e) => e.__isSuspense,
    W_ = {
        name: "Suspense",
        __isSuspense: !0,
        process(e, t, r, n, i, s, o, l, f, d) {
            e == null ? Y_(t, r, n, i, s, o, l, f, d) : J_(e, t, r, n, i, o, l, f, d)
        },
        hydrate: Q_,
        create: _d,
        normalize: X_,
    },
    Hg = W_
function Ra(e, t) {
    const r = e.props && e.props[t]
    fe(r) && r()
}
function Y_(e, t, r, n, i, s, o, l, f) {
    const {
            p: d,
            o: { createElement: h },
        } = f,
        y = h("div"),
        E = (e.suspense = _d(e, i, n, t, y, r, s, o, l, f))
    d(null, (E.pendingBranch = e.ssContent), y, null, n, E, s, o),
        E.deps > 0 ? (Ra(e, "onPending"), Ra(e, "onFallback"), d(null, e.ssFallback, t, r, n, null, s, o), vo(E, e.ssFallback)) : E.resolve()
}
function J_(e, t, r, n, i, s, o, l, { p: f, um: d, o: { createElement: h } }) {
    const y = (t.suspense = e.suspense)
    ;(y.vnode = t), (t.el = e.el)
    const E = t.ssContent,
        T = t.ssFallback,
        { activeBranch: S, pendingBranch: N, isInFallback: P, isHydrating: M } = y
    if (N)
        (y.pendingBranch = E),
            kn(E, N)
                ? (f(N, E, y.hiddenContainer, null, i, y, s, o, l), y.deps <= 0 ? y.resolve() : P && (f(S, T, r, n, i, null, s, o, l), vo(y, T)))
                : (y.pendingId++,
                  M ? ((y.isHydrating = !1), (y.activeBranch = N)) : d(N, i, y),
                  (y.deps = 0),
                  (y.effects.length = 0),
                  (y.hiddenContainer = h("div")),
                  P
                      ? (f(null, E, y.hiddenContainer, null, i, y, s, o, l),
                        y.deps <= 0 ? y.resolve() : (f(S, T, r, n, i, null, s, o, l), vo(y, T)))
                      : S && kn(E, S)
                      ? (f(S, E, r, n, i, y, s, o, l), y.resolve(!0))
                      : (f(null, E, y.hiddenContainer, null, i, y, s, o, l), y.deps <= 0 && y.resolve()))
    else if (S && kn(E, S)) f(S, E, r, n, i, y, s, o, l), vo(y, E)
    else if ((Ra(t, "onPending"), (y.pendingBranch = E), y.pendingId++, f(null, E, y.hiddenContainer, null, i, y, s, o, l), y.deps <= 0))
        y.resolve()
    else {
        const { timeout: k, pendingId: F } = y
        k > 0
            ? setTimeout(() => {
                  y.pendingId === F && y.fallback(T)
              }, k)
            : k === 0 && y.fallback(T)
    }
}
function _d(e, t, r, n, i, s, o, l, f, d, h = !1) {
    const {
            p: y,
            m: E,
            um: T,
            n: S,
            o: { parentNode: N, remove: P },
        } = d,
        M = Ui(e.props && e.props.timeout),
        k = {
            vnode: e,
            parent: t,
            parentComponent: r,
            isSVG: o,
            container: n,
            hiddenContainer: i,
            anchor: s,
            deps: 0,
            pendingId: 0,
            timeout: typeof M == "number" ? M : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !0,
            isHydrating: h,
            isUnmounted: !1,
            effects: [],
            resolve(F = !1) {
                const { vnode: $, activeBranch: R, pendingBranch: W, pendingId: nt, effects: J, parentComponent: Q, container: ot } = k
                if (k.isHydrating) k.isHydrating = !1
                else if (!F) {
                    const x = R && W.transition && W.transition.mode === "out-in"
                    x &&
                        (R.transition.afterLeave = () => {
                            nt === k.pendingId && E(W, ot, a, 0)
                        })
                    let { anchor: a } = k
                    R && ((a = S(R)), T(R, Q, k, !0)), x || E(W, ot, a, 0)
                }
                vo(k, W), (k.pendingBranch = null), (k.isInFallback = !1)
                let it = k.parent,
                    at = !1
                for (; it; ) {
                    if (it.pendingBranch) {
                        it.effects.push(...J), (at = !0)
                        break
                    }
                    it = it.parent
                }
                at || bd(J), (k.effects = []), Ra($, "onResolve")
            },
            fallback(F) {
                if (!k.pendingBranch) return
                const { vnode: $, activeBranch: R, parentComponent: W, container: nt, isSVG: J } = k
                Ra($, "onFallback")
                const Q = S(R),
                    ot = () => {
                        !k.isInFallback || (y(null, F, nt, Q, W, null, J, l, f), vo(k, F))
                    },
                    it = F.transition && F.transition.mode === "out-in"
                it && (R.transition.afterLeave = ot), (k.isInFallback = !0), T(R, W, null, !0), it || ot()
            },
            move(F, $, R) {
                k.activeBranch && E(k.activeBranch, F, $, R), (k.container = F)
            },
            next() {
                return k.activeBranch && S(k.activeBranch)
            },
            registerDep(F, $) {
                const R = !!k.pendingBranch
                R && k.deps++
                const W = F.vnode.el
                F.asyncDep
                    .catch((nt) => {
                        Hs(nt, F, 0)
                    })
                    .then((nt) => {
                        if (F.isUnmounted || k.isUnmounted || k.pendingId !== F.suspenseId) return
                        F.asyncResolved = !0
                        const { vnode: J } = F
                        wc(F, nt, !1), W && (J.el = W)
                        const Q = !W && F.subTree.el
                        $(F, J, N(W || F.subTree.el), W ? null : S(F.subTree), k, o, f),
                            Q && P(Q),
                            yd(F, J.el),
                            R && --k.deps === 0 && k.resolve()
                    })
            },
            unmount(F, $) {
                ;(k.isUnmounted = !0), k.activeBranch && T(k.activeBranch, r, F, $), k.pendingBranch && T(k.pendingBranch, r, F, $)
            },
        }
    return k
}
function Q_(e, t, r, n, i, s, o, l, f) {
    const d = (t.suspense = _d(t, n, r, e.parentNode, document.createElement("div"), null, i, s, o, l, !0)),
        h = f(e, (d.pendingBranch = t.ssContent), r, d, s, o)
    return d.deps === 0 && d.resolve(), h
}
function X_(e) {
    const { shapeFlag: t, children: r } = e,
        n = t & 32
    ;(e.ssContent = Sh(n ? r.default : r)), (e.ssFallback = n ? Sh(r.fallback) : Ut(or))
}
function Sh(e) {
    let t
    if (fe(e)) {
        const r = Os && e._c
        r && ((e._d = !1), Y()), (e = e()), r && ((e._d = !0), (t = wr), mm())
    }
    return $t(e) && (e = z_(e)), (e = Sr(e)), t && !e.dynamicChildren && (e.dynamicChildren = t.filter((r) => r !== e)), e
}
function qg(e, t) {
    t && t.pendingBranch ? ($t(e) ? t.effects.push(...e) : t.effects.push(e)) : bd(e)
}
function vo(e, t) {
    e.activeBranch = t
    const { vnode: r, parentComponent: n } = e,
        i = (r.el = t.el)
    n && n.subTree === r && ((n.vnode.el = i), yd(n, i))
}
function cn(e, t) {
    if (Qe) {
        let r = Qe.provides
        const n = Qe.parent && Qe.parent.provides
        n === r && (r = Qe.provides = Object.create(n)), (r[e] = t)
    }
}
function Ie(e, t, r = !1) {
    const n = Qe || dr
    if (n) {
        const i = n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides
        if (i && e in i) return i[e]
        if (arguments.length > 1) return r && fe(t) ? t.call(n.proxy) : t
    }
}
function Z_(e, t) {
    return Xa(e, null, t)
}
function zg(e, t) {
    return Xa(e, null, { flush: "post" })
}
function tw(e, t) {
    return Xa(e, null, { flush: "sync" })
}
const kh = {}
function Oe(e, t, r) {
    return Xa(e, t, r)
}
function Xa(e, t, { immediate: r, deep: n, flush: i, onTrack: s, onTrigger: o } = Ce) {
    const l = Qe
    let f,
        d = !1,
        h = !1
    if (
        (Re(e)
            ? ((f = () => e.value), (d = tu(e)))
            : Di(e)
            ? ((f = () => e), (n = !0))
            : $t(e)
            ? ((h = !0),
              (d = e.some((M) => Di(M) || tu(M))),
              (f = () =>
                  e.map((M) => {
                      if (Re(M)) return M.value
                      if (Di(M)) return xs(M)
                      if (fe(M)) return Pn(M, l, 2)
                  })))
            : fe(e)
            ? t
                ? (f = () => Pn(e, l, 2))
                : (f = () => {
                      if (!(l && l.isUnmounted)) return y && y(), Br(e, l, 3, [E])
                  })
            : (f = fn),
        t && n)
    ) {
        const M = f
        f = () => xs(M())
    }
    let y,
        E = (M) => {
            y = P.onStop = () => {
                Pn(M, l, 4)
            }
        }
    if (xo) return (E = fn), t ? r && Br(t, l, 3, [f(), h ? [] : void 0, E]) : f(), fn
    let T = h ? [] : kh
    const S = () => {
        if (!!P.active)
            if (t) {
                const M = P.run()
                ;(n || d || (h ? M.some((k, F) => _o(k, T[F])) : _o(M, T))) && (y && y(), Br(t, l, 3, [M, T === kh ? void 0 : T, E]), (T = M))
            } else P.run()
    }
    S.allowRecurse = !!t
    let N
    i === "sync" ? (N = S) : i === "post" ? (N = () => sr(S, l && l.suspense)) : (N = () => F_(S))
    const P = new Qa(f, N)
    return (
        t ? (r ? S() : (T = P.run())) : i === "post" ? sr(P.run.bind(P), l && l.suspense) : P.run(),
        () => {
            P.stop(), l && l.scope && sd(l.scope.effects, P)
        }
    )
}
function ew(e, t, r) {
    const n = this.proxy,
        i = Fe(e) ? (e.includes(".") ? jg(n, e) : () => n[e]) : e.bind(n, n)
    let s
    fe(t) ? (s = t) : ((s = t.handler), (r = t))
    const o = Qe
    ji(this)
    const l = Xa(i, s.bind(n), r)
    return o ? ji(o) : $i(), l
}
function jg(e, t) {
    const r = t.split(".")
    return () => {
        let n = e
        for (let i = 0; i < r.length && n; i++) n = n[r[i]]
        return n
    }
}
function xs(e, t) {
    if (!ze(e) || e.__v_skip || ((t = t || new Set()), t.has(e))) return e
    if ((t.add(e), Re(e))) xs(e.value, t)
    else if ($t(e)) for (let r = 0; r < e.length; r++) xs(e[r], t)
    else if (Fs(e) || go(e))
        e.forEach((r) => {
            xs(r, t)
        })
    else if (mg(e)) for (const r in e) xs(e[r], t)
    return e
}
function wd() {
    const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
    return (
        je(() => {
            e.isMounted = !0
        }),
        qs(() => {
            e.isUnmounting = !0
        }),
        e
    )
}
const jr = [Function, Array],
    rw = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: jr,
            onEnter: jr,
            onAfterEnter: jr,
            onEnterCancelled: jr,
            onBeforeLeave: jr,
            onLeave: jr,
            onAfterLeave: jr,
            onLeaveCancelled: jr,
            onBeforeAppear: jr,
            onAppear: jr,
            onAfterAppear: jr,
            onAppearCancelled: jr,
        },
        setup(e, { slots: t }) {
            const r = vi(),
                n = wd()
            let i
            return () => {
                const s = t.default && $u(t.default(), !0)
                if (!s || !s.length) return
                let o = s[0]
                if (s.length > 1) {
                    for (const N of s)
                        if (N.type !== or) {
                            o = N
                            break
                        }
                }
                const l = Ae(e),
                    { mode: f } = l
                if (n.isLeaving) return vf(o)
                const d = Nh(o)
                if (!d) return vf(o)
                const h = Ao(d, l, n, r)
                Ns(d, h)
                const y = r.subTree,
                    E = y && Nh(y)
                let T = !1
                const { getTransitionKey: S } = d.type
                if (S) {
                    const N = S()
                    i === void 0 ? (i = N) : N !== i && ((i = N), (T = !0))
                }
                if (E && E.type !== or && (!kn(d, E) || T)) {
                    const N = Ao(E, l, n, r)
                    if ((Ns(E, N), f === "out-in"))
                        return (
                            (n.isLeaving = !0),
                            (N.afterLeave = () => {
                                ;(n.isLeaving = !1), r.update()
                            }),
                            vf(o)
                        )
                    f === "in-out" &&
                        d.type !== or &&
                        (N.delayLeave = (P, M, k) => {
                            const F = Kg(n, E)
                            ;(F[String(E.key)] = E),
                                (P._leaveCb = () => {
                                    M(), (P._leaveCb = void 0), delete h.delayedLeave
                                }),
                                (h.delayedLeave = k)
                        })
                }
                return o
            }
        },
    },
    Ad = rw
function Kg(e, t) {
    const { leavingVNodes: r } = e
    let n = r.get(t.type)
    return n || ((n = Object.create(null)), r.set(t.type, n)), n
}
function Ao(e, t, r, n) {
    const {
            appear: i,
            mode: s,
            persisted: o = !1,
            onBeforeEnter: l,
            onEnter: f,
            onAfterEnter: d,
            onEnterCancelled: h,
            onBeforeLeave: y,
            onLeave: E,
            onAfterLeave: T,
            onLeaveCancelled: S,
            onBeforeAppear: N,
            onAppear: P,
            onAfterAppear: M,
            onAppearCancelled: k,
        } = t,
        F = String(e.key),
        $ = Kg(r, e),
        R = (J, Q) => {
            J && Br(J, n, 9, Q)
        },
        W = (J, Q) => {
            const ot = Q[1]
            R(J, Q), $t(J) ? J.every((it) => it.length <= 1) && ot() : J.length <= 1 && ot()
        },
        nt = {
            mode: s,
            persisted: o,
            beforeEnter(J) {
                let Q = l
                if (!r.isMounted)
                    if (i) Q = N || l
                    else return
                J._leaveCb && J._leaveCb(!0)
                const ot = $[F]
                ot && kn(e, ot) && ot.el._leaveCb && ot.el._leaveCb(), R(Q, [J])
            },
            enter(J) {
                let Q = f,
                    ot = d,
                    it = h
                if (!r.isMounted)
                    if (i) (Q = P || f), (ot = M || d), (it = k || h)
                    else return
                let at = !1
                const x = (J._enterCb = (a) => {
                    at || ((at = !0), a ? R(it, [J]) : R(ot, [J]), nt.delayedLeave && nt.delayedLeave(), (J._enterCb = void 0))
                })
                Q ? W(Q, [J, x]) : x()
            },
            leave(J, Q) {
                const ot = String(e.key)
                if ((J._enterCb && J._enterCb(!0), r.isUnmounting)) return Q()
                R(y, [J])
                let it = !1
                const at = (J._leaveCb = (x) => {
                    it || ((it = !0), Q(), x ? R(S, [J]) : R(T, [J]), (J._leaveCb = void 0), $[ot] === e && delete $[ot])
                })
                ;($[ot] = e), E ? W(E, [J, at]) : at()
            },
            clone(J) {
                return Ao(J, t, r, n)
            },
        }
    return nt
}
function vf(e) {
    if (Za(e)) return (e = Fn(e)), (e.children = null), e
}
function Nh(e) {
    return Za(e) ? (e.children ? e.children[0] : void 0) : e
}
function Ns(e, t) {
    e.shapeFlag & 6 && e.component
        ? Ns(e.component.subTree, t)
        : e.shapeFlag & 128
        ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback)))
        : (e.transition = t)
}
function $u(e, t = !1, r) {
    let n = [],
        i = 0
    for (let s = 0; s < e.length; s++) {
        let o = e[s]
        const l = r == null ? o.key : String(r) + String(o.key != null ? o.key : s)
        o.type === Yt
            ? (o.patchFlag & 128 && i++, (n = n.concat($u(o.children, t, l))))
            : (t || o.type !== or) && n.push(l != null ? Fn(o, { key: l }) : o)
    }
    if (i > 1) for (let s = 0; s < n.length; s++) n[s].patchFlag = -2
    return n
}
function bt(e) {
    return fe(e) ? { setup: e, name: e.name } : e
}
const Cs = (e) => !!e.type.__asyncLoader
function nw(e) {
    fe(e) && (e = { loader: e })
    const { loader: t, loadingComponent: r, errorComponent: n, delay: i = 200, timeout: s, suspensible: o = !0, onError: l } = e
    let f = null,
        d,
        h = 0
    const y = () => (h++, (f = null), E()),
        E = () => {
            let T
            return (
                f ||
                (T = f =
                    t()
                        .catch((S) => {
                            if (((S = S instanceof Error ? S : new Error(String(S))), l))
                                return new Promise((N, P) => {
                                    l(
                                        S,
                                        () => N(y()),
                                        () => P(S),
                                        h + 1
                                    )
                                })
                            throw S
                        })
                        .then((S) =>
                            T !== f && f ? f : (S && (S.__esModule || S[Symbol.toStringTag] === "Module") && (S = S.default), (d = S), S)
                        ))
            )
        }
    return bt({
        name: "AsyncComponentWrapper",
        __asyncLoader: E,
        get __asyncResolved() {
            return d
        },
        setup() {
            const T = Qe
            if (d) return () => bf(d, T)
            const S = (k) => {
                ;(f = null), Hs(k, T, 13, !n)
            }
            if ((o && T.suspense) || xo)
                return E()
                    .then((k) => () => bf(k, T))
                    .catch((k) => (S(k), () => (n ? Ut(n, { error: k }) : null)))
            const N = Ht(!1),
                P = Ht(),
                M = Ht(!!i)
            return (
                i &&
                    setTimeout(() => {
                        M.value = !1
                    }, i),
                s != null &&
                    setTimeout(() => {
                        if (!N.value && !P.value) {
                            const k = new Error(`Async component timed out after ${s}ms.`)
                            S(k), (P.value = k)
                        }
                    }, s),
                E()
                    .then(() => {
                        ;(N.value = !0), T.parent && Za(T.parent.vnode) && vd(T.parent.update)
                    })
                    .catch((k) => {
                        S(k), (P.value = k)
                    }),
                () => {
                    if (N.value && d) return bf(d, T)
                    if (P.value && n) return Ut(n, { error: P.value })
                    if (r && !M.value) return Ut(r)
                }
            )
        },
    })
}
function bf(e, { vnode: { ref: t, props: r, children: n, shapeFlag: i }, parent: s }) {
    const o = Ut(e, r, n)
    return (o.ref = t), o
}
const Za = (e) => e.type.__isKeepAlive,
    iw = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] },
        setup(e, { slots: t }) {
            const r = vi(),
                n = r.ctx
            if (!n.renderer)
                return () => {
                    const k = t.default && t.default()
                    return k && k.length === 1 ? k[0] : k
                }
            const i = new Map(),
                s = new Set()
            let o = null
            const l = r.suspense,
                {
                    renderer: {
                        p: f,
                        m: d,
                        um: h,
                        o: { createElement: y },
                    },
                } = n,
                E = y("div")
            ;(n.activate = (k, F, $, R, W) => {
                const nt = k.component
                d(k, F, $, 0, l),
                    f(nt.vnode, k, F, $, nt, l, R, k.slotScopeIds, W),
                    sr(() => {
                        ;(nt.isDeactivated = !1), nt.a && mo(nt.a)
                        const J = k.props && k.props.onVnodeMounted
                        J && yr(J, nt.parent, k)
                    }, l)
            }),
                (n.deactivate = (k) => {
                    const F = k.component
                    d(k, E, null, 1, l),
                        sr(() => {
                            F.da && mo(F.da)
                            const $ = k.props && k.props.onVnodeUnmounted
                            $ && yr($, F.parent, k), (F.isDeactivated = !0)
                        }, l)
                })
            function T(k) {
                yf(k), h(k, r, l, !0)
            }
            function S(k) {
                i.forEach((F, $) => {
                    const R = au(F.type)
                    R && (!k || !k(R)) && N($)
                })
            }
            function N(k) {
                const F = i.get(k)
                !o || F.type !== o.type ? T(F) : o && yf(o), i.delete(k), s.delete(k)
            }
            Oe(
                () => [e.include, e.exclude],
                ([k, F]) => {
                    k && S(($) => ha(k, $)), F && S(($) => !ha(F, $))
                },
                { flush: "post", deep: !0 }
            )
            let P = null
            const M = () => {
                P != null && i.set(P, _f(r.subTree))
            }
            return (
                je(M),
                Vu(M),
                qs(() => {
                    i.forEach((k) => {
                        const { subTree: F, suspense: $ } = r,
                            R = _f(F)
                        if (k.type === R.type) {
                            yf(R)
                            const W = R.component.da
                            W && sr(W, $)
                            return
                        }
                        T(k)
                    })
                }),
                () => {
                    if (((P = null), !t.default)) return null
                    const k = t.default(),
                        F = k[0]
                    if (k.length > 1) return (o = null), k
                    if (!zi(F) || (!(F.shapeFlag & 4) && !(F.shapeFlag & 128))) return (o = null), F
                    let $ = _f(F)
                    const R = $.type,
                        W = au(Cs($) ? $.type.__asyncResolved || {} : R),
                        { include: nt, exclude: J, max: Q } = e
                    if ((nt && (!W || !ha(nt, W))) || (J && W && ha(J, W))) return (o = $), F
                    const ot = $.key == null ? R : $.key,
                        it = i.get(ot)
                    return (
                        $.el && (($ = Fn($)), F.shapeFlag & 128 && (F.ssContent = $)),
                        (P = ot),
                        it
                            ? (($.el = it.el),
                              ($.component = it.component),
                              $.transition && Ns($, $.transition),
                              ($.shapeFlag |= 512),
                              s.delete(ot),
                              s.add(ot))
                            : (s.add(ot), Q && s.size > parseInt(Q, 10) && N(s.values().next().value)),
                        ($.shapeFlag |= 256),
                        (o = $),
                        Ug(F.type) ? F : $
                    )
                }
            )
        },
    },
    sw = iw
function ha(e, t) {
    return $t(e) ? e.some((r) => ha(r, t)) : Fe(e) ? e.split(",").includes(t) : e.test ? e.test(t) : !1
}
function tl(e, t) {
    Wg(e, "a", t)
}
function Gg(e, t) {
    Wg(e, "da", t)
}
function Wg(e, t, r = Qe) {
    const n =
        e.__wdc ||
        (e.__wdc = () => {
            let i = r
            for (; i; ) {
                if (i.isDeactivated) return
                i = i.parent
            }
            return e()
        })
    if ((Fu(t, n, r), r)) {
        let i = r.parent
        for (; i && i.parent; ) Za(i.parent.vnode) && ow(n, t, r, i), (i = i.parent)
    }
}
function ow(e, t, r, n) {
    const i = Fu(t, e, n, !0)
    el(() => {
        sd(n[t], i)
    }, r)
}
function yf(e) {
    let t = e.shapeFlag
    t & 256 && (t -= 256), t & 512 && (t -= 512), (e.shapeFlag = t)
}
function _f(e) {
    return e.shapeFlag & 128 ? e.ssContent : e
}
function Fu(e, t, r = Qe, n = !1) {
    if (r) {
        const i = r[e] || (r[e] = []),
            s =
                t.__weh ||
                (t.__weh = (...o) => {
                    if (r.isUnmounted) return
                    Vs(), ji(r)
                    const l = Br(t, r, e, o)
                    return $i(), Us(), l
                })
        return n ? i.unshift(s) : i.push(s), s
    }
}
const mi =
        (e) =>
        (t, r = Qe) =>
            (!xo || e === "sp") && Fu(e, t, r),
    Yg = mi("bm"),
    je = mi("m"),
    Jg = mi("bu"),
    Vu = mi("u"),
    qs = mi("bum"),
    el = mi("um"),
    Qg = mi("sp"),
    Xg = mi("rtg"),
    Zg = mi("rtc")
function tm(e, t = Qe) {
    Fu("ec", e, t)
}
function qi(e, t) {
    const r = dr
    if (r === null) return e
    const n = Hu(r) || r.proxy,
        i = e.dirs || (e.dirs = [])
    for (let s = 0; s < t.length; s++) {
        let [o, l, f, d = Ce] = t[s]
        fe(o) && (o = { mounted: o, updated: o }),
            o.deep && xs(l),
            i.push({ dir: o, instance: n, value: l, oldValue: void 0, arg: f, modifiers: d })
    }
    return e
}
function Cn(e, t, r, n) {
    const i = e.dirs,
        s = t && t.dirs
    for (let o = 0; o < i.length; o++) {
        const l = i[o]
        s && (l.oldValue = s[o].value)
        let f = l.dir[n]
        f && (Vs(), Br(f, r, 8, [e.el, l, e, t]), Us())
    }
}
const Ed = "components",
    aw = "directives"
function ui(e, t) {
    return xd(Ed, e, !0, t) || e
}
const em = Symbol()
function Kt(e) {
    return Fe(e) ? xd(Ed, e, !1) || e : e || em
}
function lw(e) {
    return xd(aw, e)
}
function xd(e, t, r = !0, n = !1) {
    const i = dr || Qe
    if (i) {
        const s = i.type
        if (e === Ed) {
            const l = au(s, !1)
            if (l && (l === t || l === Pr(t) || l === Ja(Pr(t)))) return s
        }
        const o = Oh(i[e] || s[e], t) || Oh(i.appContext[e], t)
        return !o && n ? s : o
    }
}
function Oh(e, t) {
    return e && (e[t] || e[Pr(t)] || e[Ja(Pr(t))])
}
function Pe(e, t, r, n) {
    let i
    const s = r && r[n]
    if ($t(e) || Fe(e)) {
        i = new Array(e.length)
        for (let o = 0, l = e.length; o < l; o++) i[o] = t(e[o], o, void 0, s && s[o])
    } else if (typeof e == "number") {
        i = new Array(e)
        for (let o = 0; o < e; o++) i[o] = t(o + 1, o, void 0, s && s[o])
    } else if (ze(e))
        if (e[Symbol.iterator]) i = Array.from(e, (o, l) => t(o, l, void 0, s && s[l]))
        else {
            const o = Object.keys(e)
            i = new Array(o.length)
            for (let l = 0, f = o.length; l < f; l++) {
                const d = o[l]
                i[l] = t(e[d], d, l, s && s[l])
            }
        }
    else i = []
    return r && (r[n] = i), i
}
function rm(e, t) {
    for (let r = 0; r < t.length; r++) {
        const n = t[r]
        if ($t(n)) for (let i = 0; i < n.length; i++) e[n[i].name] = n[i].fn
        else n && (e[n.name] = n.fn)
    }
    return e
}
function mt(e, t, r = {}, n, i) {
    if (dr.isCE || (dr.parent && Cs(dr.parent) && dr.parent.isCE)) return Ut("slot", t === "default" ? null : { name: t }, n && n())
    let s = e[t]
    s && s._c && (s._d = !1), Y()
    const o = s && nm(s(r)),
        l = kt(Yt, { key: r.key || `_${t}` }, o || (n ? n() : []), o && e._ === 1 ? 64 : -2)
    return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), s && s._c && (s._d = !0), l
}
function nm(e) {
    return e.some((t) => (zi(t) ? !(t.type === or || (t.type === Yt && !nm(t.children))) : !0)) ? e : null
}
function uw(e) {
    const t = {}
    for (const r in e) t[va(r)] = e[r]
    return t
}
const pc = (e) => (e ? (_m(e) ? Hu(e) || e.proxy : pc(e.parent)) : null),
    nu = qe(Object.create(null), {
        $: (e) => e,
        $el: (e) => e.vnode.el,
        $data: (e) => e.data,
        $props: (e) => e.props,
        $attrs: (e) => e.attrs,
        $slots: (e) => e.slots,
        $refs: (e) => e.refs,
        $parent: (e) => pc(e.parent),
        $root: (e) => pc(e.root),
        $emit: (e) => e.emit,
        $options: (e) => sm(e),
        $forceUpdate: (e) => e.f || (e.f = () => vd(e.update)),
        $nextTick: (e) => e.n || (e.n = Wr.bind(e.proxy)),
        $watch: (e) => ew.bind(e),
    }),
    gc = {
        get({ _: e }, t) {
            const { ctx: r, setupState: n, data: i, props: s, accessCache: o, type: l, appContext: f } = e
            let d
            if (t[0] !== "$") {
                const T = o[t]
                if (T !== void 0)
                    switch (T) {
                        case 1:
                            return n[t]
                        case 2:
                            return i[t]
                        case 4:
                            return r[t]
                        case 3:
                            return s[t]
                    }
                else {
                    if (n !== Ce && Ee(n, t)) return (o[t] = 1), n[t]
                    if (i !== Ce && Ee(i, t)) return (o[t] = 2), i[t]
                    if ((d = e.propsOptions[0]) && Ee(d, t)) return (o[t] = 3), s[t]
                    if (r !== Ce && Ee(r, t)) return (o[t] = 4), r[t]
                    mc && (o[t] = 0)
                }
            }
            const h = nu[t]
            let y, E
            if (h) return t === "$attrs" && Rr(e, "get", t), h(e)
            if ((y = l.__cssModules) && (y = y[t])) return y
            if (r !== Ce && Ee(r, t)) return (o[t] = 4), r[t]
            if (((E = f.config.globalProperties), Ee(E, t))) return E[t]
        },
        set({ _: e }, t, r) {
            const { data: n, setupState: i, ctx: s } = e
            return i !== Ce && Ee(i, t)
                ? ((i[t] = r), !0)
                : n !== Ce && Ee(n, t)
                ? ((n[t] = r), !0)
                : Ee(e.props, t) || (t[0] === "$" && t.slice(1) in e)
                ? !1
                : ((s[t] = r), !0)
        },
        has({ _: { data: e, setupState: t, accessCache: r, ctx: n, appContext: i, propsOptions: s } }, o) {
            let l
            return (
                !!r[o] ||
                (e !== Ce && Ee(e, o)) ||
                (t !== Ce && Ee(t, o)) ||
                ((l = s[0]) && Ee(l, o)) ||
                Ee(n, o) ||
                Ee(nu, o) ||
                Ee(i.config.globalProperties, o)
            )
        },
        defineProperty(e, t, r) {
            return r.get != null ? (e._.accessCache[t] = 0) : Ee(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r)
        },
    },
    fw = qe({}, gc, {
        get(e, t) {
            if (t !== Symbol.unscopables) return gc.get(e, t, e)
        },
        has(e, t) {
            return t[0] !== "_" && !Iy(t)
        },
    })
let mc = !0
function cw(e) {
    const t = sm(e),
        r = e.proxy,
        n = e.ctx
    ;(mc = !1), t.beforeCreate && Ih(t.beforeCreate, e, "bc")
    const {
        data: i,
        computed: s,
        methods: o,
        watch: l,
        provide: f,
        inject: d,
        created: h,
        beforeMount: y,
        mounted: E,
        beforeUpdate: T,
        updated: S,
        activated: N,
        deactivated: P,
        beforeDestroy: M,
        beforeUnmount: k,
        destroyed: F,
        unmounted: $,
        render: R,
        renderTracked: W,
        renderTriggered: nt,
        errorCaptured: J,
        serverPrefetch: Q,
        expose: ot,
        inheritAttrs: it,
        components: at,
        directives: x,
        filters: a,
    } = t
    if ((d && dw(d, n, null, e.appContext.config.unwrapInjectedRef), o))
        for (const _ in o) {
            const A = o[_]
            fe(A) && (n[_] = A.bind(r))
        }
    if (i) {
        const _ = i.call(r, r)
        ze(_) && (e.data = Ze(_))
    }
    if (((mc = !0), s))
        for (const _ in s) {
            const A = s[_],
                w = fe(A) ? A.bind(r, r) : fe(A.get) ? A.get.bind(r, r) : fn,
                v = !fe(A) && fe(A.set) ? A.set.bind(r) : fn,
                g = K({ get: w, set: v })
            Object.defineProperty(n, _, { enumerable: !0, configurable: !0, get: () => g.value, set: (u) => (g.value = u) })
        }
    if (l) for (const _ in l) im(l[_], n, r, _)
    if (f) {
        const _ = fe(f) ? f.call(r) : f
        Reflect.ownKeys(_).forEach((A) => {
            cn(A, _[A])
        })
    }
    h && Ih(h, e, "c")
    function m(_, A) {
        $t(A) ? A.forEach((w) => _(w.bind(r))) : A && _(A.bind(r))
    }
    if ((m(Yg, y), m(je, E), m(Jg, T), m(Vu, S), m(tl, N), m(Gg, P), m(tm, J), m(Zg, W), m(Xg, nt), m(qs, k), m(el, $), m(Qg, Q), $t(ot)))
        if (ot.length) {
            const _ = e.exposed || (e.exposed = {})
            ot.forEach((A) => {
                Object.defineProperty(_, A, { get: () => r[A], set: (w) => (r[A] = w) })
            })
        } else e.exposed || (e.exposed = {})
    R && e.render === fn && (e.render = R), it != null && (e.inheritAttrs = it), at && (e.components = at), x && (e.directives = x)
}
function dw(e, t, r = fn, n = !1) {
    $t(e) && (e = vc(e))
    for (const i in e) {
        const s = e[i]
        let o
        ze(s) ? ("default" in s ? (o = Ie(s.from || i, s.default, !0)) : (o = Ie(s.from || i))) : (o = Ie(s)),
            Re(o) && n
                ? Object.defineProperty(t, i, { enumerable: !0, configurable: !0, get: () => o.value, set: (l) => (o.value = l) })
                : (t[i] = o)
    }
}
function Ih(e, t, r) {
    Br($t(e) ? e.map((n) => n.bind(t.proxy)) : e.bind(t.proxy), t, r)
}
function im(e, t, r, n) {
    const i = n.includes(".") ? jg(r, n) : () => r[n]
    if (Fe(e)) {
        const s = t[e]
        fe(s) && Oe(i, s)
    } else if (fe(e)) Oe(i, e.bind(r))
    else if (ze(e))
        if ($t(e)) e.forEach((s) => im(s, t, r, n))
        else {
            const s = fe(e.handler) ? e.handler.bind(r) : t[e.handler]
            fe(s) && Oe(i, s, e)
        }
}
function sm(e) {
    const t = e.type,
        { mixins: r, extends: n } = t,
        {
            mixins: i,
            optionsCache: s,
            config: { optionMergeStrategies: o },
        } = e.appContext,
        l = s.get(t)
    let f
    return l ? (f = l) : !i.length && !r && !n ? (f = t) : ((f = {}), i.length && i.forEach((d) => iu(f, d, o, !0)), iu(f, t, o)), s.set(t, f), f
}
function iu(e, t, r, n = !1) {
    const { mixins: i, extends: s } = t
    s && iu(e, s, r, !0), i && i.forEach((o) => iu(e, o, r, !0))
    for (const o in t)
        if (!(n && o === "expose")) {
            const l = hw[o] || (r && r[o])
            e[o] = l ? l(e[o], t[o]) : t[o]
        }
    return e
}
const hw = {
    data: Bh,
    props: _s,
    emits: _s,
    methods: _s,
    computed: _s,
    beforeCreate: pr,
    created: pr,
    beforeMount: pr,
    mounted: pr,
    beforeUpdate: pr,
    updated: pr,
    beforeDestroy: pr,
    beforeUnmount: pr,
    destroyed: pr,
    unmounted: pr,
    activated: pr,
    deactivated: pr,
    errorCaptured: pr,
    serverPrefetch: pr,
    components: _s,
    directives: _s,
    watch: gw,
    provide: Bh,
    inject: pw,
}
function Bh(e, t) {
    return t
        ? e
            ? function () {
                  return qe(fe(e) ? e.call(this, this) : e, fe(t) ? t.call(this, this) : t)
              }
            : t
        : e
}
function pw(e, t) {
    return _s(vc(e), vc(t))
}
function vc(e) {
    if ($t(e)) {
        const t = {}
        for (let r = 0; r < e.length; r++) t[e[r]] = e[r]
        return t
    }
    return e
}
function pr(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function _s(e, t) {
    return e ? qe(qe(Object.create(null), e), t) : t
}
function gw(e, t) {
    if (!e) return t
    if (!t) return e
    const r = qe(Object.create(null), e)
    for (const n in t) r[n] = pr(e[n], t[n])
    return r
}
function mw(e, t, r, n = !1) {
    const i = {},
        s = {}
    Zl(s, Uu, 1), (e.propsDefaults = Object.create(null)), om(e, t, i, s)
    for (const o in e.propsOptions[0]) o in i || (i[o] = void 0)
    r ? (e.props = n ? i : Ng(i)) : e.type.props ? (e.props = i) : (e.props = s), (e.attrs = s)
}
function vw(e, t, r, n) {
    const {
            props: i,
            attrs: s,
            vnode: { patchFlag: o },
        } = e,
        l = Ae(i),
        [f] = e.propsOptions
    let d = !1
    if ((n || o > 0) && !(o & 16)) {
        if (o & 8) {
            const h = e.vnode.dynamicProps
            for (let y = 0; y < h.length; y++) {
                let E = h[y]
                if (Lu(e.emitsOptions, E)) continue
                const T = t[E]
                if (f)
                    if (Ee(s, E)) T !== s[E] && ((s[E] = T), (d = !0))
                    else {
                        const S = Pr(E)
                        i[S] = bc(f, l, S, T, e, !1)
                    }
                else T !== s[E] && ((s[E] = T), (d = !0))
            }
        }
    } else {
        om(e, t, i, s) && (d = !0)
        let h
        for (const y in l)
            (!t || (!Ee(t, y) && ((h = Bn(y)) === y || !Ee(t, h)))) &&
                (f ? r && (r[y] !== void 0 || r[h] !== void 0) && (i[y] = bc(f, l, y, void 0, e, !0)) : delete i[y])
        if (s !== l) for (const y in s) (!t || (!Ee(t, y) && !0)) && (delete s[y], (d = !0))
    }
    d && li(e, "set", "$attrs")
}
function om(e, t, r, n) {
    const [i, s] = e.propsOptions
    let o = !1,
        l
    if (t)
        for (let f in t) {
            if (ma(f)) continue
            const d = t[f]
            let h
            i && Ee(i, (h = Pr(f)))
                ? !s || !s.includes(h)
                    ? (r[h] = d)
                    : ((l || (l = {}))[h] = d)
                : Lu(e.emitsOptions, f) || ((!(f in n) || d !== n[f]) && ((n[f] = d), (o = !0)))
        }
    if (s) {
        const f = Ae(r),
            d = l || Ce
        for (let h = 0; h < s.length; h++) {
            const y = s[h]
            r[y] = bc(i, f, y, d[y], e, !Ee(d, y))
        }
    }
    return o
}
function bc(e, t, r, n, i, s) {
    const o = e[r]
    if (o != null) {
        const l = Ee(o, "default")
        if (l && n === void 0) {
            const f = o.default
            if (o.type !== Function && fe(f)) {
                const { propsDefaults: d } = i
                r in d ? (n = d[r]) : (ji(i), (n = d[r] = f.call(null, t)), $i())
            } else n = f
        }
        o[0] && (s && !l ? (n = !1) : o[1] && (n === "" || n === Bn(r)) && (n = !0))
    }
    return n
}
function am(e, t, r = !1) {
    const n = t.propsCache,
        i = n.get(e)
    if (i) return i
    const s = e.props,
        o = {},
        l = []
    let f = !1
    if (!fe(e)) {
        const h = (y) => {
            f = !0
            const [E, T] = am(y, t, !0)
            qe(o, E), T && l.push(...T)
        }
        !r && t.mixins.length && t.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h)
    }
    if (!s && !f) return n.set(e, po), po
    if ($t(s))
        for (let h = 0; h < s.length; h++) {
            const y = Pr(s[h])
            Ph(y) && (o[y] = Ce)
        }
    else if (s)
        for (const h in s) {
            const y = Pr(h)
            if (Ph(y)) {
                const E = s[h],
                    T = (o[y] = $t(E) || fe(E) ? { type: E } : E)
                if (T) {
                    const S = Dh(Boolean, T.type),
                        N = Dh(String, T.type)
                    ;(T[0] = S > -1), (T[1] = N < 0 || S < N), (S > -1 || Ee(T, "default")) && l.push(y)
                }
            }
        }
    const d = [o, l]
    return n.set(e, d), d
}
function Ph(e) {
    return e[0] !== "$"
}
function Rh(e) {
    const t = e && e.toString().match(/^\s*function (\w+)/)
    return t ? t[1] : e === null ? "null" : ""
}
function Lh(e, t) {
    return Rh(e) === Rh(t)
}
function Dh(e, t) {
    return $t(t) ? t.findIndex((r) => Lh(r, e)) : fe(t) && Lh(t, e) ? 0 : -1
}
const lm = (e) => e[0] === "_" || e === "$stable",
    Td = (e) => ($t(e) ? e.map(Sr) : [Sr(e)]),
    bw = (e, t, r) => {
        if (t._n) return t
        const n = Ct((...i) => Td(t(...i)), r)
        return (n._c = !1), n
    },
    um = (e, t, r) => {
        const n = e._ctx
        for (const i in e) {
            if (lm(i)) continue
            const s = e[i]
            if (fe(s)) t[i] = bw(i, s, n)
            else if (s != null) {
                const o = Td(s)
                t[i] = () => o
            }
        }
    },
    fm = (e, t) => {
        const r = Td(t)
        e.slots.default = () => r
    },
    yw = (e, t) => {
        if (e.vnode.shapeFlag & 32) {
            const r = t._
            r ? ((e.slots = Ae(t)), Zl(t, "_", r)) : um(t, (e.slots = {}))
        } else (e.slots = {}), t && fm(e, t)
        Zl(e.slots, Uu, 1)
    },
    _w = (e, t, r) => {
        const { vnode: n, slots: i } = e
        let s = !0,
            o = Ce
        if (n.shapeFlag & 32) {
            const l = t._
            l ? (r && l === 1 ? (s = !1) : (qe(i, t), !r && l === 1 && delete i._)) : ((s = !t.$stable), um(t, i)), (o = t)
        } else t && (fm(e, t), (o = { default: 1 }))
        if (s) for (const l in i) !lm(l) && !(l in o) && delete i[l]
    }
function cm() {
    return {
        app: null,
        config: {
            isNativeTag: Fy,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
    }
}
let ww = 0
function Aw(e, t) {
    return function (n, i = null) {
        fe(n) || (n = Object.assign({}, n)), i != null && !ze(i) && (i = null)
        const s = cm(),
            o = new Set()
        let l = !1
        const f = (s.app = {
            _uid: ww++,
            _component: n,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: Sm,
            get config() {
                return s.config
            },
            set config(d) {},
            use(d, ...h) {
                return o.has(d) || (d && fe(d.install) ? (o.add(d), d.install(f, ...h)) : fe(d) && (o.add(d), d(f, ...h))), f
            },
            mixin(d) {
                return s.mixins.includes(d) || s.mixins.push(d), f
            },
            component(d, h) {
                return h ? ((s.components[d] = h), f) : s.components[d]
            },
            directive(d, h) {
                return h ? ((s.directives[d] = h), f) : s.directives[d]
            },
            mount(d, h, y) {
                if (!l) {
                    const E = Ut(n, i)
                    return (
                        (E.appContext = s),
                        h && t ? t(E, d) : e(E, d, y),
                        (l = !0),
                        (f._container = d),
                        (d.__vue_app__ = f),
                        Hu(E.component) || E.component.proxy
                    )
                }
            },
            unmount() {
                l && (e(null, f._container), delete f._container.__vue_app__)
            },
            provide(d, h) {
                return (s.provides[d] = h), f
            },
        })
        return f
    }
}
function su(e, t, r, n, i = !1) {
    if ($t(e)) {
        e.forEach((E, T) => su(E, t && ($t(t) ? t[T] : t), r, n, i))
        return
    }
    if (Cs(n) && !i) return
    const s = n.shapeFlag & 4 ? Hu(n.component) || n.component.proxy : n.el,
        o = i ? null : s,
        { i: l, r: f } = e,
        d = t && t.r,
        h = l.refs === Ce ? (l.refs = {}) : l.refs,
        y = l.setupState
    if ((d != null && d !== f && (Fe(d) ? ((h[d] = null), Ee(y, d) && (y[d] = null)) : Re(d) && (d.value = null)), fe(f))) Pn(f, l, 12, [o, h])
    else {
        const E = Fe(f),
            T = Re(f)
        if (E || T) {
            const S = () => {
                if (e.f) {
                    const N = E ? h[f] : f.value
                    i
                        ? $t(N) && sd(N, s)
                        : $t(N)
                        ? N.includes(s) || N.push(s)
                        : E
                        ? ((h[f] = [s]), Ee(y, f) && (y[f] = h[f]))
                        : ((f.value = [s]), e.k && (h[e.k] = f.value))
                } else E ? ((h[f] = o), Ee(y, f) && (y[f] = o)) : T && ((f.value = o), e.k && (h[e.k] = o))
            }
            o ? ((S.id = -1), sr(S, r)) : S()
        }
    }
}
let Ai = !1
const yl = (e) => /svg/.test(e.namespaceURI) && e.tagName !== "foreignObject",
    _l = (e) => e.nodeType === 8
function Ew(e) {
    const {
            mt: t,
            p: r,
            o: { patchProp: n, createText: i, nextSibling: s, parentNode: o, remove: l, insert: f, createComment: d },
        } = e,
        h = (M, k) => {
            if (!k.hasChildNodes()) {
                r(null, M, k), ru(), (k._vnode = M)
                return
            }
            ;(Ai = !1),
                y(k.firstChild, M, null, null, null),
                ru(),
                (k._vnode = M),
                Ai && console.error("Hydration completed but contains mismatches.")
        },
        y = (M, k, F, $, R, W = !1) => {
            const nt = _l(M) && M.data === "[",
                J = () => N(M, k, F, $, R, nt),
                { type: Q, ref: ot, shapeFlag: it, patchFlag: at } = k,
                x = M.nodeType
            ;(k.el = M), at === -2 && ((W = !1), (k.dynamicChildren = null))
            let a = null
            switch (Q) {
                case Eo:
                    x !== 3
                        ? k.children === ""
                            ? (f((k.el = i("")), o(M), M), (a = M))
                            : (a = J())
                        : (M.data !== k.children && ((Ai = !0), (M.data = k.children)), (a = s(M)))
                    break
                case or:
                    x !== 8 || nt ? (a = J()) : (a = s(M))
                    break
                case Ms:
                    if (x !== 1 && x !== 3) a = J()
                    else {
                        a = M
                        const c = !k.children.length
                        for (let m = 0; m < k.staticCount; m++)
                            c && (k.children += a.nodeType === 1 ? a.outerHTML : a.data), m === k.staticCount - 1 && (k.anchor = a), (a = s(a))
                        return a
                    }
                    break
                case Yt:
                    nt ? (a = S(M, k, F, $, R, W)) : (a = J())
                    break
                default:
                    if (it & 1) x !== 1 || k.type.toLowerCase() !== M.tagName.toLowerCase() ? (a = J()) : (a = E(M, k, F, $, R, W))
                    else if (it & 6) {
                        k.slotScopeIds = R
                        const c = o(M)
                        if (
                            (t(k, c, null, F, $, yl(c), W), (a = nt ? P(M) : s(M)), a && _l(a) && a.data === "teleport end" && (a = s(a)), Cs(k))
                        ) {
                            let m
                            nt ? ((m = Ut(Yt)), (m.anchor = a ? a.previousSibling : c.lastChild)) : (m = M.nodeType === 3 ? ve("") : Ut("div")),
                                (m.el = M),
                                (k.component.subTree = m)
                        }
                    } else
                        it & 64
                            ? x !== 8
                                ? (a = J())
                                : (a = k.type.hydrate(M, k, F, $, R, W, e, T))
                            : it & 128 && (a = k.type.hydrate(M, k, F, $, yl(o(M)), R, W, e, y))
            }
            return ot != null && su(ot, null, $, k), a
        },
        E = (M, k, F, $, R, W) => {
            W = W || !!k.dynamicChildren
            const { type: nt, props: J, patchFlag: Q, shapeFlag: ot, dirs: it } = k,
                at = (nt === "input" && it) || nt === "option"
            if (at || Q !== -1) {
                if ((it && Cn(k, null, F, "created"), J))
                    if (at || !W || Q & 48)
                        for (const a in J) ((at && a.endsWith("value")) || (Wa(a) && !ma(a))) && n(M, a, null, J[a], !1, void 0, F)
                    else J.onClick && n(M, "onClick", null, J.onClick, !1, void 0, F)
                let x
                if (
                    ((x = J && J.onVnodeBeforeMount) && yr(x, F, k),
                    it && Cn(k, null, F, "beforeMount"),
                    ((x = J && J.onVnodeMounted) || it) &&
                        qg(() => {
                            x && yr(x, F, k), it && Cn(k, null, F, "mounted")
                        }, $),
                    ot & 16 && !(J && (J.innerHTML || J.textContent)))
                ) {
                    let a = T(M.firstChild, k, M, F, $, R, W)
                    for (; a; ) {
                        Ai = !0
                        const c = a
                        ;(a = a.nextSibling), l(c)
                    }
                } else ot & 8 && M.textContent !== k.children && ((Ai = !0), (M.textContent = k.children))
            }
            return M.nextSibling
        },
        T = (M, k, F, $, R, W, nt) => {
            nt = nt || !!k.dynamicChildren
            const J = k.children,
                Q = J.length
            for (let ot = 0; ot < Q; ot++) {
                const it = nt ? J[ot] : (J[ot] = Sr(J[ot]))
                if (M) M = y(M, it, $, R, W, nt)
                else {
                    if (it.type === Eo && !it.children) continue
                    ;(Ai = !0), r(null, it, F, null, $, R, yl(F), W)
                }
            }
            return M
        },
        S = (M, k, F, $, R, W) => {
            const { slotScopeIds: nt } = k
            nt && (R = R ? R.concat(nt) : nt)
            const J = o(M),
                Q = T(s(M), k, J, F, $, R, W)
            return Q && _l(Q) && Q.data === "]" ? s((k.anchor = Q)) : ((Ai = !0), f((k.anchor = d("]")), J, Q), Q)
        },
        N = (M, k, F, $, R, W) => {
            if (((Ai = !0), (k.el = null), W)) {
                const Q = P(M)
                for (;;) {
                    const ot = s(M)
                    if (ot && ot !== Q) l(ot)
                    else break
                }
            }
            const nt = s(M),
                J = o(M)
            return l(M), r(null, k, J, nt, F, $, yl(J), R), nt
        },
        P = (M) => {
            let k = 0
            for (; M; )
                if (((M = s(M)), M && _l(M) && (M.data === "[" && k++, M.data === "]"))) {
                    if (k === 0) return s(M)
                    k--
                }
            return M
        }
    return [h, y]
}
const sr = qg
function dm(e) {
    return pm(e)
}
function hm(e) {
    return pm(e, Ew)
}
function pm(e, t) {
    const r = jy()
    r.__VUE__ = !0
    const {
            insert: n,
            remove: i,
            patchProp: s,
            createElement: o,
            createText: l,
            createComment: f,
            setText: d,
            setElementText: h,
            parentNode: y,
            nextSibling: E,
            setScopeId: T = fn,
            cloneNode: S,
            insertStaticContent: N,
        } = e,
        P = (C, O, I, G = null, q = null, X = null, lt = !1, tt = null, rt = !!O.dynamicChildren) => {
            if (C === O) return
            C && !kn(C, O) && ((G = U(C)), p(C, q, X, !0), (C = null)), O.patchFlag === -2 && ((rt = !1), (O.dynamicChildren = null))
            const { type: st, ref: ct, shapeFlag: ht } = O
            switch (st) {
                case Eo:
                    M(C, O, I, G)
                    break
                case or:
                    k(C, O, I, G)
                    break
                case Ms:
                    C == null && F(O, I, G, lt)
                    break
                case Yt:
                    x(C, O, I, G, q, X, lt, tt, rt)
                    break
                default:
                    ht & 1
                        ? W(C, O, I, G, q, X, lt, tt, rt)
                        : ht & 6
                        ? a(C, O, I, G, q, X, lt, tt, rt)
                        : (ht & 64 || ht & 128) && st.process(C, O, I, G, q, X, lt, tt, rt, dt)
            }
            ct != null && q && su(ct, C && C.ref, X, O || C, !O)
        },
        M = (C, O, I, G) => {
            if (C == null) n((O.el = l(O.children)), I, G)
            else {
                const q = (O.el = C.el)
                O.children !== C.children && d(q, O.children)
            }
        },
        k = (C, O, I, G) => {
            C == null ? n((O.el = f(O.children || "")), I, G) : (O.el = C.el)
        },
        F = (C, O, I, G) => {
            ;[C.el, C.anchor] = N(C.children, O, I, G, C.el, C.anchor)
        },
        $ = ({ el: C, anchor: O }, I, G) => {
            let q
            for (; C && C !== O; ) (q = E(C)), n(C, I, G), (C = q)
            n(O, I, G)
        },
        R = ({ el: C, anchor: O }) => {
            let I
            for (; C && C !== O; ) (I = E(C)), i(C), (C = I)
            i(O)
        },
        W = (C, O, I, G, q, X, lt, tt, rt) => {
            ;(lt = lt || O.type === "svg"), C == null ? nt(O, I, G, q, X, lt, tt, rt) : ot(C, O, q, X, lt, tt, rt)
        },
        nt = (C, O, I, G, q, X, lt, tt) => {
            let rt, st
            const { type: ct, props: ht, shapeFlag: gt, transition: pt, patchFlag: vt, dirs: Tt } = C
            if (C.el && S !== void 0 && vt === -1) rt = C.el = S(C.el)
            else {
                if (
                    ((rt = C.el = o(C.type, X, ht && ht.is, ht)),
                    gt & 8 ? h(rt, C.children) : gt & 16 && Q(C.children, rt, null, G, q, X && ct !== "foreignObject", lt, tt),
                    Tt && Cn(C, null, G, "created"),
                    ht)
                ) {
                    for (const At in ht) At !== "value" && !ma(At) && s(rt, At, null, ht[At], X, C.children, G, q, D)
                    "value" in ht && s(rt, "value", null, ht.value), (st = ht.onVnodeBeforeMount) && yr(st, G, C)
                }
                J(rt, C, C.scopeId, lt, G)
            }
            Tt && Cn(C, null, G, "beforeMount")
            const Et = (!q || (q && !q.pendingBranch)) && pt && !pt.persisted
            Et && pt.beforeEnter(rt),
                n(rt, O, I),
                ((st = ht && ht.onVnodeMounted) || Et || Tt) &&
                    sr(() => {
                        st && yr(st, G, C), Et && pt.enter(rt), Tt && Cn(C, null, G, "mounted")
                    }, q)
        },
        J = (C, O, I, G, q) => {
            if ((I && T(C, I), G)) for (let X = 0; X < G.length; X++) T(C, G[X])
            if (q) {
                let X = q.subTree
                if (O === X) {
                    const lt = q.vnode
                    J(C, lt, lt.scopeId, lt.slotScopeIds, q.parent)
                }
            }
        },
        Q = (C, O, I, G, q, X, lt, tt, rt = 0) => {
            for (let st = rt; st < C.length; st++) {
                const ct = (C[st] = tt ? Ni(C[st]) : Sr(C[st]))
                P(null, ct, O, I, G, q, X, lt, tt)
            }
        },
        ot = (C, O, I, G, q, X, lt) => {
            const tt = (O.el = C.el)
            let { patchFlag: rt, dynamicChildren: st, dirs: ct } = O
            rt |= C.patchFlag & 16
            const ht = C.props || Ce,
                gt = O.props || Ce
            let pt
            I && vs(I, !1), (pt = gt.onVnodeBeforeUpdate) && yr(pt, I, O, C), ct && Cn(O, C, I, "beforeUpdate"), I && vs(I, !0)
            const vt = q && O.type !== "foreignObject"
            if ((st ? it(C.dynamicChildren, st, tt, I, G, vt, X) : lt || w(C, O, tt, null, I, G, vt, X, !1), rt > 0)) {
                if (rt & 16) at(tt, O, ht, gt, I, G, q)
                else if (
                    (rt & 2 && ht.class !== gt.class && s(tt, "class", null, gt.class, q),
                    rt & 4 && s(tt, "style", ht.style, gt.style, q),
                    rt & 8)
                ) {
                    const Tt = O.dynamicProps
                    for (let Et = 0; Et < Tt.length; Et++) {
                        const At = Tt[Et],
                            Ft = ht[At],
                            Ot = gt[At]
                        ;(Ot !== Ft || At === "value") && s(tt, At, Ft, Ot, q, C.children, I, G, D)
                    }
                }
                rt & 1 && C.children !== O.children && h(tt, O.children)
            } else !lt && st == null && at(tt, O, ht, gt, I, G, q)
            ;((pt = gt.onVnodeUpdated) || ct) &&
                sr(() => {
                    pt && yr(pt, I, O, C), ct && Cn(O, C, I, "updated")
                }, G)
        },
        it = (C, O, I, G, q, X, lt) => {
            for (let tt = 0; tt < O.length; tt++) {
                const rt = C[tt],
                    st = O[tt],
                    ct = rt.el && (rt.type === Yt || !kn(rt, st) || rt.shapeFlag & 70) ? y(rt.el) : I
                P(rt, st, ct, null, G, q, X, lt, !0)
            }
        },
        at = (C, O, I, G, q, X, lt) => {
            if (I !== G) {
                for (const tt in G) {
                    if (ma(tt)) continue
                    const rt = G[tt],
                        st = I[tt]
                    rt !== st && tt !== "value" && s(C, tt, st, rt, lt, O.children, q, X, D)
                }
                if (I !== Ce) for (const tt in I) !ma(tt) && !(tt in G) && s(C, tt, I[tt], null, lt, O.children, q, X, D)
                "value" in G && s(C, "value", I.value, G.value)
            }
        },
        x = (C, O, I, G, q, X, lt, tt, rt) => {
            const st = (O.el = C ? C.el : l("")),
                ct = (O.anchor = C ? C.anchor : l(""))
            let { patchFlag: ht, dynamicChildren: gt, slotScopeIds: pt } = O
            pt && (tt = tt ? tt.concat(pt) : pt),
                C == null
                    ? (n(st, I, G), n(ct, I, G), Q(O.children, I, ct, q, X, lt, tt, rt))
                    : ht > 0 && ht & 64 && gt && C.dynamicChildren
                    ? (it(C.dynamicChildren, gt, I, q, X, lt, tt), (O.key != null || (q && O === q.subTree)) && Cd(C, O, !0))
                    : w(C, O, I, ct, q, X, lt, tt, rt)
        },
        a = (C, O, I, G, q, X, lt, tt, rt) => {
            ;(O.slotScopeIds = tt), C == null ? (O.shapeFlag & 512 ? q.ctx.activate(O, I, G, lt, rt) : c(O, I, G, q, X, lt, rt)) : m(C, O, rt)
        },
        c = (C, O, I, G, q, X, lt) => {
            const tt = (C.component = ym(C, G, q))
            if ((Za(C) && (tt.ctx.renderer = dt), wm(tt), tt.asyncDep)) {
                if ((q && q.registerDep(tt, _), !C.el)) {
                    const rt = (tt.subTree = Ut(or))
                    k(null, rt, O, I)
                }
                return
            }
            _(tt, C, O, I, q, X, lt)
        },
        m = (C, O, I) => {
            const G = (O.component = C.component)
            if (G_(C, O, I))
                if (G.asyncDep && !G.asyncResolved) {
                    A(G, O, I)
                    return
                } else (G.next = O), $_(G.update), G.update()
            else (O.el = C.el), (G.vnode = O)
        },
        _ = (C, O, I, G, q, X, lt) => {
            const tt = () => {
                    if (C.isMounted) {
                        let { next: ct, bu: ht, u: gt, parent: pt, vnode: vt } = C,
                            Tt = ct,
                            Et
                        vs(C, !1),
                            ct ? ((ct.el = vt.el), A(C, ct, lt)) : (ct = vt),
                            ht && mo(ht),
                            (Et = ct.props && ct.props.onVnodeBeforeUpdate) && yr(Et, pt, ct, vt),
                            vs(C, !0)
                        const At = $l(C),
                            Ft = C.subTree
                        ;(C.subTree = At),
                            P(Ft, At, y(Ft.el), U(Ft), C, q, X),
                            (ct.el = At.el),
                            Tt === null && yd(C, At.el),
                            gt && sr(gt, q),
                            (Et = ct.props && ct.props.onVnodeUpdated) && sr(() => yr(Et, pt, ct, vt), q)
                    } else {
                        let ct
                        const { el: ht, props: gt } = O,
                            { bm: pt, m: vt, parent: Tt } = C,
                            Et = Cs(O)
                        if ((vs(C, !1), pt && mo(pt), !Et && (ct = gt && gt.onVnodeBeforeMount) && yr(ct, Tt, O), vs(C, !0), ht && et)) {
                            const At = () => {
                                ;(C.subTree = $l(C)), et(ht, C.subTree, C, q, null)
                            }
                            Et ? O.type.__asyncLoader().then(() => !C.isUnmounted && At()) : At()
                        } else {
                            const At = (C.subTree = $l(C))
                            P(null, At, I, G, C, q, X), (O.el = At.el)
                        }
                        if ((vt && sr(vt, q), !Et && (ct = gt && gt.onVnodeMounted))) {
                            const At = O
                            sr(() => yr(ct, Tt, At), q)
                        }
                        ;(O.shapeFlag & 256 || (Tt && Cs(Tt.vnode) && Tt.vnode.shapeFlag & 256)) && C.a && sr(C.a, q),
                            (C.isMounted = !0),
                            (O = I = G = null)
                    }
                },
                rt = (C.effect = new Qa(tt, () => vd(st), C.scope)),
                st = (C.update = () => rt.run())
            ;(st.id = C.uid), vs(C, !0), st()
        },
        A = (C, O, I) => {
            O.component = C
            const G = C.vnode.props
            ;(C.vnode = O), (C.next = null), vw(C, O.props, G, I), _w(C, O.children, I), Vs(), Ru(void 0, C.update), Us()
        },
        w = (C, O, I, G, q, X, lt, tt, rt = !1) => {
            const st = C && C.children,
                ct = C ? C.shapeFlag : 0,
                ht = O.children,
                { patchFlag: gt, shapeFlag: pt } = O
            if (gt > 0) {
                if (gt & 128) {
                    g(st, ht, I, G, q, X, lt, tt, rt)
                    return
                } else if (gt & 256) {
                    v(st, ht, I, G, q, X, lt, tt, rt)
                    return
                }
            }
            pt & 8
                ? (ct & 16 && D(st, q, X), ht !== st && h(I, ht))
                : ct & 16
                ? pt & 16
                    ? g(st, ht, I, G, q, X, lt, tt, rt)
                    : D(st, q, X, !0)
                : (ct & 8 && h(I, ""), pt & 16 && Q(ht, I, G, q, X, lt, tt, rt))
        },
        v = (C, O, I, G, q, X, lt, tt, rt) => {
            ;(C = C || po), (O = O || po)
            const st = C.length,
                ct = O.length,
                ht = Math.min(st, ct)
            let gt
            for (gt = 0; gt < ht; gt++) {
                const pt = (O[gt] = rt ? Ni(O[gt]) : Sr(O[gt]))
                P(C[gt], pt, I, null, q, X, lt, tt, rt)
            }
            st > ct ? D(C, q, X, !0, !1, ht) : Q(O, I, G, q, X, lt, tt, rt, ht)
        },
        g = (C, O, I, G, q, X, lt, tt, rt) => {
            let st = 0
            const ct = O.length
            let ht = C.length - 1,
                gt = ct - 1
            for (; st <= ht && st <= gt; ) {
                const pt = C[st],
                    vt = (O[st] = rt ? Ni(O[st]) : Sr(O[st]))
                if (kn(pt, vt)) P(pt, vt, I, null, q, X, lt, tt, rt)
                else break
                st++
            }
            for (; st <= ht && st <= gt; ) {
                const pt = C[ht],
                    vt = (O[gt] = rt ? Ni(O[gt]) : Sr(O[gt]))
                if (kn(pt, vt)) P(pt, vt, I, null, q, X, lt, tt, rt)
                else break
                ht--, gt--
            }
            if (st > ht) {
                if (st <= gt) {
                    const pt = gt + 1,
                        vt = pt < ct ? O[pt].el : G
                    for (; st <= gt; ) P(null, (O[st] = rt ? Ni(O[st]) : Sr(O[st])), I, vt, q, X, lt, tt, rt), st++
                }
            } else if (st > gt) for (; st <= ht; ) p(C[st], q, X, !0), st++
            else {
                const pt = st,
                    vt = st,
                    Tt = new Map()
                for (st = vt; st <= gt; st++) {
                    const Mt = (O[st] = rt ? Ni(O[st]) : Sr(O[st]))
                    Mt.key != null && Tt.set(Mt.key, st)
                }
                let Et,
                    At = 0
                const Ft = gt - vt + 1
                let Ot = !1,
                    Bt = 0
                const ke = new Array(Ft)
                for (st = 0; st < Ft; st++) ke[st] = 0
                for (st = pt; st <= ht; st++) {
                    const Mt = C[st]
                    if (At >= Ft) {
                        p(Mt, q, X, !0)
                        continue
                    }
                    let ge
                    if (Mt.key != null) ge = Tt.get(Mt.key)
                    else
                        for (Et = vt; Et <= gt; Et++)
                            if (ke[Et - vt] === 0 && kn(Mt, O[Et])) {
                                ge = Et
                                break
                            }
                    ge === void 0
                        ? p(Mt, q, X, !0)
                        : ((ke[ge - vt] = st + 1), ge >= Bt ? (Bt = ge) : (Ot = !0), P(Mt, O[ge], I, null, q, X, lt, tt, rt), At++)
                }
                const Vt = Ot ? xw(ke) : po
                for (Et = Vt.length - 1, st = Ft - 1; st >= 0; st--) {
                    const Mt = vt + st,
                        ge = O[Mt],
                        Rt = Mt + 1 < ct ? O[Mt + 1].el : G
                    ke[st] === 0 ? P(null, ge, I, Rt, q, X, lt, tt, rt) : Ot && (Et < 0 || st !== Vt[Et] ? u(ge, I, Rt, 2) : Et--)
                }
            }
        },
        u = (C, O, I, G, q = null) => {
            const { el: X, type: lt, transition: tt, children: rt, shapeFlag: st } = C
            if (st & 6) {
                u(C.component.subTree, O, I, G)
                return
            }
            if (st & 128) {
                C.suspense.move(O, I, G)
                return
            }
            if (st & 64) {
                lt.move(C, O, I, dt)
                return
            }
            if (lt === Yt) {
                n(X, O, I)
                for (let ht = 0; ht < rt.length; ht++) u(rt[ht], O, I, G)
                n(C.anchor, O, I)
                return
            }
            if (lt === Ms) {
                $(C, O, I)
                return
            }
            if (G !== 2 && st & 1 && tt)
                if (G === 0) tt.beforeEnter(X), n(X, O, I), sr(() => tt.enter(X), q)
                else {
                    const { leave: ht, delayLeave: gt, afterLeave: pt } = tt,
                        vt = () => n(X, O, I),
                        Tt = () => {
                            ht(X, () => {
                                vt(), pt && pt()
                            })
                        }
                    gt ? gt(X, vt, Tt) : Tt()
                }
            else n(X, O, I)
        },
        p = (C, O, I, G = !1, q = !1) => {
            const { type: X, props: lt, ref: tt, children: rt, dynamicChildren: st, shapeFlag: ct, patchFlag: ht, dirs: gt } = C
            if ((tt != null && su(tt, null, I, C, !0), ct & 256)) {
                O.ctx.deactivate(C)
                return
            }
            const pt = ct & 1 && gt,
                vt = !Cs(C)
            let Tt
            if ((vt && (Tt = lt && lt.onVnodeBeforeUnmount) && yr(Tt, O, C), ct & 6)) B(C.component, I, G)
            else {
                if (ct & 128) {
                    C.suspense.unmount(I, G)
                    return
                }
                pt && Cn(C, null, O, "beforeUnmount"),
                    ct & 64
                        ? C.type.remove(C, O, I, q, dt, G)
                        : st && (X !== Yt || (ht > 0 && ht & 64))
                        ? D(st, O, I, !1, !0)
                        : ((X === Yt && ht & 384) || (!q && ct & 16)) && D(rt, O, I),
                    G && H(C)
            }
            ;((vt && (Tt = lt && lt.onVnodeUnmounted)) || pt) &&
                sr(() => {
                    Tt && yr(Tt, O, C), pt && Cn(C, null, O, "unmounted")
                }, I)
        },
        H = (C) => {
            const { type: O, el: I, anchor: G, transition: q } = C
            if (O === Yt) {
                b(I, G)
                return
            }
            if (O === Ms) {
                R(C)
                return
            }
            const X = () => {
                i(I), q && !q.persisted && q.afterLeave && q.afterLeave()
            }
            if (C.shapeFlag & 1 && q && !q.persisted) {
                const { leave: lt, delayLeave: tt } = q,
                    rt = () => lt(I, X)
                tt ? tt(C.el, X, rt) : rt()
            } else X()
        },
        b = (C, O) => {
            let I
            for (; C !== O; ) (I = E(C)), i(C), (C = I)
            i(O)
        },
        B = (C, O, I) => {
            const { bum: G, scope: q, update: X, subTree: lt, um: tt } = C
            G && mo(G),
                q.stop(),
                X && ((X.active = !1), p(lt, C, O, I)),
                tt && sr(tt, O),
                sr(() => {
                    C.isUnmounted = !0
                }, O),
                O &&
                    O.pendingBranch &&
                    !O.isUnmounted &&
                    C.asyncDep &&
                    !C.asyncResolved &&
                    C.suspenseId === O.pendingId &&
                    (O.deps--, O.deps === 0 && O.resolve())
        },
        D = (C, O, I, G = !1, q = !1, X = 0) => {
            for (let lt = X; lt < C.length; lt++) p(C[lt], O, I, G, q)
        },
        U = (C) => (C.shapeFlag & 6 ? U(C.component.subTree) : C.shapeFlag & 128 ? C.suspense.next() : E(C.anchor || C.el)),
        j = (C, O, I) => {
            C == null ? O._vnode && p(O._vnode, null, null, !0) : P(O._vnode || null, C, O, null, null, null, I), ru(), (O._vnode = C)
        },
        dt = { p: P, um: p, m: u, r: H, mt: c, mc: Q, pc: w, pbc: it, n: U, o: e }
    let Z, et
    return t && ([Z, et] = t(dt)), { render: j, hydrate: Z, createApp: Aw(j, Z) }
}
function vs({ effect: e, update: t }, r) {
    e.allowRecurse = t.allowRecurse = r
}
function Cd(e, t, r = !1) {
    const n = e.children,
        i = t.children
    if ($t(n) && $t(i))
        for (let s = 0; s < n.length; s++) {
            const o = n[s]
            let l = i[s]
            l.shapeFlag & 1 &&
                !l.dynamicChildren &&
                ((l.patchFlag <= 0 || l.patchFlag === 32) && ((l = i[s] = Ni(i[s])), (l.el = o.el)), r || Cd(o, l))
        }
}
function xw(e) {
    const t = e.slice(),
        r = [0]
    let n, i, s, o, l
    const f = e.length
    for (n = 0; n < f; n++) {
        const d = e[n]
        if (d !== 0) {
            if (((i = r[r.length - 1]), e[i] < d)) {
                ;(t[n] = i), r.push(n)
                continue
            }
            for (s = 0, o = r.length - 1; s < o; ) (l = (s + o) >> 1), e[r[l]] < d ? (s = l + 1) : (o = l)
            d < e[r[s]] && (s > 0 && (t[n] = r[s - 1]), (r[s] = n))
        }
    }
    for (s = r.length, o = r[s - 1]; s-- > 0; ) (r[s] = o), (o = t[o])
    return r
}
const Tw = (e) => e.__isTeleport,
    wa = (e) => e && (e.disabled || e.disabled === ""),
    $h = (e) => typeof SVGElement != "undefined" && e instanceof SVGElement,
    yc = (e, t) => {
        const r = e && e.to
        return Fe(r) ? (t ? t(r) : null) : r
    },
    Cw = {
        __isTeleport: !0,
        process(e, t, r, n, i, s, o, l, f, d) {
            const {
                    mc: h,
                    pc: y,
                    pbc: E,
                    o: { insert: T, querySelector: S, createText: N, createComment: P },
                } = d,
                M = wa(t.props)
            let { shapeFlag: k, children: F, dynamicChildren: $ } = t
            if (e == null) {
                const R = (t.el = N("")),
                    W = (t.anchor = N(""))
                T(R, r, n), T(W, r, n)
                const nt = (t.target = yc(t.props, S)),
                    J = (t.targetAnchor = N(""))
                nt && (T(J, nt), (o = o || $h(nt)))
                const Q = (ot, it) => {
                    k & 16 && h(F, ot, it, i, s, o, l, f)
                }
                M ? Q(r, W) : nt && Q(nt, J)
            } else {
                t.el = e.el
                const R = (t.anchor = e.anchor),
                    W = (t.target = e.target),
                    nt = (t.targetAnchor = e.targetAnchor),
                    J = wa(e.props),
                    Q = J ? r : W,
                    ot = J ? R : nt
                if (((o = o || $h(W)), $ ? (E(e.dynamicChildren, $, Q, i, s, o, l), Cd(e, t, !0)) : f || y(e, t, Q, ot, i, s, o, l, !1), M))
                    J || wl(t, r, R, d, 1)
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const it = (t.target = yc(t.props, S))
                    it && wl(t, it, null, d, 0)
                } else J && wl(t, W, nt, d, 1)
            }
        },
        remove(e, t, r, n, { um: i, o: { remove: s } }, o) {
            const { shapeFlag: l, children: f, anchor: d, targetAnchor: h, target: y, props: E } = e
            if ((y && s(h), (o || !wa(E)) && (s(d), l & 16)))
                for (let T = 0; T < f.length; T++) {
                    const S = f[T]
                    i(S, t, r, !0, !!S.dynamicChildren)
                }
        },
        move: wl,
        hydrate: Mw,
    }
function wl(e, t, r, { o: { insert: n }, m: i }, s = 2) {
    s === 0 && n(e.targetAnchor, t, r)
    const { el: o, anchor: l, shapeFlag: f, children: d, props: h } = e,
        y = s === 2
    if ((y && n(o, t, r), (!y || wa(h)) && f & 16)) for (let E = 0; E < d.length; E++) i(d[E], t, r, 2)
    y && n(l, t, r)
}
function Mw(e, t, r, n, i, s, { o: { nextSibling: o, parentNode: l, querySelector: f } }, d) {
    const h = (t.target = yc(t.props, f))
    if (h) {
        const y = h._lpa || h.firstChild
        if (t.shapeFlag & 16)
            if (wa(t.props)) (t.anchor = d(o(e), t, l(e), r, n, i, s)), (t.targetAnchor = y)
            else {
                t.anchor = o(e)
                let E = y
                for (; E; )
                    if (((E = o(E)), E && E.nodeType === 8 && E.data === "teleport anchor")) {
                        ;(t.targetAnchor = E), (h._lpa = t.targetAnchor && o(t.targetAnchor))
                        break
                    }
                d(y, t, h, r, n, i, s)
            }
    }
    return t.anchor && o(t.anchor)
}
const gm = Cw,
    Yt = Symbol(void 0),
    Eo = Symbol(void 0),
    or = Symbol(void 0),
    Ms = Symbol(void 0),
    Aa = []
let wr = null
function Y(e = !1) {
    Aa.push((wr = e ? null : []))
}
function mm() {
    Aa.pop(), (wr = Aa[Aa.length - 1] || null)
}
let Os = 1
function _c(e) {
    Os += e
}
function vm(e) {
    return (e.dynamicChildren = Os > 0 ? wr || po : null), mm(), Os > 0 && wr && wr.push(e), e
}
function ft(e, t, r, n, i, s) {
    return vm(xt(e, t, r, n, i, s, !0))
}
function kt(e, t, r, n, i) {
    return vm(Ut(e, t, r, n, i, !0))
}
function zi(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function kn(e, t) {
    return e.type === t.type && e.key === t.key
}
function Sw(e) {}
const Uu = "__vInternal",
    bm = ({ key: e }) => (e != null ? e : null),
    Fl = ({ ref: e, ref_key: t, ref_for: r }) => (e != null ? (Fe(e) || Re(e) || fe(e) ? { i: dr, r: e, k: t, f: !!r } : e) : null)
function xt(e, t = null, r = null, n = 0, i = null, s = e === Yt ? 0 : 1, o = !1, l = !1) {
    const f = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && bm(t),
        ref: t && Fl(t),
        scopeId: Du,
        slotScopeIds: null,
        children: r,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: n,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
    }
    return (
        l ? (Md(f, r), s & 128 && e.normalize(f)) : r && (f.shapeFlag |= Fe(r) ? 8 : 16),
        Os > 0 && !o && wr && (f.patchFlag > 0 || s & 6) && f.patchFlag !== 32 && wr.push(f),
        f
    )
}
const Ut = kw
function kw(e, t = null, r = null, n = 0, i = null, s = !1) {
    if (((!e || e === em) && (e = or), zi(e))) {
        const l = Fn(e, t, !0)
        return r && Md(l, r), Os > 0 && !s && wr && (l.shapeFlag & 6 ? (wr[wr.indexOf(e)] = l) : wr.push(l)), (l.patchFlag |= -2), l
    }
    if ((Fw(e) && (e = e.__vccOpts), t)) {
        t = Ho(t)
        let { class: l, style: f } = t
        l && !Fe(l) && (t.class = wt(l)), ze(f) && (dd(f) && !$t(f) && (f = qe({}, f)), (t.style = hn(f)))
    }
    const o = Fe(e) ? 1 : Ug(e) ? 128 : Tw(e) ? 64 : ze(e) ? 4 : fe(e) ? 2 : 0
    return xt(e, t, r, n, i, o, s, !0)
}
function Ho(e) {
    return e ? (dd(e) || Uu in e ? qe({}, e) : e) : null
}
function Fn(e, t, r = !1) {
    const { props: n, ref: i, patchFlag: s, children: o } = e,
        l = t ? ce(n || {}, t) : n
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: l,
        key: l && bm(l),
        ref: t && t.ref ? (r && i ? ($t(i) ? i.concat(Fl(t)) : [i, Fl(t)]) : Fl(t)) : i,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Yt ? (s === -1 ? 16 : s | 16) : s,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Fn(e.ssContent),
        ssFallback: e.ssFallback && Fn(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
    }
}
function ve(e = " ", t = 0) {
    return Ut(Eo, null, e, t)
}
function Nw(e, t) {
    const r = Ut(Ms, null, e)
    return (r.staticCount = t), r
}
function Dt(e = "", t = !1) {
    return t ? (Y(), kt(or, null, e)) : Ut(or, null, e)
}
function Sr(e) {
    return e == null || typeof e == "boolean" ? Ut(or) : $t(e) ? Ut(Yt, null, e.slice()) : typeof e == "object" ? Ni(e) : Ut(Eo, null, String(e))
}
function Ni(e) {
    return e.el === null || e.memo ? e : Fn(e)
}
function Md(e, t) {
    let r = 0
    const { shapeFlag: n } = e
    if (t == null) t = null
    else if ($t(t)) r = 16
    else if (typeof t == "object")
        if (n & 65) {
            const i = t.default
            i && (i._c && (i._d = !1), Md(e, i()), i._c && (i._d = !0))
            return
        } else {
            r = 32
            const i = t._
            !i && !(Uu in t) ? (t._ctx = dr) : i === 3 && dr && (dr.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
        }
    else fe(t) ? ((t = { default: t, _ctx: dr }), (r = 32)) : ((t = String(t)), n & 64 ? ((r = 16), (t = [ve(t)])) : (r = 8))
    ;(e.children = t), (e.shapeFlag |= r)
}
function ce(...e) {
    const t = {}
    for (let r = 0; r < e.length; r++) {
        const n = e[r]
        for (const i in n)
            if (i === "class") t.class !== n.class && (t.class = wt([t.class, n.class]))
            else if (i === "style") t.style = hn([t.style, n.style])
            else if (Wa(i)) {
                const s = t[i],
                    o = n[i]
                o && s !== o && !($t(s) && s.includes(o)) && (t[i] = s ? [].concat(s, o) : o)
            } else i !== "" && (t[i] = n[i])
    }
    return t
}
function yr(e, t, r, n = null) {
    Br(e, t, 7, [r, n])
}
const Ow = cm()
let Iw = 0
function ym(e, t, r) {
    const n = e.type,
        i = (t ? t.appContext : e.appContext) || Ow,
        s = {
            uid: Iw++,
            vnode: e,
            type: n,
            parent: t,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new ld(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: am(n, i),
            emitsOptions: Vg(n, i),
            emit: null,
            emitted: null,
            propsDefaults: Ce,
            inheritAttrs: n.inheritAttrs,
            ctx: Ce,
            data: Ce,
            props: Ce,
            attrs: Ce,
            slots: Ce,
            refs: Ce,
            setupState: Ce,
            setupContext: null,
            suspense: r,
            suspenseId: r ? r.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null,
        }
    return (s.ctx = { _: s }), (s.root = t ? t.root : s), (s.emit = V_.bind(null, s)), e.ce && e.ce(s), s
}
let Qe = null
const vi = () => Qe || dr,
    ji = (e) => {
        ;(Qe = e), e.scope.on()
    },
    $i = () => {
        Qe && Qe.scope.off(), (Qe = null)
    }
function _m(e) {
    return e.vnode.shapeFlag & 4
}
let xo = !1
function wm(e, t = !1) {
    xo = t
    const { props: r, children: n } = e.vnode,
        i = _m(e)
    mw(e, r, i, t), yw(e, n)
    const s = i ? Bw(e, t) : void 0
    return (xo = !1), s
}
function Bw(e, t) {
    const r = e.type
    ;(e.accessCache = Object.create(null)), (e.proxy = Oa(new Proxy(e.ctx, gc)))
    const { setup: n } = r
    if (n) {
        const i = (e.setupContext = n.length > 1 ? Em(e) : null)
        ji(e), Vs()
        const s = Pn(n, e, 0, [e.props, i])
        if ((Us(), $i(), od(s))) {
            if ((s.then($i, $i), t))
                return s
                    .then((o) => {
                        wc(e, o, t)
                    })
                    .catch((o) => {
                        Hs(o, e, 0)
                    })
            e.asyncDep = s
        } else wc(e, s, t)
    } else Am(e, t)
}
function wc(e, t, r) {
    fe(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : ze(t) && (e.setupState = gd(t)), Am(e, r)
}
let ou, Ac
function Pw(e) {
    ;(ou = e),
        (Ac = (t) => {
            t.render._rc && (t.withProxy = new Proxy(t.ctx, fw))
        })
}
const Rw = () => !ou
function Am(e, t, r) {
    const n = e.type
    if (!e.render) {
        if (!t && ou && !n.render) {
            const i = n.template
            if (i) {
                const { isCustomElement: s, compilerOptions: o } = e.appContext.config,
                    { delimiters: l, compilerOptions: f } = n,
                    d = qe(qe({ isCustomElement: s, delimiters: l }, o), f)
                n.render = ou(i, d)
            }
        }
        ;(e.render = n.render || fn), Ac && Ac(e)
    }
    ji(e), Vs(), cw(e), Us(), $i()
}
function Lw(e) {
    return new Proxy(e.attrs, {
        get(t, r) {
            return Rr(e, "get", "$attrs"), t[r]
        },
    })
}
function Em(e) {
    const t = (n) => {
        e.exposed = n || {}
    }
    let r
    return {
        get attrs() {
            return r || (r = Lw(e))
        },
        slots: e.slots,
        emit: e.emit,
        expose: t,
    }
}
function Hu(e) {
    if (e.exposed)
        return (
            e.exposeProxy ||
            (e.exposeProxy = new Proxy(gd(Oa(e.exposed)), {
                get(t, r) {
                    if (r in t) return t[r]
                    if (r in nu) return nu[r](e)
                },
            }))
        )
}
const Dw = /(?:^|[-_])(\w)/g,
    $w = (e) => e.replace(Dw, (t) => t.toUpperCase()).replace(/[-_]/g, "")
function au(e, t = !0) {
    return fe(e) ? e.displayName || e.name : e.name || (t && e.__name)
}
function xm(e, t, r = !1) {
    let n = au(t)
    if (!n && t.__file) {
        const i = t.__file.match(/([^/\\]+)\.\w+$/)
        i && (n = i[1])
    }
    if (!n && e && e.parent) {
        const i = (s) => {
            for (const o in s) if (s[o] === t) return o
        }
        n = i(e.components || e.parent.type.components) || i(e.appContext.components)
    }
    return n ? $w(n) : r ? "App" : "Anonymous"
}
function Fw(e) {
    return fe(e) && "__vccOpts" in e
}
const K = (e, t) => cc(e, t, xo)
function Vw() {
    return null
}
function Uw() {
    return null
}
function Hw(e) {}
function qw(e, t) {
    return null
}
function Qi() {
    return Tm().slots
}
function Sd() {
    return Tm().attrs
}
function Tm() {
    const e = vi()
    return e.setupContext || (e.setupContext = Em(e))
}
function zw(e, t) {
    const r = $t(e) ? e.reduce((n, i) => ((n[i] = {}), n), {}) : e
    for (const n in t) {
        const i = r[n]
        i ? ($t(i) || fe(i) ? (r[n] = { type: i, default: t[n] }) : (i.default = t[n])) : i === null && (r[n] = { default: t[n] })
    }
    return r
}
function jw(e, t) {
    const r = {}
    for (const n in e) t.includes(n) || Object.defineProperty(r, n, { enumerable: !0, get: () => e[n] })
    return r
}
function Kw(e) {
    const t = vi()
    let r = e()
    return (
        $i(),
        od(r) &&
            (r = r.catch((n) => {
                throw (ji(t), n)
            })),
        [r, () => ji(t)]
    )
}
function he(e, t, r) {
    const n = arguments.length
    return n === 2
        ? ze(t) && !$t(t)
            ? zi(t)
                ? Ut(e, null, [t])
                : Ut(e, t)
            : Ut(e, null, t)
        : (n > 3 ? (r = Array.prototype.slice.call(arguments, 2)) : n === 3 && zi(r) && (r = [r]), Ut(e, t, r))
}
const Cm = Symbol(""),
    Gw = () => {
        {
            const e = Ie(Cm)
            return e || Bg("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), e
        }
    }
function Ww() {}
function Yw(e, t, r, n) {
    const i = r[n]
    if (i && Mm(i, e)) return i
    const s = t()
    return (s.memo = e.slice()), (r[n] = s)
}
function Mm(e, t) {
    const r = e.memo
    if (r.length != t.length) return !1
    for (let n = 0; n < r.length; n++) if (_o(r[n], t[n])) return !1
    return Os > 0 && wr && wr.push(e), !0
}
const Sm = "3.2.37",
    Jw = {
        createComponentInstance: ym,
        setupComponent: wm,
        renderComponentRoot: $l,
        setCurrentRenderingInstance: Pa,
        isVNode: zi,
        normalizeVNode: Sr,
    },
    Qw = Jw,
    Xw = null,
    Zw = null,
    tA = "http://www.w3.org/2000/svg",
    As = typeof document != "undefined" ? document : null,
    Fh = As && As.createElement("template"),
    eA = {
        insert: (e, t, r) => {
            t.insertBefore(e, r || null)
        },
        remove: (e) => {
            const t = e.parentNode
            t && t.removeChild(e)
        },
        createElement: (e, t, r, n) => {
            const i = t ? As.createElementNS(tA, e) : As.createElement(e, r ? { is: r } : void 0)
            return e === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i
        },
        createText: (e) => As.createTextNode(e),
        createComment: (e) => As.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: (e) => e.parentNode,
        nextSibling: (e) => e.nextSibling,
        querySelector: (e) => As.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        cloneNode(e) {
            const t = e.cloneNode(!0)
            return "_value" in e && (t._value = e._value), t
        },
        insertStaticContent(e, t, r, n, i, s) {
            const o = r ? r.previousSibling : t.lastChild
            if (i && (i === s || i.nextSibling)) for (; t.insertBefore(i.cloneNode(!0), r), !(i === s || !(i = i.nextSibling)); );
            else {
                Fh.innerHTML = n ? `<svg>${e}</svg>` : e
                const l = Fh.content
                if (n) {
                    const f = l.firstChild
                    for (; f.firstChild; ) l.appendChild(f.firstChild)
                    l.removeChild(f)
                }
                t.insertBefore(l, r)
            }
            return [o ? o.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild]
        },
    }
function rA(e, t, r) {
    const n = e._vtc
    n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : (e.className = t)
}
function nA(e, t, r) {
    const n = e.style,
        i = Fe(r)
    if (r && !i) {
        for (const s in r) Ec(n, s, r[s])
        if (t && !Fe(t)) for (const s in t) r[s] == null && Ec(n, s, "")
    } else {
        const s = n.display
        i ? t !== r && (n.cssText = r) : t && e.removeAttribute("style"), "_vod" in e && (n.display = s)
    }
}
const Vh = /\s*!important$/
function Ec(e, t, r) {
    if ($t(r)) r.forEach((n) => Ec(e, t, n))
    else if ((r == null && (r = ""), t.startsWith("--"))) e.setProperty(t, r)
    else {
        const n = iA(e, t)
        Vh.test(r) ? e.setProperty(Bn(n), r.replace(Vh, ""), "important") : (e[n] = r)
    }
}
const Uh = ["Webkit", "Moz", "ms"],
    wf = {}
function iA(e, t) {
    const r = wf[t]
    if (r) return r
    let n = Pr(t)
    if (n !== "filter" && n in e) return (wf[t] = n)
    n = Ja(n)
    for (let i = 0; i < Uh.length; i++) {
        const s = Uh[i] + n
        if (s in e) return (wf[t] = s)
    }
    return t
}
const Hh = "http://www.w3.org/1999/xlink"
function sA(e, t, r, n, i) {
    if (n && t.startsWith("xlink:")) r == null ? e.removeAttributeNS(Hh, t.slice(6, t.length)) : e.setAttributeNS(Hh, t, r)
    else {
        const s = Py(t)
        r == null || (s && !hg(r)) ? e.removeAttribute(t) : e.setAttribute(t, s ? "" : r)
    }
}
function oA(e, t, r, n, i, s, o) {
    if (t === "innerHTML" || t === "textContent") {
        n && o(n, i, s), (e[t] = r == null ? "" : r)
        return
    }
    if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) {
        e._value = r
        const f = r == null ? "" : r
        ;(e.value !== f || e.tagName === "OPTION") && (e.value = f), r == null && e.removeAttribute(t)
        return
    }
    let l = !1
    if (r === "" || r == null) {
        const f = typeof e[t]
        f === "boolean" ? (r = hg(r)) : r == null && f === "string" ? ((r = ""), (l = !0)) : f === "number" && ((r = 0), (l = !0))
    }
    try {
        e[t] = r
    } catch {}
    l && e.removeAttribute(t)
}
const [km, aA] = (() => {
    let e = Date.now,
        t = !1
    if (typeof window != "undefined") {
        Date.now() > document.createEvent("Event").timeStamp && (e = performance.now.bind(performance))
        const r = navigator.userAgent.match(/firefox\/(\d+)/i)
        t = !!(r && Number(r[1]) <= 53)
    }
    return [e, t]
})()
let xc = 0
const lA = Promise.resolve(),
    uA = () => {
        xc = 0
    },
    fA = () => xc || (lA.then(uA), (xc = km()))
function Xn(e, t, r, n) {
    e.addEventListener(t, r, n)
}
function cA(e, t, r, n) {
    e.removeEventListener(t, r, n)
}
function dA(e, t, r, n, i = null) {
    const s = e._vei || (e._vei = {}),
        o = s[t]
    if (n && o) o.value = n
    else {
        const [l, f] = hA(t)
        if (n) {
            const d = (s[t] = pA(n, i))
            Xn(e, l, d, f)
        } else o && (cA(e, l, o, f), (s[t] = void 0))
    }
}
const qh = /(?:Once|Passive|Capture)$/
function hA(e) {
    let t
    if (qh.test(e)) {
        t = {}
        let r
        for (; (r = e.match(qh)); ) (e = e.slice(0, e.length - r[0].length)), (t[r[0].toLowerCase()] = !0)
    }
    return [Bn(e.slice(2)), t]
}
function pA(e, t) {
    const r = (n) => {
        const i = n.timeStamp || km()
        ;(aA || i >= r.attached - 1) && Br(gA(n, r.value), t, 5, [n])
    }
    return (r.value = e), (r.attached = fA()), r
}
function gA(e, t) {
    if ($t(t)) {
        const r = e.stopImmediatePropagation
        return (
            (e.stopImmediatePropagation = () => {
                r.call(e), (e._stopped = !0)
            }),
            t.map((n) => (i) => !i._stopped && n && n(i))
        )
    } else return t
}
const zh = /^on[a-z]/,
    mA = (e, t, r, n, i = !1, s, o, l, f) => {
        t === "class"
            ? rA(e, n, i)
            : t === "style"
            ? nA(e, r, n)
            : Wa(t)
            ? id(t) || dA(e, t, r, n, o)
            : (t[0] === "." ? ((t = t.slice(1)), !0) : t[0] === "^" ? ((t = t.slice(1)), !1) : vA(e, t, n, i))
            ? oA(e, t, n, s, o, l, f)
            : (t === "true-value" ? (e._trueValue = n) : t === "false-value" && (e._falseValue = n), sA(e, t, n, i))
    }
function vA(e, t, r, n) {
    return n
        ? !!(t === "innerHTML" || t === "textContent" || (t in e && zh.test(t) && fe(r)))
        : t === "spellcheck" ||
          t === "draggable" ||
          t === "translate" ||
          t === "form" ||
          (t === "list" && e.tagName === "INPUT") ||
          (t === "type" && e.tagName === "TEXTAREA") ||
          (zh.test(t) && Fe(r))
        ? !1
        : t in e
}
function Nm(e, t) {
    const r = bt(e)
    class n extends qu {
        constructor(s) {
            super(r, s, t)
        }
    }
    return (n.def = r), n
}
const bA = (e) => Nm(e, qm),
    yA = typeof HTMLElement != "undefined" ? HTMLElement : class {}
class qu extends yA {
    constructor(t, r = {}, n) {
        super(),
            (this._def = t),
            (this._props = r),
            (this._instance = null),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            this.shadowRoot && n ? n(this._createVNode(), this.shadowRoot) : this.attachShadow({ mode: "open" })
    }
    connectedCallback() {
        ;(this._connected = !0), this._instance || this._resolveDef()
    }
    disconnectedCallback() {
        ;(this._connected = !1),
            Wr(() => {
                this._connected || (Cc(null, this.shadowRoot), (this._instance = null))
            })
    }
    _resolveDef() {
        if (this._resolved) return
        this._resolved = !0
        for (let n = 0; n < this.attributes.length; n++) this._setAttr(this.attributes[n].name)
        new MutationObserver((n) => {
            for (const i of n) this._setAttr(i.attributeName)
        }).observe(this, { attributes: !0 })
        const t = (n) => {
                const { props: i, styles: s } = n,
                    o = !$t(i),
                    l = i ? (o ? Object.keys(i) : i) : []
                let f
                if (o)
                    for (const d in this._props) {
                        const h = i[d]
                        ;(h === Number || (h && h.type === Number)) &&
                            ((this._props[d] = Ui(this._props[d])), ((f || (f = Object.create(null)))[d] = !0))
                    }
                this._numberProps = f
                for (const d of Object.keys(this)) d[0] !== "_" && this._setProp(d, this[d], !0, !1)
                for (const d of l.map(Pr))
                    Object.defineProperty(this, d, {
                        get() {
                            return this._getProp(d)
                        },
                        set(h) {
                            this._setProp(d, h)
                        },
                    })
                this._applyStyles(s), this._update()
            },
            r = this._def.__asyncLoader
        r ? r().then(t) : t(this._def)
    }
    _setAttr(t) {
        let r = this.getAttribute(t)
        this._numberProps && this._numberProps[t] && (r = Ui(r)), this._setProp(Pr(t), r, !1)
    }
    _getProp(t) {
        return this._props[t]
    }
    _setProp(t, r, n = !0, i = !0) {
        r !== this._props[t] &&
            ((this._props[t] = r),
            i && this._instance && this._update(),
            n &&
                (r === !0
                    ? this.setAttribute(Bn(t), "")
                    : typeof r == "string" || typeof r == "number"
                    ? this.setAttribute(Bn(t), r + "")
                    : r || this.removeAttribute(Bn(t))))
    }
    _update() {
        Cc(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const t = Ut(this._def, qe({}, this._props))
        return (
            this._instance ||
                (t.ce = (r) => {
                    ;(this._instance = r),
                        (r.isCE = !0),
                        (r.emit = (i, ...s) => {
                            this.dispatchEvent(new CustomEvent(i, { detail: s }))
                        })
                    let n = this
                    for (; (n = n && (n.parentNode || n.host)); )
                        if (n instanceof qu) {
                            r.parent = n._instance
                            break
                        }
                }),
            t
        )
    }
    _applyStyles(t) {
        t &&
            t.forEach((r) => {
                const n = document.createElement("style")
                ;(n.textContent = r), this.shadowRoot.appendChild(n)
            })
    }
}
function _A(e = "$style") {
    {
        const t = vi()
        if (!t) return Ce
        const r = t.type.__cssModules
        if (!r) return Ce
        const n = r[e]
        return n || Ce
    }
}
function wA(e) {
    const t = vi()
    if (!t) return
    const r = () => Tc(t.subTree, e(t.proxy))
    zg(r),
        je(() => {
            const n = new MutationObserver(r)
            n.observe(t.subTree.el.parentNode, { childList: !0 }), el(() => n.disconnect())
        })
}
function Tc(e, t) {
    if (e.shapeFlag & 128) {
        const r = e.suspense
        ;(e = r.activeBranch),
            r.pendingBranch &&
                !r.isHydrating &&
                r.effects.push(() => {
                    Tc(r.activeBranch, t)
                })
    }
    for (; e.component; ) e = e.component.subTree
    if (e.shapeFlag & 1 && e.el) jh(e.el, t)
    else if (e.type === Yt) e.children.forEach((r) => Tc(r, t))
    else if (e.type === Ms) {
        let { el: r, anchor: n } = e
        for (; r && (jh(r, t), r !== n); ) r = r.nextSibling
    }
}
function jh(e, t) {
    if (e.nodeType === 1) {
        const r = e.style
        for (const n in t) r.setProperty(`--${n}`, t[n])
    }
}
const Ei = "transition",
    ea = "animation",
    zu = (e, { slots: t }) => he(Ad, Im(e), t)
zu.displayName = "Transition"
const Om = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
    },
    AA = (zu.props = qe({}, Ad.props, Om)),
    bs = (e, t = []) => {
        $t(e) ? e.forEach((r) => r(...t)) : e && e(...t)
    },
    Kh = (e) => (e ? ($t(e) ? e.some((t) => t.length > 1) : e.length > 1) : !1)
function Im(e) {
    const t = {}
    for (const at in e) at in Om || (t[at] = e[at])
    if (e.css === !1) return t
    const {
            name: r = "v",
            type: n,
            duration: i,
            enterFromClass: s = `${r}-enter-from`,
            enterActiveClass: o = `${r}-enter-active`,
            enterToClass: l = `${r}-enter-to`,
            appearFromClass: f = s,
            appearActiveClass: d = o,
            appearToClass: h = l,
            leaveFromClass: y = `${r}-leave-from`,
            leaveActiveClass: E = `${r}-leave-active`,
            leaveToClass: T = `${r}-leave-to`,
        } = e,
        S = EA(i),
        N = S && S[0],
        P = S && S[1],
        {
            onBeforeEnter: M,
            onEnter: k,
            onEnterCancelled: F,
            onLeave: $,
            onLeaveCancelled: R,
            onBeforeAppear: W = M,
            onAppear: nt = k,
            onAppearCancelled: J = F,
        } = t,
        Q = (at, x, a) => {
            ki(at, x ? h : l), ki(at, x ? d : o), a && a()
        },
        ot = (at, x) => {
            ;(at._isLeaving = !1), ki(at, y), ki(at, T), ki(at, E), x && x()
        },
        it = (at) => (x, a) => {
            const c = at ? nt : k,
                m = () => Q(x, at, a)
            bs(c, [x, m]),
                Gh(() => {
                    ki(x, at ? f : s), Wn(x, at ? h : l), Kh(c) || Wh(x, n, N, m)
                })
        }
    return qe(t, {
        onBeforeEnter(at) {
            bs(M, [at]), Wn(at, s), Wn(at, o)
        },
        onBeforeAppear(at) {
            bs(W, [at]), Wn(at, f), Wn(at, d)
        },
        onEnter: it(!1),
        onAppear: it(!0),
        onLeave(at, x) {
            at._isLeaving = !0
            const a = () => ot(at, x)
            Wn(at, y),
                Pm(),
                Wn(at, E),
                Gh(() => {
                    !at._isLeaving || (ki(at, y), Wn(at, T), Kh($) || Wh(at, n, P, a))
                }),
                bs($, [at, a])
        },
        onEnterCancelled(at) {
            Q(at, !1), bs(F, [at])
        },
        onAppearCancelled(at) {
            Q(at, !0), bs(J, [at])
        },
        onLeaveCancelled(at) {
            ot(at), bs(R, [at])
        },
    })
}
function EA(e) {
    if (e == null) return null
    if (ze(e)) return [Af(e.enter), Af(e.leave)]
    {
        const t = Af(e)
        return [t, t]
    }
}
function Af(e) {
    return Ui(e)
}
function Wn(e, t) {
    t.split(/\s+/).forEach((r) => r && e.classList.add(r)), (e._vtc || (e._vtc = new Set())).add(t)
}
function ki(e, t) {
    t.split(/\s+/).forEach((n) => n && e.classList.remove(n))
    const { _vtc: r } = e
    r && (r.delete(t), r.size || (e._vtc = void 0))
}
function Gh(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e)
    })
}
let xA = 0
function Wh(e, t, r, n) {
    const i = (e._endId = ++xA),
        s = () => {
            i === e._endId && n()
        }
    if (r) return setTimeout(s, r)
    const { type: o, timeout: l, propCount: f } = Bm(e, t)
    if (!o) return n()
    const d = o + "end"
    let h = 0
    const y = () => {
            e.removeEventListener(d, E), s()
        },
        E = (T) => {
            T.target === e && ++h >= f && y()
        }
    setTimeout(() => {
        h < f && y()
    }, l + 1),
        e.addEventListener(d, E)
}
function Bm(e, t) {
    const r = window.getComputedStyle(e),
        n = (S) => (r[S] || "").split(", "),
        i = n(Ei + "Delay"),
        s = n(Ei + "Duration"),
        o = Yh(i, s),
        l = n(ea + "Delay"),
        f = n(ea + "Duration"),
        d = Yh(l, f)
    let h = null,
        y = 0,
        E = 0
    t === Ei
        ? o > 0 && ((h = Ei), (y = o), (E = s.length))
        : t === ea
        ? d > 0 && ((h = ea), (y = d), (E = f.length))
        : ((y = Math.max(o, d)), (h = y > 0 ? (o > d ? Ei : ea) : null), (E = h ? (h === Ei ? s.length : f.length) : 0))
    const T = h === Ei && /\b(transform|all)(,|$)/.test(r[Ei + "Property"])
    return { type: h, timeout: y, propCount: E, hasTransform: T }
}
function Yh(e, t) {
    for (; e.length < t.length; ) e = e.concat(e)
    return Math.max(...t.map((r, n) => Jh(r) + Jh(e[n])))
}
function Jh(e) {
    return Number(e.slice(0, -1).replace(",", ".")) * 1e3
}
function Pm() {
    return document.body.offsetHeight
}
const Rm = new WeakMap(),
    Lm = new WeakMap(),
    TA = {
        name: "TransitionGroup",
        props: qe({}, AA, { tag: String, moveClass: String }),
        setup(e, { slots: t }) {
            const r = vi(),
                n = wd()
            let i, s
            return (
                Vu(() => {
                    if (!i.length) return
                    const o = e.moveClass || `${e.name || "v"}-move`
                    if (!NA(i[0].el, r.vnode.el, o)) return
                    i.forEach(MA), i.forEach(SA)
                    const l = i.filter(kA)
                    Pm(),
                        l.forEach((f) => {
                            const d = f.el,
                                h = d.style
                            Wn(d, o), (h.transform = h.webkitTransform = h.transitionDuration = "")
                            const y = (d._moveCb = (E) => {
                                ;(E && E.target !== d) ||
                                    ((!E || /transform$/.test(E.propertyName)) &&
                                        (d.removeEventListener("transitionend", y), (d._moveCb = null), ki(d, o)))
                            })
                            d.addEventListener("transitionend", y)
                        })
                }),
                () => {
                    const o = Ae(e),
                        l = Im(o)
                    let f = o.tag || Yt
                    ;(i = s), (s = t.default ? $u(t.default()) : [])
                    for (let d = 0; d < s.length; d++) {
                        const h = s[d]
                        h.key != null && Ns(h, Ao(h, l, n, r))
                    }
                    if (i)
                        for (let d = 0; d < i.length; d++) {
                            const h = i[d]
                            Ns(h, Ao(h, l, n, r)), Rm.set(h, h.el.getBoundingClientRect())
                        }
                    return Ut(f, null, s)
                }
            )
        },
    },
    CA = TA
function MA(e) {
    const t = e.el
    t._moveCb && t._moveCb(), t._enterCb && t._enterCb()
}
function SA(e) {
    Lm.set(e, e.el.getBoundingClientRect())
}
function kA(e) {
    const t = Rm.get(e),
        r = Lm.get(e),
        n = t.left - r.left,
        i = t.top - r.top
    if (n || i) {
        const s = e.el.style
        return (s.transform = s.webkitTransform = `translate(${n}px,${i}px)`), (s.transitionDuration = "0s"), e
    }
}
function NA(e, t, r) {
    const n = e.cloneNode()
    e._vtc &&
        e._vtc.forEach((o) => {
            o.split(/\s+/).forEach((l) => l && n.classList.remove(l))
        }),
        r.split(/\s+/).forEach((o) => o && n.classList.add(o)),
        (n.style.display = "none")
    const i = t.nodeType === 1 ? t : t.parentNode
    i.appendChild(n)
    const { hasTransform: s } = Bm(n)
    return i.removeChild(n), s
}
const Ki = (e) => {
    const t = e.props["onUpdate:modelValue"] || !1
    return $t(t) ? (r) => mo(t, r) : t
}
function OA(e) {
    e.target.composing = !0
}
function Qh(e) {
    const t = e.target
    t.composing && ((t.composing = !1), t.dispatchEvent(new Event("input")))
}
const lu = {
        created(e, { modifiers: { lazy: t, trim: r, number: n } }, i) {
            e._assign = Ki(i)
            const s = n || (i.props && i.props.type === "number")
            Xn(e, t ? "change" : "input", (o) => {
                if (o.target.composing) return
                let l = e.value
                r && (l = l.trim()), s && (l = Ui(l)), e._assign(l)
            }),
                r &&
                    Xn(e, "change", () => {
                        e.value = e.value.trim()
                    }),
                t || (Xn(e, "compositionstart", OA), Xn(e, "compositionend", Qh), Xn(e, "change", Qh))
        },
        mounted(e, { value: t }) {
            e.value = t == null ? "" : t
        },
        beforeUpdate(e, { value: t, modifiers: { lazy: r, trim: n, number: i } }, s) {
            if (
                ((e._assign = Ki(s)),
                e.composing ||
                    (document.activeElement === e &&
                        e.type !== "range" &&
                        (r || (n && e.value.trim() === t) || ((i || e.type === "number") && Ui(e.value) === t))))
            )
                return
            const o = t == null ? "" : t
            e.value !== o && (e.value = o)
        },
    },
    ju = {
        deep: !0,
        created(e, t, r) {
            ;(e._assign = Ki(r)),
                Xn(e, "change", () => {
                    const n = e._modelValue,
                        i = To(e),
                        s = e.checked,
                        o = e._assign
                    if ($t(n)) {
                        const l = Su(n, i),
                            f = l !== -1
                        if (s && !f) o(n.concat(i))
                        else if (!s && f) {
                            const d = [...n]
                            d.splice(l, 1), o(d)
                        }
                    } else if (Fs(n)) {
                        const l = new Set(n)
                        s ? l.add(i) : l.delete(i), o(l)
                    } else o(Dm(e, s))
                })
        },
        mounted: Xh,
        beforeUpdate(e, t, r) {
            ;(e._assign = Ki(r)), Xh(e, t, r)
        },
    }
function Xh(e, { value: t, oldValue: r }, n) {
    ;(e._modelValue = t),
        $t(t) ? (e.checked = Su(t, n.props.value) > -1) : Fs(t) ? (e.checked = t.has(n.props.value)) : t !== r && (e.checked = Vi(t, Dm(e, !0)))
}
const Ku = {
        created(e, { value: t }, r) {
            ;(e.checked = Vi(t, r.props.value)),
                (e._assign = Ki(r)),
                Xn(e, "change", () => {
                    e._assign(To(e))
                })
        },
        beforeUpdate(e, { value: t, oldValue: r }, n) {
            ;(e._assign = Ki(n)), t !== r && (e.checked = Vi(t, n.props.value))
        },
    },
    kd = {
        deep: !0,
        created(e, { value: t, modifiers: { number: r } }, n) {
            const i = Fs(t)
            Xn(e, "change", () => {
                const s = Array.prototype.filter.call(e.options, (o) => o.selected).map((o) => (r ? Ui(To(o)) : To(o)))
                e._assign(e.multiple ? (i ? new Set(s) : s) : s[0])
            }),
                (e._assign = Ki(n))
        },
        mounted(e, { value: t }) {
            Zh(e, t)
        },
        beforeUpdate(e, t, r) {
            e._assign = Ki(r)
        },
        updated(e, { value: t }) {
            Zh(e, t)
        },
    }
function Zh(e, t) {
    const r = e.multiple
    if (!(r && !$t(t) && !Fs(t))) {
        for (let n = 0, i = e.options.length; n < i; n++) {
            const s = e.options[n],
                o = To(s)
            if (r) $t(t) ? (s.selected = Su(t, o) > -1) : (s.selected = t.has(o))
            else if (Vi(To(s), t)) {
                e.selectedIndex !== n && (e.selectedIndex = n)
                return
            }
        }
        !r && e.selectedIndex !== -1 && (e.selectedIndex = -1)
    }
}
function To(e) {
    return "_value" in e ? e._value : e.value
}
function Dm(e, t) {
    const r = t ? "_trueValue" : "_falseValue"
    return r in e ? e[r] : t
}
const $m = {
    created(e, t, r) {
        Al(e, t, r, null, "created")
    },
    mounted(e, t, r) {
        Al(e, t, r, null, "mounted")
    },
    beforeUpdate(e, t, r, n) {
        Al(e, t, r, n, "beforeUpdate")
    },
    updated(e, t, r, n) {
        Al(e, t, r, n, "updated")
    },
}
function Fm(e, t) {
    switch (e) {
        case "SELECT":
            return kd
        case "TEXTAREA":
            return lu
        default:
            switch (t) {
                case "checkbox":
                    return ju
                case "radio":
                    return Ku
                default:
                    return lu
            }
    }
}
function Al(e, t, r, n, i) {
    const o = Fm(e.tagName, r.props && r.props.type)[i]
    o && o(e, t, r, n)
}
function IA() {
    ;(lu.getSSRProps = ({ value: e }) => ({ value: e })),
        (Ku.getSSRProps = ({ value: e }, t) => {
            if (t.props && Vi(t.props.value, e)) return { checked: !0 }
        }),
        (ju.getSSRProps = ({ value: e }, t) => {
            if ($t(e)) {
                if (t.props && Su(e, t.props.value) > -1) return { checked: !0 }
            } else if (Fs(e)) {
                if (t.props && e.has(t.props.value)) return { checked: !0 }
            } else if (e) return { checked: !0 }
        }),
        ($m.getSSRProps = (e, t) => {
            if (typeof t.type != "string") return
            const r = Fm(t.type.toUpperCase(), t.props && t.props.type)
            if (r.getSSRProps) return r.getSSRProps(e, t)
        })
}
const BA = ["ctrl", "shift", "alt", "meta"],
    PA = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, t) => BA.some((r) => e[`${r}Key`] && !t.includes(r)),
    },
    Gu =
        (e, t) =>
        (r, ...n) => {
            for (let i = 0; i < t.length; i++) {
                const s = PA[t[i]]
                if (s && s(r, t)) return
            }
            return e(r, ...n)
        },
    RA = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" },
    LA = (e, t) => (r) => {
        if (!("key" in r)) return
        const n = Bn(r.key)
        if (t.some((i) => i === n || RA[i] === n)) return e(r)
    },
    uu = {
        beforeMount(e, { value: t }, { transition: r }) {
            ;(e._vod = e.style.display === "none" ? "" : e.style.display), r && t ? r.beforeEnter(e) : ra(e, t)
        },
        mounted(e, { value: t }, { transition: r }) {
            r && t && r.enter(e)
        },
        updated(e, { value: t, oldValue: r }, { transition: n }) {
            !t != !r &&
                (n
                    ? t
                        ? (n.beforeEnter(e), ra(e, !0), n.enter(e))
                        : n.leave(e, () => {
                              ra(e, !1)
                          })
                    : ra(e, t))
        },
        beforeUnmount(e, { value: t }) {
            ra(e, t)
        },
    }
function ra(e, t) {
    e.style.display = t ? e._vod : "none"
}
function DA() {
    uu.getSSRProps = ({ value: e }) => {
        if (!e) return { style: { display: "none" } }
    }
}
const Vm = qe({ patchProp: mA }, eA)
let Ea,
    t0 = !1
function Um() {
    return Ea || (Ea = dm(Vm))
}
function Hm() {
    return (Ea = t0 ? Ea : hm(Vm)), (t0 = !0), Ea
}
const Cc = (...e) => {
        Um().render(...e)
    },
    qm = (...e) => {
        Hm().hydrate(...e)
    },
    zm = (...e) => {
        const t = Um().createApp(...e),
            { mount: r } = t
        return (
            (t.mount = (n) => {
                const i = jm(n)
                if (!i) return
                const s = t._component
                !fe(s) && !s.render && !s.template && (s.template = i.innerHTML), (i.innerHTML = "")
                const o = r(i, !1, i instanceof SVGElement)
                return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
            }),
            t
        )
    },
    $A = (...e) => {
        const t = Hm().createApp(...e),
            { mount: r } = t
        return (
            (t.mount = (n) => {
                const i = jm(n)
                if (i) return r(i, !0, i instanceof SVGElement)
            }),
            t
        )
    }
function jm(e) {
    return Fe(e) ? document.querySelector(e) : e
}
let e0 = !1
const FA = () => {
        e0 || ((e0 = !0), IA(), DA())
    },
    VA = () => {}
var UA = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            compile: VA,
            EffectScope: ld,
            ReactiveEffect: Qa,
            customRef: S_,
            effect: Qy,
            effectScope: Ky,
            getCurrentScope: Gy,
            isProxy: dd,
            isReactive: Di,
            isReadonly: wo,
            isRef: Re,
            isShallow: tu,
            markRaw: Oa,
            onScopeDispose: Wy,
            proxyRefs: gd,
            reactive: Ze,
            readonly: cd,
            ref: Ht,
            shallowReactive: Ng,
            shallowReadonly: E_,
            shallowRef: Og,
            stop: Xy,
            toRaw: Ae,
            toRef: L,
            toRefs: k_,
            triggerRef: T_,
            unref: V,
            camelize: Pr,
            capitalize: Ja,
            normalizeClass: wt,
            normalizeProps: Ga,
            normalizeStyle: hn,
            toDisplayString: jt,
            toHandlerKey: va,
            BaseTransition: Ad,
            Comment: or,
            Fragment: Yt,
            KeepAlive: sw,
            Static: Ms,
            Suspense: Hg,
            Teleport: gm,
            Text: Eo,
            callWithAsyncErrorHandling: Br,
            callWithErrorHandling: Pn,
            cloneVNode: Fn,
            compatUtils: Zw,
            computed: K,
            createBlock: kt,
            createCommentVNode: Dt,
            createElementBlock: ft,
            createElementVNode: xt,
            createHydrationRenderer: hm,
            createPropsRestProxy: jw,
            createRenderer: dm,
            createSlots: rm,
            createStaticVNode: Nw,
            createTextVNode: ve,
            createVNode: Ut,
            defineAsyncComponent: nw,
            defineComponent: bt,
            defineEmits: Uw,
            defineExpose: Hw,
            defineProps: Vw,
            get devtools() {
                return ro
            },
            getCurrentInstance: vi,
            getTransitionRawChildren: $u,
            guardReactiveProps: Ho,
            h: he,
            handleError: Hs,
            initCustomFormatter: Ww,
            inject: Ie,
            isMemoSame: Mm,
            isRuntimeOnly: Rw,
            isVNode: zi,
            mergeDefaults: zw,
            mergeProps: ce,
            nextTick: Wr,
            onActivated: tl,
            onBeforeMount: Yg,
            onBeforeUnmount: qs,
            onBeforeUpdate: Jg,
            onDeactivated: Gg,
            onErrorCaptured: tm,
            onMounted: je,
            onRenderTracked: Zg,
            onRenderTriggered: Xg,
            onServerPrefetch: Qg,
            onUnmounted: el,
            onUpdated: Vu,
            openBlock: Y,
            popScopeId: H_,
            provide: cn,
            pushScopeId: U_,
            queuePostFlushCb: bd,
            registerRuntimeCompiler: Pw,
            renderList: Pe,
            renderSlot: mt,
            resolveComponent: ui,
            resolveDirective: lw,
            resolveDynamicComponent: Kt,
            resolveFilter: Xw,
            resolveTransitionHooks: Ao,
            setBlockTracking: _c,
            setDevtoolsHook: Fg,
            setTransitionHooks: Ns,
            ssrContextKey: Cm,
            ssrUtils: Qw,
            toHandlers: uw,
            transformVNodeArgs: Sw,
            useAttrs: Sd,
            useSSRContext: Gw,
            useSlots: Qi,
            useTransitionState: wd,
            version: Sm,
            warn: Bg,
            watch: Oe,
            watchEffect: Z_,
            watchPostEffect: zg,
            watchSyncEffect: tw,
            withAsyncContext: Kw,
            withCtx: Ct,
            withDefaults: qw,
            withDirectives: qi,
            withMemo: Yw,
            withScopeId: q_,
            Transition: zu,
            TransitionGroup: CA,
            VueElement: qu,
            createApp: zm,
            createSSRApp: $A,
            defineCustomElement: Nm,
            defineSSRCustomElement: bA,
            hydrate: qm,
            initDirectivesForSSR: FA,
            render: Cc,
            useCssModule: _A,
            useCssVars: wA,
            vModelCheckbox: ju,
            vModelDynamic: $m,
            vModelRadio: Ku,
            vModelSelect: kd,
            vModelText: lu,
            vShow: uu,
            withKeys: LA,
            withModifiers: Gu,
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
)
/*!
 * vue-router v4.1.5
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */ const no = typeof window != "undefined"
function HA(e) {
    return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const Me = Object.assign
function Ef(e, t) {
    const r = {}
    for (const n in t) {
        const i = t[n]
        r[n] = pn(i) ? i.map(e) : e(i)
    }
    return r
}
const xa = () => {},
    pn = Array.isArray,
    qA = /\/$/,
    zA = (e) => e.replace(qA, "")
function xf(e, t, r = "/") {
    let n,
        i = {},
        s = "",
        o = ""
    const l = t.indexOf("#")
    let f = t.indexOf("?")
    return (
        l < f && l >= 0 && (f = -1),
        f > -1 && ((n = t.slice(0, f)), (s = t.slice(f + 1, l > -1 ? l : t.length)), (i = e(s))),
        l > -1 && ((n = n || t.slice(0, l)), (o = t.slice(l, t.length))),
        (n = WA(n != null ? n : t, r)),
        { fullPath: n + (s && "?") + s + o, path: n, query: i, hash: o }
    )
}
function jA(e, t) {
    const r = t.query ? e(t.query) : ""
    return t.path + (r && "?") + r + (t.hash || "")
}
function r0(e, t) {
    return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}
function KA(e, t, r) {
    const n = t.matched.length - 1,
        i = r.matched.length - 1
    return n > -1 && n === i && Co(t.matched[n], r.matched[i]) && Km(t.params, r.params) && e(t.query) === e(r.query) && t.hash === r.hash
}
function Co(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t)
}
function Km(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1
    for (const r in e) if (!GA(e[r], t[r])) return !1
    return !0
}
function GA(e, t) {
    return pn(e) ? n0(e, t) : pn(t) ? n0(t, e) : e === t
}
function n0(e, t) {
    return pn(t) ? e.length === t.length && e.every((r, n) => r === t[n]) : e.length === 1 && e[0] === t
}
function WA(e, t) {
    if (e.startsWith("/")) return e
    if (!e) return t
    const r = t.split("/"),
        n = e.split("/")
    let i = r.length - 1,
        s,
        o
    for (s = 0; s < n.length; s++)
        if (((o = n[s]), o !== "."))
            if (o === "..") i > 1 && i--
            else break
    return r.slice(0, i).join("/") + "/" + n.slice(s - (s === n.length ? 1 : 0)).join("/")
}
var La
;(function (e) {
    ;(e.pop = "pop"), (e.push = "push")
})(La || (La = {}))
var Ta
;(function (e) {
    ;(e.back = "back"), (e.forward = "forward"), (e.unknown = "")
})(Ta || (Ta = {}))
function YA(e) {
    if (!e)
        if (no) {
            const t = document.querySelector("base")
            ;(e = (t && t.getAttribute("href")) || "/"), (e = e.replace(/^\w+:\/\/[^\/]+/, ""))
        } else e = "/"
    return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), zA(e)
}
const JA = /^[^#]+#/
function QA(e, t) {
    return e.replace(JA, "#") + t
}
function XA(e, t) {
    const r = document.documentElement.getBoundingClientRect(),
        n = e.getBoundingClientRect()
    return { behavior: t.behavior, left: n.left - r.left - (t.left || 0), top: n.top - r.top - (t.top || 0) }
}
const Wu = () => ({ left: window.pageXOffset, top: window.pageYOffset })
function ZA(e) {
    let t
    if ("el" in e) {
        const r = e.el,
            n = typeof r == "string" && r.startsWith("#"),
            i = typeof r == "string" ? (n ? document.getElementById(r.slice(1)) : document.querySelector(r)) : r
        if (!i) return
        t = XA(i, e)
    } else t = e
    "scrollBehavior" in document.documentElement.style
        ? window.scrollTo(t)
        : window.scrollTo(t.left != null ? t.left : window.pageXOffset, t.top != null ? t.top : window.pageYOffset)
}
function i0(e, t) {
    return (history.state ? history.state.position - t : -1) + e
}
const Mc = new Map()
function t2(e, t) {
    Mc.set(e, t)
}
function e2(e) {
    const t = Mc.get(e)
    return Mc.delete(e), t
}
let r2 = () => location.protocol + "//" + location.host
function Gm(e, t) {
    const { pathname: r, search: n, hash: i } = t,
        s = e.indexOf("#")
    if (s > -1) {
        let l = i.includes(e.slice(s)) ? e.slice(s).length : 1,
            f = i.slice(l)
        return f[0] !== "/" && (f = "/" + f), r0(f, "")
    }
    return r0(r, e) + n + i
}
function n2(e, t, r, n) {
    let i = [],
        s = [],
        o = null
    const l = ({ state: E }) => {
        const T = Gm(e, location),
            S = r.value,
            N = t.value
        let P = 0
        if (E) {
            if (((r.value = T), (t.value = E), o && o === S)) {
                o = null
                return
            }
            P = N ? E.position - N.position : 0
        } else n(T)
        i.forEach((M) => {
            M(r.value, S, { delta: P, type: La.pop, direction: P ? (P > 0 ? Ta.forward : Ta.back) : Ta.unknown })
        })
    }
    function f() {
        o = r.value
    }
    function d(E) {
        i.push(E)
        const T = () => {
            const S = i.indexOf(E)
            S > -1 && i.splice(S, 1)
        }
        return s.push(T), T
    }
    function h() {
        const { history: E } = window
        !E.state || E.replaceState(Me({}, E.state, { scroll: Wu() }), "")
    }
    function y() {
        for (const E of s) E()
        ;(s = []), window.removeEventListener("popstate", l), window.removeEventListener("beforeunload", h)
    }
    return window.addEventListener("popstate", l), window.addEventListener("beforeunload", h), { pauseListeners: f, listen: d, destroy: y }
}
function s0(e, t, r, n = !1, i = !1) {
    return { back: e, current: t, forward: r, replaced: n, position: window.history.length, scroll: i ? Wu() : null }
}
function i2(e) {
    const { history: t, location: r } = window,
        n = { value: Gm(e, r) },
        i = { value: t.state }
    i.value || s(n.value, { back: null, current: n.value, forward: null, position: t.length - 1, replaced: !0, scroll: null }, !0)
    function s(f, d, h) {
        const y = e.indexOf("#"),
            E = y > -1 ? (r.host && document.querySelector("base") ? e : e.slice(y)) + f : r2() + e + f
        try {
            t[h ? "replaceState" : "pushState"](d, "", E), (i.value = d)
        } catch (T) {
            console.error(T), r[h ? "replace" : "assign"](E)
        }
    }
    function o(f, d) {
        const h = Me({}, t.state, s0(i.value.back, f, i.value.forward, !0), d, { position: i.value.position })
        s(f, h, !0), (n.value = f)
    }
    function l(f, d) {
        const h = Me({}, i.value, t.state, { forward: f, scroll: Wu() })
        s(h.current, h, !0)
        const y = Me({}, s0(n.value, f, null), { position: h.position + 1 }, d)
        s(f, y, !1), (n.value = f)
    }
    return { location: n, state: i, push: l, replace: o }
}
function s2(e) {
    e = YA(e)
    const t = i2(e),
        r = n2(e, t.state, t.location, t.replace)
    function n(s, o = !0) {
        o || r.pauseListeners(), history.go(s)
    }
    const i = Me({ location: "", base: e, go: n, createHref: QA.bind(null, e) }, t, r)
    return (
        Object.defineProperty(i, "location", { enumerable: !0, get: () => t.location.value }),
        Object.defineProperty(i, "state", { enumerable: !0, get: () => t.state.value }),
        i
    )
}
function o2(e) {
    return typeof e == "string" || (e && typeof e == "object")
}
function Wm(e) {
    return typeof e == "string" || typeof e == "symbol"
}
const xi = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 },
    Ym = Symbol("")
var o0
;(function (e) {
    ;(e[(e.aborted = 4)] = "aborted"), (e[(e.cancelled = 8)] = "cancelled"), (e[(e.duplicated = 16)] = "duplicated")
})(o0 || (o0 = {}))
function Mo(e, t) {
    return Me(new Error(), { type: e, [Ym]: !0 }, t)
}
function Gn(e, t) {
    return e instanceof Error && Ym in e && (t == null || !!(e.type & t))
}
const a0 = "[^/]+?",
    a2 = { sensitive: !1, strict: !1, start: !0, end: !0 },
    l2 = /[.+*?^${}()[\]/\\]/g
function u2(e, t) {
    const r = Me({}, a2, t),
        n = []
    let i = r.start ? "^" : ""
    const s = []
    for (const d of e) {
        const h = d.length ? [] : [90]
        r.strict && !d.length && (i += "/")
        for (let y = 0; y < d.length; y++) {
            const E = d[y]
            let T = 40 + (r.sensitive ? 0.25 : 0)
            if (E.type === 0) y || (i += "/"), (i += E.value.replace(l2, "\\$&")), (T += 40)
            else if (E.type === 1) {
                const { value: S, repeatable: N, optional: P, regexp: M } = E
                s.push({ name: S, repeatable: N, optional: P })
                const k = M || a0
                if (k !== a0) {
                    T += 10
                    try {
                        new RegExp(`(${k})`)
                    } catch ($) {
                        throw new Error(`Invalid custom RegExp for param "${S}" (${k}): ` + $.message)
                    }
                }
                let F = N ? `((?:${k})(?:/(?:${k}))*)` : `(${k})`
                y || (F = P && d.length < 2 ? `(?:/${F})` : "/" + F),
                    P && (F += "?"),
                    (i += F),
                    (T += 20),
                    P && (T += -8),
                    N && (T += -20),
                    k === ".*" && (T += -50)
            }
            h.push(T)
        }
        n.push(h)
    }
    if (r.strict && r.end) {
        const d = n.length - 1
        n[d][n[d].length - 1] += 0.7000000000000001
    }
    r.strict || (i += "/?"), r.end ? (i += "$") : r.strict && (i += "(?:/|$)")
    const o = new RegExp(i, r.sensitive ? "" : "i")
    function l(d) {
        const h = d.match(o),
            y = {}
        if (!h) return null
        for (let E = 1; E < h.length; E++) {
            const T = h[E] || "",
                S = s[E - 1]
            y[S.name] = T && S.repeatable ? T.split("/") : T
        }
        return y
    }
    function f(d) {
        let h = "",
            y = !1
        for (const E of e) {
            ;(!y || !h.endsWith("/")) && (h += "/"), (y = !1)
            for (const T of E)
                if (T.type === 0) h += T.value
                else if (T.type === 1) {
                    const { value: S, repeatable: N, optional: P } = T,
                        M = S in d ? d[S] : ""
                    if (pn(M) && !N) throw new Error(`Provided param "${S}" is an array but it is not repeatable (* or + modifiers)`)
                    const k = pn(M) ? M.join("/") : M
                    if (!k)
                        if (P) E.length < 2 && (h.endsWith("/") ? (h = h.slice(0, -1)) : (y = !0))
                        else throw new Error(`Missing required param "${S}"`)
                    h += k
                }
        }
        return h || "/"
    }
    return { re: o, score: n, keys: s, parse: l, stringify: f }
}
function f2(e, t) {
    let r = 0
    for (; r < e.length && r < t.length; ) {
        const n = t[r] - e[r]
        if (n) return n
        r++
    }
    return e.length < t.length
        ? e.length === 1 && e[0] === 40 + 40
            ? -1
            : 1
        : e.length > t.length
        ? t.length === 1 && t[0] === 40 + 40
            ? 1
            : -1
        : 0
}
function c2(e, t) {
    let r = 0
    const n = e.score,
        i = t.score
    for (; r < n.length && r < i.length; ) {
        const s = f2(n[r], i[r])
        if (s) return s
        r++
    }
    if (Math.abs(i.length - n.length) === 1) {
        if (l0(n)) return 1
        if (l0(i)) return -1
    }
    return i.length - n.length
}
function l0(e) {
    const t = e[e.length - 1]
    return e.length > 0 && t[t.length - 1] < 0
}
const d2 = { type: 0, value: "" },
    h2 = /[a-zA-Z0-9_]/
function p2(e) {
    if (!e) return [[]]
    if (e === "/") return [[d2]]
    if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`)
    function t(T) {
        throw new Error(`ERR (${r})/"${d}": ${T}`)
    }
    let r = 0,
        n = r
    const i = []
    let s
    function o() {
        s && i.push(s), (s = [])
    }
    let l = 0,
        f,
        d = "",
        h = ""
    function y() {
        !d ||
            (r === 0
                ? s.push({ type: 0, value: d })
                : r === 1 || r === 2 || r === 3
                ? (s.length > 1 && (f === "*" || f === "+") && t(`A repeatable param (${d}) must be alone in its segment. eg: '/:ids+.`),
                  s.push({ type: 1, value: d, regexp: h, repeatable: f === "*" || f === "+", optional: f === "*" || f === "?" }))
                : t("Invalid state to consume buffer"),
            (d = ""))
    }
    function E() {
        d += f
    }
    for (; l < e.length; ) {
        if (((f = e[l++]), f === "\\" && r !== 2)) {
            ;(n = r), (r = 4)
            continue
        }
        switch (r) {
            case 0:
                f === "/" ? (d && y(), o()) : f === ":" ? (y(), (r = 1)) : E()
                break
            case 4:
                E(), (r = n)
                break
            case 1:
                f === "(" ? (r = 2) : h2.test(f) ? E() : (y(), (r = 0), f !== "*" && f !== "?" && f !== "+" && l--)
                break
            case 2:
                f === ")" ? (h[h.length - 1] == "\\" ? (h = h.slice(0, -1) + f) : (r = 3)) : (h += f)
                break
            case 3:
                y(), (r = 0), f !== "*" && f !== "?" && f !== "+" && l--, (h = "")
                break
            default:
                t("Unknown state")
                break
        }
    }
    return r === 2 && t(`Unfinished custom RegExp for param "${d}"`), y(), o(), i
}
function g2(e, t, r) {
    const n = u2(p2(e.path), r),
        i = Me(n, { record: e, parent: t, children: [], alias: [] })
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i), i
}
function m2(e, t) {
    const r = [],
        n = new Map()
    t = c0({ strict: !1, end: !0, sensitive: !1 }, t)
    function i(h) {
        return n.get(h)
    }
    function s(h, y, E) {
        const T = !E,
            S = v2(h)
        S.aliasOf = E && E.record
        const N = c0(t, h),
            P = [S]
        if ("alias" in h) {
            const F = typeof h.alias == "string" ? [h.alias] : h.alias
            for (const $ of F) P.push(Me({}, S, { components: E ? E.record.components : S.components, path: $, aliasOf: E ? E.record : S }))
        }
        let M, k
        for (const F of P) {
            const { path: $ } = F
            if (y && $[0] !== "/") {
                const R = y.record.path,
                    W = R[R.length - 1] === "/" ? "" : "/"
                F.path = y.record.path + ($ && W + $)
            }
            if (
                ((M = g2(F, y, N)),
                E ? E.alias.push(M) : ((k = k || M), k !== M && k.alias.push(M), T && h.name && !f0(M) && o(h.name)),
                S.children)
            ) {
                const R = S.children
                for (let W = 0; W < R.length; W++) s(R[W], M, E && E.children[W])
            }
            ;(E = E || M), f(M)
        }
        return k
            ? () => {
                  o(k)
              }
            : xa
    }
    function o(h) {
        if (Wm(h)) {
            const y = n.get(h)
            y && (n.delete(h), r.splice(r.indexOf(y), 1), y.children.forEach(o), y.alias.forEach(o))
        } else {
            const y = r.indexOf(h)
            y > -1 && (r.splice(y, 1), h.record.name && n.delete(h.record.name), h.children.forEach(o), h.alias.forEach(o))
        }
    }
    function l() {
        return r
    }
    function f(h) {
        let y = 0
        for (; y < r.length && c2(h, r[y]) >= 0 && (h.record.path !== r[y].record.path || !Jm(h, r[y])); ) y++
        r.splice(y, 0, h), h.record.name && !f0(h) && n.set(h.record.name, h)
    }
    function d(h, y) {
        let E,
            T = {},
            S,
            N
        if ("name" in h && h.name) {
            if (((E = n.get(h.name)), !E)) throw Mo(1, { location: h })
            ;(N = E.record.name),
                (T = Me(
                    u0(
                        y.params,
                        E.keys.filter((k) => !k.optional).map((k) => k.name)
                    ),
                    h.params &&
                        u0(
                            h.params,
                            E.keys.map((k) => k.name)
                        )
                )),
                (S = E.stringify(T))
        } else if ("path" in h) (S = h.path), (E = r.find((k) => k.re.test(S))), E && ((T = E.parse(S)), (N = E.record.name))
        else {
            if (((E = y.name ? n.get(y.name) : r.find((k) => k.re.test(y.path))), !E)) throw Mo(1, { location: h, currentLocation: y })
            ;(N = E.record.name), (T = Me({}, y.params, h.params)), (S = E.stringify(T))
        }
        const P = []
        let M = E
        for (; M; ) P.unshift(M.record), (M = M.parent)
        return { name: N, path: S, params: T, matched: P, meta: y2(P) }
    }
    return e.forEach((h) => s(h)), { addRoute: s, resolve: d, removeRoute: o, getRoutes: l, getRecordMatcher: i }
}
function u0(e, t) {
    const r = {}
    for (const n of t) n in e && (r[n] = e[n])
    return r
}
function v2(e) {
    return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: b2(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: "components" in e ? e.components || null : e.component && { default: e.component },
    }
}
function b2(e) {
    const t = {},
        r = e.props || !1
    if ("component" in e) t.default = r
    else for (const n in e.components) t[n] = typeof r == "boolean" ? r : r[n]
    return t
}
function f0(e) {
    for (; e; ) {
        if (e.record.aliasOf) return !0
        e = e.parent
    }
    return !1
}
function y2(e) {
    return e.reduce((t, r) => Me(t, r.meta), {})
}
function c0(e, t) {
    const r = {}
    for (const n in e) r[n] = n in t ? t[n] : e[n]
    return r
}
function Jm(e, t) {
    return t.children.some((r) => r === e || Jm(e, r))
}
const Qm = /#/g,
    _2 = /&/g,
    w2 = /\//g,
    A2 = /=/g,
    E2 = /\?/g,
    Xm = /\+/g,
    x2 = /%5B/g,
    T2 = /%5D/g,
    Zm = /%5E/g,
    C2 = /%60/g,
    tv = /%7B/g,
    M2 = /%7C/g,
    ev = /%7D/g,
    S2 = /%20/g
function Nd(e) {
    return encodeURI("" + e)
        .replace(M2, "|")
        .replace(x2, "[")
        .replace(T2, "]")
}
function k2(e) {
    return Nd(e).replace(tv, "{").replace(ev, "}").replace(Zm, "^")
}
function Sc(e) {
    return Nd(e)
        .replace(Xm, "%2B")
        .replace(S2, "+")
        .replace(Qm, "%23")
        .replace(_2, "%26")
        .replace(C2, "`")
        .replace(tv, "{")
        .replace(ev, "}")
        .replace(Zm, "^")
}
function N2(e) {
    return Sc(e).replace(A2, "%3D")
}
function O2(e) {
    return Nd(e).replace(Qm, "%23").replace(E2, "%3F")
}
function I2(e) {
    return e == null ? "" : O2(e).replace(w2, "%2F")
}
function fu(e) {
    try {
        return decodeURIComponent("" + e)
    } catch {}
    return "" + e
}
function B2(e) {
    const t = {}
    if (e === "" || e === "?") return t
    const n = (e[0] === "?" ? e.slice(1) : e).split("&")
    for (let i = 0; i < n.length; ++i) {
        const s = n[i].replace(Xm, " "),
            o = s.indexOf("="),
            l = fu(o < 0 ? s : s.slice(0, o)),
            f = o < 0 ? null : fu(s.slice(o + 1))
        if (l in t) {
            let d = t[l]
            pn(d) || (d = t[l] = [d]), d.push(f)
        } else t[l] = f
    }
    return t
}
function d0(e) {
    let t = ""
    for (let r in e) {
        const n = e[r]
        if (((r = N2(r)), n == null)) {
            n !== void 0 && (t += (t.length ? "&" : "") + r)
            continue
        }
        ;(pn(n) ? n.map((s) => s && Sc(s)) : [n && Sc(n)]).forEach((s) => {
            s !== void 0 && ((t += (t.length ? "&" : "") + r), s != null && (t += "=" + s))
        })
    }
    return t
}
function P2(e) {
    const t = {}
    for (const r in e) {
        const n = e[r]
        n !== void 0 && (t[r] = pn(n) ? n.map((i) => (i == null ? null : "" + i)) : n == null ? n : "" + n)
    }
    return t
}
const R2 = Symbol(""),
    h0 = Symbol(""),
    Od = Symbol(""),
    Id = Symbol(""),
    kc = Symbol("")
function na() {
    let e = []
    function t(n) {
        return (
            e.push(n),
            () => {
                const i = e.indexOf(n)
                i > -1 && e.splice(i, 1)
            }
        )
    }
    function r() {
        e = []
    }
    return { add: t, list: () => e, reset: r }
}
function Oi(e, t, r, n, i) {
    const s = n && (n.enterCallbacks[i] = n.enterCallbacks[i] || [])
    return () =>
        new Promise((o, l) => {
            const f = (y) => {
                    y === !1
                        ? l(Mo(4, { from: r, to: t }))
                        : y instanceof Error
                        ? l(y)
                        : o2(y)
                        ? l(Mo(2, { from: t, to: y }))
                        : (s && n.enterCallbacks[i] === s && typeof y == "function" && s.push(y), o())
                },
                d = e.call(n && n.instances[i], t, r, f)
            let h = Promise.resolve(d)
            e.length < 3 && (h = h.then(f)), h.catch((y) => l(y))
        })
}
function Tf(e, t, r, n) {
    const i = []
    for (const s of e)
        for (const o in s.components) {
            let l = s.components[o]
            if (!(t !== "beforeRouteEnter" && !s.instances[o]))
                if (L2(l)) {
                    const d = (l.__vccOpts || l)[t]
                    d && i.push(Oi(d, r, n, s, o))
                } else {
                    let f = l()
                    i.push(() =>
                        f.then((d) => {
                            if (!d) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`))
                            const h = HA(d) ? d.default : d
                            s.components[o] = h
                            const E = (h.__vccOpts || h)[t]
                            return E && Oi(E, r, n, s, o)()
                        })
                    )
                }
        }
    return i
}
function L2(e) {
    return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}
function p0(e) {
    const t = Ie(Od),
        r = Ie(Id),
        n = K(() => t.resolve(V(e.to))),
        i = K(() => {
            const { matched: f } = n.value,
                { length: d } = f,
                h = f[d - 1],
                y = r.matched
            if (!h || !y.length) return -1
            const E = y.findIndex(Co.bind(null, h))
            if (E > -1) return E
            const T = g0(f[d - 2])
            return d > 1 && g0(h) === T && y[y.length - 1].path !== T ? y.findIndex(Co.bind(null, f[d - 2])) : E
        }),
        s = K(() => i.value > -1 && V2(r.params, n.value.params)),
        o = K(() => i.value > -1 && i.value === r.matched.length - 1 && Km(r.params, n.value.params))
    function l(f = {}) {
        return F2(f) ? t[V(e.replace) ? "replace" : "push"](V(e.to)).catch(xa) : Promise.resolve()
    }
    return { route: n, href: K(() => n.value.href), isActive: s, isExactActive: o, navigate: l }
}
const D2 = bt({
        name: "RouterLink",
        compatConfig: { MODE: 3 },
        props: {
            to: { type: [String, Object], required: !0 },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: { type: String, default: "page" },
        },
        useLink: p0,
        setup(e, { slots: t }) {
            const r = Ze(p0(e)),
                { options: n } = Ie(Od),
                i = K(() => ({
                    [m0(e.activeClass, n.linkActiveClass, "router-link-active")]: r.isActive,
                    [m0(e.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive,
                }))
            return () => {
                const s = t.default && t.default(r)
                return e.custom
                    ? s
                    : he(
                          "a",
                          { "aria-current": r.isExactActive ? e.ariaCurrentValue : null, href: r.href, onClick: r.navigate, class: i.value },
                          s
                      )
            }
        },
    }),
    $2 = D2
function F2(e) {
    if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
            const t = e.currentTarget.getAttribute("target")
            if (/\b_blank\b/i.test(t)) return
        }
        return e.preventDefault && e.preventDefault(), !0
    }
}
function V2(e, t) {
    for (const r in t) {
        const n = t[r],
            i = e[r]
        if (typeof n == "string") {
            if (n !== i) return !1
        } else if (!pn(i) || i.length !== n.length || n.some((s, o) => s !== i[o])) return !1
    }
    return !0
}
function g0(e) {
    return e ? (e.aliasOf ? e.aliasOf.path : e.path) : ""
}
const m0 = (e, t, r) => (e != null ? e : t != null ? t : r),
    U2 = bt({
        name: "RouterView",
        inheritAttrs: !1,
        props: { name: { type: String, default: "default" }, route: Object },
        compatConfig: { MODE: 3 },
        setup(e, { attrs: t, slots: r }) {
            const n = Ie(kc),
                i = K(() => e.route || n.value),
                s = Ie(h0, 0),
                o = K(() => {
                    let d = V(s)
                    const { matched: h } = i.value
                    let y
                    for (; (y = h[d]) && !y.components; ) d++
                    return d
                }),
                l = K(() => i.value.matched[o.value])
            cn(
                h0,
                K(() => o.value + 1)
            ),
                cn(R2, l),
                cn(kc, i)
            const f = Ht()
            return (
                Oe(
                    () => [f.value, l.value, e.name],
                    ([d, h, y], [E, T, S]) => {
                        h &&
                            ((h.instances[y] = d),
                            T &&
                                T !== h &&
                                d &&
                                d === E &&
                                (h.leaveGuards.size || (h.leaveGuards = T.leaveGuards),
                                h.updateGuards.size || (h.updateGuards = T.updateGuards))),
                            d && h && (!T || !Co(h, T) || !E) && (h.enterCallbacks[y] || []).forEach((N) => N(d))
                    },
                    { flush: "post" }
                ),
                () => {
                    const d = i.value,
                        h = e.name,
                        y = l.value,
                        E = y && y.components[h]
                    if (!E) return v0(r.default, { Component: E, route: d })
                    const T = y.props[h],
                        S = T ? (T === !0 ? d.params : typeof T == "function" ? T(d) : T) : null,
                        P = he(
                            E,
                            Me({}, S, t, {
                                onVnodeUnmounted: (M) => {
                                    M.component.isUnmounted && (y.instances[h] = null)
                                },
                                ref: f,
                            })
                        )
                    return v0(r.default, { Component: P, route: d }) || P
                }
            )
        },
    })
function v0(e, t) {
    if (!e) return null
    const r = e(t)
    return r.length === 1 ? r[0] : r
}
const H2 = U2
function q2(e) {
    const t = m2(e.routes, e),
        r = e.parseQuery || B2,
        n = e.stringifyQuery || d0,
        i = e.history,
        s = na(),
        o = na(),
        l = na(),
        f = Og(xi)
    let d = xi
    no && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual")
    const h = Ef.bind(null, (b) => "" + b),
        y = Ef.bind(null, I2),
        E = Ef.bind(null, fu)
    function T(b, B) {
        let D, U
        return Wm(b) ? ((D = t.getRecordMatcher(b)), (U = B)) : (U = b), t.addRoute(U, D)
    }
    function S(b) {
        const B = t.getRecordMatcher(b)
        B && t.removeRoute(B)
    }
    function N() {
        return t.getRoutes().map((b) => b.record)
    }
    function P(b) {
        return !!t.getRecordMatcher(b)
    }
    function M(b, B) {
        if (((B = Me({}, B || f.value)), typeof b == "string")) {
            const et = xf(r, b, B.path),
                C = t.resolve({ path: et.path }, B),
                O = i.createHref(et.fullPath)
            return Me(et, C, { params: E(C.params), hash: fu(et.hash), redirectedFrom: void 0, href: O })
        }
        let D
        if ("path" in b) D = Me({}, b, { path: xf(r, b.path, B.path).path })
        else {
            const et = Me({}, b.params)
            for (const C in et) et[C] == null && delete et[C]
            ;(D = Me({}, b, { params: y(b.params) })), (B.params = y(B.params))
        }
        const U = t.resolve(D, B),
            j = b.hash || ""
        U.params = h(E(U.params))
        const dt = jA(n, Me({}, b, { hash: k2(j), path: U.path })),
            Z = i.createHref(dt)
        return Me({ fullPath: dt, hash: j, query: n === d0 ? P2(b.query) : b.query || {} }, U, { redirectedFrom: void 0, href: Z })
    }
    function k(b) {
        return typeof b == "string" ? xf(r, b, f.value.path) : Me({}, b)
    }
    function F(b, B) {
        if (d !== b) return Mo(8, { from: B, to: b })
    }
    function $(b) {
        return nt(b)
    }
    function R(b) {
        return $(Me(k(b), { replace: !0 }))
    }
    function W(b) {
        const B = b.matched[b.matched.length - 1]
        if (B && B.redirect) {
            const { redirect: D } = B
            let U = typeof D == "function" ? D(b) : D
            return (
                typeof U == "string" && ((U = U.includes("?") || U.includes("#") ? (U = k(U)) : { path: U }), (U.params = {})),
                Me({ query: b.query, hash: b.hash, params: "path" in U ? {} : b.params }, U)
            )
        }
    }
    function nt(b, B) {
        const D = (d = M(b)),
            U = f.value,
            j = b.state,
            dt = b.force,
            Z = b.replace === !0,
            et = W(D)
        if (et) return nt(Me(k(et), { state: typeof et == "object" ? Me({}, j, et.state) : j, force: dt, replace: Z }), B || D)
        const C = D
        C.redirectedFrom = B
        let O
        return (
            !dt && KA(n, U, D) && ((O = Mo(16, { to: C, from: U })), v(U, U, !0, !1)),
            (O ? Promise.resolve(O) : Q(C, U))
                .catch((I) => (Gn(I) ? (Gn(I, 2) ? I : w(I)) : _(I, C, U)))
                .then((I) => {
                    if (I) {
                        if (Gn(I, 2))
                            return nt(
                                Me({ replace: Z }, k(I.to), { state: typeof I.to == "object" ? Me({}, j, I.to.state) : j, force: dt }),
                                B || C
                            )
                    } else I = it(C, U, !0, Z, j)
                    return ot(C, U, I), I
                })
        )
    }
    function J(b, B) {
        const D = F(b, B)
        return D ? Promise.reject(D) : Promise.resolve()
    }
    function Q(b, B) {
        let D
        const [U, j, dt] = z2(b, B)
        D = Tf(U.reverse(), "beforeRouteLeave", b, B)
        for (const et of U)
            et.leaveGuards.forEach((C) => {
                D.push(Oi(C, b, B))
            })
        const Z = J.bind(null, b, B)
        return (
            D.push(Z),
            Ys(D)
                .then(() => {
                    D = []
                    for (const et of s.list()) D.push(Oi(et, b, B))
                    return D.push(Z), Ys(D)
                })
                .then(() => {
                    D = Tf(j, "beforeRouteUpdate", b, B)
                    for (const et of j)
                        et.updateGuards.forEach((C) => {
                            D.push(Oi(C, b, B))
                        })
                    return D.push(Z), Ys(D)
                })
                .then(() => {
                    D = []
                    for (const et of b.matched)
                        if (et.beforeEnter && !B.matched.includes(et))
                            if (pn(et.beforeEnter)) for (const C of et.beforeEnter) D.push(Oi(C, b, B))
                            else D.push(Oi(et.beforeEnter, b, B))
                    return D.push(Z), Ys(D)
                })
                .then(() => (b.matched.forEach((et) => (et.enterCallbacks = {})), (D = Tf(dt, "beforeRouteEnter", b, B)), D.push(Z), Ys(D)))
                .then(() => {
                    D = []
                    for (const et of o.list()) D.push(Oi(et, b, B))
                    return D.push(Z), Ys(D)
                })
                .catch((et) => (Gn(et, 8) ? et : Promise.reject(et)))
        )
    }
    function ot(b, B, D) {
        for (const U of l.list()) U(b, B, D)
    }
    function it(b, B, D, U, j) {
        const dt = F(b, B)
        if (dt) return dt
        const Z = B === xi,
            et = no ? history.state : {}
        D && (U || Z ? i.replace(b.fullPath, Me({ scroll: Z && et && et.scroll }, j)) : i.push(b.fullPath, j)), (f.value = b), v(b, B, D, Z), w()
    }
    let at
    function x() {
        at ||
            (at = i.listen((b, B, D) => {
                if (!H.listening) return
                const U = M(b),
                    j = W(U)
                if (j) {
                    nt(Me(j, { replace: !0 }), U).catch(xa)
                    return
                }
                d = U
                const dt = f.value
                no && t2(i0(dt.fullPath, D.delta), Wu()),
                    Q(U, dt)
                        .catch((Z) =>
                            Gn(Z, 12)
                                ? Z
                                : Gn(Z, 2)
                                ? (nt(Z.to, U)
                                      .then((et) => {
                                          Gn(et, 20) && !D.delta && D.type === La.pop && i.go(-1, !1)
                                      })
                                      .catch(xa),
                                  Promise.reject())
                                : (D.delta && i.go(-D.delta, !1), _(Z, U, dt))
                        )
                        .then((Z) => {
                            ;(Z = Z || it(U, dt, !1)),
                                Z && (D.delta && !Gn(Z, 8) ? i.go(-D.delta, !1) : D.type === La.pop && Gn(Z, 20) && i.go(-1, !1)),
                                ot(U, dt, Z)
                        })
                        .catch(xa)
            }))
    }
    let a = na(),
        c = na(),
        m
    function _(b, B, D) {
        w(b)
        const U = c.list()
        return U.length ? U.forEach((j) => j(b, B, D)) : console.error(b), Promise.reject(b)
    }
    function A() {
        return m && f.value !== xi
            ? Promise.resolve()
            : new Promise((b, B) => {
                  a.add([b, B])
              })
    }
    function w(b) {
        return m || ((m = !b), x(), a.list().forEach(([B, D]) => (b ? D(b) : B())), a.reset()), b
    }
    function v(b, B, D, U) {
        const { scrollBehavior: j } = e
        if (!no || !j) return Promise.resolve()
        const dt = (!D && e2(i0(b.fullPath, 0))) || ((U || !D) && history.state && history.state.scroll) || null
        return Wr()
            .then(() => j(b, B, dt))
            .then((Z) => Z && ZA(Z))
            .catch((Z) => _(Z, b, B))
    }
    const g = (b) => i.go(b)
    let u
    const p = new Set(),
        H = {
            currentRoute: f,
            listening: !0,
            addRoute: T,
            removeRoute: S,
            hasRoute: P,
            getRoutes: N,
            resolve: M,
            options: e,
            push: $,
            replace: R,
            go: g,
            back: () => g(-1),
            forward: () => g(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: l.add,
            onError: c.add,
            isReady: A,
            install(b) {
                const B = this
                b.component("RouterLink", $2),
                    b.component("RouterView", H2),
                    (b.config.globalProperties.$router = B),
                    Object.defineProperty(b.config.globalProperties, "$route", { enumerable: !0, get: () => V(f) }),
                    no && !u && f.value === xi && ((u = !0), $(i.location).catch((j) => {}))
                const D = {}
                for (const j in xi) D[j] = K(() => f.value[j])
                b.provide(Od, B), b.provide(Id, Ze(D)), b.provide(kc, f)
                const U = b.unmount
                p.add(b),
                    (b.unmount = function () {
                        p.delete(b), p.size < 1 && ((d = xi), at && at(), (at = null), (f.value = xi), (u = !1), (m = !1)), U()
                    })
            },
        }
    return H
}
function Ys(e) {
    return e.reduce((t, r) => t.then(() => r()), Promise.resolve())
}
function z2(e, t) {
    const r = [],
        n = [],
        i = [],
        s = Math.max(t.matched.length, e.matched.length)
    for (let o = 0; o < s; o++) {
        const l = t.matched[o]
        l && (e.matched.find((d) => Co(d, l)) ? n.push(l) : r.push(l))
        const f = e.matched[o]
        f && (t.matched.find((d) => Co(d, f)) || i.push(f))
    }
    return [r, n, i]
}
function rv() {
    return Ie(Id)
}
var Bd =
    typeof globalThis != "undefined"
        ? globalThis
        : typeof window != "undefined"
        ? window
        : typeof global != "undefined"
        ? global
        : typeof self != "undefined"
        ? self
        : {}
function j2(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
function K2(e) {
    if (e.__esModule) return e
    var t = Object.defineProperty({}, "__esModule", { value: !0 })
    return (
        Object.keys(e).forEach(function (r) {
            var n = Object.getOwnPropertyDescriptor(e, r)
            Object.defineProperty(
                t,
                r,
                n.get
                    ? n
                    : {
                          enumerable: !0,
                          get: function () {
                              return e[r]
                          },
                      }
            )
        }),
        t
    )
}
var nv = { exports: {} }
;(function (e) {
    ;(function (t, r) {
        function n(x, a) {
            if (!x) throw new Error(a || "Assertion failed")
        }
        function i(x, a) {
            x.super_ = a
            var c = function () {}
            ;(c.prototype = a.prototype), (x.prototype = new c()), (x.prototype.constructor = x)
        }
        function s(x, a, c) {
            if (s.isBN(x)) return x
            ;(this.negative = 0),
                (this.words = null),
                (this.length = 0),
                (this.red = null),
                x !== null && ((a === "le" || a === "be") && ((c = a), (a = 10)), this._init(x || 0, a || 10, c || "be"))
        }
        typeof t == "object" ? (t.exports = s) : (r.BN = s), (s.BN = s), (s.wordSize = 26)
        var o
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? (o = window.Buffer) : (o = require("buffer").Buffer)
        } catch {}
        ;(s.isBN = function (a) {
            return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words)
        }),
            (s.max = function (a, c) {
                return a.cmp(c) > 0 ? a : c
            }),
            (s.min = function (a, c) {
                return a.cmp(c) < 0 ? a : c
            }),
            (s.prototype._init = function (a, c, m) {
                if (typeof a == "number") return this._initNumber(a, c, m)
                if (typeof a == "object") return this._initArray(a, c, m)
                c === "hex" && (c = 16), n(c === (c | 0) && c >= 2 && c <= 36), (a = a.toString().replace(/\s+/g, ""))
                var _ = 0
                a[0] === "-" && (_++, (this.negative = 1)),
                    _ < a.length &&
                        (c === 16 ? this._parseHex(a, _, m) : (this._parseBase(a, c, _), m === "le" && this._initArray(this.toArray(), c, m)))
            }),
            (s.prototype._initNumber = function (a, c, m) {
                a < 0 && ((this.negative = 1), (a = -a)),
                    a < 67108864
                        ? ((this.words = [a & 67108863]), (this.length = 1))
                        : a < 4503599627370496
                        ? ((this.words = [a & 67108863, (a / 67108864) & 67108863]), (this.length = 2))
                        : (n(a < 9007199254740992), (this.words = [a & 67108863, (a / 67108864) & 67108863, 1]), (this.length = 3)),
                    m === "le" && this._initArray(this.toArray(), c, m)
            }),
            (s.prototype._initArray = function (a, c, m) {
                if ((n(typeof a.length == "number"), a.length <= 0)) return (this.words = [0]), (this.length = 1), this
                ;(this.length = Math.ceil(a.length / 3)), (this.words = new Array(this.length))
                for (var _ = 0; _ < this.length; _++) this.words[_] = 0
                var A,
                    w,
                    v = 0
                if (m === "be")
                    for (_ = a.length - 1, A = 0; _ >= 0; _ -= 3)
                        (w = a[_] | (a[_ - 1] << 8) | (a[_ - 2] << 16)),
                            (this.words[A] |= (w << v) & 67108863),
                            (this.words[A + 1] = (w >>> (26 - v)) & 67108863),
                            (v += 24),
                            v >= 26 && ((v -= 26), A++)
                else if (m === "le")
                    for (_ = 0, A = 0; _ < a.length; _ += 3)
                        (w = a[_] | (a[_ + 1] << 8) | (a[_ + 2] << 16)),
                            (this.words[A] |= (w << v) & 67108863),
                            (this.words[A + 1] = (w >>> (26 - v)) & 67108863),
                            (v += 24),
                            v >= 26 && ((v -= 26), A++)
                return this._strip()
            })
        function l(x, a) {
            var c = x.charCodeAt(a)
            if (c >= 48 && c <= 57) return c - 48
            if (c >= 65 && c <= 70) return c - 55
            if (c >= 97 && c <= 102) return c - 87
            n(!1, "Invalid character in " + x)
        }
        function f(x, a, c) {
            var m = l(x, c)
            return c - 1 >= a && (m |= l(x, c - 1) << 4), m
        }
        s.prototype._parseHex = function (a, c, m) {
            ;(this.length = Math.ceil((a.length - c) / 6)), (this.words = new Array(this.length))
            for (var _ = 0; _ < this.length; _++) this.words[_] = 0
            var A = 0,
                w = 0,
                v
            if (m === "be")
                for (_ = a.length - 1; _ >= c; _ -= 2)
                    (v = f(a, c, _) << A),
                        (this.words[w] |= v & 67108863),
                        A >= 18 ? ((A -= 18), (w += 1), (this.words[w] |= v >>> 26)) : (A += 8)
            else {
                var g = a.length - c
                for (_ = g % 2 === 0 ? c + 1 : c; _ < a.length; _ += 2)
                    (v = f(a, c, _) << A),
                        (this.words[w] |= v & 67108863),
                        A >= 18 ? ((A -= 18), (w += 1), (this.words[w] |= v >>> 26)) : (A += 8)
            }
            this._strip()
        }
        function d(x, a, c, m) {
            for (var _ = 0, A = 0, w = Math.min(x.length, c), v = a; v < w; v++) {
                var g = x.charCodeAt(v) - 48
                ;(_ *= m), g >= 49 ? (A = g - 49 + 10) : g >= 17 ? (A = g - 17 + 10) : (A = g), n(g >= 0 && A < m, "Invalid character"), (_ += A)
            }
            return _
        }
        ;(s.prototype._parseBase = function (a, c, m) {
            ;(this.words = [0]), (this.length = 1)
            for (var _ = 0, A = 1; A <= 67108863; A *= c) _++
            _--, (A = (A / c) | 0)
            for (var w = a.length - m, v = w % _, g = Math.min(w, w - v) + m, u = 0, p = m; p < g; p += _)
                (u = d(a, p, p + _, c)), this.imuln(A), this.words[0] + u < 67108864 ? (this.words[0] += u) : this._iaddn(u)
            if (v !== 0) {
                var H = 1
                for (u = d(a, p, a.length, c), p = 0; p < v; p++) H *= c
                this.imuln(H), this.words[0] + u < 67108864 ? (this.words[0] += u) : this._iaddn(u)
            }
            this._strip()
        }),
            (s.prototype.copy = function (a) {
                a.words = new Array(this.length)
                for (var c = 0; c < this.length; c++) a.words[c] = this.words[c]
                ;(a.length = this.length), (a.negative = this.negative), (a.red = this.red)
            })
        function h(x, a) {
            ;(x.words = a.words), (x.length = a.length), (x.negative = a.negative), (x.red = a.red)
        }
        if (
            ((s.prototype._move = function (a) {
                h(a, this)
            }),
            (s.prototype.clone = function () {
                var a = new s(null)
                return this.copy(a), a
            }),
            (s.prototype._expand = function (a) {
                for (; this.length < a; ) this.words[this.length++] = 0
                return this
            }),
            (s.prototype._strip = function () {
                for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                return this._normSign()
            }),
            (s.prototype._normSign = function () {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            typeof Symbol != "undefined" && typeof Symbol.for == "function")
        )
            try {
                s.prototype[Symbol.for("nodejs.util.inspect.custom")] = y
            } catch {
                s.prototype.inspect = y
            }
        else s.prototype.inspect = y
        function y() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var E = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000",
            ],
            T = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            S = [
                0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
                11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
                17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ]
        ;(s.prototype.toString = function (a, c) {
            ;(a = a || 10), (c = c | 0 || 1)
            var m
            if (a === 16 || a === "hex") {
                m = ""
                for (var _ = 0, A = 0, w = 0; w < this.length; w++) {
                    var v = this.words[w],
                        g = (((v << _) | A) & 16777215).toString(16)
                    ;(A = (v >>> (24 - _)) & 16777215),
                        (_ += 2),
                        _ >= 26 && ((_ -= 26), w--),
                        A !== 0 || w !== this.length - 1 ? (m = E[6 - g.length] + g + m) : (m = g + m)
                }
                for (A !== 0 && (m = A.toString(16) + m); m.length % c !== 0; ) m = "0" + m
                return this.negative !== 0 && (m = "-" + m), m
            }
            if (a === (a | 0) && a >= 2 && a <= 36) {
                var u = T[a],
                    p = S[a]
                m = ""
                var H = this.clone()
                for (H.negative = 0; !H.isZero(); ) {
                    var b = H.modrn(p).toString(a)
                    ;(H = H.idivn(p)), H.isZero() ? (m = b + m) : (m = E[u - b.length] + b + m)
                }
                for (this.isZero() && (m = "0" + m); m.length % c !== 0; ) m = "0" + m
                return this.negative !== 0 && (m = "-" + m), m
            }
            n(!1, "Base should be between 2 and 36")
        }),
            (s.prototype.toNumber = function () {
                var a = this.words[0]
                return (
                    this.length === 2
                        ? (a += this.words[1] * 67108864)
                        : this.length === 3 && this.words[2] === 1
                        ? (a += 4503599627370496 + this.words[1] * 67108864)
                        : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
                    this.negative !== 0 ? -a : a
                )
            }),
            (s.prototype.toJSON = function () {
                return this.toString(16, 2)
            }),
            o &&
                (s.prototype.toBuffer = function (a, c) {
                    return this.toArrayLike(o, a, c)
                }),
            (s.prototype.toArray = function (a, c) {
                return this.toArrayLike(Array, a, c)
            })
        var N = function (a, c) {
            return a.allocUnsafe ? a.allocUnsafe(c) : new a(c)
        }
        ;(s.prototype.toArrayLike = function (a, c, m) {
            this._strip()
            var _ = this.byteLength(),
                A = m || Math.max(1, _)
            n(_ <= A, "byte array longer than desired length"), n(A > 0, "Requested array length <= 0")
            var w = N(a, A),
                v = c === "le" ? "LE" : "BE"
            return this["_toArrayLike" + v](w, _), w
        }),
            (s.prototype._toArrayLikeLE = function (a, c) {
                for (var m = 0, _ = 0, A = 0, w = 0; A < this.length; A++) {
                    var v = (this.words[A] << w) | _
                    ;(a[m++] = v & 255),
                        m < a.length && (a[m++] = (v >> 8) & 255),
                        m < a.length && (a[m++] = (v >> 16) & 255),
                        w === 6 ? (m < a.length && (a[m++] = (v >> 24) & 255), (_ = 0), (w = 0)) : ((_ = v >>> 24), (w += 2))
                }
                if (m < a.length) for (a[m++] = _; m < a.length; ) a[m++] = 0
            }),
            (s.prototype._toArrayLikeBE = function (a, c) {
                for (var m = a.length - 1, _ = 0, A = 0, w = 0; A < this.length; A++) {
                    var v = (this.words[A] << w) | _
                    ;(a[m--] = v & 255),
                        m >= 0 && (a[m--] = (v >> 8) & 255),
                        m >= 0 && (a[m--] = (v >> 16) & 255),
                        w === 6 ? (m >= 0 && (a[m--] = (v >> 24) & 255), (_ = 0), (w = 0)) : ((_ = v >>> 24), (w += 2))
                }
                if (m >= 0) for (a[m--] = _; m >= 0; ) a[m--] = 0
            }),
            Math.clz32
                ? (s.prototype._countBits = function (a) {
                      return 32 - Math.clz32(a)
                  })
                : (s.prototype._countBits = function (a) {
                      var c = a,
                          m = 0
                      return (
                          c >= 4096 && ((m += 13), (c >>>= 13)),
                          c >= 64 && ((m += 7), (c >>>= 7)),
                          c >= 8 && ((m += 4), (c >>>= 4)),
                          c >= 2 && ((m += 2), (c >>>= 2)),
                          m + c
                      )
                  }),
            (s.prototype._zeroBits = function (a) {
                if (a === 0) return 26
                var c = a,
                    m = 0
                return (
                    (c & 8191) === 0 && ((m += 13), (c >>>= 13)),
                    (c & 127) === 0 && ((m += 7), (c >>>= 7)),
                    (c & 15) === 0 && ((m += 4), (c >>>= 4)),
                    (c & 3) === 0 && ((m += 2), (c >>>= 2)),
                    (c & 1) === 0 && m++,
                    m
                )
            }),
            (s.prototype.bitLength = function () {
                var a = this.words[this.length - 1],
                    c = this._countBits(a)
                return (this.length - 1) * 26 + c
            })
        function P(x) {
            for (var a = new Array(x.bitLength()), c = 0; c < a.length; c++) {
                var m = (c / 26) | 0,
                    _ = c % 26
                a[c] = (x.words[m] >>> _) & 1
            }
            return a
        }
        ;(s.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var a = 0, c = 0; c < this.length; c++) {
                var m = this._zeroBits(this.words[c])
                if (((a += m), m !== 26)) break
            }
            return a
        }),
            (s.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }),
            (s.prototype.toTwos = function (a) {
                return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone()
            }),
            (s.prototype.fromTwos = function (a) {
                return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone()
            }),
            (s.prototype.isNeg = function () {
                return this.negative !== 0
            }),
            (s.prototype.neg = function () {
                return this.clone().ineg()
            }),
            (s.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }),
            (s.prototype.iuor = function (a) {
                for (; this.length < a.length; ) this.words[this.length++] = 0
                for (var c = 0; c < a.length; c++) this.words[c] = this.words[c] | a.words[c]
                return this._strip()
            }),
            (s.prototype.ior = function (a) {
                return n((this.negative | a.negative) === 0), this.iuor(a)
            }),
            (s.prototype.or = function (a) {
                return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this)
            }),
            (s.prototype.uor = function (a) {
                return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this)
            }),
            (s.prototype.iuand = function (a) {
                var c
                this.length > a.length ? (c = a) : (c = this)
                for (var m = 0; m < c.length; m++) this.words[m] = this.words[m] & a.words[m]
                return (this.length = c.length), this._strip()
            }),
            (s.prototype.iand = function (a) {
                return n((this.negative | a.negative) === 0), this.iuand(a)
            }),
            (s.prototype.and = function (a) {
                return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this)
            }),
            (s.prototype.uand = function (a) {
                return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this)
            }),
            (s.prototype.iuxor = function (a) {
                var c, m
                this.length > a.length ? ((c = this), (m = a)) : ((c = a), (m = this))
                for (var _ = 0; _ < m.length; _++) this.words[_] = c.words[_] ^ m.words[_]
                if (this !== c) for (; _ < c.length; _++) this.words[_] = c.words[_]
                return (this.length = c.length), this._strip()
            }),
            (s.prototype.ixor = function (a) {
                return n((this.negative | a.negative) === 0), this.iuxor(a)
            }),
            (s.prototype.xor = function (a) {
                return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this)
            }),
            (s.prototype.uxor = function (a) {
                return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this)
            }),
            (s.prototype.inotn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = Math.ceil(a / 26) | 0,
                    m = a % 26
                this._expand(c), m > 0 && c--
                for (var _ = 0; _ < c; _++) this.words[_] = ~this.words[_] & 67108863
                return m > 0 && (this.words[_] = ~this.words[_] & (67108863 >> (26 - m))), this._strip()
            }),
            (s.prototype.notn = function (a) {
                return this.clone().inotn(a)
            }),
            (s.prototype.setn = function (a, c) {
                n(typeof a == "number" && a >= 0)
                var m = (a / 26) | 0,
                    _ = a % 26
                return (
                    this._expand(m + 1),
                    c ? (this.words[m] = this.words[m] | (1 << _)) : (this.words[m] = this.words[m] & ~(1 << _)),
                    this._strip()
                )
            }),
            (s.prototype.iadd = function (a) {
                var c
                if (this.negative !== 0 && a.negative === 0)
                    return (this.negative = 0), (c = this.isub(a)), (this.negative ^= 1), this._normSign()
                if (this.negative === 0 && a.negative !== 0) return (a.negative = 0), (c = this.isub(a)), (a.negative = 1), c._normSign()
                var m, _
                this.length > a.length ? ((m = this), (_ = a)) : ((m = a), (_ = this))
                for (var A = 0, w = 0; w < _.length; w++)
                    (c = (m.words[w] | 0) + (_.words[w] | 0) + A), (this.words[w] = c & 67108863), (A = c >>> 26)
                for (; A !== 0 && w < m.length; w++) (c = (m.words[w] | 0) + A), (this.words[w] = c & 67108863), (A = c >>> 26)
                if (((this.length = m.length), A !== 0)) (this.words[this.length] = A), this.length++
                else if (m !== this) for (; w < m.length; w++) this.words[w] = m.words[w]
                return this
            }),
            (s.prototype.add = function (a) {
                var c
                return a.negative !== 0 && this.negative === 0
                    ? ((a.negative = 0), (c = this.sub(a)), (a.negative ^= 1), c)
                    : a.negative === 0 && this.negative !== 0
                    ? ((this.negative = 0), (c = a.sub(this)), (this.negative = 1), c)
                    : this.length > a.length
                    ? this.clone().iadd(a)
                    : a.clone().iadd(this)
            }),
            (s.prototype.isub = function (a) {
                if (a.negative !== 0) {
                    a.negative = 0
                    var c = this.iadd(a)
                    return (a.negative = 1), c._normSign()
                } else if (this.negative !== 0) return (this.negative = 0), this.iadd(a), (this.negative = 1), this._normSign()
                var m = this.cmp(a)
                if (m === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
                var _, A
                m > 0 ? ((_ = this), (A = a)) : ((_ = a), (A = this))
                for (var w = 0, v = 0; v < A.length; v++)
                    (c = (_.words[v] | 0) - (A.words[v] | 0) + w), (w = c >> 26), (this.words[v] = c & 67108863)
                for (; w !== 0 && v < _.length; v++) (c = (_.words[v] | 0) + w), (w = c >> 26), (this.words[v] = c & 67108863)
                if (w === 0 && v < _.length && _ !== this) for (; v < _.length; v++) this.words[v] = _.words[v]
                return (this.length = Math.max(this.length, v)), _ !== this && (this.negative = 1), this._strip()
            }),
            (s.prototype.sub = function (a) {
                return this.clone().isub(a)
            })
        function M(x, a, c) {
            c.negative = a.negative ^ x.negative
            var m = (x.length + a.length) | 0
            ;(c.length = m), (m = (m - 1) | 0)
            var _ = x.words[0] | 0,
                A = a.words[0] | 0,
                w = _ * A,
                v = w & 67108863,
                g = (w / 67108864) | 0
            c.words[0] = v
            for (var u = 1; u < m; u++) {
                for (var p = g >>> 26, H = g & 67108863, b = Math.min(u, a.length - 1), B = Math.max(0, u - x.length + 1); B <= b; B++) {
                    var D = (u - B) | 0
                    ;(_ = x.words[D] | 0), (A = a.words[B] | 0), (w = _ * A + H), (p += (w / 67108864) | 0), (H = w & 67108863)
                }
                ;(c.words[u] = H | 0), (g = p | 0)
            }
            return g !== 0 ? (c.words[u] = g | 0) : c.length--, c._strip()
        }
        var k = function (a, c, m) {
            var _ = a.words,
                A = c.words,
                w = m.words,
                v = 0,
                g,
                u,
                p,
                H = _[0] | 0,
                b = H & 8191,
                B = H >>> 13,
                D = _[1] | 0,
                U = D & 8191,
                j = D >>> 13,
                dt = _[2] | 0,
                Z = dt & 8191,
                et = dt >>> 13,
                C = _[3] | 0,
                O = C & 8191,
                I = C >>> 13,
                G = _[4] | 0,
                q = G & 8191,
                X = G >>> 13,
                lt = _[5] | 0,
                tt = lt & 8191,
                rt = lt >>> 13,
                st = _[6] | 0,
                ct = st & 8191,
                ht = st >>> 13,
                gt = _[7] | 0,
                pt = gt & 8191,
                vt = gt >>> 13,
                Tt = _[8] | 0,
                Et = Tt & 8191,
                At = Tt >>> 13,
                Ft = _[9] | 0,
                Ot = Ft & 8191,
                Bt = Ft >>> 13,
                ke = A[0] | 0,
                Vt = ke & 8191,
                Mt = ke >>> 13,
                ge = A[1] | 0,
                Rt = ge & 8191,
                qt = ge >>> 13,
                vr = A[2] | 0,
                Gt = vr & 8191,
                zt = vr >>> 13,
                vn = A[3] | 0,
                Jt = vn & 8191,
                Qt = vn >>> 13,
                bn = A[4] | 0,
                Xt = bn & 8191,
                Zt = bn >>> 13,
                yn = A[5] | 0,
                te = yn & 8191,
                ee = yn >>> 13,
                _n = A[6] | 0,
                re = _n & 8191,
                ne = _n >>> 13,
                wn = A[7] | 0,
                ie = wn & 8191,
                se = wn >>> 13,
                An = A[8] | 0,
                oe = An & 8191,
                ae = An >>> 13,
                En = A[9] | 0,
                le = En & 8191,
                ue = En >>> 13
            ;(m.negative = a.negative ^ c.negative),
                (m.length = 19),
                (g = Math.imul(b, Vt)),
                (u = Math.imul(b, Mt)),
                (u = (u + Math.imul(B, Vt)) | 0),
                (p = Math.imul(B, Mt))
            var Vr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Vr >>> 26)) | 0),
                (Vr &= 67108863),
                (g = Math.imul(U, Vt)),
                (u = Math.imul(U, Mt)),
                (u = (u + Math.imul(j, Vt)) | 0),
                (p = Math.imul(j, Mt)),
                (g = (g + Math.imul(b, Rt)) | 0),
                (u = (u + Math.imul(b, qt)) | 0),
                (u = (u + Math.imul(B, Rt)) | 0),
                (p = (p + Math.imul(B, qt)) | 0)
            var Ur = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Ur >>> 26)) | 0),
                (Ur &= 67108863),
                (g = Math.imul(Z, Vt)),
                (u = Math.imul(Z, Mt)),
                (u = (u + Math.imul(et, Vt)) | 0),
                (p = Math.imul(et, Mt)),
                (g = (g + Math.imul(U, Rt)) | 0),
                (u = (u + Math.imul(U, qt)) | 0),
                (u = (u + Math.imul(j, Rt)) | 0),
                (p = (p + Math.imul(j, qt)) | 0),
                (g = (g + Math.imul(b, Gt)) | 0),
                (u = (u + Math.imul(b, zt)) | 0),
                (u = (u + Math.imul(B, Gt)) | 0),
                (p = (p + Math.imul(B, zt)) | 0)
            var Hr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Hr >>> 26)) | 0),
                (Hr &= 67108863),
                (g = Math.imul(O, Vt)),
                (u = Math.imul(O, Mt)),
                (u = (u + Math.imul(I, Vt)) | 0),
                (p = Math.imul(I, Mt)),
                (g = (g + Math.imul(Z, Rt)) | 0),
                (u = (u + Math.imul(Z, qt)) | 0),
                (u = (u + Math.imul(et, Rt)) | 0),
                (p = (p + Math.imul(et, qt)) | 0),
                (g = (g + Math.imul(U, Gt)) | 0),
                (u = (u + Math.imul(U, zt)) | 0),
                (u = (u + Math.imul(j, Gt)) | 0),
                (p = (p + Math.imul(j, zt)) | 0),
                (g = (g + Math.imul(b, Jt)) | 0),
                (u = (u + Math.imul(b, Qt)) | 0),
                (u = (u + Math.imul(B, Jt)) | 0),
                (p = (p + Math.imul(B, Qt)) | 0)
            var qr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (qr >>> 26)) | 0),
                (qr &= 67108863),
                (g = Math.imul(q, Vt)),
                (u = Math.imul(q, Mt)),
                (u = (u + Math.imul(X, Vt)) | 0),
                (p = Math.imul(X, Mt)),
                (g = (g + Math.imul(O, Rt)) | 0),
                (u = (u + Math.imul(O, qt)) | 0),
                (u = (u + Math.imul(I, Rt)) | 0),
                (p = (p + Math.imul(I, qt)) | 0),
                (g = (g + Math.imul(Z, Gt)) | 0),
                (u = (u + Math.imul(Z, zt)) | 0),
                (u = (u + Math.imul(et, Gt)) | 0),
                (p = (p + Math.imul(et, zt)) | 0),
                (g = (g + Math.imul(U, Jt)) | 0),
                (u = (u + Math.imul(U, Qt)) | 0),
                (u = (u + Math.imul(j, Jt)) | 0),
                (p = (p + Math.imul(j, Qt)) | 0),
                (g = (g + Math.imul(b, Xt)) | 0),
                (u = (u + Math.imul(b, Zt)) | 0),
                (u = (u + Math.imul(B, Xt)) | 0),
                (p = (p + Math.imul(B, Zt)) | 0)
            var zr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (zr >>> 26)) | 0),
                (zr &= 67108863),
                (g = Math.imul(tt, Vt)),
                (u = Math.imul(tt, Mt)),
                (u = (u + Math.imul(rt, Vt)) | 0),
                (p = Math.imul(rt, Mt)),
                (g = (g + Math.imul(q, Rt)) | 0),
                (u = (u + Math.imul(q, qt)) | 0),
                (u = (u + Math.imul(X, Rt)) | 0),
                (p = (p + Math.imul(X, qt)) | 0),
                (g = (g + Math.imul(O, Gt)) | 0),
                (u = (u + Math.imul(O, zt)) | 0),
                (u = (u + Math.imul(I, Gt)) | 0),
                (p = (p + Math.imul(I, zt)) | 0),
                (g = (g + Math.imul(Z, Jt)) | 0),
                (u = (u + Math.imul(Z, Qt)) | 0),
                (u = (u + Math.imul(et, Jt)) | 0),
                (p = (p + Math.imul(et, Qt)) | 0),
                (g = (g + Math.imul(U, Xt)) | 0),
                (u = (u + Math.imul(U, Zt)) | 0),
                (u = (u + Math.imul(j, Xt)) | 0),
                (p = (p + Math.imul(j, Zt)) | 0),
                (g = (g + Math.imul(b, te)) | 0),
                (u = (u + Math.imul(b, ee)) | 0),
                (u = (u + Math.imul(B, te)) | 0),
                (p = (p + Math.imul(B, ee)) | 0)
            var ns = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ns >>> 26)) | 0),
                (ns &= 67108863),
                (g = Math.imul(ct, Vt)),
                (u = Math.imul(ct, Mt)),
                (u = (u + Math.imul(ht, Vt)) | 0),
                (p = Math.imul(ht, Mt)),
                (g = (g + Math.imul(tt, Rt)) | 0),
                (u = (u + Math.imul(tt, qt)) | 0),
                (u = (u + Math.imul(rt, Rt)) | 0),
                (p = (p + Math.imul(rt, qt)) | 0),
                (g = (g + Math.imul(q, Gt)) | 0),
                (u = (u + Math.imul(q, zt)) | 0),
                (u = (u + Math.imul(X, Gt)) | 0),
                (p = (p + Math.imul(X, zt)) | 0),
                (g = (g + Math.imul(O, Jt)) | 0),
                (u = (u + Math.imul(O, Qt)) | 0),
                (u = (u + Math.imul(I, Jt)) | 0),
                (p = (p + Math.imul(I, Qt)) | 0),
                (g = (g + Math.imul(Z, Xt)) | 0),
                (u = (u + Math.imul(Z, Zt)) | 0),
                (u = (u + Math.imul(et, Xt)) | 0),
                (p = (p + Math.imul(et, Zt)) | 0),
                (g = (g + Math.imul(U, te)) | 0),
                (u = (u + Math.imul(U, ee)) | 0),
                (u = (u + Math.imul(j, te)) | 0),
                (p = (p + Math.imul(j, ee)) | 0),
                (g = (g + Math.imul(b, re)) | 0),
                (u = (u + Math.imul(b, ne)) | 0),
                (u = (u + Math.imul(B, re)) | 0),
                (p = (p + Math.imul(B, ne)) | 0)
            var is = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (is >>> 26)) | 0),
                (is &= 67108863),
                (g = Math.imul(pt, Vt)),
                (u = Math.imul(pt, Mt)),
                (u = (u + Math.imul(vt, Vt)) | 0),
                (p = Math.imul(vt, Mt)),
                (g = (g + Math.imul(ct, Rt)) | 0),
                (u = (u + Math.imul(ct, qt)) | 0),
                (u = (u + Math.imul(ht, Rt)) | 0),
                (p = (p + Math.imul(ht, qt)) | 0),
                (g = (g + Math.imul(tt, Gt)) | 0),
                (u = (u + Math.imul(tt, zt)) | 0),
                (u = (u + Math.imul(rt, Gt)) | 0),
                (p = (p + Math.imul(rt, zt)) | 0),
                (g = (g + Math.imul(q, Jt)) | 0),
                (u = (u + Math.imul(q, Qt)) | 0),
                (u = (u + Math.imul(X, Jt)) | 0),
                (p = (p + Math.imul(X, Qt)) | 0),
                (g = (g + Math.imul(O, Xt)) | 0),
                (u = (u + Math.imul(O, Zt)) | 0),
                (u = (u + Math.imul(I, Xt)) | 0),
                (p = (p + Math.imul(I, Zt)) | 0),
                (g = (g + Math.imul(Z, te)) | 0),
                (u = (u + Math.imul(Z, ee)) | 0),
                (u = (u + Math.imul(et, te)) | 0),
                (p = (p + Math.imul(et, ee)) | 0),
                (g = (g + Math.imul(U, re)) | 0),
                (u = (u + Math.imul(U, ne)) | 0),
                (u = (u + Math.imul(j, re)) | 0),
                (p = (p + Math.imul(j, ne)) | 0),
                (g = (g + Math.imul(b, ie)) | 0),
                (u = (u + Math.imul(b, se)) | 0),
                (u = (u + Math.imul(B, ie)) | 0),
                (p = (p + Math.imul(B, se)) | 0)
            var ss = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ss >>> 26)) | 0),
                (ss &= 67108863),
                (g = Math.imul(Et, Vt)),
                (u = Math.imul(Et, Mt)),
                (u = (u + Math.imul(At, Vt)) | 0),
                (p = Math.imul(At, Mt)),
                (g = (g + Math.imul(pt, Rt)) | 0),
                (u = (u + Math.imul(pt, qt)) | 0),
                (u = (u + Math.imul(vt, Rt)) | 0),
                (p = (p + Math.imul(vt, qt)) | 0),
                (g = (g + Math.imul(ct, Gt)) | 0),
                (u = (u + Math.imul(ct, zt)) | 0),
                (u = (u + Math.imul(ht, Gt)) | 0),
                (p = (p + Math.imul(ht, zt)) | 0),
                (g = (g + Math.imul(tt, Jt)) | 0),
                (u = (u + Math.imul(tt, Qt)) | 0),
                (u = (u + Math.imul(rt, Jt)) | 0),
                (p = (p + Math.imul(rt, Qt)) | 0),
                (g = (g + Math.imul(q, Xt)) | 0),
                (u = (u + Math.imul(q, Zt)) | 0),
                (u = (u + Math.imul(X, Xt)) | 0),
                (p = (p + Math.imul(X, Zt)) | 0),
                (g = (g + Math.imul(O, te)) | 0),
                (u = (u + Math.imul(O, ee)) | 0),
                (u = (u + Math.imul(I, te)) | 0),
                (p = (p + Math.imul(I, ee)) | 0),
                (g = (g + Math.imul(Z, re)) | 0),
                (u = (u + Math.imul(Z, ne)) | 0),
                (u = (u + Math.imul(et, re)) | 0),
                (p = (p + Math.imul(et, ne)) | 0),
                (g = (g + Math.imul(U, ie)) | 0),
                (u = (u + Math.imul(U, se)) | 0),
                (u = (u + Math.imul(j, ie)) | 0),
                (p = (p + Math.imul(j, se)) | 0),
                (g = (g + Math.imul(b, oe)) | 0),
                (u = (u + Math.imul(b, ae)) | 0),
                (u = (u + Math.imul(B, oe)) | 0),
                (p = (p + Math.imul(B, ae)) | 0)
            var os = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (os >>> 26)) | 0),
                (os &= 67108863),
                (g = Math.imul(Ot, Vt)),
                (u = Math.imul(Ot, Mt)),
                (u = (u + Math.imul(Bt, Vt)) | 0),
                (p = Math.imul(Bt, Mt)),
                (g = (g + Math.imul(Et, Rt)) | 0),
                (u = (u + Math.imul(Et, qt)) | 0),
                (u = (u + Math.imul(At, Rt)) | 0),
                (p = (p + Math.imul(At, qt)) | 0),
                (g = (g + Math.imul(pt, Gt)) | 0),
                (u = (u + Math.imul(pt, zt)) | 0),
                (u = (u + Math.imul(vt, Gt)) | 0),
                (p = (p + Math.imul(vt, zt)) | 0),
                (g = (g + Math.imul(ct, Jt)) | 0),
                (u = (u + Math.imul(ct, Qt)) | 0),
                (u = (u + Math.imul(ht, Jt)) | 0),
                (p = (p + Math.imul(ht, Qt)) | 0),
                (g = (g + Math.imul(tt, Xt)) | 0),
                (u = (u + Math.imul(tt, Zt)) | 0),
                (u = (u + Math.imul(rt, Xt)) | 0),
                (p = (p + Math.imul(rt, Zt)) | 0),
                (g = (g + Math.imul(q, te)) | 0),
                (u = (u + Math.imul(q, ee)) | 0),
                (u = (u + Math.imul(X, te)) | 0),
                (p = (p + Math.imul(X, ee)) | 0),
                (g = (g + Math.imul(O, re)) | 0),
                (u = (u + Math.imul(O, ne)) | 0),
                (u = (u + Math.imul(I, re)) | 0),
                (p = (p + Math.imul(I, ne)) | 0),
                (g = (g + Math.imul(Z, ie)) | 0),
                (u = (u + Math.imul(Z, se)) | 0),
                (u = (u + Math.imul(et, ie)) | 0),
                (p = (p + Math.imul(et, se)) | 0),
                (g = (g + Math.imul(U, oe)) | 0),
                (u = (u + Math.imul(U, ae)) | 0),
                (u = (u + Math.imul(j, oe)) | 0),
                (p = (p + Math.imul(j, ae)) | 0),
                (g = (g + Math.imul(b, le)) | 0),
                (u = (u + Math.imul(b, ue)) | 0),
                (u = (u + Math.imul(B, le)) | 0),
                (p = (p + Math.imul(B, ue)) | 0)
            var as = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (as >>> 26)) | 0),
                (as &= 67108863),
                (g = Math.imul(Ot, Rt)),
                (u = Math.imul(Ot, qt)),
                (u = (u + Math.imul(Bt, Rt)) | 0),
                (p = Math.imul(Bt, qt)),
                (g = (g + Math.imul(Et, Gt)) | 0),
                (u = (u + Math.imul(Et, zt)) | 0),
                (u = (u + Math.imul(At, Gt)) | 0),
                (p = (p + Math.imul(At, zt)) | 0),
                (g = (g + Math.imul(pt, Jt)) | 0),
                (u = (u + Math.imul(pt, Qt)) | 0),
                (u = (u + Math.imul(vt, Jt)) | 0),
                (p = (p + Math.imul(vt, Qt)) | 0),
                (g = (g + Math.imul(ct, Xt)) | 0),
                (u = (u + Math.imul(ct, Zt)) | 0),
                (u = (u + Math.imul(ht, Xt)) | 0),
                (p = (p + Math.imul(ht, Zt)) | 0),
                (g = (g + Math.imul(tt, te)) | 0),
                (u = (u + Math.imul(tt, ee)) | 0),
                (u = (u + Math.imul(rt, te)) | 0),
                (p = (p + Math.imul(rt, ee)) | 0),
                (g = (g + Math.imul(q, re)) | 0),
                (u = (u + Math.imul(q, ne)) | 0),
                (u = (u + Math.imul(X, re)) | 0),
                (p = (p + Math.imul(X, ne)) | 0),
                (g = (g + Math.imul(O, ie)) | 0),
                (u = (u + Math.imul(O, se)) | 0),
                (u = (u + Math.imul(I, ie)) | 0),
                (p = (p + Math.imul(I, se)) | 0),
                (g = (g + Math.imul(Z, oe)) | 0),
                (u = (u + Math.imul(Z, ae)) | 0),
                (u = (u + Math.imul(et, oe)) | 0),
                (p = (p + Math.imul(et, ae)) | 0),
                (g = (g + Math.imul(U, le)) | 0),
                (u = (u + Math.imul(U, ue)) | 0),
                (u = (u + Math.imul(j, le)) | 0),
                (p = (p + Math.imul(j, ue)) | 0)
            var ls = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ls >>> 26)) | 0),
                (ls &= 67108863),
                (g = Math.imul(Ot, Gt)),
                (u = Math.imul(Ot, zt)),
                (u = (u + Math.imul(Bt, Gt)) | 0),
                (p = Math.imul(Bt, zt)),
                (g = (g + Math.imul(Et, Jt)) | 0),
                (u = (u + Math.imul(Et, Qt)) | 0),
                (u = (u + Math.imul(At, Jt)) | 0),
                (p = (p + Math.imul(At, Qt)) | 0),
                (g = (g + Math.imul(pt, Xt)) | 0),
                (u = (u + Math.imul(pt, Zt)) | 0),
                (u = (u + Math.imul(vt, Xt)) | 0),
                (p = (p + Math.imul(vt, Zt)) | 0),
                (g = (g + Math.imul(ct, te)) | 0),
                (u = (u + Math.imul(ct, ee)) | 0),
                (u = (u + Math.imul(ht, te)) | 0),
                (p = (p + Math.imul(ht, ee)) | 0),
                (g = (g + Math.imul(tt, re)) | 0),
                (u = (u + Math.imul(tt, ne)) | 0),
                (u = (u + Math.imul(rt, re)) | 0),
                (p = (p + Math.imul(rt, ne)) | 0),
                (g = (g + Math.imul(q, ie)) | 0),
                (u = (u + Math.imul(q, se)) | 0),
                (u = (u + Math.imul(X, ie)) | 0),
                (p = (p + Math.imul(X, se)) | 0),
                (g = (g + Math.imul(O, oe)) | 0),
                (u = (u + Math.imul(O, ae)) | 0),
                (u = (u + Math.imul(I, oe)) | 0),
                (p = (p + Math.imul(I, ae)) | 0),
                (g = (g + Math.imul(Z, le)) | 0),
                (u = (u + Math.imul(Z, ue)) | 0),
                (u = (u + Math.imul(et, le)) | 0),
                (p = (p + Math.imul(et, ue)) | 0)
            var us = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (us >>> 26)) | 0),
                (us &= 67108863),
                (g = Math.imul(Ot, Jt)),
                (u = Math.imul(Ot, Qt)),
                (u = (u + Math.imul(Bt, Jt)) | 0),
                (p = Math.imul(Bt, Qt)),
                (g = (g + Math.imul(Et, Xt)) | 0),
                (u = (u + Math.imul(Et, Zt)) | 0),
                (u = (u + Math.imul(At, Xt)) | 0),
                (p = (p + Math.imul(At, Zt)) | 0),
                (g = (g + Math.imul(pt, te)) | 0),
                (u = (u + Math.imul(pt, ee)) | 0),
                (u = (u + Math.imul(vt, te)) | 0),
                (p = (p + Math.imul(vt, ee)) | 0),
                (g = (g + Math.imul(ct, re)) | 0),
                (u = (u + Math.imul(ct, ne)) | 0),
                (u = (u + Math.imul(ht, re)) | 0),
                (p = (p + Math.imul(ht, ne)) | 0),
                (g = (g + Math.imul(tt, ie)) | 0),
                (u = (u + Math.imul(tt, se)) | 0),
                (u = (u + Math.imul(rt, ie)) | 0),
                (p = (p + Math.imul(rt, se)) | 0),
                (g = (g + Math.imul(q, oe)) | 0),
                (u = (u + Math.imul(q, ae)) | 0),
                (u = (u + Math.imul(X, oe)) | 0),
                (p = (p + Math.imul(X, ae)) | 0),
                (g = (g + Math.imul(O, le)) | 0),
                (u = (u + Math.imul(O, ue)) | 0),
                (u = (u + Math.imul(I, le)) | 0),
                (p = (p + Math.imul(I, ue)) | 0)
            var fs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (fs >>> 26)) | 0),
                (fs &= 67108863),
                (g = Math.imul(Ot, Xt)),
                (u = Math.imul(Ot, Zt)),
                (u = (u + Math.imul(Bt, Xt)) | 0),
                (p = Math.imul(Bt, Zt)),
                (g = (g + Math.imul(Et, te)) | 0),
                (u = (u + Math.imul(Et, ee)) | 0),
                (u = (u + Math.imul(At, te)) | 0),
                (p = (p + Math.imul(At, ee)) | 0),
                (g = (g + Math.imul(pt, re)) | 0),
                (u = (u + Math.imul(pt, ne)) | 0),
                (u = (u + Math.imul(vt, re)) | 0),
                (p = (p + Math.imul(vt, ne)) | 0),
                (g = (g + Math.imul(ct, ie)) | 0),
                (u = (u + Math.imul(ct, se)) | 0),
                (u = (u + Math.imul(ht, ie)) | 0),
                (p = (p + Math.imul(ht, se)) | 0),
                (g = (g + Math.imul(tt, oe)) | 0),
                (u = (u + Math.imul(tt, ae)) | 0),
                (u = (u + Math.imul(rt, oe)) | 0),
                (p = (p + Math.imul(rt, ae)) | 0),
                (g = (g + Math.imul(q, le)) | 0),
                (u = (u + Math.imul(q, ue)) | 0),
                (u = (u + Math.imul(X, le)) | 0),
                (p = (p + Math.imul(X, ue)) | 0)
            var cs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (cs >>> 26)) | 0),
                (cs &= 67108863),
                (g = Math.imul(Ot, te)),
                (u = Math.imul(Ot, ee)),
                (u = (u + Math.imul(Bt, te)) | 0),
                (p = Math.imul(Bt, ee)),
                (g = (g + Math.imul(Et, re)) | 0),
                (u = (u + Math.imul(Et, ne)) | 0),
                (u = (u + Math.imul(At, re)) | 0),
                (p = (p + Math.imul(At, ne)) | 0),
                (g = (g + Math.imul(pt, ie)) | 0),
                (u = (u + Math.imul(pt, se)) | 0),
                (u = (u + Math.imul(vt, ie)) | 0),
                (p = (p + Math.imul(vt, se)) | 0),
                (g = (g + Math.imul(ct, oe)) | 0),
                (u = (u + Math.imul(ct, ae)) | 0),
                (u = (u + Math.imul(ht, oe)) | 0),
                (p = (p + Math.imul(ht, ae)) | 0),
                (g = (g + Math.imul(tt, le)) | 0),
                (u = (u + Math.imul(tt, ue)) | 0),
                (u = (u + Math.imul(rt, le)) | 0),
                (p = (p + Math.imul(rt, ue)) | 0)
            var ds = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ds >>> 26)) | 0),
                (ds &= 67108863),
                (g = Math.imul(Ot, re)),
                (u = Math.imul(Ot, ne)),
                (u = (u + Math.imul(Bt, re)) | 0),
                (p = Math.imul(Bt, ne)),
                (g = (g + Math.imul(Et, ie)) | 0),
                (u = (u + Math.imul(Et, se)) | 0),
                (u = (u + Math.imul(At, ie)) | 0),
                (p = (p + Math.imul(At, se)) | 0),
                (g = (g + Math.imul(pt, oe)) | 0),
                (u = (u + Math.imul(pt, ae)) | 0),
                (u = (u + Math.imul(vt, oe)) | 0),
                (p = (p + Math.imul(vt, ae)) | 0),
                (g = (g + Math.imul(ct, le)) | 0),
                (u = (u + Math.imul(ct, ue)) | 0),
                (u = (u + Math.imul(ht, le)) | 0),
                (p = (p + Math.imul(ht, ue)) | 0)
            var hs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (hs >>> 26)) | 0),
                (hs &= 67108863),
                (g = Math.imul(Ot, ie)),
                (u = Math.imul(Ot, se)),
                (u = (u + Math.imul(Bt, ie)) | 0),
                (p = Math.imul(Bt, se)),
                (g = (g + Math.imul(Et, oe)) | 0),
                (u = (u + Math.imul(Et, ae)) | 0),
                (u = (u + Math.imul(At, oe)) | 0),
                (p = (p + Math.imul(At, ae)) | 0),
                (g = (g + Math.imul(pt, le)) | 0),
                (u = (u + Math.imul(pt, ue)) | 0),
                (u = (u + Math.imul(vt, le)) | 0),
                (p = (p + Math.imul(vt, ue)) | 0)
            var ps = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ps >>> 26)) | 0),
                (ps &= 67108863),
                (g = Math.imul(Ot, oe)),
                (u = Math.imul(Ot, ae)),
                (u = (u + Math.imul(Bt, oe)) | 0),
                (p = Math.imul(Bt, ae)),
                (g = (g + Math.imul(Et, le)) | 0),
                (u = (u + Math.imul(Et, ue)) | 0),
                (u = (u + Math.imul(At, le)) | 0),
                (p = (p + Math.imul(At, ue)) | 0)
            var gs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (gs >>> 26)) | 0),
                (gs &= 67108863),
                (g = Math.imul(Ot, le)),
                (u = Math.imul(Ot, ue)),
                (u = (u + Math.imul(Bt, le)) | 0),
                (p = Math.imul(Bt, ue))
            var ms = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            return (
                (v = (((p + (u >>> 13)) | 0) + (ms >>> 26)) | 0),
                (ms &= 67108863),
                (w[0] = Vr),
                (w[1] = Ur),
                (w[2] = Hr),
                (w[3] = qr),
                (w[4] = zr),
                (w[5] = ns),
                (w[6] = is),
                (w[7] = ss),
                (w[8] = os),
                (w[9] = as),
                (w[10] = ls),
                (w[11] = us),
                (w[12] = fs),
                (w[13] = cs),
                (w[14] = ds),
                (w[15] = hs),
                (w[16] = ps),
                (w[17] = gs),
                (w[18] = ms),
                v !== 0 && ((w[19] = v), m.length++),
                m
            )
        }
        Math.imul || (k = M)
        function F(x, a, c) {
            ;(c.negative = a.negative ^ x.negative), (c.length = x.length + a.length)
            for (var m = 0, _ = 0, A = 0; A < c.length - 1; A++) {
                var w = _
                _ = 0
                for (var v = m & 67108863, g = Math.min(A, a.length - 1), u = Math.max(0, A - x.length + 1); u <= g; u++) {
                    var p = A - u,
                        H = x.words[p] | 0,
                        b = a.words[u] | 0,
                        B = H * b,
                        D = B & 67108863
                    ;(w = (w + ((B / 67108864) | 0)) | 0),
                        (D = (D + v) | 0),
                        (v = D & 67108863),
                        (w = (w + (D >>> 26)) | 0),
                        (_ += w >>> 26),
                        (w &= 67108863)
                }
                ;(c.words[A] = v), (m = w), (w = _)
            }
            return m !== 0 ? (c.words[A] = m) : c.length--, c._strip()
        }
        function $(x, a, c) {
            return F(x, a, c)
        }
        ;(s.prototype.mulTo = function (a, c) {
            var m,
                _ = this.length + a.length
            return (
                this.length === 10 && a.length === 10
                    ? (m = k(this, a, c))
                    : _ < 63
                    ? (m = M(this, a, c))
                    : _ < 1024
                    ? (m = F(this, a, c))
                    : (m = $(this, a, c)),
                m
            )
        }),
            (s.prototype.mul = function (a) {
                var c = new s(null)
                return (c.words = new Array(this.length + a.length)), this.mulTo(a, c)
            }),
            (s.prototype.mulf = function (a) {
                var c = new s(null)
                return (c.words = new Array(this.length + a.length)), $(this, a, c)
            }),
            (s.prototype.imul = function (a) {
                return this.clone().mulTo(a, this)
            }),
            (s.prototype.imuln = function (a) {
                var c = a < 0
                c && (a = -a), n(typeof a == "number"), n(a < 67108864)
                for (var m = 0, _ = 0; _ < this.length; _++) {
                    var A = (this.words[_] | 0) * a,
                        w = (A & 67108863) + (m & 67108863)
                    ;(m >>= 26), (m += (A / 67108864) | 0), (m += w >>> 26), (this.words[_] = w & 67108863)
                }
                return m !== 0 && ((this.words[_] = m), this.length++), c ? this.ineg() : this
            }),
            (s.prototype.muln = function (a) {
                return this.clone().imuln(a)
            }),
            (s.prototype.sqr = function () {
                return this.mul(this)
            }),
            (s.prototype.isqr = function () {
                return this.imul(this.clone())
            }),
            (s.prototype.pow = function (a) {
                var c = P(a)
                if (c.length === 0) return new s(1)
                for (var m = this, _ = 0; _ < c.length && c[_] === 0; _++, m = m.sqr());
                if (++_ < c.length) for (var A = m.sqr(); _ < c.length; _++, A = A.sqr()) c[_] !== 0 && (m = m.mul(A))
                return m
            }),
            (s.prototype.iushln = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = (67108863 >>> (26 - c)) << (26 - c),
                    A
                if (c !== 0) {
                    var w = 0
                    for (A = 0; A < this.length; A++) {
                        var v = this.words[A] & _,
                            g = ((this.words[A] | 0) - v) << c
                        ;(this.words[A] = g | w), (w = v >>> (26 - c))
                    }
                    w && ((this.words[A] = w), this.length++)
                }
                if (m !== 0) {
                    for (A = this.length - 1; A >= 0; A--) this.words[A + m] = this.words[A]
                    for (A = 0; A < m; A++) this.words[A] = 0
                    this.length += m
                }
                return this._strip()
            }),
            (s.prototype.ishln = function (a) {
                return n(this.negative === 0), this.iushln(a)
            }),
            (s.prototype.iushrn = function (a, c, m) {
                n(typeof a == "number" && a >= 0)
                var _
                c ? (_ = (c - (c % 26)) / 26) : (_ = 0)
                var A = a % 26,
                    w = Math.min((a - A) / 26, this.length),
                    v = 67108863 ^ ((67108863 >>> A) << A),
                    g = m
                if (((_ -= w), (_ = Math.max(0, _)), g)) {
                    for (var u = 0; u < w; u++) g.words[u] = this.words[u]
                    g.length = w
                }
                if (w !== 0)
                    if (this.length > w) for (this.length -= w, u = 0; u < this.length; u++) this.words[u] = this.words[u + w]
                    else (this.words[0] = 0), (this.length = 1)
                var p = 0
                for (u = this.length - 1; u >= 0 && (p !== 0 || u >= _); u--) {
                    var H = this.words[u] | 0
                    ;(this.words[u] = (p << (26 - A)) | (H >>> A)), (p = H & v)
                }
                return g && p !== 0 && (g.words[g.length++] = p), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip()
            }),
            (s.prototype.ishrn = function (a, c, m) {
                return n(this.negative === 0), this.iushrn(a, c, m)
            }),
            (s.prototype.shln = function (a) {
                return this.clone().ishln(a)
            }),
            (s.prototype.ushln = function (a) {
                return this.clone().iushln(a)
            }),
            (s.prototype.shrn = function (a) {
                return this.clone().ishrn(a)
            }),
            (s.prototype.ushrn = function (a) {
                return this.clone().iushrn(a)
            }),
            (s.prototype.testn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = 1 << c
                if (this.length <= m) return !1
                var A = this.words[m]
                return !!(A & _)
            }),
            (s.prototype.imaskn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26
                if ((n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)) return this
                if ((c !== 0 && m++, (this.length = Math.min(m, this.length)), c !== 0)) {
                    var _ = 67108863 ^ ((67108863 >>> c) << c)
                    this.words[this.length - 1] &= _
                }
                return this._strip()
            }),
            (s.prototype.maskn = function (a) {
                return this.clone().imaskn(a)
            }),
            (s.prototype.iaddn = function (a) {
                return (
                    n(typeof a == "number"),
                    n(a < 67108864),
                    a < 0
                        ? this.isubn(-a)
                        : this.negative !== 0
                        ? this.length === 1 && (this.words[0] | 0) <= a
                            ? ((this.words[0] = a - (this.words[0] | 0)), (this.negative = 0), this)
                            : ((this.negative = 0), this.isubn(a), (this.negative = 1), this)
                        : this._iaddn(a)
                )
            }),
            (s.prototype._iaddn = function (a) {
                this.words[0] += a
                for (var c = 0; c < this.length && this.words[c] >= 67108864; c++)
                    (this.words[c] -= 67108864), c === this.length - 1 ? (this.words[c + 1] = 1) : this.words[c + 1]++
                return (this.length = Math.max(this.length, c + 1)), this
            }),
            (s.prototype.isubn = function (a) {
                if ((n(typeof a == "number"), n(a < 67108864), a < 0)) return this.iaddn(-a)
                if (this.negative !== 0) return (this.negative = 0), this.iaddn(a), (this.negative = 1), this
                if (((this.words[0] -= a), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1)
                else for (var c = 0; c < this.length && this.words[c] < 0; c++) (this.words[c] += 67108864), (this.words[c + 1] -= 1)
                return this._strip()
            }),
            (s.prototype.addn = function (a) {
                return this.clone().iaddn(a)
            }),
            (s.prototype.subn = function (a) {
                return this.clone().isubn(a)
            }),
            (s.prototype.iabs = function () {
                return (this.negative = 0), this
            }),
            (s.prototype.abs = function () {
                return this.clone().iabs()
            }),
            (s.prototype._ishlnsubmul = function (a, c, m) {
                var _ = a.length + m,
                    A
                this._expand(_)
                var w,
                    v = 0
                for (A = 0; A < a.length; A++) {
                    w = (this.words[A + m] | 0) + v
                    var g = (a.words[A] | 0) * c
                    ;(w -= g & 67108863), (v = (w >> 26) - ((g / 67108864) | 0)), (this.words[A + m] = w & 67108863)
                }
                for (; A < this.length - m; A++) (w = (this.words[A + m] | 0) + v), (v = w >> 26), (this.words[A + m] = w & 67108863)
                if (v === 0) return this._strip()
                for (n(v === -1), v = 0, A = 0; A < this.length; A++)
                    (w = -(this.words[A] | 0) + v), (v = w >> 26), (this.words[A] = w & 67108863)
                return (this.negative = 1), this._strip()
            }),
            (s.prototype._wordDiv = function (a, c) {
                var m = this.length - a.length,
                    _ = this.clone(),
                    A = a,
                    w = A.words[A.length - 1] | 0,
                    v = this._countBits(w)
                ;(m = 26 - v), m !== 0 && ((A = A.ushln(m)), _.iushln(m), (w = A.words[A.length - 1] | 0))
                var g = _.length - A.length,
                    u
                if (c !== "mod") {
                    ;(u = new s(null)), (u.length = g + 1), (u.words = new Array(u.length))
                    for (var p = 0; p < u.length; p++) u.words[p] = 0
                }
                var H = _.clone()._ishlnsubmul(A, 1, g)
                H.negative === 0 && ((_ = H), u && (u.words[g] = 1))
                for (var b = g - 1; b >= 0; b--) {
                    var B = (_.words[A.length + b] | 0) * 67108864 + (_.words[A.length + b - 1] | 0)
                    for (B = Math.min((B / w) | 0, 67108863), _._ishlnsubmul(A, B, b); _.negative !== 0; )
                        B--, (_.negative = 0), _._ishlnsubmul(A, 1, b), _.isZero() || (_.negative ^= 1)
                    u && (u.words[b] = B)
                }
                return u && u._strip(), _._strip(), c !== "div" && m !== 0 && _.iushrn(m), { div: u || null, mod: _ }
            }),
            (s.prototype.divmod = function (a, c, m) {
                if ((n(!a.isZero()), this.isZero())) return { div: new s(0), mod: new s(0) }
                var _, A, w
                return this.negative !== 0 && a.negative === 0
                    ? ((w = this.neg().divmod(a, c)),
                      c !== "mod" && (_ = w.div.neg()),
                      c !== "div" && ((A = w.mod.neg()), m && A.negative !== 0 && A.iadd(a)),
                      { div: _, mod: A })
                    : this.negative === 0 && a.negative !== 0
                    ? ((w = this.divmod(a.neg(), c)), c !== "mod" && (_ = w.div.neg()), { div: _, mod: w.mod })
                    : (this.negative & a.negative) !== 0
                    ? ((w = this.neg().divmod(a.neg(), c)),
                      c !== "div" && ((A = w.mod.neg()), m && A.negative !== 0 && A.isub(a)),
                      { div: w.div, mod: A })
                    : a.length > this.length || this.cmp(a) < 0
                    ? { div: new s(0), mod: this }
                    : a.length === 1
                    ? c === "div"
                        ? { div: this.divn(a.words[0]), mod: null }
                        : c === "mod"
                        ? { div: null, mod: new s(this.modrn(a.words[0])) }
                        : { div: this.divn(a.words[0]), mod: new s(this.modrn(a.words[0])) }
                    : this._wordDiv(a, c)
            }),
            (s.prototype.div = function (a) {
                return this.divmod(a, "div", !1).div
            }),
            (s.prototype.mod = function (a) {
                return this.divmod(a, "mod", !1).mod
            }),
            (s.prototype.umod = function (a) {
                return this.divmod(a, "mod", !0).mod
            }),
            (s.prototype.divRound = function (a) {
                var c = this.divmod(a)
                if (c.mod.isZero()) return c.div
                var m = c.div.negative !== 0 ? c.mod.isub(a) : c.mod,
                    _ = a.ushrn(1),
                    A = a.andln(1),
                    w = m.cmp(_)
                return w < 0 || (A === 1 && w === 0) ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1)
            }),
            (s.prototype.modrn = function (a) {
                var c = a < 0
                c && (a = -a), n(a <= 67108863)
                for (var m = (1 << 26) % a, _ = 0, A = this.length - 1; A >= 0; A--) _ = (m * _ + (this.words[A] | 0)) % a
                return c ? -_ : _
            }),
            (s.prototype.modn = function (a) {
                return this.modrn(a)
            }),
            (s.prototype.idivn = function (a) {
                var c = a < 0
                c && (a = -a), n(a <= 67108863)
                for (var m = 0, _ = this.length - 1; _ >= 0; _--) {
                    var A = (this.words[_] | 0) + m * 67108864
                    ;(this.words[_] = (A / a) | 0), (m = A % a)
                }
                return this._strip(), c ? this.ineg() : this
            }),
            (s.prototype.divn = function (a) {
                return this.clone().idivn(a)
            }),
            (s.prototype.egcd = function (a) {
                n(a.negative === 0), n(!a.isZero())
                var c = this,
                    m = a.clone()
                c.negative !== 0 ? (c = c.umod(a)) : (c = c.clone())
                for (var _ = new s(1), A = new s(0), w = new s(0), v = new s(1), g = 0; c.isEven() && m.isEven(); ) c.iushrn(1), m.iushrn(1), ++g
                for (var u = m.clone(), p = c.clone(); !c.isZero(); ) {
                    for (var H = 0, b = 1; (c.words[0] & b) === 0 && H < 26; ++H, b <<= 1);
                    if (H > 0) for (c.iushrn(H); H-- > 0; ) (_.isOdd() || A.isOdd()) && (_.iadd(u), A.isub(p)), _.iushrn(1), A.iushrn(1)
                    for (var B = 0, D = 1; (m.words[0] & D) === 0 && B < 26; ++B, D <<= 1);
                    if (B > 0) for (m.iushrn(B); B-- > 0; ) (w.isOdd() || v.isOdd()) && (w.iadd(u), v.isub(p)), w.iushrn(1), v.iushrn(1)
                    c.cmp(m) >= 0 ? (c.isub(m), _.isub(w), A.isub(v)) : (m.isub(c), w.isub(_), v.isub(A))
                }
                return { a: w, b: v, gcd: m.iushln(g) }
            }),
            (s.prototype._invmp = function (a) {
                n(a.negative === 0), n(!a.isZero())
                var c = this,
                    m = a.clone()
                c.negative !== 0 ? (c = c.umod(a)) : (c = c.clone())
                for (var _ = new s(1), A = new s(0), w = m.clone(); c.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
                    for (var v = 0, g = 1; (c.words[0] & g) === 0 && v < 26; ++v, g <<= 1);
                    if (v > 0) for (c.iushrn(v); v-- > 0; ) _.isOdd() && _.iadd(w), _.iushrn(1)
                    for (var u = 0, p = 1; (m.words[0] & p) === 0 && u < 26; ++u, p <<= 1);
                    if (u > 0) for (m.iushrn(u); u-- > 0; ) A.isOdd() && A.iadd(w), A.iushrn(1)
                    c.cmp(m) >= 0 ? (c.isub(m), _.isub(A)) : (m.isub(c), A.isub(_))
                }
                var H
                return c.cmpn(1) === 0 ? (H = _) : (H = A), H.cmpn(0) < 0 && H.iadd(a), H
            }),
            (s.prototype.gcd = function (a) {
                if (this.isZero()) return a.abs()
                if (a.isZero()) return this.abs()
                var c = this.clone(),
                    m = a.clone()
                ;(c.negative = 0), (m.negative = 0)
                for (var _ = 0; c.isEven() && m.isEven(); _++) c.iushrn(1), m.iushrn(1)
                do {
                    for (; c.isEven(); ) c.iushrn(1)
                    for (; m.isEven(); ) m.iushrn(1)
                    var A = c.cmp(m)
                    if (A < 0) {
                        var w = c
                        ;(c = m), (m = w)
                    } else if (A === 0 || m.cmpn(1) === 0) break
                    c.isub(m)
                } while (!0)
                return m.iushln(_)
            }),
            (s.prototype.invm = function (a) {
                return this.egcd(a).a.umod(a)
            }),
            (s.prototype.isEven = function () {
                return (this.words[0] & 1) === 0
            }),
            (s.prototype.isOdd = function () {
                return (this.words[0] & 1) === 1
            }),
            (s.prototype.andln = function (a) {
                return this.words[0] & a
            }),
            (s.prototype.bincn = function (a) {
                n(typeof a == "number")
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = 1 << c
                if (this.length <= m) return this._expand(m + 1), (this.words[m] |= _), this
                for (var A = _, w = m; A !== 0 && w < this.length; w++) {
                    var v = this.words[w] | 0
                    ;(v += A), (A = v >>> 26), (v &= 67108863), (this.words[w] = v)
                }
                return A !== 0 && ((this.words[w] = A), this.length++), this
            }),
            (s.prototype.isZero = function () {
                return this.length === 1 && this.words[0] === 0
            }),
            (s.prototype.cmpn = function (a) {
                var c = a < 0
                if (this.negative !== 0 && !c) return -1
                if (this.negative === 0 && c) return 1
                this._strip()
                var m
                if (this.length > 1) m = 1
                else {
                    c && (a = -a), n(a <= 67108863, "Number is too big")
                    var _ = this.words[0] | 0
                    m = _ === a ? 0 : _ < a ? -1 : 1
                }
                return this.negative !== 0 ? -m | 0 : m
            }),
            (s.prototype.cmp = function (a) {
                if (this.negative !== 0 && a.negative === 0) return -1
                if (this.negative === 0 && a.negative !== 0) return 1
                var c = this.ucmp(a)
                return this.negative !== 0 ? -c | 0 : c
            }),
            (s.prototype.ucmp = function (a) {
                if (this.length > a.length) return 1
                if (this.length < a.length) return -1
                for (var c = 0, m = this.length - 1; m >= 0; m--) {
                    var _ = this.words[m] | 0,
                        A = a.words[m] | 0
                    if (_ !== A) {
                        _ < A ? (c = -1) : _ > A && (c = 1)
                        break
                    }
                }
                return c
            }),
            (s.prototype.gtn = function (a) {
                return this.cmpn(a) === 1
            }),
            (s.prototype.gt = function (a) {
                return this.cmp(a) === 1
            }),
            (s.prototype.gten = function (a) {
                return this.cmpn(a) >= 0
            }),
            (s.prototype.gte = function (a) {
                return this.cmp(a) >= 0
            }),
            (s.prototype.ltn = function (a) {
                return this.cmpn(a) === -1
            }),
            (s.prototype.lt = function (a) {
                return this.cmp(a) === -1
            }),
            (s.prototype.lten = function (a) {
                return this.cmpn(a) <= 0
            }),
            (s.prototype.lte = function (a) {
                return this.cmp(a) <= 0
            }),
            (s.prototype.eqn = function (a) {
                return this.cmpn(a) === 0
            }),
            (s.prototype.eq = function (a) {
                return this.cmp(a) === 0
            }),
            (s.red = function (a) {
                return new it(a)
            }),
            (s.prototype.toRed = function (a) {
                return (
                    n(!this.red, "Already a number in reduction context"),
                    n(this.negative === 0, "red works only with positives"),
                    a.convertTo(this)._forceRed(a)
                )
            }),
            (s.prototype.fromRed = function () {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }),
            (s.prototype._forceRed = function (a) {
                return (this.red = a), this
            }),
            (s.prototype.forceRed = function (a) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(a)
            }),
            (s.prototype.redAdd = function (a) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, a)
            }),
            (s.prototype.redIAdd = function (a) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a)
            }),
            (s.prototype.redSub = function (a) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, a)
            }),
            (s.prototype.redISub = function (a) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, a)
            }),
            (s.prototype.redShl = function (a) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, a)
            }),
            (s.prototype.redMul = function (a) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a)
            }),
            (s.prototype.redIMul = function (a) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a)
            }),
            (s.prototype.redSqr = function () {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }),
            (s.prototype.redISqr = function () {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }),
            (s.prototype.redSqrt = function () {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }),
            (s.prototype.redInvm = function () {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }),
            (s.prototype.redNeg = function () {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }),
            (s.prototype.redPow = function (a) {
                return n(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a)
            })
        var R = { k256: null, p224: null, p192: null, p25519: null }
        function W(x, a) {
            ;(this.name = x),
                (this.p = new s(a, 16)),
                (this.n = this.p.bitLength()),
                (this.k = new s(1).iushln(this.n).isub(this.p)),
                (this.tmp = this._tmp())
        }
        ;(W.prototype._tmp = function () {
            var a = new s(null)
            return (a.words = new Array(Math.ceil(this.n / 13))), a
        }),
            (W.prototype.ireduce = function (a) {
                var c = a,
                    m
                do this.split(c, this.tmp), (c = this.imulK(c)), (c = c.iadd(this.tmp)), (m = c.bitLength())
                while (m > this.n)
                var _ = m < this.n ? -1 : c.ucmp(this.p)
                return _ === 0 ? ((c.words[0] = 0), (c.length = 1)) : _ > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c
            }),
            (W.prototype.split = function (a, c) {
                a.iushrn(this.n, 0, c)
            }),
            (W.prototype.imulK = function (a) {
                return a.imul(this.k)
            })
        function nt() {
            W.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(nt, W),
            (nt.prototype.split = function (a, c) {
                for (var m = 4194303, _ = Math.min(a.length, 9), A = 0; A < _; A++) c.words[A] = a.words[A]
                if (((c.length = _), a.length <= 9)) {
                    ;(a.words[0] = 0), (a.length = 1)
                    return
                }
                var w = a.words[9]
                for (c.words[c.length++] = w & m, A = 10; A < a.length; A++) {
                    var v = a.words[A] | 0
                    ;(a.words[A - 10] = ((v & m) << 4) | (w >>> 22)), (w = v)
                }
                ;(w >>>= 22), (a.words[A - 10] = w), w === 0 && a.length > 10 ? (a.length -= 10) : (a.length -= 9)
            }),
            (nt.prototype.imulK = function (a) {
                ;(a.words[a.length] = 0), (a.words[a.length + 1] = 0), (a.length += 2)
                for (var c = 0, m = 0; m < a.length; m++) {
                    var _ = a.words[m] | 0
                    ;(c += _ * 977), (a.words[m] = c & 67108863), (c = _ * 64 + ((c / 67108864) | 0))
                }
                return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a
            })
        function J() {
            W.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(J, W)
        function Q() {
            W.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(Q, W)
        function ot() {
            W.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(ot, W),
            (ot.prototype.imulK = function (a) {
                for (var c = 0, m = 0; m < a.length; m++) {
                    var _ = (a.words[m] | 0) * 19 + c,
                        A = _ & 67108863
                    ;(_ >>>= 26), (a.words[m] = A), (c = _)
                }
                return c !== 0 && (a.words[a.length++] = c), a
            }),
            (s._prime = function (a) {
                if (R[a]) return R[a]
                var c
                if (a === "k256") c = new nt()
                else if (a === "p224") c = new J()
                else if (a === "p192") c = new Q()
                else if (a === "p25519") c = new ot()
                else throw new Error("Unknown prime " + a)
                return (R[a] = c), c
            })
        function it(x) {
            if (typeof x == "string") {
                var a = s._prime(x)
                ;(this.m = a.p), (this.prime = a)
            } else n(x.gtn(1), "modulus must be greater than 1"), (this.m = x), (this.prime = null)
        }
        ;(it.prototype._verify1 = function (a) {
            n(a.negative === 0, "red works only with positives"), n(a.red, "red works only with red numbers")
        }),
            (it.prototype._verify2 = function (a, c) {
                n((a.negative | c.negative) === 0, "red works only with positives"),
                    n(a.red && a.red === c.red, "red works only with red numbers")
            }),
            (it.prototype.imod = function (a) {
                return this.prime ? this.prime.ireduce(a)._forceRed(this) : (h(a, a.umod(this.m)._forceRed(this)), a)
            }),
            (it.prototype.neg = function (a) {
                return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
            }),
            (it.prototype.add = function (a, c) {
                this._verify2(a, c)
                var m = a.add(c)
                return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this)
            }),
            (it.prototype.iadd = function (a, c) {
                this._verify2(a, c)
                var m = a.iadd(c)
                return m.cmp(this.m) >= 0 && m.isub(this.m), m
            }),
            (it.prototype.sub = function (a, c) {
                this._verify2(a, c)
                var m = a.sub(c)
                return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this)
            }),
            (it.prototype.isub = function (a, c) {
                this._verify2(a, c)
                var m = a.isub(c)
                return m.cmpn(0) < 0 && m.iadd(this.m), m
            }),
            (it.prototype.shl = function (a, c) {
                return this._verify1(a), this.imod(a.ushln(c))
            }),
            (it.prototype.imul = function (a, c) {
                return this._verify2(a, c), this.imod(a.imul(c))
            }),
            (it.prototype.mul = function (a, c) {
                return this._verify2(a, c), this.imod(a.mul(c))
            }),
            (it.prototype.isqr = function (a) {
                return this.imul(a, a.clone())
            }),
            (it.prototype.sqr = function (a) {
                return this.mul(a, a)
            }),
            (it.prototype.sqrt = function (a) {
                if (a.isZero()) return a.clone()
                var c = this.m.andln(3)
                if ((n(c % 2 === 1), c === 3)) {
                    var m = this.m.add(new s(1)).iushrn(2)
                    return this.pow(a, m)
                }
                for (var _ = this.m.subn(1), A = 0; !_.isZero() && _.andln(1) === 0; ) A++, _.iushrn(1)
                n(!_.isZero())
                var w = new s(1).toRed(this),
                    v = w.redNeg(),
                    g = this.m.subn(1).iushrn(1),
                    u = this.m.bitLength()
                for (u = new s(2 * u * u).toRed(this); this.pow(u, g).cmp(v) !== 0; ) u.redIAdd(v)
                for (var p = this.pow(u, _), H = this.pow(a, _.addn(1).iushrn(1)), b = this.pow(a, _), B = A; b.cmp(w) !== 0; ) {
                    for (var D = b, U = 0; D.cmp(w) !== 0; U++) D = D.redSqr()
                    n(U < B)
                    var j = this.pow(p, new s(1).iushln(B - U - 1))
                    ;(H = H.redMul(j)), (p = j.redSqr()), (b = b.redMul(p)), (B = U)
                }
                return H
            }),
            (it.prototype.invm = function (a) {
                var c = a._invmp(this.m)
                return c.negative !== 0 ? ((c.negative = 0), this.imod(c).redNeg()) : this.imod(c)
            }),
            (it.prototype.pow = function (a, c) {
                if (c.isZero()) return new s(1).toRed(this)
                if (c.cmpn(1) === 0) return a.clone()
                var m = 4,
                    _ = new Array(1 << m)
                ;(_[0] = new s(1).toRed(this)), (_[1] = a)
                for (var A = 2; A < _.length; A++) _[A] = this.mul(_[A - 1], a)
                var w = _[0],
                    v = 0,
                    g = 0,
                    u = c.bitLength() % 26
                for (u === 0 && (u = 26), A = c.length - 1; A >= 0; A--) {
                    for (var p = c.words[A], H = u - 1; H >= 0; H--) {
                        var b = (p >> H) & 1
                        if ((w !== _[0] && (w = this.sqr(w)), b === 0 && v === 0)) {
                            g = 0
                            continue
                        }
                        ;(v <<= 1), (v |= b), g++, !(g !== m && (A !== 0 || H !== 0)) && ((w = this.mul(w, _[v])), (g = 0), (v = 0))
                    }
                    u = 26
                }
                return w
            }),
            (it.prototype.convertTo = function (a) {
                var c = a.umod(this.m)
                return c === a ? c.clone() : c
            }),
            (it.prototype.convertFrom = function (a) {
                var c = a.clone()
                return (c.red = null), c
            }),
            (s.mont = function (a) {
                return new at(a)
            })
        function at(x) {
            it.call(this, x),
                (this.shift = this.m.bitLength()),
                this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
                (this.r = new s(1).iushln(this.shift)),
                (this.r2 = this.imod(this.r.sqr())),
                (this.rinv = this.r._invmp(this.m)),
                (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                (this.minv = this.minv.umod(this.r)),
                (this.minv = this.r.sub(this.minv))
        }
        i(at, it),
            (at.prototype.convertTo = function (a) {
                return this.imod(a.ushln(this.shift))
            }),
            (at.prototype.convertFrom = function (a) {
                var c = this.imod(a.mul(this.rinv))
                return (c.red = null), c
            }),
            (at.prototype.imul = function (a, c) {
                if (a.isZero() || c.isZero()) return (a.words[0] = 0), (a.length = 1), a
                var m = a.imul(c),
                    _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    A = m.isub(_).iushrn(this.shift),
                    w = A
                return A.cmp(this.m) >= 0 ? (w = A.isub(this.m)) : A.cmpn(0) < 0 && (w = A.iadd(this.m)), w._forceRed(this)
            }),
            (at.prototype.mul = function (a, c) {
                if (a.isZero() || c.isZero()) return new s(0)._forceRed(this)
                var m = a.mul(c),
                    _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    A = m.isub(_).iushrn(this.shift),
                    w = A
                return A.cmp(this.m) >= 0 ? (w = A.isub(this.m)) : A.cmpn(0) < 0 && (w = A.iadd(this.m)), w._forceRed(this)
            }),
            (at.prototype.invm = function (a) {
                var c = this.imod(a._invmp(this.m).mul(this.r2))
                return c._forceRed(this)
            })
    })(e, Bd)
})(nv)
var G2 = nv.exports
const W2 = "logger/5.7.0"
let b0 = !1,
    y0 = !1
const Vl = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 }
let _0 = Vl.default,
    Cf = null
function Y2() {
    try {
        const e = []
        if (
            (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
                try {
                    if ("test".normalize(t) !== "test") throw new Error("bad normalize")
                } catch {
                    e.push(t)
                }
            }),
            e.length)
        )
            throw new Error("missing " + e.join(", "))
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (e) {
        return e.message
    }
    return null
}
const w0 = Y2()
var Nc
;(function (e) {
    ;(e.DEBUG = "DEBUG"), (e.INFO = "INFO"), (e.WARNING = "WARNING"), (e.ERROR = "ERROR"), (e.OFF = "OFF")
})(Nc || (Nc = {}))
var an
;(function (e) {
    ;(e.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
        (e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
        (e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
        (e.NETWORK_ERROR = "NETWORK_ERROR"),
        (e.SERVER_ERROR = "SERVER_ERROR"),
        (e.TIMEOUT = "TIMEOUT"),
        (e.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
        (e.NUMERIC_FAULT = "NUMERIC_FAULT"),
        (e.MISSING_NEW = "MISSING_NEW"),
        (e.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
        (e.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
        (e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
        (e.CALL_EXCEPTION = "CALL_EXCEPTION"),
        (e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
        (e.NONCE_EXPIRED = "NONCE_EXPIRED"),
        (e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
        (e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
        (e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"),
        (e.ACTION_REJECTED = "ACTION_REJECTED")
})(an || (an = {}))
const A0 = "0123456789abcdef"
class ut {
    constructor(t) {
        Object.defineProperty(this, "version", { enumerable: !0, value: t, writable: !1 })
    }
    _log(t, r) {
        const n = t.toLowerCase()
        Vl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(_0 > Vl[n]) && console.log.apply(console, r)
    }
    debug(...t) {
        this._log(ut.levels.DEBUG, t)
    }
    info(...t) {
        this._log(ut.levels.INFO, t)
    }
    warn(...t) {
        this._log(ut.levels.WARNING, t)
    }
    makeError(t, r, n) {
        if (y0) return this.makeError("censored error", r, {})
        r || (r = ut.errors.UNKNOWN_ERROR), n || (n = {})
        const i = []
        Object.keys(n).forEach((f) => {
            const d = n[f]
            try {
                if (d instanceof Uint8Array) {
                    let h = ""
                    for (let y = 0; y < d.length; y++) (h += A0[d[y] >> 4]), (h += A0[d[y] & 15])
                    i.push(f + "=Uint8Array(0x" + h + ")")
                } else i.push(f + "=" + JSON.stringify(d))
            } catch {
                i.push(f + "=" + JSON.stringify(n[f].toString()))
            }
        }),
            i.push(`code=${r}`),
            i.push(`version=${this.version}`)
        const s = t
        let o = ""
        switch (r) {
            case an.NUMERIC_FAULT: {
                o = "NUMERIC_FAULT"
                const f = t
                switch (f) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        o += "-" + f
                        break
                    case "negative-power":
                    case "negative-width":
                        o += "-unsupported"
                        break
                    case "unbound-bitwise-result":
                        o += "-unbound-result"
                        break
                }
                break
            }
            case an.CALL_EXCEPTION:
            case an.INSUFFICIENT_FUNDS:
            case an.MISSING_NEW:
            case an.NONCE_EXPIRED:
            case an.REPLACEMENT_UNDERPRICED:
            case an.TRANSACTION_REPLACED:
            case an.UNPREDICTABLE_GAS_LIMIT:
                o = r
                break
        }
        o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (t += " (" + i.join(", ") + ")")
        const l = new Error(t)
        return (
            (l.reason = s),
            (l.code = r),
            Object.keys(n).forEach(function (f) {
                l[f] = n[f]
            }),
            l
        )
    }
    throwError(t, r, n) {
        throw this.makeError(t, r, n)
    }
    throwArgumentError(t, r, n) {
        return this.throwError(t, ut.errors.INVALID_ARGUMENT, { argument: r, value: n })
    }
    assert(t, r, n, i) {
        t || this.throwError(r, n, i)
    }
    assertArgument(t, r, n, i) {
        t || this.throwArgumentError(r, n, i)
    }
    checkNormalize(t) {
        w0 &&
            this.throwError("platform missing String.prototype.normalize", ut.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize",
                form: w0,
            })
    }
    checkSafeUint53(t, r) {
        typeof t == "number" &&
            (r == null && (r = "value not safe"),
            (t < 0 || t >= 9007199254740991) &&
                this.throwError(r, ut.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: t }),
            t % 1 && this.throwError(r, ut.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: t }))
    }
    checkArgumentCount(t, r, n) {
        n ? (n = ": " + n) : (n = ""),
            t < r && this.throwError("missing argument" + n, ut.errors.MISSING_ARGUMENT, { count: t, expectedCount: r }),
            t > r && this.throwError("too many arguments" + n, ut.errors.UNEXPECTED_ARGUMENT, { count: t, expectedCount: r })
    }
    checkNew(t, r) {
        ;(t === Object || t == null) && this.throwError("missing new", ut.errors.MISSING_NEW, { name: r.name })
    }
    checkAbstract(t, r) {
        t === r
            ? this.throwError(
                  "cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class",
                  ut.errors.UNSUPPORTED_OPERATION,
                  { name: t.name, operation: "new" }
              )
            : (t === Object || t == null) && this.throwError("missing new", ut.errors.MISSING_NEW, { name: r.name })
    }
    static globalLogger() {
        return Cf || (Cf = new ut(W2)), Cf
    }
    static setCensorship(t, r) {
        if (
            (!t &&
                r &&
                this.globalLogger().throwError("cannot permanently disable censorship", ut.errors.UNSUPPORTED_OPERATION, {
                    operation: "setCensorship",
                }),
            b0)
        ) {
            if (!t) return
            this.globalLogger().throwError("error censorship permanent", ut.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" })
        }
        ;(y0 = !!t), (b0 = !!r)
    }
    static setLogLevel(t) {
        const r = Vl[t.toLowerCase()]
        if (r == null) {
            ut.globalLogger().warn("invalid log level - " + t)
            return
        }
        _0 = r
    }
    static from(t) {
        return new ut(t)
    }
}
ut.errors = an
ut.levels = Nc
const J2 = "bytes/5.7.0",
    Ve = new ut(J2)
function iv(e) {
    return !!e.toHexString
}
function bo(e) {
    return (
        e.slice ||
            (e.slice = function () {
                const t = Array.prototype.slice.call(arguments)
                return bo(new Uint8Array(Array.prototype.slice.apply(e, t)))
            }),
        e
    )
}
function Pd(e) {
    return (Te(e) && !(e.length % 2)) || rl(e)
}
function E0(e) {
    return typeof e == "number" && e == e && e % 1 === 0
}
function rl(e) {
    if (e == null) return !1
    if (e.constructor === Uint8Array) return !0
    if (typeof e == "string" || !E0(e.length) || e.length < 0) return !1
    for (let t = 0; t < e.length; t++) {
        const r = e[t]
        if (!E0(r) || r < 0 || r >= 256) return !1
    }
    return !0
}
function Wt(e, t) {
    if ((t || (t = {}), typeof e == "number")) {
        Ve.checkSafeUint53(e, "invalid arrayify value")
        const r = []
        for (; e; ) r.unshift(e & 255), (e = parseInt(String(e / 256)))
        return r.length === 0 && r.push(0), bo(new Uint8Array(r))
    }
    if ((t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), iv(e) && (e = e.toHexString()), Te(e))) {
        let r = e.substring(2)
        r.length % 2 &&
            (t.hexPad === "left"
                ? (r = "0" + r)
                : t.hexPad === "right"
                ? (r += "0")
                : Ve.throwArgumentError("hex data is odd-length", "value", e))
        const n = []
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16))
        return bo(new Uint8Array(n))
    }
    return rl(e) ? bo(new Uint8Array(e)) : Ve.throwArgumentError("invalid arrayify value", "value", e)
}
function Ar(e) {
    const t = e.map((i) => Wt(i)),
        r = t.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r)
    return t.reduce((i, s) => (n.set(s, i), i + s.length), 0), bo(n)
}
function So(e) {
    let t = Wt(e)
    if (t.length === 0) return t
    let r = 0
    for (; r < t.length && t[r] === 0; ) r++
    return r && (t = t.slice(r)), t
}
function Q2(e, t) {
    ;(e = Wt(e)), e.length > t && Ve.throwArgumentError("value out of range", "value", arguments[0])
    const r = new Uint8Array(t)
    return r.set(e, t - e.length), bo(r)
}
function Te(e, t) {
    return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || (t && e.length !== 2 + 2 * t))
}
const Mf = "0123456789abcdef"
function Lt(e, t) {
    if ((t || (t = {}), typeof e == "number")) {
        Ve.checkSafeUint53(e, "invalid hexlify value")
        let r = ""
        for (; e; ) (r = Mf[e & 15] + r), (e = Math.floor(e / 16))
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof e == "bigint") return (e = e.toString(16)), e.length % 2 ? "0x0" + e : "0x" + e
    if ((t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), iv(e))) return e.toHexString()
    if (Te(e))
        return (
            e.length % 2 &&
                (t.hexPad === "left"
                    ? (e = "0x0" + e.substring(2))
                    : t.hexPad === "right"
                    ? (e += "0")
                    : Ve.throwArgumentError("hex data is odd-length", "value", e)),
            e.toLowerCase()
        )
    if (rl(e)) {
        let r = "0x"
        for (let n = 0; n < e.length; n++) {
            let i = e[n]
            r += Mf[(i & 240) >> 4] + Mf[i & 15]
        }
        return r
    }
    return Ve.throwArgumentError("invalid hexlify value", "value", e)
}
function Is(e) {
    if (typeof e != "string") e = Lt(e)
    else if (!Te(e) || e.length % 2) return null
    return (e.length - 2) / 2
}
function fr(e, t, r) {
    return (
        typeof e != "string" ? (e = Lt(e)) : (!Te(e) || e.length % 2) && Ve.throwArgumentError("invalid hexData", "value", e),
        (t = 2 + 2 * t),
        r != null ? "0x" + e.substring(t, 2 + 2 * r) : "0x" + e.substring(t)
    )
}
function _r(e) {
    let t = "0x"
    return (
        e.forEach((r) => {
            t += Lt(r).substring(2)
        }),
        t
    )
}
function Rd(e) {
    const t = Ld(Lt(e, { hexPad: "left" }))
    return t === "0x" ? "0x0" : t
}
function Ld(e) {
    typeof e != "string" && (e = Lt(e)), Te(e) || Ve.throwArgumentError("invalid hex string", "value", e), (e = e.substring(2))
    let t = 0
    for (; t < e.length && e[t] === "0"; ) t++
    return "0x" + e.substring(t)
}
function He(e, t) {
    for (
        typeof e != "string" ? (e = Lt(e)) : Te(e) || Ve.throwArgumentError("invalid hex string", "value", e),
            e.length > 2 * t + 2 && Ve.throwArgumentError("value out of range", "value", arguments[1]);
        e.length < 2 * t + 2;

    )
        e = "0x0" + e.substring(2)
    return e
}
function Yu(e) {
    const t = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0, yParityAndS: "0x", compact: "0x" }
    if (Pd(e)) {
        let r = Wt(e)
        r.length === 64
            ? ((t.v = 27 + (r[32] >> 7)), (r[32] &= 127), (t.r = Lt(r.slice(0, 32))), (t.s = Lt(r.slice(32, 64))))
            : r.length === 65
            ? ((t.r = Lt(r.slice(0, 32))), (t.s = Lt(r.slice(32, 64))), (t.v = r[64]))
            : Ve.throwArgumentError("invalid signature string", "signature", e),
            t.v < 27 && (t.v === 0 || t.v === 1 ? (t.v += 27) : Ve.throwArgumentError("signature invalid v byte", "signature", e)),
            (t.recoveryParam = 1 - (t.v % 2)),
            t.recoveryParam && (r[32] |= 128),
            (t._vs = Lt(r.slice(32, 64)))
    } else {
        if (((t.r = e.r), (t.s = e.s), (t.v = e.v), (t.recoveryParam = e.recoveryParam), (t._vs = e._vs), t._vs != null)) {
            const i = Q2(Wt(t._vs), 32)
            t._vs = Lt(i)
            const s = i[0] >= 128 ? 1 : 0
            t.recoveryParam == null
                ? (t.recoveryParam = s)
                : t.recoveryParam !== s && Ve.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e),
                (i[0] &= 127)
            const o = Lt(i)
            t.s == null ? (t.s = o) : t.s !== o && Ve.throwArgumentError("signature v mismatch _vs", "signature", e)
        }
        if (t.recoveryParam == null)
            t.v == null
                ? Ve.throwArgumentError("signature missing v and recoveryParam", "signature", e)
                : t.v === 0 || t.v === 1
                ? (t.recoveryParam = t.v)
                : (t.recoveryParam = 1 - (t.v % 2))
        else if (t.v == null) t.v = 27 + t.recoveryParam
        else {
            const i = t.v === 0 || t.v === 1 ? t.v : 1 - (t.v % 2)
            t.recoveryParam !== i && Ve.throwArgumentError("signature recoveryParam mismatch v", "signature", e)
        }
        t.r == null || !Te(t.r) ? Ve.throwArgumentError("signature missing or invalid r", "signature", e) : (t.r = He(t.r, 32)),
            t.s == null || !Te(t.s) ? Ve.throwArgumentError("signature missing or invalid s", "signature", e) : (t.s = He(t.s, 32))
        const r = Wt(t.s)
        r[0] >= 128 && Ve.throwArgumentError("signature s out of range", "signature", e), t.recoveryParam && (r[0] |= 128)
        const n = Lt(r)
        t._vs && (Te(t._vs) || Ve.throwArgumentError("signature invalid _vs", "signature", e), (t._vs = He(t._vs, 32))),
            t._vs == null ? (t._vs = n) : t._vs !== n && Ve.throwArgumentError("signature _vs mismatch v and s", "signature", e)
    }
    return (t.yParityAndS = t._vs), (t.compact = t.r + t.yParityAndS.substring(2)), t
}
const X2 = "bignumber/5.7.0"
var cu = G2.BN
const Yn = new ut(X2),
    Sf = {},
    x0 = 9007199254740991
let T0 = !1
class St {
    constructor(t, r) {
        t !== Sf &&
            Yn.throwError("cannot call constructor directly; use BigNumber.from", ut.errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)",
            }),
            (this._hex = r),
            (this._isBigNumber = !0),
            Object.freeze(this)
    }
    fromTwos(t) {
        return br(be(this).fromTwos(t))
    }
    toTwos(t) {
        return br(be(this).toTwos(t))
    }
    abs() {
        return this._hex[0] === "-" ? St.from(this._hex.substring(1)) : this
    }
    add(t) {
        return br(be(this).add(be(t)))
    }
    sub(t) {
        return br(be(this).sub(be(t)))
    }
    div(t) {
        return St.from(t).isZero() && Kr("division-by-zero", "div"), br(be(this).div(be(t)))
    }
    mul(t) {
        return br(be(this).mul(be(t)))
    }
    mod(t) {
        const r = be(t)
        return r.isNeg() && Kr("division-by-zero", "mod"), br(be(this).umod(r))
    }
    pow(t) {
        const r = be(t)
        return r.isNeg() && Kr("negative-power", "pow"), br(be(this).pow(r))
    }
    and(t) {
        const r = be(t)
        return (this.isNegative() || r.isNeg()) && Kr("unbound-bitwise-result", "and"), br(be(this).and(r))
    }
    or(t) {
        const r = be(t)
        return (this.isNegative() || r.isNeg()) && Kr("unbound-bitwise-result", "or"), br(be(this).or(r))
    }
    xor(t) {
        const r = be(t)
        return (this.isNegative() || r.isNeg()) && Kr("unbound-bitwise-result", "xor"), br(be(this).xor(r))
    }
    mask(t) {
        return (this.isNegative() || t < 0) && Kr("negative-width", "mask"), br(be(this).maskn(t))
    }
    shl(t) {
        return (this.isNegative() || t < 0) && Kr("negative-width", "shl"), br(be(this).shln(t))
    }
    shr(t) {
        return (this.isNegative() || t < 0) && Kr("negative-width", "shr"), br(be(this).shrn(t))
    }
    eq(t) {
        return be(this).eq(be(t))
    }
    lt(t) {
        return be(this).lt(be(t))
    }
    lte(t) {
        return be(this).lte(be(t))
    }
    gt(t) {
        return be(this).gt(be(t))
    }
    gte(t) {
        return be(this).gte(be(t))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return be(this).isZero()
    }
    toNumber() {
        try {
            return be(this).toNumber()
        } catch {
            Kr("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return Yn.throwError("this platform does not support BigInt", ut.errors.UNSUPPORTED_OPERATION, { value: this.toString() })
    }
    toString() {
        return (
            arguments.length > 0 &&
                (arguments[0] === 10
                    ? T0 || ((T0 = !0), Yn.warn("BigNumber.toString does not accept any parameters; base-10 is assumed"))
                    : arguments[0] === 16
                    ? Yn.throwError(
                          "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
                          ut.errors.UNEXPECTED_ARGUMENT,
                          {}
                      )
                    : Yn.throwError("BigNumber.toString does not accept parameters", ut.errors.UNEXPECTED_ARGUMENT, {})),
            be(this).toString(10)
        )
    }
    toHexString() {
        return this._hex
    }
    toJSON(t) {
        return { type: "BigNumber", hex: this.toHexString() }
    }
    static from(t) {
        if (t instanceof St) return t
        if (typeof t == "string")
            return t.match(/^-?0x[0-9a-f]+$/i)
                ? new St(Sf, Da(t))
                : t.match(/^-?[0-9]+$/)
                ? new St(Sf, Da(new cu(t)))
                : Yn.throwArgumentError("invalid BigNumber string", "value", t)
        if (typeof t == "number")
            return (
                t % 1 && Kr("underflow", "BigNumber.from", t), (t >= x0 || t <= -x0) && Kr("overflow", "BigNumber.from", t), St.from(String(t))
            )
        const r = t
        if (typeof r == "bigint") return St.from(r.toString())
        if (rl(r)) return St.from(Lt(r))
        if (r)
            if (r.toHexString) {
                const n = r.toHexString()
                if (typeof n == "string") return St.from(n)
            } else {
                let n = r._hex
                if (
                    (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Te(n) || (n[0] === "-" && Te(n.substring(1)))))
                )
                    return St.from(n)
            }
        return Yn.throwArgumentError("invalid BigNumber value", "value", t)
    }
    static isBigNumber(t) {
        return !!(t && t._isBigNumber)
    }
}
function Da(e) {
    if (typeof e != "string") return Da(e.toString(16))
    if (e[0] === "-")
        return (e = e.substring(1)), e[0] === "-" && Yn.throwArgumentError("invalid hex", "value", e), (e = Da(e)), e === "0x00" ? e : "-" + e
    if ((e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")) return "0x00"
    for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; ) e = "0x" + e.substring(4)
    return e
}
function br(e) {
    return St.from(Da(e))
}
function be(e) {
    const t = St.from(e).toHexString()
    return t[0] === "-" ? new cu("-" + t.substring(3), 16) : new cu(t.substring(2), 16)
}
function Kr(e, t, r) {
    const n = { fault: e, operation: t }
    return r != null && (n.value = r), Yn.throwError(e, ut.errors.NUMERIC_FAULT, n)
}
function Z2(e) {
    return new cu(e, 36).toString(16)
}
const tE = "properties/5.7.0"
var eE =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const du = new ut(tE)
function _t(e, t, r) {
    Object.defineProperty(e, t, { enumerable: !0, value: r, writable: !1 })
}
function Ir(e, t) {
    for (let r = 0; r < 32; r++) {
        if (e[t]) return e[t]
        if (!e.prototype || typeof e.prototype != "object") break
        e = Object.getPrototypeOf(e.prototype).constructor
    }
    return null
}
function Ge(e) {
    return eE(this, void 0, void 0, function* () {
        const t = Object.keys(e).map((n) => {
            const i = e[n]
            return Promise.resolve(i).then((s) => ({ key: n, value: s }))
        })
        return (yield Promise.all(t)).reduce((n, i) => ((n[i.key] = i.value), n), {})
    })
}
function rE(e, t) {
    ;(!e || typeof e != "object") && du.throwArgumentError("invalid object", "object", e),
        Object.keys(e).forEach((r) => {
            t[r] || du.throwArgumentError("invalid object key - " + r, "transaction:" + r, e)
        })
}
function Ye(e) {
    const t = {}
    for (const r in e) t[r] = e[r]
    return t
}
const nE = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 }
function sv(e) {
    if (e == null || nE[typeof e]) return !0
    if (Array.isArray(e) || typeof e == "object") {
        if (!Object.isFrozen(e)) return !1
        const t = Object.keys(e)
        for (let r = 0; r < t.length; r++) {
            let n = null
            try {
                n = e[t[r]]
            } catch {
                continue
            }
            if (!sv(n)) return !1
        }
        return !0
    }
    return du.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
}
function iE(e) {
    if (sv(e)) return e
    if (Array.isArray(e)) return Object.freeze(e.map((t) => fi(t)))
    if (typeof e == "object") {
        const t = {}
        for (const r in e) {
            const n = e[r]
            n !== void 0 && _t(t, r, fi(n))
        }
        return t
    }
    return du.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
}
function fi(e) {
    return iE(e)
}
class nl {
    constructor(t) {
        for (const r in t) this[r] = fi(t[r])
    }
}
const il = "abi/5.7.0",
    we = new ut(il),
    Bs = {}
let C0 = { calldata: !0, memory: !0, storage: !0 },
    sE = { calldata: !0, memory: !0 }
function El(e, t) {
    if (e === "bytes" || e === "string") {
        if (C0[t]) return !0
    } else if (e === "address") {
        if (t === "payable") return !0
    } else if ((e.indexOf("[") >= 0 || e === "tuple") && sE[t]) return !0
    return (C0[t] || t === "payable") && we.throwArgumentError("invalid modifier", "name", t), !1
}
function oE(e, t) {
    let r = e
    function n(l) {
        we.throwArgumentError(`unexpected character at position ${l}`, "param", e)
    }
    e = e.replace(/\s/g, " ")
    function i(l) {
        let f = { type: "", name: "", parent: l, state: { allowType: !0 } }
        return t && (f.indexed = !1), f
    }
    let s = { type: "", name: "", state: { allowType: !0 } },
        o = s
    for (let l = 0; l < e.length; l++) {
        let f = e[l]
        switch (f) {
            case "(":
                o.state.allowType && o.type === "" ? (o.type = "tuple") : o.state.allowParams || n(l),
                    (o.state.allowType = !1),
                    (o.type = io(o.type)),
                    (o.components = [i(o)]),
                    (o = o.components[0])
                break
            case ")":
                delete o.state,
                    o.name === "indexed" && (t || n(l), (o.indexed = !0), (o.name = "")),
                    El(o.type, o.name) && (o.name = ""),
                    (o.type = io(o.type))
                let d = o
                ;(o = o.parent), o || n(l), delete d.parent, (o.state.allowParams = !1), (o.state.allowName = !0), (o.state.allowArray = !0)
                break
            case ",":
                delete o.state,
                    o.name === "indexed" && (t || n(l), (o.indexed = !0), (o.name = "")),
                    El(o.type, o.name) && (o.name = ""),
                    (o.type = io(o.type))
                let h = i(o.parent)
                o.parent.components.push(h), delete o.parent, (o = h)
                break
            case " ":
                o.state.allowType &&
                    o.type !== "" &&
                    ((o.type = io(o.type)), delete o.state.allowType, (o.state.allowName = !0), (o.state.allowParams = !0)),
                    o.state.allowName &&
                        o.name !== "" &&
                        (o.name === "indexed"
                            ? (t || n(l), o.indexed && n(l), (o.indexed = !0), (o.name = ""))
                            : El(o.type, o.name)
                            ? (o.name = "")
                            : (o.state.allowName = !1))
                break
            case "[":
                o.state.allowArray || n(l), (o.type += f), (o.state.allowArray = !1), (o.state.allowName = !1), (o.state.readArray = !0)
                break
            case "]":
                o.state.readArray || n(l), (o.type += f), (o.state.readArray = !1), (o.state.allowArray = !0), (o.state.allowName = !0)
                break
            default:
                o.state.allowType
                    ? ((o.type += f), (o.state.allowParams = !0), (o.state.allowArray = !0))
                    : o.state.allowName
                    ? ((o.name += f), delete o.state.allowArray)
                    : o.state.readArray
                    ? (o.type += f)
                    : n(l)
        }
    }
    return (
        o.parent && we.throwArgumentError("unexpected eof", "param", e),
        delete s.state,
        o.name === "indexed"
            ? (t || n(r.length - 7), o.indexed && n(r.length - 7), (o.indexed = !0), (o.name = ""))
            : El(o.type, o.name) && (o.name = ""),
        (s.type = io(s.type)),
        s
    )
}
function Ul(e, t) {
    for (let r in t) _t(e, r, t[r])
}
const xe = Object.freeze({ sighash: "sighash", minimal: "minimal", full: "full", json: "json" }),
    aE = new RegExp(/^(.*)\[([0-9]*)\]$/)
class er {
    constructor(t, r) {
        t !== Bs && we.throwError("use fromString", ut.errors.UNSUPPORTED_OPERATION, { operation: "new ParamType()" }), Ul(this, r)
        let n = this.type.match(aE)
        n
            ? Ul(this, {
                  arrayLength: parseInt(n[2] || "-1"),
                  arrayChildren: er.fromObject({ type: n[1], components: this.components }),
                  baseType: "array",
              })
            : Ul(this, { arrayLength: null, arrayChildren: null, baseType: this.components != null ? "tuple" : this.type }),
            (this._isParamType = !0),
            Object.freeze(this)
    }
    format(t) {
        if ((t || (t = xe.sighash), xe[t] || we.throwArgumentError("invalid format type", "format", t), t === xe.json)) {
            let n = { type: this.baseType === "tuple" ? "tuple" : this.type, name: this.name || void 0 }
            return (
                typeof this.indexed == "boolean" && (n.indexed = this.indexed),
                this.components && (n.components = this.components.map((i) => JSON.parse(i.format(t)))),
                JSON.stringify(n)
            )
        }
        let r = ""
        return (
            this.baseType === "array"
                ? ((r += this.arrayChildren.format(t)), (r += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]"))
                : this.baseType === "tuple"
                ? (t !== xe.sighash && (r += this.type),
                  (r += "(" + this.components.map((n) => n.format(t)).join(t === xe.full ? ", " : ",") + ")"))
                : (r += this.type),
            t !== xe.sighash && (this.indexed === !0 && (r += " indexed"), t === xe.full && this.name && (r += " " + this.name)),
            r
        )
    }
    static from(t, r) {
        return typeof t == "string" ? er.fromString(t, r) : er.fromObject(t)
    }
    static fromObject(t) {
        return er.isParamType(t)
            ? t
            : new er(Bs, {
                  name: t.name || null,
                  type: io(t.type),
                  indexed: t.indexed == null ? null : !!t.indexed,
                  components: t.components ? t.components.map(er.fromObject) : null,
              })
    }
    static fromString(t, r) {
        function n(i) {
            return er.fromObject({ name: i.name, type: i.type, indexed: i.indexed, components: i.components })
        }
        return n(oE(t, !!r))
    }
    static isParamType(t) {
        return !!(t != null && t._isParamType)
    }
}
function $a(e, t) {
    return uE(e).map((r) => er.fromString(r, t))
}
class ei {
    constructor(t, r) {
        t !== Bs && we.throwError("use a static from method", ut.errors.UNSUPPORTED_OPERATION, { operation: "new Fragment()" }),
            Ul(this, r),
            (this._isFragment = !0),
            Object.freeze(this)
    }
    static from(t) {
        return ei.isFragment(t) ? t : typeof t == "string" ? ei.fromString(t) : ei.fromObject(t)
    }
    static fromObject(t) {
        if (ei.isFragment(t)) return t
        switch (t.type) {
            case "function":
                return On.fromObject(t)
            case "event":
                return Zn.fromObject(t)
            case "constructor":
                return Nn.fromObject(t)
            case "error":
                return Bi.fromObject(t)
            case "fallback":
            case "receive":
                return null
        }
        return we.throwArgumentError("invalid fragment object", "value", t)
    }
    static fromString(t) {
        return (
            (t = t.replace(/\s/g, " ")),
            (t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")),
            (t = t.trim()),
            t.split(" ")[0] === "event"
                ? Zn.fromString(t.substring(5).trim())
                : t.split(" ")[0] === "function"
                ? On.fromString(t.substring(8).trim())
                : t.split("(")[0].trim() === "constructor"
                ? Nn.fromString(t.trim())
                : t.split(" ")[0] === "error"
                ? Bi.fromString(t.substring(5).trim())
                : we.throwArgumentError("unsupported fragment", "value", t)
        )
    }
    static isFragment(t) {
        return !!(t && t._isFragment)
    }
}
class Zn extends ei {
    format(t) {
        if ((t || (t = xe.sighash), xe[t] || we.throwArgumentError("invalid format type", "format", t), t === xe.json))
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((n) => JSON.parse(n.format(t))),
            })
        let r = ""
        return (
            t !== xe.sighash && (r += "event "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === xe.full ? ", " : ",") + ") "),
            t !== xe.sighash && this.anonymous && (r += "anonymous "),
            r.trim()
        )
    }
    static from(t) {
        return typeof t == "string" ? Zn.fromString(t) : Zn.fromObject(t)
    }
    static fromObject(t) {
        if (Zn.isEventFragment(t)) return t
        t.type !== "event" && we.throwArgumentError("invalid event object", "value", t)
        const r = { name: Fa(t.name), anonymous: t.anonymous, inputs: t.inputs ? t.inputs.map(er.fromObject) : [], type: "event" }
        return new Zn(Bs, r)
    }
    static fromString(t) {
        let r = t.match(Va)
        r || we.throwArgumentError("invalid event string", "value", t)
        let n = !1
        return (
            r[3].split(" ").forEach((i) => {
                switch (i.trim()) {
                    case "anonymous":
                        n = !0
                        break
                    case "":
                        break
                    default:
                        we.warn("unknown modifier: " + i)
                }
            }),
            Zn.fromObject({ name: r[1].trim(), anonymous: n, inputs: $a(r[2], !0), type: "event" })
        )
    }
    static isEventFragment(t) {
        return t && t._isFragment && t.type === "event"
    }
}
function ov(e, t) {
    t.gas = null
    let r = e.split("@")
    return r.length !== 1
        ? (r.length > 2 && we.throwArgumentError("invalid human-readable ABI signature", "value", e),
          r[1].match(/^[0-9]+$/) || we.throwArgumentError("invalid human-readable ABI signature gas", "value", e),
          (t.gas = St.from(r[1])),
          r[0])
        : e
}
function av(e, t) {
    ;(t.constant = !1),
        (t.payable = !1),
        (t.stateMutability = "nonpayable"),
        e.split(" ").forEach((r) => {
            switch (r.trim()) {
                case "constant":
                    t.constant = !0
                    break
                case "payable":
                    ;(t.payable = !0), (t.stateMutability = "payable")
                    break
                case "nonpayable":
                    ;(t.payable = !1), (t.stateMutability = "nonpayable")
                    break
                case "pure":
                    ;(t.constant = !0), (t.stateMutability = "pure")
                    break
                case "view":
                    ;(t.constant = !0), (t.stateMutability = "view")
                    break
                case "external":
                case "public":
                case "":
                    break
                default:
                    console.log("unknown modifier: " + r)
            }
        })
}
function lv(e) {
    let t = { constant: !1, payable: !0, stateMutability: "payable" }
    return (
        e.stateMutability != null
            ? ((t.stateMutability = e.stateMutability),
              (t.constant = t.stateMutability === "view" || t.stateMutability === "pure"),
              e.constant != null &&
                  !!e.constant !== t.constant &&
                  we.throwArgumentError("cannot have constant function with mutability " + t.stateMutability, "value", e),
              (t.payable = t.stateMutability === "payable"),
              e.payable != null &&
                  !!e.payable !== t.payable &&
                  we.throwArgumentError("cannot have payable function with mutability " + t.stateMutability, "value", e))
            : e.payable != null
            ? ((t.payable = !!e.payable),
              e.constant == null &&
                  !t.payable &&
                  e.type !== "constructor" &&
                  we.throwArgumentError("unable to determine stateMutability", "value", e),
              (t.constant = !!e.constant),
              t.constant ? (t.stateMutability = "view") : (t.stateMutability = t.payable ? "payable" : "nonpayable"),
              t.payable && t.constant && we.throwArgumentError("cannot have constant payable function", "value", e))
            : e.constant != null
            ? ((t.constant = !!e.constant), (t.payable = !t.constant), (t.stateMutability = t.constant ? "view" : "payable"))
            : e.type !== "constructor" && we.throwArgumentError("unable to determine stateMutability", "value", e),
        t
    )
}
class Nn extends ei {
    format(t) {
        if ((t || (t = xe.sighash), xe[t] || we.throwArgumentError("invalid format type", "format", t), t === xe.json))
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((n) => JSON.parse(n.format(t))),
            })
        t === xe.sighash &&
            we.throwError("cannot format a constructor for sighash", ut.errors.UNSUPPORTED_OPERATION, { operation: "format(sighash)" })
        let r = "constructor(" + this.inputs.map((n) => n.format(t)).join(t === xe.full ? ", " : ",") + ") "
        return this.stateMutability && this.stateMutability !== "nonpayable" && (r += this.stateMutability + " "), r.trim()
    }
    static from(t) {
        return typeof t == "string" ? Nn.fromString(t) : Nn.fromObject(t)
    }
    static fromObject(t) {
        if (Nn.isConstructorFragment(t)) return t
        t.type !== "constructor" && we.throwArgumentError("invalid constructor object", "value", t)
        let r = lv(t)
        r.constant && we.throwArgumentError("constructor cannot be constant", "value", t)
        const n = {
            name: null,
            type: t.type,
            inputs: t.inputs ? t.inputs.map(er.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: t.gas ? St.from(t.gas) : null,
        }
        return new Nn(Bs, n)
    }
    static fromString(t) {
        let r = { type: "constructor" }
        t = ov(t, r)
        let n = t.match(Va)
        return (
            (!n || n[1].trim() !== "constructor") && we.throwArgumentError("invalid constructor string", "value", t),
            (r.inputs = $a(n[2].trim(), !1)),
            av(n[3].trim(), r),
            Nn.fromObject(r)
        )
    }
    static isConstructorFragment(t) {
        return t && t._isFragment && t.type === "constructor"
    }
}
class On extends Nn {
    format(t) {
        if ((t || (t = xe.sighash), xe[t] || we.throwArgumentError("invalid format type", "format", t), t === xe.json))
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((n) => JSON.parse(n.format(t))),
                outputs: this.outputs.map((n) => JSON.parse(n.format(t))),
            })
        let r = ""
        return (
            t !== xe.sighash && (r += "function "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === xe.full ? ", " : ",") + ") "),
            t !== xe.sighash &&
                (this.stateMutability
                    ? this.stateMutability !== "nonpayable" && (r += this.stateMutability + " ")
                    : this.constant && (r += "view "),
                this.outputs && this.outputs.length && (r += "returns (" + this.outputs.map((n) => n.format(t)).join(", ") + ") "),
                this.gas != null && (r += "@" + this.gas.toString() + " ")),
            r.trim()
        )
    }
    static from(t) {
        return typeof t == "string" ? On.fromString(t) : On.fromObject(t)
    }
    static fromObject(t) {
        if (On.isFunctionFragment(t)) return t
        t.type !== "function" && we.throwArgumentError("invalid function object", "value", t)
        let r = lv(t)
        const n = {
            type: t.type,
            name: Fa(t.name),
            constant: r.constant,
            inputs: t.inputs ? t.inputs.map(er.fromObject) : [],
            outputs: t.outputs ? t.outputs.map(er.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: t.gas ? St.from(t.gas) : null,
        }
        return new On(Bs, n)
    }
    static fromString(t) {
        let r = { type: "function" }
        t = ov(t, r)
        let n = t.split(" returns ")
        n.length > 2 && we.throwArgumentError("invalid function string", "value", t)
        let i = n[0].match(Va)
        if (
            (i || we.throwArgumentError("invalid function signature", "value", t),
            (r.name = i[1].trim()),
            r.name && Fa(r.name),
            (r.inputs = $a(i[2], !1)),
            av(i[3].trim(), r),
            n.length > 1)
        ) {
            let s = n[1].match(Va)
            ;(s[1].trim() != "" || s[3].trim() != "") && we.throwArgumentError("unexpected tokens", "value", t), (r.outputs = $a(s[2], !1))
        } else r.outputs = []
        return On.fromObject(r)
    }
    static isFunctionFragment(t) {
        return t && t._isFragment && t.type === "function"
    }
}
function M0(e) {
    const t = e.format()
    return (t === "Error(string)" || t === "Panic(uint256)") && we.throwArgumentError(`cannot specify user defined ${t} error`, "fragment", e), e
}
class Bi extends ei {
    format(t) {
        if ((t || (t = xe.sighash), xe[t] || we.throwArgumentError("invalid format type", "format", t), t === xe.json))
            return JSON.stringify({ type: "error", name: this.name, inputs: this.inputs.map((n) => JSON.parse(n.format(t))) })
        let r = ""
        return (
            t !== xe.sighash && (r += "error "),
            (r += this.name + "(" + this.inputs.map((n) => n.format(t)).join(t === xe.full ? ", " : ",") + ") "),
            r.trim()
        )
    }
    static from(t) {
        return typeof t == "string" ? Bi.fromString(t) : Bi.fromObject(t)
    }
    static fromObject(t) {
        if (Bi.isErrorFragment(t)) return t
        t.type !== "error" && we.throwArgumentError("invalid error object", "value", t)
        const r = { type: t.type, name: Fa(t.name), inputs: t.inputs ? t.inputs.map(er.fromObject) : [] }
        return M0(new Bi(Bs, r))
    }
    static fromString(t) {
        let r = { type: "error" },
            n = t.match(Va)
        return (
            n || we.throwArgumentError("invalid error signature", "value", t),
            (r.name = n[1].trim()),
            r.name && Fa(r.name),
            (r.inputs = $a(n[2], !1)),
            M0(Bi.fromObject(r))
        )
    }
    static isErrorFragment(t) {
        return t && t._isFragment && t.type === "error"
    }
}
function io(e) {
    return e.match(/^uint($|[^1-9])/) ? (e = "uint256" + e.substring(4)) : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)), e
}
const lE = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$")
function Fa(e) {
    return (!e || !e.match(lE)) && we.throwArgumentError(`invalid identifier "${e}"`, "value", e), e
}
const Va = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$")
function uE(e) {
    e = e.trim()
    let t = [],
        r = "",
        n = 0
    for (let i = 0; i < e.length; i++) {
        let s = e[i]
        s === "," && n === 0
            ? (t.push(r), (r = ""))
            : ((r += s), s === "(" ? n++ : s === ")" && (n--, n === -1 && we.throwArgumentError("unbalanced parenthesis", "value", e)))
    }
    return r && t.push(r), t
}
const Dd = new ut(il)
function fE(e) {
    const t = [],
        r = function (n, i) {
            if (!!Array.isArray(i))
                for (let s in i) {
                    const o = n.slice()
                    o.push(s)
                    try {
                        r(o, i[s])
                    } catch (l) {
                        t.push({ path: o, error: l })
                    }
                }
        }
    return r([], e), t
}
class bi {
    constructor(t, r, n, i) {
        ;(this.name = t), (this.type = r), (this.localName = n), (this.dynamic = i)
    }
    _throwError(t, r) {
        Dd.throwArgumentError(t, this.localName, r)
    }
}
class Oc {
    constructor(t) {
        _t(this, "wordSize", t || 32), (this._data = []), (this._dataLength = 0), (this._padding = new Uint8Array(t))
    }
    get data() {
        return _r(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(t) {
        return this._data.push(t), (this._dataLength += t.length), t.length
    }
    appendWriter(t) {
        return this._writeData(Ar(t._data))
    }
    writeBytes(t) {
        let r = Wt(t)
        const n = r.length % this.wordSize
        return n && (r = Ar([r, this._padding.slice(n)])), this._writeData(r)
    }
    _getValue(t) {
        let r = Wt(St.from(t))
        return (
            r.length > this.wordSize &&
                Dd.throwError("value out-of-bounds", ut.errors.BUFFER_OVERRUN, { length: this.wordSize, offset: r.length }),
            r.length % this.wordSize && (r = Ar([this._padding.slice(r.length % this.wordSize), r])),
            r
        )
    }
    writeValue(t) {
        return this._writeData(this._getValue(t))
    }
    writeUpdatableValue() {
        const t = this._data.length
        return (
            this._data.push(this._padding),
            (this._dataLength += this.wordSize),
            (r) => {
                this._data[t] = this._getValue(r)
            }
        )
    }
}
class hu {
    constructor(t, r, n, i) {
        _t(this, "_data", Wt(t)), _t(this, "wordSize", r || 32), _t(this, "_coerceFunc", n), _t(this, "allowLoose", i), (this._offset = 0)
    }
    get data() {
        return Lt(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(t, r) {
        let n = t.match("^u?int([0-9]+)$")
        return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r
    }
    coerce(t, r) {
        return this._coerceFunc ? this._coerceFunc(t, r) : hu.coerce(t, r)
    }
    _peekBytes(t, r, n) {
        let i = Math.ceil(r / this.wordSize) * this.wordSize
        return (
            this._offset + i > this._data.length &&
                (this.allowLoose && n && this._offset + r <= this._data.length
                    ? (i = r)
                    : Dd.throwError("data out-of-bounds", ut.errors.BUFFER_OVERRUN, { length: this._data.length, offset: this._offset + i })),
            this._data.slice(this._offset, this._offset + i)
        )
    }
    subReader(t) {
        return new hu(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose)
    }
    readBytes(t, r) {
        let n = this._peekBytes(0, t, !!r)
        return (this._offset += n.length), n.slice(0, t)
    }
    readValue() {
        return St.from(this.readBytes(this.wordSize))
    }
}
var uv = { exports: {} }
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ ;(function (e) {
    ;(function () {
        var t = "input is invalid type",
            r = "finalize already called",
            n = typeof window == "object",
            i = n ? window : {}
        i.JS_SHA3_NO_WINDOW && (n = !1)
        var s = !n && typeof self == "object",
            o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node
        o ? (i = Bd) : s && (i = self)
        var l = !i.JS_SHA3_NO_COMMON_JS && !0 && e.exports,
            f = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
            d = "0123456789abcdef".split(""),
            h = [31, 7936, 2031616, 520093696],
            y = [4, 1024, 262144, 67108864],
            E = [1, 256, 65536, 16777216],
            T = [6, 1536, 393216, 100663296],
            S = [0, 8, 16, 24],
            N = [
                1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648,
                138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770,
                2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0,
                2147516424, 2147483648,
            ],
            P = [224, 256, 384, 512],
            M = [128, 256],
            k = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            F = { 128: 168, 256: 136 }
        ;(i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
            (Array.isArray = function (b) {
                return Object.prototype.toString.call(b) === "[object Array]"
            }),
            f &&
                (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
                (ArrayBuffer.isView = function (b) {
                    return typeof b == "object" && b.buffer && b.buffer.constructor === ArrayBuffer
                })
        for (
            var $ = function (b, B, D) {
                    return function (U) {
                        return new u(b, B, b).update(U)[D]()
                    }
                },
                R = function (b, B, D) {
                    return function (U, j) {
                        return new u(b, B, j).update(U)[D]()
                    }
                },
                W = function (b, B, D) {
                    return function (U, j, dt, Z) {
                        return a["cshake" + b].update(U, j, dt, Z)[D]()
                    }
                },
                nt = function (b, B, D) {
                    return function (U, j, dt, Z) {
                        return a["kmac" + b].update(U, j, dt, Z)[D]()
                    }
                },
                J = function (b, B, D, U) {
                    for (var j = 0; j < k.length; ++j) {
                        var dt = k[j]
                        b[dt] = B(D, U, dt)
                    }
                    return b
                },
                Q = function (b, B) {
                    var D = $(b, B, "hex")
                    return (
                        (D.create = function () {
                            return new u(b, B, b)
                        }),
                        (D.update = function (U) {
                            return D.create().update(U)
                        }),
                        J(D, $, b, B)
                    )
                },
                ot = function (b, B) {
                    var D = R(b, B, "hex")
                    return (
                        (D.create = function (U) {
                            return new u(b, B, U)
                        }),
                        (D.update = function (U, j) {
                            return D.create(j).update(U)
                        }),
                        J(D, R, b, B)
                    )
                },
                it = function (b, B) {
                    var D = F[b],
                        U = W(b, B, "hex")
                    return (
                        (U.create = function (j, dt, Z) {
                            return !dt && !Z ? a["shake" + b].create(j) : new u(b, B, j).bytepad([dt, Z], D)
                        }),
                        (U.update = function (j, dt, Z, et) {
                            return U.create(dt, Z, et).update(j)
                        }),
                        J(U, W, b, B)
                    )
                },
                at = function (b, B) {
                    var D = F[b],
                        U = nt(b, B, "hex")
                    return (
                        (U.create = function (j, dt, Z) {
                            return new p(b, B, dt).bytepad(["KMAC", Z], D).bytepad([j], D)
                        }),
                        (U.update = function (j, dt, Z, et) {
                            return U.create(j, Z, et).update(dt)
                        }),
                        J(U, nt, b, B)
                    )
                },
                x = [
                    { name: "keccak", padding: E, bits: P, createMethod: Q },
                    { name: "sha3", padding: T, bits: P, createMethod: Q },
                    { name: "shake", padding: h, bits: M, createMethod: ot },
                    { name: "cshake", padding: y, bits: M, createMethod: it },
                    { name: "kmac", padding: y, bits: M, createMethod: at },
                ],
                a = {},
                c = [],
                m = 0;
            m < x.length;
            ++m
        )
            for (var _ = x[m], A = _.bits, w = 0; w < A.length; ++w) {
                var v = _.name + "_" + A[w]
                if ((c.push(v), (a[v] = _.createMethod(A[w], _.padding)), _.name !== "sha3")) {
                    var g = _.name + A[w]
                    c.push(g), (a[g] = a[v])
                }
            }
        function u(b, B, D) {
            ;(this.blocks = []),
                (this.s = []),
                (this.padding = B),
                (this.outputBits = D),
                (this.reset = !0),
                (this.finalized = !1),
                (this.block = 0),
                (this.start = 0),
                (this.blockCount = (1600 - (b << 1)) >> 5),
                (this.byteCount = this.blockCount << 2),
                (this.outputBlocks = D >> 5),
                (this.extraBytes = (D & 31) >> 3)
            for (var U = 0; U < 50; ++U) this.s[U] = 0
        }
        ;(u.prototype.update = function (b) {
            if (this.finalized) throw new Error(r)
            var B,
                D = typeof b
            if (D !== "string") {
                if (D === "object") {
                    if (b === null) throw new Error(t)
                    if (f && b.constructor === ArrayBuffer) b = new Uint8Array(b)
                    else if (!Array.isArray(b) && (!f || !ArrayBuffer.isView(b))) throw new Error(t)
                } else throw new Error(t)
                B = !0
            }
            for (var U = this.blocks, j = this.byteCount, dt = b.length, Z = this.blockCount, et = 0, C = this.s, O, I; et < dt; ) {
                if (this.reset) for (this.reset = !1, U[0] = this.block, O = 1; O < Z + 1; ++O) U[O] = 0
                if (B) for (O = this.start; et < dt && O < j; ++et) U[O >> 2] |= b[et] << S[O++ & 3]
                else
                    for (O = this.start; et < dt && O < j; ++et)
                        (I = b.charCodeAt(et)),
                            I < 128
                                ? (U[O >> 2] |= I << S[O++ & 3])
                                : I < 2048
                                ? ((U[O >> 2] |= (192 | (I >> 6)) << S[O++ & 3]), (U[O >> 2] |= (128 | (I & 63)) << S[O++ & 3]))
                                : I < 55296 || I >= 57344
                                ? ((U[O >> 2] |= (224 | (I >> 12)) << S[O++ & 3]),
                                  (U[O >> 2] |= (128 | ((I >> 6) & 63)) << S[O++ & 3]),
                                  (U[O >> 2] |= (128 | (I & 63)) << S[O++ & 3]))
                                : ((I = 65536 + (((I & 1023) << 10) | (b.charCodeAt(++et) & 1023))),
                                  (U[O >> 2] |= (240 | (I >> 18)) << S[O++ & 3]),
                                  (U[O >> 2] |= (128 | ((I >> 12) & 63)) << S[O++ & 3]),
                                  (U[O >> 2] |= (128 | ((I >> 6) & 63)) << S[O++ & 3]),
                                  (U[O >> 2] |= (128 | (I & 63)) << S[O++ & 3]))
                if (((this.lastByteIndex = O), O >= j)) {
                    for (this.start = O - j, this.block = U[Z], O = 0; O < Z; ++O) C[O] ^= U[O]
                    H(C), (this.reset = !0)
                } else this.start = O
            }
            return this
        }),
            (u.prototype.encode = function (b, B) {
                var D = b & 255,
                    U = 1,
                    j = [D]
                for (b = b >> 8, D = b & 255; D > 0; ) j.unshift(D), (b = b >> 8), (D = b & 255), ++U
                return B ? j.push(U) : j.unshift(U), this.update(j), j.length
            }),
            (u.prototype.encodeString = function (b) {
                var B,
                    D = typeof b
                if (D !== "string") {
                    if (D === "object") {
                        if (b === null) throw new Error(t)
                        if (f && b.constructor === ArrayBuffer) b = new Uint8Array(b)
                        else if (!Array.isArray(b) && (!f || !ArrayBuffer.isView(b))) throw new Error(t)
                    } else throw new Error(t)
                    B = !0
                }
                var U = 0,
                    j = b.length
                if (B) U = j
                else
                    for (var dt = 0; dt < b.length; ++dt) {
                        var Z = b.charCodeAt(dt)
                        Z < 128
                            ? (U += 1)
                            : Z < 2048
                            ? (U += 2)
                            : Z < 55296 || Z >= 57344
                            ? (U += 3)
                            : ((Z = 65536 + (((Z & 1023) << 10) | (b.charCodeAt(++dt) & 1023))), (U += 4))
                    }
                return (U += this.encode(U * 8)), this.update(b), U
            }),
            (u.prototype.bytepad = function (b, B) {
                for (var D = this.encode(B), U = 0; U < b.length; ++U) D += this.encodeString(b[U])
                var j = B - (D % B),
                    dt = []
                return (dt.length = j), this.update(dt), this
            }),
            (u.prototype.finalize = function () {
                if (!this.finalized) {
                    this.finalized = !0
                    var b = this.blocks,
                        B = this.lastByteIndex,
                        D = this.blockCount,
                        U = this.s
                    if (((b[B >> 2] |= this.padding[B & 3]), this.lastByteIndex === this.byteCount))
                        for (b[0] = b[D], B = 1; B < D + 1; ++B) b[B] = 0
                    for (b[D - 1] |= 2147483648, B = 0; B < D; ++B) U[B] ^= b[B]
                    H(U)
                }
            }),
            (u.prototype.toString = u.prototype.hex =
                function () {
                    this.finalize()
                    for (var b = this.blockCount, B = this.s, D = this.outputBlocks, U = this.extraBytes, j = 0, dt = 0, Z = "", et; dt < D; ) {
                        for (j = 0; j < b && dt < D; ++j, ++dt)
                            (et = B[j]),
                                (Z +=
                                    d[(et >> 4) & 15] +
                                    d[et & 15] +
                                    d[(et >> 12) & 15] +
                                    d[(et >> 8) & 15] +
                                    d[(et >> 20) & 15] +
                                    d[(et >> 16) & 15] +
                                    d[(et >> 28) & 15] +
                                    d[(et >> 24) & 15])
                        dt % b === 0 && (H(B), (j = 0))
                    }
                    return (
                        U &&
                            ((et = B[j]),
                            (Z += d[(et >> 4) & 15] + d[et & 15]),
                            U > 1 && (Z += d[(et >> 12) & 15] + d[(et >> 8) & 15]),
                            U > 2 && (Z += d[(et >> 20) & 15] + d[(et >> 16) & 15])),
                        Z
                    )
                }),
            (u.prototype.arrayBuffer = function () {
                this.finalize()
                var b = this.blockCount,
                    B = this.s,
                    D = this.outputBlocks,
                    U = this.extraBytes,
                    j = 0,
                    dt = 0,
                    Z = this.outputBits >> 3,
                    et
                U ? (et = new ArrayBuffer((D + 1) << 2)) : (et = new ArrayBuffer(Z))
                for (var C = new Uint32Array(et); dt < D; ) {
                    for (j = 0; j < b && dt < D; ++j, ++dt) C[dt] = B[j]
                    dt % b === 0 && H(B)
                }
                return U && ((C[j] = B[j]), (et = et.slice(0, Z))), et
            }),
            (u.prototype.buffer = u.prototype.arrayBuffer),
            (u.prototype.digest = u.prototype.array =
                function () {
                    this.finalize()
                    for (
                        var b = this.blockCount, B = this.s, D = this.outputBlocks, U = this.extraBytes, j = 0, dt = 0, Z = [], et, C;
                        dt < D;

                    ) {
                        for (j = 0; j < b && dt < D; ++j, ++dt)
                            (et = dt << 2),
                                (C = B[j]),
                                (Z[et] = C & 255),
                                (Z[et + 1] = (C >> 8) & 255),
                                (Z[et + 2] = (C >> 16) & 255),
                                (Z[et + 3] = (C >> 24) & 255)
                        dt % b === 0 && H(B)
                    }
                    return (
                        U &&
                            ((et = dt << 2),
                            (C = B[j]),
                            (Z[et] = C & 255),
                            U > 1 && (Z[et + 1] = (C >> 8) & 255),
                            U > 2 && (Z[et + 2] = (C >> 16) & 255)),
                        Z
                    )
                })
        function p(b, B, D) {
            u.call(this, b, B, D)
        }
        ;(p.prototype = new u()),
            (p.prototype.finalize = function () {
                return this.encode(this.outputBits, !0), u.prototype.finalize.call(this)
            })
        var H = function (b) {
            var B,
                D,
                U,
                j,
                dt,
                Z,
                et,
                C,
                O,
                I,
                G,
                q,
                X,
                lt,
                tt,
                rt,
                st,
                ct,
                ht,
                gt,
                pt,
                vt,
                Tt,
                Et,
                At,
                Ft,
                Ot,
                Bt,
                ke,
                Vt,
                Mt,
                ge,
                Rt,
                qt,
                vr,
                Gt,
                zt,
                vn,
                Jt,
                Qt,
                bn,
                Xt,
                Zt,
                yn,
                te,
                ee,
                _n,
                re,
                ne,
                wn,
                ie,
                se,
                An,
                oe,
                ae,
                En,
                le,
                ue,
                Vr,
                Ur,
                Hr,
                qr,
                zr
            for (U = 0; U < 48; U += 2)
                (j = b[0] ^ b[10] ^ b[20] ^ b[30] ^ b[40]),
                    (dt = b[1] ^ b[11] ^ b[21] ^ b[31] ^ b[41]),
                    (Z = b[2] ^ b[12] ^ b[22] ^ b[32] ^ b[42]),
                    (et = b[3] ^ b[13] ^ b[23] ^ b[33] ^ b[43]),
                    (C = b[4] ^ b[14] ^ b[24] ^ b[34] ^ b[44]),
                    (O = b[5] ^ b[15] ^ b[25] ^ b[35] ^ b[45]),
                    (I = b[6] ^ b[16] ^ b[26] ^ b[36] ^ b[46]),
                    (G = b[7] ^ b[17] ^ b[27] ^ b[37] ^ b[47]),
                    (q = b[8] ^ b[18] ^ b[28] ^ b[38] ^ b[48]),
                    (X = b[9] ^ b[19] ^ b[29] ^ b[39] ^ b[49]),
                    (B = q ^ ((Z << 1) | (et >>> 31))),
                    (D = X ^ ((et << 1) | (Z >>> 31))),
                    (b[0] ^= B),
                    (b[1] ^= D),
                    (b[10] ^= B),
                    (b[11] ^= D),
                    (b[20] ^= B),
                    (b[21] ^= D),
                    (b[30] ^= B),
                    (b[31] ^= D),
                    (b[40] ^= B),
                    (b[41] ^= D),
                    (B = j ^ ((C << 1) | (O >>> 31))),
                    (D = dt ^ ((O << 1) | (C >>> 31))),
                    (b[2] ^= B),
                    (b[3] ^= D),
                    (b[12] ^= B),
                    (b[13] ^= D),
                    (b[22] ^= B),
                    (b[23] ^= D),
                    (b[32] ^= B),
                    (b[33] ^= D),
                    (b[42] ^= B),
                    (b[43] ^= D),
                    (B = Z ^ ((I << 1) | (G >>> 31))),
                    (D = et ^ ((G << 1) | (I >>> 31))),
                    (b[4] ^= B),
                    (b[5] ^= D),
                    (b[14] ^= B),
                    (b[15] ^= D),
                    (b[24] ^= B),
                    (b[25] ^= D),
                    (b[34] ^= B),
                    (b[35] ^= D),
                    (b[44] ^= B),
                    (b[45] ^= D),
                    (B = C ^ ((q << 1) | (X >>> 31))),
                    (D = O ^ ((X << 1) | (q >>> 31))),
                    (b[6] ^= B),
                    (b[7] ^= D),
                    (b[16] ^= B),
                    (b[17] ^= D),
                    (b[26] ^= B),
                    (b[27] ^= D),
                    (b[36] ^= B),
                    (b[37] ^= D),
                    (b[46] ^= B),
                    (b[47] ^= D),
                    (B = I ^ ((j << 1) | (dt >>> 31))),
                    (D = G ^ ((dt << 1) | (j >>> 31))),
                    (b[8] ^= B),
                    (b[9] ^= D),
                    (b[18] ^= B),
                    (b[19] ^= D),
                    (b[28] ^= B),
                    (b[29] ^= D),
                    (b[38] ^= B),
                    (b[39] ^= D),
                    (b[48] ^= B),
                    (b[49] ^= D),
                    (lt = b[0]),
                    (tt = b[1]),
                    (ee = (b[11] << 4) | (b[10] >>> 28)),
                    (_n = (b[10] << 4) | (b[11] >>> 28)),
                    (Bt = (b[20] << 3) | (b[21] >>> 29)),
                    (ke = (b[21] << 3) | (b[20] >>> 29)),
                    (Ur = (b[31] << 9) | (b[30] >>> 23)),
                    (Hr = (b[30] << 9) | (b[31] >>> 23)),
                    (Xt = (b[40] << 18) | (b[41] >>> 14)),
                    (Zt = (b[41] << 18) | (b[40] >>> 14)),
                    (qt = (b[2] << 1) | (b[3] >>> 31)),
                    (vr = (b[3] << 1) | (b[2] >>> 31)),
                    (rt = (b[13] << 12) | (b[12] >>> 20)),
                    (st = (b[12] << 12) | (b[13] >>> 20)),
                    (re = (b[22] << 10) | (b[23] >>> 22)),
                    (ne = (b[23] << 10) | (b[22] >>> 22)),
                    (Vt = (b[33] << 13) | (b[32] >>> 19)),
                    (Mt = (b[32] << 13) | (b[33] >>> 19)),
                    (qr = (b[42] << 2) | (b[43] >>> 30)),
                    (zr = (b[43] << 2) | (b[42] >>> 30)),
                    (oe = (b[5] << 30) | (b[4] >>> 2)),
                    (ae = (b[4] << 30) | (b[5] >>> 2)),
                    (Gt = (b[14] << 6) | (b[15] >>> 26)),
                    (zt = (b[15] << 6) | (b[14] >>> 26)),
                    (ct = (b[25] << 11) | (b[24] >>> 21)),
                    (ht = (b[24] << 11) | (b[25] >>> 21)),
                    (wn = (b[34] << 15) | (b[35] >>> 17)),
                    (ie = (b[35] << 15) | (b[34] >>> 17)),
                    (ge = (b[45] << 29) | (b[44] >>> 3)),
                    (Rt = (b[44] << 29) | (b[45] >>> 3)),
                    (Et = (b[6] << 28) | (b[7] >>> 4)),
                    (At = (b[7] << 28) | (b[6] >>> 4)),
                    (En = (b[17] << 23) | (b[16] >>> 9)),
                    (le = (b[16] << 23) | (b[17] >>> 9)),
                    (vn = (b[26] << 25) | (b[27] >>> 7)),
                    (Jt = (b[27] << 25) | (b[26] >>> 7)),
                    (gt = (b[36] << 21) | (b[37] >>> 11)),
                    (pt = (b[37] << 21) | (b[36] >>> 11)),
                    (se = (b[47] << 24) | (b[46] >>> 8)),
                    (An = (b[46] << 24) | (b[47] >>> 8)),
                    (yn = (b[8] << 27) | (b[9] >>> 5)),
                    (te = (b[9] << 27) | (b[8] >>> 5)),
                    (Ft = (b[18] << 20) | (b[19] >>> 12)),
                    (Ot = (b[19] << 20) | (b[18] >>> 12)),
                    (ue = (b[29] << 7) | (b[28] >>> 25)),
                    (Vr = (b[28] << 7) | (b[29] >>> 25)),
                    (Qt = (b[38] << 8) | (b[39] >>> 24)),
                    (bn = (b[39] << 8) | (b[38] >>> 24)),
                    (vt = (b[48] << 14) | (b[49] >>> 18)),
                    (Tt = (b[49] << 14) | (b[48] >>> 18)),
                    (b[0] = lt ^ (~rt & ct)),
                    (b[1] = tt ^ (~st & ht)),
                    (b[10] = Et ^ (~Ft & Bt)),
                    (b[11] = At ^ (~Ot & ke)),
                    (b[20] = qt ^ (~Gt & vn)),
                    (b[21] = vr ^ (~zt & Jt)),
                    (b[30] = yn ^ (~ee & re)),
                    (b[31] = te ^ (~_n & ne)),
                    (b[40] = oe ^ (~En & ue)),
                    (b[41] = ae ^ (~le & Vr)),
                    (b[2] = rt ^ (~ct & gt)),
                    (b[3] = st ^ (~ht & pt)),
                    (b[12] = Ft ^ (~Bt & Vt)),
                    (b[13] = Ot ^ (~ke & Mt)),
                    (b[22] = Gt ^ (~vn & Qt)),
                    (b[23] = zt ^ (~Jt & bn)),
                    (b[32] = ee ^ (~re & wn)),
                    (b[33] = _n ^ (~ne & ie)),
                    (b[42] = En ^ (~ue & Ur)),
                    (b[43] = le ^ (~Vr & Hr)),
                    (b[4] = ct ^ (~gt & vt)),
                    (b[5] = ht ^ (~pt & Tt)),
                    (b[14] = Bt ^ (~Vt & ge)),
                    (b[15] = ke ^ (~Mt & Rt)),
                    (b[24] = vn ^ (~Qt & Xt)),
                    (b[25] = Jt ^ (~bn & Zt)),
                    (b[34] = re ^ (~wn & se)),
                    (b[35] = ne ^ (~ie & An)),
                    (b[44] = ue ^ (~Ur & qr)),
                    (b[45] = Vr ^ (~Hr & zr)),
                    (b[6] = gt ^ (~vt & lt)),
                    (b[7] = pt ^ (~Tt & tt)),
                    (b[16] = Vt ^ (~ge & Et)),
                    (b[17] = Mt ^ (~Rt & At)),
                    (b[26] = Qt ^ (~Xt & qt)),
                    (b[27] = bn ^ (~Zt & vr)),
                    (b[36] = wn ^ (~se & yn)),
                    (b[37] = ie ^ (~An & te)),
                    (b[46] = Ur ^ (~qr & oe)),
                    (b[47] = Hr ^ (~zr & ae)),
                    (b[8] = vt ^ (~lt & rt)),
                    (b[9] = Tt ^ (~tt & st)),
                    (b[18] = ge ^ (~Et & Ft)),
                    (b[19] = Rt ^ (~At & Ot)),
                    (b[28] = Xt ^ (~qt & Gt)),
                    (b[29] = Zt ^ (~vr & zt)),
                    (b[38] = se ^ (~yn & ee)),
                    (b[39] = An ^ (~te & _n)),
                    (b[48] = qr ^ (~oe & En)),
                    (b[49] = zr ^ (~ae & le)),
                    (b[0] ^= N[U]),
                    (b[1] ^= N[U + 1])
        }
        if (l) e.exports = a
        else for (m = 0; m < c.length; ++m) i[c[m]] = a[c[m]]
    })()
})(uv)
var cE = uv.exports
function Xe(e) {
    return "0x" + cE.keccak_256(Wt(e))
}
const dE = "rlp/5.7.0",
    Mn = new ut(dE)
function S0(e) {
    const t = []
    for (; e; ) t.unshift(e & 255), (e >>= 8)
    return t
}
function k0(e, t, r) {
    let n = 0
    for (let i = 0; i < r; i++) n = n * 256 + e[t + i]
    return n
}
function fv(e) {
    if (Array.isArray(e)) {
        let n = []
        if (
            (e.forEach(function (s) {
                n = n.concat(fv(s))
            }),
            n.length <= 55)
        )
            return n.unshift(192 + n.length), n
        const i = S0(n.length)
        return i.unshift(247 + i.length), i.concat(n)
    }
    Pd(e) || Mn.throwArgumentError("RLP object must be BytesLike", "object", e)
    const t = Array.prototype.slice.call(Wt(e))
    if (t.length === 1 && t[0] <= 127) return t
    if (t.length <= 55) return t.unshift(128 + t.length), t
    const r = S0(t.length)
    return r.unshift(183 + r.length), r.concat(t)
}
function Ju(e) {
    return Lt(fv(e))
}
function N0(e, t, r, n) {
    const i = []
    for (; r < t + 1 + n; ) {
        const s = cv(e, r)
        i.push(s.result), (r += s.consumed), r > t + 1 + n && Mn.throwError("child data too short", ut.errors.BUFFER_OVERRUN, {})
    }
    return { consumed: 1 + n, result: i }
}
function cv(e, t) {
    if ((e.length === 0 && Mn.throwError("data too short", ut.errors.BUFFER_OVERRUN, {}), e[t] >= 248)) {
        const r = e[t] - 247
        t + 1 + r > e.length && Mn.throwError("data short segment too short", ut.errors.BUFFER_OVERRUN, {})
        const n = k0(e, t + 1, r)
        return t + 1 + r + n > e.length && Mn.throwError("data long segment too short", ut.errors.BUFFER_OVERRUN, {}), N0(e, t, t + 1 + r, r + n)
    } else if (e[t] >= 192) {
        const r = e[t] - 192
        return t + 1 + r > e.length && Mn.throwError("data array too short", ut.errors.BUFFER_OVERRUN, {}), N0(e, t, t + 1, r)
    } else if (e[t] >= 184) {
        const r = e[t] - 183
        t + 1 + r > e.length && Mn.throwError("data array too short", ut.errors.BUFFER_OVERRUN, {})
        const n = k0(e, t + 1, r)
        t + 1 + r + n > e.length && Mn.throwError("data array too short", ut.errors.BUFFER_OVERRUN, {})
        const i = Lt(e.slice(t + 1 + r, t + 1 + r + n))
        return { consumed: 1 + r + n, result: i }
    } else if (e[t] >= 128) {
        const r = e[t] - 128
        t + 1 + r > e.length && Mn.throwError("data too short", ut.errors.BUFFER_OVERRUN, {})
        const n = Lt(e.slice(t + 1, t + 1 + r))
        return { consumed: 1 + r, result: n }
    }
    return { consumed: 1, result: Lt(e[t]) }
}
function $d(e) {
    const t = Wt(e),
        r = cv(t, 0)
    return r.consumed !== t.length && Mn.throwArgumentError("invalid rlp data", "data", e), r.result
}
const hE = "address/5.7.0",
    uo = new ut(hE)
function O0(e) {
    Te(e, 20) || uo.throwArgumentError("invalid address", "address", e), (e = e.toLowerCase())
    const t = e.substring(2).split(""),
        r = new Uint8Array(40)
    for (let i = 0; i < 40; i++) r[i] = t[i].charCodeAt(0)
    const n = Wt(Xe(r))
    for (let i = 0; i < 40; i += 2)
        n[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase())
    return "0x" + t.join("")
}
const pE = 9007199254740991
function gE(e) {
    return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10
}
const Fd = {}
for (let e = 0; e < 10; e++) Fd[String(e)] = String(e)
for (let e = 0; e < 26; e++) Fd[String.fromCharCode(65 + e)] = String(10 + e)
const I0 = Math.floor(gE(pE))
function mE(e) {
    ;(e = e.toUpperCase()), (e = e.substring(4) + e.substring(0, 2) + "00")
    let t = e
        .split("")
        .map((n) => Fd[n])
        .join("")
    for (; t.length >= I0; ) {
        let n = t.substring(0, I0)
        t = (parseInt(n, 10) % 97) + t.substring(n.length)
    }
    let r = String(98 - (parseInt(t, 10) % 97))
    for (; r.length < 2; ) r = "0" + r
    return r
}
function rr(e) {
    let t = null
    if ((typeof e != "string" && uo.throwArgumentError("invalid address", "address", e), e.match(/^(0x)?[0-9a-fA-F]{40}$/)))
        e.substring(0, 2) !== "0x" && (e = "0x" + e),
            (t = O0(e)),
            e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e && uo.throwArgumentError("bad address checksum", "address", e)
    else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (e.substring(2, 4) !== mE(e) && uo.throwArgumentError("bad icap checksum", "address", e), t = Z2(e.substring(4)); t.length < 40; )
            t = "0" + t
        t = O0("0x" + t)
    } else uo.throwArgumentError("invalid address", "address", e)
    return t
}
function Vd(e) {
    let t = null
    try {
        t = rr(e.from)
    } catch {
        uo.throwArgumentError("missing from address", "transaction", e)
    }
    const r = So(Wt(St.from(e.nonce).toHexString()))
    return rr(fr(Xe(Ju([t, r])), 12))
}
class vE extends bi {
    constructor(t) {
        super("address", "address", t, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(t, r) {
        try {
            r = rr(r)
        } catch (n) {
            this._throwError(n.message, r)
        }
        return t.writeValue(r)
    }
    decode(t) {
        return rr(He(t.readValue().toHexString(), 20))
    }
}
class bE extends bi {
    constructor(t) {
        super(t.name, t.type, void 0, t.dynamic), (this.coder = t)
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(t, r) {
        return this.coder.encode(t, r)
    }
    decode(t) {
        return this.coder.decode(t)
    }
}
const fo = new ut(il)
function dv(e, t, r) {
    let n = null
    if (Array.isArray(r)) n = r
    else if (r && typeof r == "object") {
        let f = {}
        n = t.map((d) => {
            const h = d.localName
            return (
                h ||
                    fo.throwError("cannot encode object for signature with missing names", ut.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: d,
                        value: r,
                    }),
                f[h] &&
                    fo.throwError("cannot encode object for signature with duplicate names", ut.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: d,
                        value: r,
                    }),
                (f[h] = !0),
                r[h]
            )
        })
    } else fo.throwArgumentError("invalid tuple value", "tuple", r)
    t.length !== n.length && fo.throwArgumentError("types/value length mismatch", "tuple", r)
    let i = new Oc(e.wordSize),
        s = new Oc(e.wordSize),
        o = []
    t.forEach((f, d) => {
        let h = n[d]
        if (f.dynamic) {
            let y = s.length
            f.encode(s, h)
            let E = i.writeUpdatableValue()
            o.push((T) => {
                E(T + y)
            })
        } else f.encode(i, h)
    }),
        o.forEach((f) => {
            f(i.length)
        })
    let l = e.appendWriter(i)
    return (l += e.appendWriter(s)), l
}
function hv(e, t) {
    let r = [],
        n = e.subReader(0)
    t.forEach((s) => {
        let o = null
        if (s.dynamic) {
            let l = e.readValue(),
                f = n.subReader(l.toNumber())
            try {
                o = s.decode(f)
            } catch (d) {
                if (d.code === ut.errors.BUFFER_OVERRUN) throw d
                ;(o = d), (o.baseType = s.name), (o.name = s.localName), (o.type = s.type)
            }
        } else
            try {
                o = s.decode(e)
            } catch (l) {
                if (l.code === ut.errors.BUFFER_OVERRUN) throw l
                ;(o = l), (o.baseType = s.name), (o.name = s.localName), (o.type = s.type)
            }
        o != null && r.push(o)
    })
    const i = t.reduce((s, o) => {
        const l = o.localName
        return l && (s[l] || (s[l] = 0), s[l]++), s
    }, {})
    t.forEach((s, o) => {
        let l = s.localName
        if (!l || i[l] !== 1 || (l === "length" && (l = "_length"), r[l] != null)) return
        const f = r[o]
        f instanceof Error
            ? Object.defineProperty(r, l, {
                  enumerable: !0,
                  get: () => {
                      throw f
                  },
              })
            : (r[l] = f)
    })
    for (let s = 0; s < r.length; s++) {
        const o = r[s]
        o instanceof Error &&
            Object.defineProperty(r, s, {
                enumerable: !0,
                get: () => {
                    throw o
                },
            })
    }
    return Object.freeze(r)
}
class yE extends bi {
    constructor(t, r, n) {
        const i = t.type + "[" + (r >= 0 ? r : "") + "]",
            s = r === -1 || t.dynamic
        super("array", i, n, s), (this.coder = t), (this.length = r)
    }
    defaultValue() {
        const t = this.coder.defaultValue(),
            r = []
        for (let n = 0; n < this.length; n++) r.push(t)
        return r
    }
    encode(t, r) {
        Array.isArray(r) || this._throwError("expected array value", r)
        let n = this.length
        n === -1 && ((n = r.length), t.writeValue(r.length)),
            fo.checkArgumentCount(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""))
        let i = []
        for (let s = 0; s < r.length; s++) i.push(this.coder)
        return dv(t, i, r)
    }
    decode(t) {
        let r = this.length
        r === -1 &&
            ((r = t.readValue().toNumber()),
            r * 32 > t._data.length && fo.throwError("insufficient data length", ut.errors.BUFFER_OVERRUN, { length: t._data.length, count: r }))
        let n = []
        for (let i = 0; i < r; i++) n.push(new bE(this.coder))
        return t.coerce(this.name, hv(t, n))
    }
}
class _E extends bi {
    constructor(t) {
        super("bool", "bool", t, !1)
    }
    defaultValue() {
        return !1
    }
    encode(t, r) {
        return t.writeValue(r ? 1 : 0)
    }
    decode(t) {
        return t.coerce(this.type, !t.readValue().isZero())
    }
}
class pv extends bi {
    constructor(t, r) {
        super(t, t, r, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(t, r) {
        r = Wt(r)
        let n = t.writeValue(r.length)
        return (n += t.writeBytes(r)), n
    }
    decode(t) {
        return t.readBytes(t.readValue().toNumber(), !0)
    }
}
class wE extends pv {
    constructor(t) {
        super("bytes", t)
    }
    decode(t) {
        return t.coerce(this.name, Lt(super.decode(t)))
    }
}
class AE extends bi {
    constructor(t, r) {
        let n = "bytes" + String(t)
        super(n, n, r, !1), (this.size = t)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(t, r) {
        let n = Wt(r)
        return n.length !== this.size && this._throwError("incorrect data length", r), t.writeBytes(n)
    }
    decode(t) {
        return t.coerce(this.name, Lt(t.readBytes(this.size)))
    }
}
class EE extends bi {
    constructor(t) {
        super("null", "", t, !1)
    }
    defaultValue() {
        return null
    }
    encode(t, r) {
        return r != null && this._throwError("not null", r), t.writeBytes([])
    }
    decode(t) {
        return t.readBytes(0), t.coerce(this.name, null)
    }
}
const xE = "0x0000000000000000000000000000000000000000",
    TE = St.from(-1),
    gv = St.from(0),
    CE = St.from(1),
    ME = St.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    SE = "0x0000000000000000000000000000000000000000000000000000000000000000"
class kE extends bi {
    constructor(t, r, n) {
        const i = (r ? "int" : "uint") + t * 8
        super(i, i, n, !1), (this.size = t), (this.signed = r)
    }
    defaultValue() {
        return 0
    }
    encode(t, r) {
        let n = St.from(r),
            i = ME.mask(t.wordSize * 8)
        if (this.signed) {
            let s = i.mask(this.size * 8 - 1)
            ;(n.gt(s) || n.lt(s.add(CE).mul(TE))) && this._throwError("value out-of-bounds", r)
        } else (n.lt(gv) || n.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", r)
        return (
            (n = n.toTwos(this.size * 8).mask(this.size * 8)),
            this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * t.wordSize)),
            t.writeValue(n)
        )
    }
    decode(t) {
        let r = t.readValue().mask(this.size * 8)
        return this.signed && (r = r.fromTwos(this.size * 8)), t.coerce(this.name, r)
    }
}
const NE = "strings/5.7.0",
    mv = new ut(NE)
var Ua
;(function (e) {
    ;(e.current = ""), (e.NFC = "NFC"), (e.NFD = "NFD"), (e.NFKC = "NFKC"), (e.NFKD = "NFKD")
})(Ua || (Ua = {}))
var Cr
;(function (e) {
    ;(e.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
        (e.BAD_PREFIX = "bad codepoint prefix"),
        (e.OVERRUN = "string overrun"),
        (e.MISSING_CONTINUE = "missing continuation byte"),
        (e.OUT_OF_RANGE = "out of UTF-8 range"),
        (e.UTF16_SURROGATE = "UTF-16 surrogate"),
        (e.OVERLONG = "overlong representation")
})(Cr || (Cr = {}))
function OE(e, t, r, n, i) {
    return mv.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, "bytes", r)
}
function vv(e, t, r, n, i) {
    if (e === Cr.BAD_PREFIX || e === Cr.UNEXPECTED_CONTINUE) {
        let s = 0
        for (let o = t + 1; o < r.length && r[o] >> 6 === 2; o++) s++
        return s
    }
    return e === Cr.OVERRUN ? r.length - t - 1 : 0
}
function IE(e, t, r, n, i) {
    return e === Cr.OVERLONG ? (n.push(i), 0) : (n.push(65533), vv(e, t, r))
}
const BE = Object.freeze({ error: OE, ignore: vv, replace: IE })
function bv(e, t) {
    t == null && (t = BE.error), (e = Wt(e))
    const r = []
    let n = 0
    for (; n < e.length; ) {
        const i = e[n++]
        if (i >> 7 === 0) {
            r.push(i)
            continue
        }
        let s = null,
            o = null
        if ((i & 224) === 192) (s = 1), (o = 127)
        else if ((i & 240) === 224) (s = 2), (o = 2047)
        else if ((i & 248) === 240) (s = 3), (o = 65535)
        else {
            ;(i & 192) === 128 ? (n += t(Cr.UNEXPECTED_CONTINUE, n - 1, e, r)) : (n += t(Cr.BAD_PREFIX, n - 1, e, r))
            continue
        }
        if (n - 1 + s >= e.length) {
            n += t(Cr.OVERRUN, n - 1, e, r)
            continue
        }
        let l = i & ((1 << (8 - s - 1)) - 1)
        for (let f = 0; f < s; f++) {
            let d = e[n]
            if ((d & 192) != 128) {
                ;(n += t(Cr.MISSING_CONTINUE, n, e, r)), (l = null)
                break
            }
            ;(l = (l << 6) | (d & 63)), n++
        }
        if (l !== null) {
            if (l > 1114111) {
                n += t(Cr.OUT_OF_RANGE, n - 1 - s, e, r, l)
                continue
            }
            if (l >= 55296 && l <= 57343) {
                n += t(Cr.UTF16_SURROGATE, n - 1 - s, e, r, l)
                continue
            }
            if (l <= o) {
                n += t(Cr.OVERLONG, n - 1 - s, e, r, l)
                continue
            }
            r.push(l)
        }
    }
    return r
}
function ci(e, t = Ua.current) {
    t != Ua.current && (mv.checkNormalize(), (e = e.normalize(t)))
    let r = []
    for (let n = 0; n < e.length; n++) {
        const i = e.charCodeAt(n)
        if (i < 128) r.push(i)
        else if (i < 2048) r.push((i >> 6) | 192), r.push((i & 63) | 128)
        else if ((i & 64512) == 55296) {
            n++
            const s = e.charCodeAt(n)
            if (n >= e.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string")
            const o = 65536 + ((i & 1023) << 10) + (s & 1023)
            r.push((o >> 18) | 240), r.push(((o >> 12) & 63) | 128), r.push(((o >> 6) & 63) | 128), r.push((o & 63) | 128)
        } else r.push((i >> 12) | 224), r.push(((i >> 6) & 63) | 128), r.push((i & 63) | 128)
    }
    return Wt(r)
}
function PE(e) {
    return e
        .map((t) => (t <= 65535 ? String.fromCharCode(t) : ((t -= 65536), String.fromCharCode(((t >> 10) & 1023) + 55296, (t & 1023) + 56320))))
        .join("")
}
function sl(e, t) {
    return PE(bv(e, t))
}
function RE(e, t = Ua.current) {
    return bv(ci(e, t))
}
class LE extends pv {
    constructor(t) {
        super("string", t)
    }
    defaultValue() {
        return ""
    }
    encode(t, r) {
        return super.encode(t, ci(r))
    }
    decode(t) {
        return sl(super.decode(t))
    }
}
class xl extends bi {
    constructor(t, r) {
        let n = !1
        const i = []
        t.forEach((o) => {
            o.dynamic && (n = !0), i.push(o.type)
        })
        const s = "tuple(" + i.join(",") + ")"
        super("tuple", s, r, n), (this.coders = t)
    }
    defaultValue() {
        const t = []
        this.coders.forEach((n) => {
            t.push(n.defaultValue())
        })
        const r = this.coders.reduce((n, i) => {
            const s = i.localName
            return s && (n[s] || (n[s] = 0), n[s]++), n
        }, {})
        return (
            this.coders.forEach((n, i) => {
                let s = n.localName
                !s || r[s] !== 1 || (s === "length" && (s = "_length"), t[s] == null && (t[s] = t[i]))
            }),
            Object.freeze(t)
        )
    }
    encode(t, r) {
        return dv(t, this.coders, r)
    }
    decode(t) {
        return t.coerce(this.name, hv(t, this.coders))
    }
}
const Tl = new ut(il),
    DE = new RegExp(/^bytes([0-9]*)$/),
    $E = new RegExp(/^(u?int)([0-9]*)$/)
class FE {
    constructor(t) {
        _t(this, "coerceFunc", t || null)
    }
    _getCoder(t) {
        switch (t.baseType) {
            case "address":
                return new vE(t.name)
            case "bool":
                return new _E(t.name)
            case "string":
                return new LE(t.name)
            case "bytes":
                return new wE(t.name)
            case "array":
                return new yE(this._getCoder(t.arrayChildren), t.arrayLength, t.name)
            case "tuple":
                return new xl(
                    (t.components || []).map((n) => this._getCoder(n)),
                    t.name
                )
            case "":
                return new EE(t.name)
        }
        let r = t.type.match($E)
        if (r) {
            let n = parseInt(r[2] || "256")
            return (
                (n === 0 || n > 256 || n % 8 !== 0) && Tl.throwArgumentError("invalid " + r[1] + " bit length", "param", t),
                new kE(n / 8, r[1] === "int", t.name)
            )
        }
        if (((r = t.type.match(DE)), r)) {
            let n = parseInt(r[1])
            return (n === 0 || n > 32) && Tl.throwArgumentError("invalid bytes length", "param", t), new AE(n, t.name)
        }
        return Tl.throwArgumentError("invalid type", "type", t.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(t, r) {
        return new hu(t, this._getWordSize(), this.coerceFunc, r)
    }
    _getWriter() {
        return new Oc(this._getWordSize())
    }
    getDefaultValue(t) {
        const r = t.map((i) => this._getCoder(er.from(i)))
        return new xl(r, "_").defaultValue()
    }
    encode(t, r) {
        t.length !== r.length &&
            Tl.throwError("types/values length mismatch", ut.errors.INVALID_ARGUMENT, {
                count: { types: t.length, values: r.length },
                value: { types: t, values: r },
            })
        const n = t.map((o) => this._getCoder(er.from(o))),
            i = new xl(n, "_"),
            s = this._getWriter()
        return i.encode(s, r), s.data
    }
    decode(t, r, n) {
        const i = t.map((o) => this._getCoder(er.from(o)))
        return new xl(i, "_").decode(this._getReader(Wt(r), n))
    }
}
const VE = new FE()
function co(e) {
    return Xe(ci(e))
}
const yv = "hash/5.7.0"
function _v(e) {
    e = atob(e)
    const t = []
    for (let r = 0; r < e.length; r++) t.push(e.charCodeAt(r))
    return Wt(t)
}
function wv(e) {
    e = Wt(e)
    let t = ""
    for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r])
    return btoa(t)
}
function Av(e, t) {
    t == null && (t = 1)
    const r = [],
        n = r.forEach,
        i = function (s, o) {
            n.call(s, function (l) {
                o > 0 && Array.isArray(l) ? i(l, o - 1) : r.push(l)
            })
        }
    return i(e, t), r
}
function UE(e) {
    const t = {}
    for (let r = 0; r < e.length; r++) {
        const n = e[r]
        t[n[0]] = n[1]
    }
    return t
}
function HE(e) {
    let t = 0
    function r() {
        return (e[t++] << 8) | e[t++]
    }
    let n = r(),
        i = 1,
        s = [0, 1]
    for (let R = 1; R < n; R++) s.push((i += r()))
    let o = r(),
        l = t
    t += o
    let f = 0,
        d = 0
    function h() {
        return f == 0 && ((d = (d << 8) | e[t++]), (f = 8)), (d >> --f) & 1
    }
    const y = 31,
        E = Math.pow(2, y),
        T = E >>> 1,
        S = T >> 1,
        N = E - 1
    let P = 0
    for (let R = 0; R < y; R++) P = (P << 1) | h()
    let M = [],
        k = 0,
        F = E
    for (;;) {
        let R = Math.floor(((P - k + 1) * i - 1) / F),
            W = 0,
            nt = n
        for (; nt - W > 1; ) {
            let ot = (W + nt) >>> 1
            R < s[ot] ? (nt = ot) : (W = ot)
        }
        if (W == 0) break
        M.push(W)
        let J = k + Math.floor((F * s[W]) / i),
            Q = k + Math.floor((F * s[W + 1]) / i) - 1
        for (; ((J ^ Q) & T) == 0; ) (P = ((P << 1) & N) | h()), (J = (J << 1) & N), (Q = ((Q << 1) & N) | 1)
        for (; J & ~Q & S; ) (P = (P & T) | ((P << 1) & (N >>> 1)) | h()), (J = (J << 1) ^ T), (Q = ((Q ^ T) << 1) | T | 1)
        ;(k = J), (F = 1 + Q - J)
    }
    let $ = n - 4
    return M.map((R) => {
        switch (R - $) {
            case 3:
                return $ + 65792 + ((e[l++] << 16) | (e[l++] << 8) | e[l++])
            case 2:
                return $ + 256 + ((e[l++] << 8) | e[l++])
            case 1:
                return $ + e[l++]
            default:
                return R - 1
        }
    })
}
function qE(e) {
    let t = 0
    return () => e[t++]
}
function zE(e) {
    return qE(HE(e))
}
function jE(e) {
    return e & 1 ? ~e >> 1 : e >> 1
}
function KE(e, t) {
    let r = Array(e)
    for (let n = 0; n < e; n++) r[n] = 1 + t()
    return r
}
function B0(e, t) {
    let r = Array(e)
    for (let n = 0, i = -1; n < e; n++) r[n] = i += 1 + t()
    return r
}
function GE(e, t) {
    let r = Array(e)
    for (let n = 0, i = 0; n < e; n++) r[n] = i += jE(t())
    return r
}
function pu(e, t) {
    let r = B0(e(), e),
        n = e(),
        i = B0(n, e),
        s = KE(n, e)
    for (let o = 0; o < n; o++) for (let l = 0; l < s[o]; l++) r.push(i[o] + l)
    return t ? r.map((o) => t[o]) : r
}
function WE(e) {
    let t = []
    for (;;) {
        let r = e()
        if (r == 0) break
        t.push(JE(r, e))
    }
    for (;;) {
        let r = e() - 1
        if (r < 0) break
        t.push(QE(r, e))
    }
    return UE(Av(t))
}
function YE(e) {
    let t = []
    for (;;) {
        let r = e()
        if (r == 0) break
        t.push(r)
    }
    return t
}
function Ev(e, t, r) {
    let n = Array(e)
        .fill(void 0)
        .map(() => [])
    for (let i = 0; i < t; i++) GE(e, r).forEach((s, o) => n[o].push(s))
    return n
}
function JE(e, t) {
    let r = 1 + t(),
        n = t(),
        i = YE(t),
        s = Ev(i.length, 1 + e, t)
    return Av(
        s.map((o, l) => {
            const f = o[0],
                d = o.slice(1)
            return Array(i[l])
                .fill(void 0)
                .map((h, y) => {
                    let E = y * n
                    return [f + y * r, d.map((T) => T + E)]
                })
        })
    )
}
function QE(e, t) {
    let r = 1 + t()
    return Ev(r, 1 + e, t).map((i) => [i[0], i.slice(1)])
}
function XE(e) {
    let t = pu(e).sort((n, i) => n - i)
    return r()
    function r() {
        let n = []
        for (;;) {
            let d = pu(e, t)
            if (d.length == 0) break
            n.push({ set: new Set(d), node: r() })
        }
        n.sort((d, h) => h.set.size - d.set.size)
        let i = e(),
            s = i % 3
        i = (i / 3) | 0
        let o = !!(i & 1)
        i >>= 1
        let l = i == 1,
            f = i == 2
        return { branches: n, valid: s, fe0f: o, save: l, check: f }
    }
}
function ZE() {
    return zE(
        _v(
            "AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="
        )
    )
}
const Qu = ZE(),
    tx = new Set(pu(Qu)),
    ex = new Set(pu(Qu)),
    rx = WE(Qu),
    nx = XE(Qu),
    P0 = 45,
    R0 = 95
function xv(e) {
    return RE(e)
}
function ix(e) {
    return e.filter((t) => t != 65039)
}
function Tv(e) {
    for (let t of e.split(".")) {
        let r = xv(t)
        try {
            for (let n = r.lastIndexOf(R0) - 1; n >= 0; n--) if (r[n] !== R0) throw new Error("underscore only allowed at start")
            if (r.length >= 4 && r.every((n) => n < 128) && r[2] === P0 && r[3] === P0) throw new Error("invalid label extension")
        } catch (n) {
            throw new Error(`Invalid label "${t}": ${n.message}`)
        }
    }
    return e
}
function sx(e) {
    return Tv(ox(e, ix))
}
function ox(e, t) {
    let r = xv(e).reverse(),
        n = []
    for (; r.length; ) {
        let i = lx(r)
        if (i) {
            n.push(...t(i))
            continue
        }
        let s = r.pop()
        if (tx.has(s)) {
            n.push(s)
            continue
        }
        if (ex.has(s)) continue
        let o = rx[s]
        if (o) {
            n.push(...o)
            continue
        }
        throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`)
    }
    return Tv(ax(String.fromCodePoint(...n)))
}
function ax(e) {
    return e.normalize("NFC")
}
function lx(e, t) {
    var r
    let n = nx,
        i,
        s,
        o = [],
        l = e.length
    for (t && (t.length = 0); l; ) {
        let f = e[--l]
        if (((n = (r = n.branches.find((d) => d.set.has(f))) === null || r === void 0 ? void 0 : r.node), !n)) break
        if (n.save) s = f
        else if (n.check && f === s) break
        o.push(f),
            n.fe0f && (o.push(65039), l > 0 && e[l - 1] == 65039 && l--),
            n.valid && ((i = o.slice()), n.valid == 2 && i.splice(1, 1), t && t.push(...e.slice(l).reverse()), (e.length = l))
    }
    return i
}
const ux = new ut(yv),
    Cv = new Uint8Array(32)
Cv.fill(0)
function L0(e) {
    if (e.length === 0) throw new Error("invalid ENS name; empty component")
    return e
}
function Mv(e) {
    const t = ci(sx(e)),
        r = []
    if (e.length === 0) return r
    let n = 0
    for (let i = 0; i < t.length; i++) t[i] === 46 && (r.push(L0(t.slice(n, i))), (n = i + 1))
    if (n >= t.length) throw new Error("invalid ENS name; empty component")
    return r.push(L0(t.slice(n))), r
}
function Hl(e) {
    typeof e != "string" && ux.throwArgumentError("invalid ENS name; not a string", "name", e)
    let t = Cv
    const r = Mv(e)
    for (; r.length; ) t = Xe(Ar([t, Xe(r.pop())]))
    return Lt(t)
}
function fx(e) {
    return (
        Lt(
            Ar(
                Mv(e).map((t) => {
                    if (t.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes")
                    const r = new Uint8Array(t.length + 1)
                    return r.set(t, 1), (r[0] = r.length - 1), r
                })
            )
        ) + "00"
    )
}
var cx =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const $e = new ut(yv),
    Sv = new Uint8Array(32)
Sv.fill(0)
const dx = St.from(-1),
    kv = St.from(0),
    Nv = St.from(1),
    hx = St.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
function px(e) {
    const t = Wt(e),
        r = t.length % 32
    return r ? _r([t, Sv.slice(r)]) : Lt(t)
}
const gx = He(Nv.toHexString(), 32),
    mx = He(kv.toHexString(), 32),
    D0 = { name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32" },
    kf = ["name", "version", "chainId", "verifyingContract", "salt"]
function $0(e) {
    return function (t) {
        return typeof t != "string" && $e.throwArgumentError(`invalid domain value for ${JSON.stringify(e)}`, `domain.${e}`, t), t
    }
}
const vx = {
    name: $0("name"),
    version: $0("version"),
    chainId: function (e) {
        try {
            return St.from(e).toString()
        } catch {}
        return $e.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", e)
    },
    verifyingContract: function (e) {
        try {
            return rr(e).toLowerCase()
        } catch {}
        return $e.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", e)
    },
    salt: function (e) {
        try {
            const t = Wt(e)
            if (t.length !== 32) throw new Error("bad length")
            return Lt(t)
        } catch {}
        return $e.throwArgumentError('invalid domain value "salt"', "domain.salt", e)
    },
}
function Nf(e) {
    {
        const t = e.match(/^(u?)int(\d*)$/)
        if (t) {
            const r = t[1] === "",
                n = parseInt(t[2] || "256")
            ;(n % 8 !== 0 || n > 256 || (t[2] && t[2] !== String(n))) && $e.throwArgumentError("invalid numeric width", "type", e)
            const i = hx.mask(r ? n - 1 : n),
                s = r ? i.add(Nv).mul(dx) : kv
            return function (o) {
                const l = St.from(o)
                return (
                    (l.lt(s) || l.gt(i)) && $e.throwArgumentError(`value out-of-bounds for ${e}`, "value", o),
                    He(l.toTwos(256).toHexString(), 32)
                )
            }
        }
    }
    {
        const t = e.match(/^bytes(\d+)$/)
        if (t) {
            const r = parseInt(t[1])
            return (
                (r === 0 || r > 32 || t[1] !== String(r)) && $e.throwArgumentError("invalid bytes width", "type", e),
                function (n) {
                    return Wt(n).length !== r && $e.throwArgumentError(`invalid length for ${e}`, "value", n), px(n)
                }
            )
        }
    }
    switch (e) {
        case "address":
            return function (t) {
                return He(rr(t), 32)
            }
        case "bool":
            return function (t) {
                return t ? gx : mx
            }
        case "bytes":
            return function (t) {
                return Xe(t)
            }
        case "string":
            return function (t) {
                return co(t)
            }
    }
    return null
}
function F0(e, t) {
    return `${e}(${t.map(({ name: r, type: n }) => n + " " + r).join(",")})`
}
class xr {
    constructor(t) {
        _t(this, "types", Object.freeze(fi(t))), _t(this, "_encoderCache", {}), _t(this, "_types", {})
        const r = {},
            n = {},
            i = {}
        Object.keys(t).forEach((l) => {
            ;(r[l] = {}), (n[l] = []), (i[l] = {})
        })
        for (const l in t) {
            const f = {}
            t[l].forEach((d) => {
                f[d.name] && $e.throwArgumentError(`duplicate variable name ${JSON.stringify(d.name)} in ${JSON.stringify(l)}`, "types", t),
                    (f[d.name] = !0)
                const h = d.type.match(/^([^\x5b]*)(\x5b|$)/)[1]
                h === l && $e.throwArgumentError(`circular type reference to ${JSON.stringify(h)}`, "types", t),
                    !Nf(h) && (n[h] || $e.throwArgumentError(`unknown type ${JSON.stringify(h)}`, "types", t), n[h].push(l), (r[l][h] = !0))
            })
        }
        const s = Object.keys(n).filter((l) => n[l].length === 0)
        s.length === 0
            ? $e.throwArgumentError("missing primary type", "types", t)
            : s.length > 1 &&
              $e.throwArgumentError(`ambiguous primary types or unused types: ${s.map((l) => JSON.stringify(l)).join(", ")}`, "types", t),
            _t(this, "primaryType", s[0])
        function o(l, f) {
            f[l] && $e.throwArgumentError(`circular type reference to ${JSON.stringify(l)}`, "types", t),
                (f[l] = !0),
                Object.keys(r[l]).forEach((d) => {
                    !n[d] ||
                        (o(d, f),
                        Object.keys(f).forEach((h) => {
                            i[h][d] = !0
                        }))
                }),
                delete f[l]
        }
        o(this.primaryType, {})
        for (const l in i) {
            const f = Object.keys(i[l])
            f.sort(), (this._types[l] = F0(l, t[l]) + f.map((d) => F0(d, t[d])).join(""))
        }
    }
    getEncoder(t) {
        let r = this._encoderCache[t]
        return r || (r = this._encoderCache[t] = this._getEncoder(t)), r
    }
    _getEncoder(t) {
        {
            const i = Nf(t)
            if (i) return i
        }
        const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (r) {
            const i = r[1],
                s = this.getEncoder(i),
                o = parseInt(r[3])
            return (l) => {
                o >= 0 && l.length !== o && $e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", l)
                let f = l.map(s)
                return this._types[i] && (f = f.map(Xe)), Xe(_r(f))
            }
        }
        const n = this.types[t]
        if (n) {
            const i = co(this._types[t])
            return (s) => {
                const o = n.map(({ name: l, type: f }) => {
                    const d = this.getEncoder(f)(s[l])
                    return this._types[f] ? Xe(d) : d
                })
                return o.unshift(i), _r(o)
            }
        }
        return $e.throwArgumentError(`unknown type: ${t}`, "type", t)
    }
    encodeType(t) {
        const r = this._types[t]
        return r || $e.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t), r
    }
    encodeData(t, r) {
        return this.getEncoder(t)(r)
    }
    hashStruct(t, r) {
        return Xe(this.encodeData(t, r))
    }
    encode(t) {
        return this.encodeData(this.primaryType, t)
    }
    hash(t) {
        return this.hashStruct(this.primaryType, t)
    }
    _visit(t, r, n) {
        if (Nf(t)) return n(t, r)
        const i = t.match(/^(.*)(\x5b(\d*)\x5d)$/)
        if (i) {
            const o = i[1],
                l = parseInt(i[3])
            return (
                l >= 0 && r.length !== l && $e.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r),
                r.map((f) => this._visit(o, f, n))
            )
        }
        const s = this.types[t]
        return s
            ? s.reduce((o, { name: l, type: f }) => ((o[l] = this._visit(f, r[l], n)), o), {})
            : $e.throwArgumentError(`unknown type: ${t}`, "type", t)
    }
    visit(t, r) {
        return this._visit(this.primaryType, t, r)
    }
    static from(t) {
        return new xr(t)
    }
    static getPrimaryType(t) {
        return xr.from(t).primaryType
    }
    static hashStruct(t, r, n) {
        return xr.from(r).hashStruct(t, n)
    }
    static hashDomain(t) {
        const r = []
        for (const n in t) {
            const i = D0[n]
            i || $e.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", t), r.push({ name: n, type: i })
        }
        return r.sort((n, i) => kf.indexOf(n.name) - kf.indexOf(i.name)), xr.hashStruct("EIP712Domain", { EIP712Domain: r }, t)
    }
    static encode(t, r, n) {
        return _r(["0x1901", xr.hashDomain(t), xr.from(r).hash(n)])
    }
    static hash(t, r, n) {
        return Xe(xr.encode(t, r, n))
    }
    static resolveNames(t, r, n, i) {
        return cx(this, void 0, void 0, function* () {
            t = Ye(t)
            const s = {}
            t.verifyingContract && !Te(t.verifyingContract, 20) && (s[t.verifyingContract] = "0x")
            const o = xr.from(r)
            o.visit(n, (l, f) => (l === "address" && !Te(f, 20) && (s[f] = "0x"), f))
            for (const l in s) s[l] = yield i(l)
            return (
                t.verifyingContract && s[t.verifyingContract] && (t.verifyingContract = s[t.verifyingContract]),
                (n = o.visit(n, (l, f) => (l === "address" && s[f] ? s[f] : f))),
                { domain: t, value: n }
            )
        })
    }
    static getPayload(t, r, n) {
        xr.hashDomain(t)
        const i = {},
            s = []
        kf.forEach((f) => {
            const d = t[f]
            d != null && ((i[f] = vx[f](d)), s.push({ name: f, type: D0[f] }))
        })
        const o = xr.from(r),
            l = Ye(r)
        return (
            l.EIP712Domain ? $e.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : (l.EIP712Domain = s),
            o.encode(n),
            {
                types: l,
                domain: i,
                primaryType: o.primaryType,
                message: o.visit(n, (f, d) => {
                    if (f.match(/^bytes(\d*)/)) return Lt(Wt(d))
                    if (f.match(/^u?int/)) return St.from(d).toString()
                    switch (f) {
                        case "address":
                            return d.toLowerCase()
                        case "bool":
                            return !!d
                        case "string":
                            return typeof d != "string" && $e.throwArgumentError("invalid string", "value", d), d
                    }
                    return $e.throwArgumentError("unsupported type", "type", f)
                }),
            }
        )
    }
}
const De = new ut(il)
class bx extends nl {}
class yx extends nl {}
class _x extends nl {}
class Ic extends nl {
    static isIndexed(t) {
        return !!(t && t._isIndexed)
    }
}
const wx = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] },
}
function V0(e, t) {
    const r = new Error(`deferred error during ABI decoding triggered accessing ${e}`)
    return (r.error = t), r
}
class Bc {
    constructor(t) {
        let r = []
        typeof t == "string" ? (r = JSON.parse(t)) : (r = t),
            _t(
                this,
                "fragments",
                r.map((n) => ei.from(n)).filter((n) => n != null)
            ),
            _t(this, "_abiCoder", Ir(new.target, "getAbiCoder")()),
            _t(this, "functions", {}),
            _t(this, "errors", {}),
            _t(this, "events", {}),
            _t(this, "structs", {}),
            this.fragments.forEach((n) => {
                let i = null
                switch (n.type) {
                    case "constructor":
                        if (this.deploy) {
                            De.warn("duplicate definition - constructor")
                            return
                        }
                        _t(this, "deploy", n)
                        return
                    case "function":
                        i = this.functions
                        break
                    case "event":
                        i = this.events
                        break
                    case "error":
                        i = this.errors
                        break
                    default:
                        return
                }
                let s = n.format()
                if (i[s]) {
                    De.warn("duplicate definition - " + s)
                    return
                }
                i[s] = n
            }),
            this.deploy || _t(this, "deploy", Nn.from({ payable: !1, type: "constructor" })),
            _t(this, "_isInterface", !0)
    }
    format(t) {
        t || (t = xe.full), t === xe.sighash && De.throwArgumentError("interface does not support formatting sighash", "format", t)
        const r = this.fragments.map((n) => n.format(t))
        return t === xe.json ? JSON.stringify(r.map((n) => JSON.parse(n))) : r
    }
    static getAbiCoder() {
        return VE
    }
    static getAddress(t) {
        return rr(t)
    }
    static getSighash(t) {
        return fr(co(t.format()), 0, 4)
    }
    static getEventTopic(t) {
        return co(t.format())
    }
    getFunction(t) {
        if (Te(t)) {
            for (const n in this.functions) if (t === this.getSighash(n)) return this.functions[n]
            De.throwArgumentError("no matching function", "sighash", t)
        }
        if (t.indexOf("(") === -1) {
            const n = t.trim(),
                i = Object.keys(this.functions).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? De.throwArgumentError("no matching function", "name", n)
                    : i.length > 1 && De.throwArgumentError("multiple matching functions", "name", n),
                this.functions[i[0]]
            )
        }
        const r = this.functions[On.fromString(t).format()]
        return r || De.throwArgumentError("no matching function", "signature", t), r
    }
    getEvent(t) {
        if (Te(t)) {
            const n = t.toLowerCase()
            for (const i in this.events) if (n === this.getEventTopic(i)) return this.events[i]
            De.throwArgumentError("no matching event", "topichash", n)
        }
        if (t.indexOf("(") === -1) {
            const n = t.trim(),
                i = Object.keys(this.events).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? De.throwArgumentError("no matching event", "name", n)
                    : i.length > 1 && De.throwArgumentError("multiple matching events", "name", n),
                this.events[i[0]]
            )
        }
        const r = this.events[Zn.fromString(t).format()]
        return r || De.throwArgumentError("no matching event", "signature", t), r
    }
    getError(t) {
        if (Te(t)) {
            const n = Ir(this.constructor, "getSighash")
            for (const i in this.errors) {
                const s = this.errors[i]
                if (t === n(s)) return this.errors[i]
            }
            De.throwArgumentError("no matching error", "sighash", t)
        }
        if (t.indexOf("(") === -1) {
            const n = t.trim(),
                i = Object.keys(this.errors).filter((s) => s.split("(")[0] === n)
            return (
                i.length === 0
                    ? De.throwArgumentError("no matching error", "name", n)
                    : i.length > 1 && De.throwArgumentError("multiple matching errors", "name", n),
                this.errors[i[0]]
            )
        }
        const r = this.errors[On.fromString(t).format()]
        return r || De.throwArgumentError("no matching error", "signature", t), r
    }
    getSighash(t) {
        if (typeof t == "string")
            try {
                t = this.getFunction(t)
            } catch (r) {
                try {
                    t = this.getError(t)
                } catch {
                    throw r
                }
            }
        return Ir(this.constructor, "getSighash")(t)
    }
    getEventTopic(t) {
        return typeof t == "string" && (t = this.getEvent(t)), Ir(this.constructor, "getEventTopic")(t)
    }
    _decodeParams(t, r) {
        return this._abiCoder.decode(t, r)
    }
    _encodeParams(t, r) {
        return this._abiCoder.encode(t, r)
    }
    encodeDeploy(t) {
        return this._encodeParams(this.deploy.inputs, t || [])
    }
    decodeErrorResult(t, r) {
        typeof t == "string" && (t = this.getError(t))
        const n = Wt(r)
        return (
            Lt(n.slice(0, 4)) !== this.getSighash(t) && De.throwArgumentError(`data signature does not match error ${t.name}.`, "data", Lt(n)),
            this._decodeParams(t.inputs, n.slice(4))
        )
    }
    encodeErrorResult(t, r) {
        return typeof t == "string" && (t = this.getError(t)), Lt(Ar([this.getSighash(t), this._encodeParams(t.inputs, r || [])]))
    }
    decodeFunctionData(t, r) {
        typeof t == "string" && (t = this.getFunction(t))
        const n = Wt(r)
        return (
            Lt(n.slice(0, 4)) !== this.getSighash(t) &&
                De.throwArgumentError(`data signature does not match function ${t.name}.`, "data", Lt(n)),
            this._decodeParams(t.inputs, n.slice(4))
        )
    }
    encodeFunctionData(t, r) {
        return typeof t == "string" && (t = this.getFunction(t)), Lt(Ar([this.getSighash(t), this._encodeParams(t.inputs, r || [])]))
    }
    decodeFunctionResult(t, r) {
        typeof t == "string" && (t = this.getFunction(t))
        let n = Wt(r),
            i = null,
            s = "",
            o = null,
            l = null,
            f = null
        switch (n.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(t.outputs, n)
                } catch {}
                break
            case 4: {
                const d = Lt(n.slice(0, 4)),
                    h = wx[d]
                if (h)
                    (o = this._abiCoder.decode(h.inputs, n.slice(4))),
                        (l = h.name),
                        (f = h.signature),
                        h.reason && (i = o[0]),
                        l === "Error"
                            ? (s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}`)
                            : l === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`)
                else
                    try {
                        const y = this.getError(d)
                        ;(o = this._abiCoder.decode(y.inputs, n.slice(4))), (l = y.name), (f = y.format())
                    } catch {}
                break
            }
        }
        return De.throwError("call revert exception" + s, ut.errors.CALL_EXCEPTION, {
            method: t.format(),
            data: Lt(r),
            errorArgs: o,
            errorName: l,
            errorSignature: f,
            reason: i,
        })
    }
    encodeFunctionResult(t, r) {
        return typeof t == "string" && (t = this.getFunction(t)), Lt(this._abiCoder.encode(t.outputs, r || []))
    }
    encodeFilterTopics(t, r) {
        typeof t == "string" && (t = this.getEvent(t)),
            r.length > t.inputs.length &&
                De.throwError("too many arguments for " + t.format(), ut.errors.UNEXPECTED_ARGUMENT, { argument: "values", value: r })
        let n = []
        t.anonymous || n.push(this.getEventTopic(t))
        const i = (s, o) =>
            s.type === "string"
                ? co(o)
                : s.type === "bytes"
                ? Xe(Lt(o))
                : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"),
                  s.type.match(/^u?int/) && (o = St.from(o).toHexString()),
                  s.type === "address" && this._abiCoder.encode(["address"], [o]),
                  He(Lt(o), 32))
        for (
            r.forEach((s, o) => {
                let l = t.inputs[o]
                if (!l.indexed) {
                    s != null && De.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + l.name, s)
                    return
                }
                s == null
                    ? n.push(null)
                    : l.baseType === "array" || l.baseType === "tuple"
                    ? De.throwArgumentError("filtering with tuples or arrays not supported", "contract." + l.name, s)
                    : Array.isArray(s)
                    ? n.push(s.map((f) => i(l, f)))
                    : n.push(i(l, s))
            });
            n.length && n[n.length - 1] === null;

        )
            n.pop()
        return n
    }
    encodeEventLog(t, r) {
        typeof t == "string" && (t = this.getEvent(t))
        const n = [],
            i = [],
            s = []
        return (
            t.anonymous || n.push(this.getEventTopic(t)),
            r.length !== t.inputs.length && De.throwArgumentError("event arguments/values mismatch", "values", r),
            t.inputs.forEach((o, l) => {
                const f = r[l]
                if (o.indexed)
                    if (o.type === "string") n.push(co(f))
                    else if (o.type === "bytes") n.push(Xe(f))
                    else {
                        if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented")
                        n.push(this._abiCoder.encode([o.type], [f]))
                    }
                else i.push(o), s.push(f)
            }),
            { data: this._abiCoder.encode(i, s), topics: n }
        )
    }
    decodeEventLog(t, r, n) {
        if ((typeof t == "string" && (t = this.getEvent(t)), n != null && !t.anonymous)) {
            let E = this.getEventTopic(t)
            ;(!Te(n[0], 32) || n[0].toLowerCase() !== E) &&
                De.throwError("fragment/topic mismatch", ut.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: E, value: n[0] }),
                (n = n.slice(1))
        }
        let i = [],
            s = [],
            o = []
        t.inputs.forEach((E, T) => {
            E.indexed
                ? E.type === "string" || E.type === "bytes" || E.baseType === "tuple" || E.baseType === "array"
                    ? (i.push(er.fromObject({ type: "bytes32", name: E.name })), o.push(!0))
                    : (i.push(E), o.push(!1))
                : (s.push(E), o.push(!1))
        })
        let l = n != null ? this._abiCoder.decode(i, Ar(n)) : null,
            f = this._abiCoder.decode(s, r, !0),
            d = [],
            h = 0,
            y = 0
        t.inputs.forEach((E, T) => {
            if (E.indexed)
                if (l == null) d[T] = new Ic({ _isIndexed: !0, hash: null })
                else if (o[T]) d[T] = new Ic({ _isIndexed: !0, hash: l[y++] })
                else
                    try {
                        d[T] = l[y++]
                    } catch (S) {
                        d[T] = S
                    }
            else
                try {
                    d[T] = f[h++]
                } catch (S) {
                    d[T] = S
                }
            if (E.name && d[E.name] == null) {
                const S = d[T]
                S instanceof Error
                    ? Object.defineProperty(d, E.name, {
                          enumerable: !0,
                          get: () => {
                              throw V0(`property ${JSON.stringify(E.name)}`, S)
                          },
                      })
                    : (d[E.name] = S)
            }
        })
        for (let E = 0; E < d.length; E++) {
            const T = d[E]
            T instanceof Error &&
                Object.defineProperty(d, E, {
                    enumerable: !0,
                    get: () => {
                        throw V0(`index ${E}`, T)
                    },
                })
        }
        return Object.freeze(d)
    }
    parseTransaction(t) {
        let r = this.getFunction(t.data.substring(0, 10).toLowerCase())
        return r
            ? new yx({
                  args: this._abiCoder.decode(r.inputs, "0x" + t.data.substring(10)),
                  functionFragment: r,
                  name: r.name,
                  signature: r.format(),
                  sighash: this.getSighash(r),
                  value: St.from(t.value || "0"),
              })
            : null
    }
    parseLog(t) {
        let r = this.getEvent(t.topics[0])
        return !r || r.anonymous
            ? null
            : new bx({
                  eventFragment: r,
                  name: r.name,
                  signature: r.format(),
                  topic: this.getEventTopic(r),
                  args: this.decodeEventLog(r, t.data, t.topics),
              })
    }
    parseError(t) {
        const r = Lt(t)
        let n = this.getError(r.substring(0, 10).toLowerCase())
        return n
            ? new _x({
                  args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
                  errorFragment: n,
                  name: n.name,
                  signature: n.format(),
                  sighash: this.getSighash(n),
              })
            : null
    }
    static isInterface(t) {
        return !!(t && t._isInterface)
    }
}
const Ax = "abstract-provider/5.7.0"
var Ex =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const xx = new ut(Ax)
class Tx extends nl {
    static isForkEvent(t) {
        return !!(t && t._isForkEvent)
    }
}
class Xu {
    constructor() {
        xx.checkAbstract(new.target, Xu), _t(this, "_isProvider", !0)
    }
    getFeeData() {
        return Ex(this, void 0, void 0, function* () {
            const { block: t, gasPrice: r } = yield Ge({ block: this.getBlock("latest"), gasPrice: this.getGasPrice().catch((o) => null) })
            let n = null,
                i = null,
                s = null
            return (
                t && t.baseFeePerGas && ((n = t.baseFeePerGas), (s = St.from("1500000000")), (i = t.baseFeePerGas.mul(2).add(s))),
                { lastBaseFeePerGas: n, maxFeePerGas: i, maxPriorityFeePerGas: s, gasPrice: r }
            )
        })
    }
    addListener(t, r) {
        return this.on(t, r)
    }
    removeListener(t, r) {
        return this.off(t, r)
    }
    static isProvider(t) {
        return !!(t && t._isProvider)
    }
}
const Cx = "abstract-signer/5.7.0"
var nn =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const Gr = new ut(Cx),
    Mx = [
        "accessList",
        "ccipReadEnabled",
        "chainId",
        "customData",
        "data",
        "from",
        "gasLimit",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "to",
        "type",
        "value",
    ],
    Sx = [ut.errors.INSUFFICIENT_FUNDS, ut.errors.NONCE_EXPIRED, ut.errors.REPLACEMENT_UNDERPRICED]
class qo {
    constructor() {
        Gr.checkAbstract(new.target, qo), _t(this, "_isSigner", !0)
    }
    getBalance(t) {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t)
        })
    }
    getTransactionCount(t) {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), t)
        })
    }
    estimateGas(t) {
        return nn(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas")
            const r = yield Ge(this.checkTransaction(t))
            return yield this.provider.estimateGas(r)
        })
    }
    call(t, r) {
        return nn(this, void 0, void 0, function* () {
            this._checkProvider("call")
            const n = yield Ge(this.checkTransaction(t))
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(t) {
        return nn(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction")
            const r = yield this.populateTransaction(t),
                n = yield this.signTransaction(r)
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(t) {
        return nn(this, void 0, void 0, function* () {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(t)
        })
    }
    checkTransaction(t) {
        for (const n in t) Mx.indexOf(n) === -1 && Gr.throwArgumentError("invalid transaction key: " + n, "transaction", t)
        const r = Ye(t)
        return (
            r.from == null
                ? (r.from = this.getAddress())
                : (r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(
                      (n) => (
                          n[0].toLowerCase() !== n[1].toLowerCase() && Gr.throwArgumentError("from address mismatch", "transaction", t), n[0]
                      )
                  )),
            r
        )
    }
    populateTransaction(t) {
        return nn(this, void 0, void 0, function* () {
            const r = yield Ge(this.checkTransaction(t))
            r.to != null &&
                ((r.to = Promise.resolve(r.to).then((i) =>
                    nn(this, void 0, void 0, function* () {
                        if (i == null) return null
                        const s = yield this.resolveName(i)
                        return s == null && Gr.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
                    })
                )),
                r.to.catch((i) => {}))
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null
            if (
                (r.gasPrice != null && (r.type === 2 || n)
                    ? Gr.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", t)
                    : (r.type === 0 || r.type === 1) &&
                      n &&
                      Gr.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", t),
                (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
            )
                r.type = 2
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice())
            else {
                const i = yield this.getFeeData()
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (((r.type = 2), r.gasPrice != null)) {
                            const s = r.gasPrice
                            delete r.gasPrice, (r.maxFeePerGas = s), (r.maxPriorityFeePerGas = s)
                        } else
                            r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
                                r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas)
                    else
                        i.gasPrice != null
                            ? (n &&
                                  Gr.throwError("network does not support EIP-1559", ut.errors.UNSUPPORTED_OPERATION, {
                                      operation: "populateTransaction",
                                  }),
                              r.gasPrice == null && (r.gasPrice = i.gasPrice),
                              (r.type = 0))
                            : Gr.throwError("failed to get consistent fee data", ut.errors.UNSUPPORTED_OPERATION, {
                                  operation: "signer.getFeeData",
                              })
                else
                    r.type === 2 &&
                        (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas),
                        r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return (
                r.nonce == null && (r.nonce = this.getTransactionCount("pending")),
                r.gasLimit == null &&
                    (r.gasLimit = this.estimateGas(r).catch((i) => {
                        if (Sx.indexOf(i.code) >= 0) throw i
                        return Gr.throwError(
                            "cannot estimate gas; transaction may fail or may require manual gas limit",
                            ut.errors.UNPREDICTABLE_GAS_LIMIT,
                            { error: i, tx: r }
                        )
                    })),
                r.chainId == null
                    ? (r.chainId = this.getChainId())
                    : (r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(
                          (i) => (i[1] !== 0 && i[0] !== i[1] && Gr.throwArgumentError("chainId address mismatch", "transaction", t), i[0])
                      )),
                yield Ge(r)
            )
        })
    }
    _checkProvider(t) {
        this.provider || Gr.throwError("missing provider", ut.errors.UNSUPPORTED_OPERATION, { operation: t || "_checkProvider" })
    }
    static isSigner(t) {
        return !!(t && t._isSigner)
    }
}
class Ud extends qo {
    constructor(t, r) {
        super(), _t(this, "address", t), _t(this, "provider", r || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(t, r) {
        return Promise.resolve().then(() => {
            Gr.throwError(t, ut.errors.UNSUPPORTED_OPERATION, { operation: r })
        })
    }
    signMessage(t) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(t) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(t, r, n) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(t) {
        return new Ud(this.address, t)
    }
}
var Ov = { exports: {} }
;(function (e) {
    ;(function (t, r) {
        function n(x, a) {
            if (!x) throw new Error(a || "Assertion failed")
        }
        function i(x, a) {
            x.super_ = a
            var c = function () {}
            ;(c.prototype = a.prototype), (x.prototype = new c()), (x.prototype.constructor = x)
        }
        function s(x, a, c) {
            if (s.isBN(x)) return x
            ;(this.negative = 0),
                (this.words = null),
                (this.length = 0),
                (this.red = null),
                x !== null && ((a === "le" || a === "be") && ((c = a), (a = 10)), this._init(x || 0, a || 10, c || "be"))
        }
        typeof t == "object" ? (t.exports = s) : (r.BN = s), (s.BN = s), (s.wordSize = 26)
        var o
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? (o = window.Buffer) : (o = require("buffer").Buffer)
        } catch {}
        ;(s.isBN = function (a) {
            return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words)
        }),
            (s.max = function (a, c) {
                return a.cmp(c) > 0 ? a : c
            }),
            (s.min = function (a, c) {
                return a.cmp(c) < 0 ? a : c
            }),
            (s.prototype._init = function (a, c, m) {
                if (typeof a == "number") return this._initNumber(a, c, m)
                if (typeof a == "object") return this._initArray(a, c, m)
                c === "hex" && (c = 16), n(c === (c | 0) && c >= 2 && c <= 36), (a = a.toString().replace(/\s+/g, ""))
                var _ = 0
                a[0] === "-" && (_++, (this.negative = 1)),
                    _ < a.length &&
                        (c === 16 ? this._parseHex(a, _, m) : (this._parseBase(a, c, _), m === "le" && this._initArray(this.toArray(), c, m)))
            }),
            (s.prototype._initNumber = function (a, c, m) {
                a < 0 && ((this.negative = 1), (a = -a)),
                    a < 67108864
                        ? ((this.words = [a & 67108863]), (this.length = 1))
                        : a < 4503599627370496
                        ? ((this.words = [a & 67108863, (a / 67108864) & 67108863]), (this.length = 2))
                        : (n(a < 9007199254740992), (this.words = [a & 67108863, (a / 67108864) & 67108863, 1]), (this.length = 3)),
                    m === "le" && this._initArray(this.toArray(), c, m)
            }),
            (s.prototype._initArray = function (a, c, m) {
                if ((n(typeof a.length == "number"), a.length <= 0)) return (this.words = [0]), (this.length = 1), this
                ;(this.length = Math.ceil(a.length / 3)), (this.words = new Array(this.length))
                for (var _ = 0; _ < this.length; _++) this.words[_] = 0
                var A,
                    w,
                    v = 0
                if (m === "be")
                    for (_ = a.length - 1, A = 0; _ >= 0; _ -= 3)
                        (w = a[_] | (a[_ - 1] << 8) | (a[_ - 2] << 16)),
                            (this.words[A] |= (w << v) & 67108863),
                            (this.words[A + 1] = (w >>> (26 - v)) & 67108863),
                            (v += 24),
                            v >= 26 && ((v -= 26), A++)
                else if (m === "le")
                    for (_ = 0, A = 0; _ < a.length; _ += 3)
                        (w = a[_] | (a[_ + 1] << 8) | (a[_ + 2] << 16)),
                            (this.words[A] |= (w << v) & 67108863),
                            (this.words[A + 1] = (w >>> (26 - v)) & 67108863),
                            (v += 24),
                            v >= 26 && ((v -= 26), A++)
                return this._strip()
            })
        function l(x, a) {
            var c = x.charCodeAt(a)
            if (c >= 48 && c <= 57) return c - 48
            if (c >= 65 && c <= 70) return c - 55
            if (c >= 97 && c <= 102) return c - 87
            n(!1, "Invalid character in " + x)
        }
        function f(x, a, c) {
            var m = l(x, c)
            return c - 1 >= a && (m |= l(x, c - 1) << 4), m
        }
        s.prototype._parseHex = function (a, c, m) {
            ;(this.length = Math.ceil((a.length - c) / 6)), (this.words = new Array(this.length))
            for (var _ = 0; _ < this.length; _++) this.words[_] = 0
            var A = 0,
                w = 0,
                v
            if (m === "be")
                for (_ = a.length - 1; _ >= c; _ -= 2)
                    (v = f(a, c, _) << A),
                        (this.words[w] |= v & 67108863),
                        A >= 18 ? ((A -= 18), (w += 1), (this.words[w] |= v >>> 26)) : (A += 8)
            else {
                var g = a.length - c
                for (_ = g % 2 === 0 ? c + 1 : c; _ < a.length; _ += 2)
                    (v = f(a, c, _) << A),
                        (this.words[w] |= v & 67108863),
                        A >= 18 ? ((A -= 18), (w += 1), (this.words[w] |= v >>> 26)) : (A += 8)
            }
            this._strip()
        }
        function d(x, a, c, m) {
            for (var _ = 0, A = 0, w = Math.min(x.length, c), v = a; v < w; v++) {
                var g = x.charCodeAt(v) - 48
                ;(_ *= m), g >= 49 ? (A = g - 49 + 10) : g >= 17 ? (A = g - 17 + 10) : (A = g), n(g >= 0 && A < m, "Invalid character"), (_ += A)
            }
            return _
        }
        ;(s.prototype._parseBase = function (a, c, m) {
            ;(this.words = [0]), (this.length = 1)
            for (var _ = 0, A = 1; A <= 67108863; A *= c) _++
            _--, (A = (A / c) | 0)
            for (var w = a.length - m, v = w % _, g = Math.min(w, w - v) + m, u = 0, p = m; p < g; p += _)
                (u = d(a, p, p + _, c)), this.imuln(A), this.words[0] + u < 67108864 ? (this.words[0] += u) : this._iaddn(u)
            if (v !== 0) {
                var H = 1
                for (u = d(a, p, a.length, c), p = 0; p < v; p++) H *= c
                this.imuln(H), this.words[0] + u < 67108864 ? (this.words[0] += u) : this._iaddn(u)
            }
            this._strip()
        }),
            (s.prototype.copy = function (a) {
                a.words = new Array(this.length)
                for (var c = 0; c < this.length; c++) a.words[c] = this.words[c]
                ;(a.length = this.length), (a.negative = this.negative), (a.red = this.red)
            })
        function h(x, a) {
            ;(x.words = a.words), (x.length = a.length), (x.negative = a.negative), (x.red = a.red)
        }
        if (
            ((s.prototype._move = function (a) {
                h(a, this)
            }),
            (s.prototype.clone = function () {
                var a = new s(null)
                return this.copy(a), a
            }),
            (s.prototype._expand = function (a) {
                for (; this.length < a; ) this.words[this.length++] = 0
                return this
            }),
            (s.prototype._strip = function () {
                for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
                return this._normSign()
            }),
            (s.prototype._normSign = function () {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            typeof Symbol != "undefined" && typeof Symbol.for == "function")
        )
            try {
                s.prototype[Symbol.for("nodejs.util.inspect.custom")] = y
            } catch {
                s.prototype.inspect = y
            }
        else s.prototype.inspect = y
        function y() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var E = [
                "",
                "0",
                "00",
                "000",
                "0000",
                "00000",
                "000000",
                "0000000",
                "00000000",
                "000000000",
                "0000000000",
                "00000000000",
                "000000000000",
                "0000000000000",
                "00000000000000",
                "000000000000000",
                "0000000000000000",
                "00000000000000000",
                "000000000000000000",
                "0000000000000000000",
                "00000000000000000000",
                "000000000000000000000",
                "0000000000000000000000",
                "00000000000000000000000",
                "000000000000000000000000",
                "0000000000000000000000000",
            ],
            T = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            S = [
                0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
                11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907,
                17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
            ]
        ;(s.prototype.toString = function (a, c) {
            ;(a = a || 10), (c = c | 0 || 1)
            var m
            if (a === 16 || a === "hex") {
                m = ""
                for (var _ = 0, A = 0, w = 0; w < this.length; w++) {
                    var v = this.words[w],
                        g = (((v << _) | A) & 16777215).toString(16)
                    ;(A = (v >>> (24 - _)) & 16777215),
                        (_ += 2),
                        _ >= 26 && ((_ -= 26), w--),
                        A !== 0 || w !== this.length - 1 ? (m = E[6 - g.length] + g + m) : (m = g + m)
                }
                for (A !== 0 && (m = A.toString(16) + m); m.length % c !== 0; ) m = "0" + m
                return this.negative !== 0 && (m = "-" + m), m
            }
            if (a === (a | 0) && a >= 2 && a <= 36) {
                var u = T[a],
                    p = S[a]
                m = ""
                var H = this.clone()
                for (H.negative = 0; !H.isZero(); ) {
                    var b = H.modrn(p).toString(a)
                    ;(H = H.idivn(p)), H.isZero() ? (m = b + m) : (m = E[u - b.length] + b + m)
                }
                for (this.isZero() && (m = "0" + m); m.length % c !== 0; ) m = "0" + m
                return this.negative !== 0 && (m = "-" + m), m
            }
            n(!1, "Base should be between 2 and 36")
        }),
            (s.prototype.toNumber = function () {
                var a = this.words[0]
                return (
                    this.length === 2
                        ? (a += this.words[1] * 67108864)
                        : this.length === 3 && this.words[2] === 1
                        ? (a += 4503599627370496 + this.words[1] * 67108864)
                        : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"),
                    this.negative !== 0 ? -a : a
                )
            }),
            (s.prototype.toJSON = function () {
                return this.toString(16, 2)
            }),
            o &&
                (s.prototype.toBuffer = function (a, c) {
                    return this.toArrayLike(o, a, c)
                }),
            (s.prototype.toArray = function (a, c) {
                return this.toArrayLike(Array, a, c)
            })
        var N = function (a, c) {
            return a.allocUnsafe ? a.allocUnsafe(c) : new a(c)
        }
        ;(s.prototype.toArrayLike = function (a, c, m) {
            this._strip()
            var _ = this.byteLength(),
                A = m || Math.max(1, _)
            n(_ <= A, "byte array longer than desired length"), n(A > 0, "Requested array length <= 0")
            var w = N(a, A),
                v = c === "le" ? "LE" : "BE"
            return this["_toArrayLike" + v](w, _), w
        }),
            (s.prototype._toArrayLikeLE = function (a, c) {
                for (var m = 0, _ = 0, A = 0, w = 0; A < this.length; A++) {
                    var v = (this.words[A] << w) | _
                    ;(a[m++] = v & 255),
                        m < a.length && (a[m++] = (v >> 8) & 255),
                        m < a.length && (a[m++] = (v >> 16) & 255),
                        w === 6 ? (m < a.length && (a[m++] = (v >> 24) & 255), (_ = 0), (w = 0)) : ((_ = v >>> 24), (w += 2))
                }
                if (m < a.length) for (a[m++] = _; m < a.length; ) a[m++] = 0
            }),
            (s.prototype._toArrayLikeBE = function (a, c) {
                for (var m = a.length - 1, _ = 0, A = 0, w = 0; A < this.length; A++) {
                    var v = (this.words[A] << w) | _
                    ;(a[m--] = v & 255),
                        m >= 0 && (a[m--] = (v >> 8) & 255),
                        m >= 0 && (a[m--] = (v >> 16) & 255),
                        w === 6 ? (m >= 0 && (a[m--] = (v >> 24) & 255), (_ = 0), (w = 0)) : ((_ = v >>> 24), (w += 2))
                }
                if (m >= 0) for (a[m--] = _; m >= 0; ) a[m--] = 0
            }),
            Math.clz32
                ? (s.prototype._countBits = function (a) {
                      return 32 - Math.clz32(a)
                  })
                : (s.prototype._countBits = function (a) {
                      var c = a,
                          m = 0
                      return (
                          c >= 4096 && ((m += 13), (c >>>= 13)),
                          c >= 64 && ((m += 7), (c >>>= 7)),
                          c >= 8 && ((m += 4), (c >>>= 4)),
                          c >= 2 && ((m += 2), (c >>>= 2)),
                          m + c
                      )
                  }),
            (s.prototype._zeroBits = function (a) {
                if (a === 0) return 26
                var c = a,
                    m = 0
                return (
                    (c & 8191) === 0 && ((m += 13), (c >>>= 13)),
                    (c & 127) === 0 && ((m += 7), (c >>>= 7)),
                    (c & 15) === 0 && ((m += 4), (c >>>= 4)),
                    (c & 3) === 0 && ((m += 2), (c >>>= 2)),
                    (c & 1) === 0 && m++,
                    m
                )
            }),
            (s.prototype.bitLength = function () {
                var a = this.words[this.length - 1],
                    c = this._countBits(a)
                return (this.length - 1) * 26 + c
            })
        function P(x) {
            for (var a = new Array(x.bitLength()), c = 0; c < a.length; c++) {
                var m = (c / 26) | 0,
                    _ = c % 26
                a[c] = (x.words[m] >>> _) & 1
            }
            return a
        }
        ;(s.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var a = 0, c = 0; c < this.length; c++) {
                var m = this._zeroBits(this.words[c])
                if (((a += m), m !== 26)) break
            }
            return a
        }),
            (s.prototype.byteLength = function () {
                return Math.ceil(this.bitLength() / 8)
            }),
            (s.prototype.toTwos = function (a) {
                return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone()
            }),
            (s.prototype.fromTwos = function (a) {
                return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone()
            }),
            (s.prototype.isNeg = function () {
                return this.negative !== 0
            }),
            (s.prototype.neg = function () {
                return this.clone().ineg()
            }),
            (s.prototype.ineg = function () {
                return this.isZero() || (this.negative ^= 1), this
            }),
            (s.prototype.iuor = function (a) {
                for (; this.length < a.length; ) this.words[this.length++] = 0
                for (var c = 0; c < a.length; c++) this.words[c] = this.words[c] | a.words[c]
                return this._strip()
            }),
            (s.prototype.ior = function (a) {
                return n((this.negative | a.negative) === 0), this.iuor(a)
            }),
            (s.prototype.or = function (a) {
                return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this)
            }),
            (s.prototype.uor = function (a) {
                return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this)
            }),
            (s.prototype.iuand = function (a) {
                var c
                this.length > a.length ? (c = a) : (c = this)
                for (var m = 0; m < c.length; m++) this.words[m] = this.words[m] & a.words[m]
                return (this.length = c.length), this._strip()
            }),
            (s.prototype.iand = function (a) {
                return n((this.negative | a.negative) === 0), this.iuand(a)
            }),
            (s.prototype.and = function (a) {
                return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this)
            }),
            (s.prototype.uand = function (a) {
                return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this)
            }),
            (s.prototype.iuxor = function (a) {
                var c, m
                this.length > a.length ? ((c = this), (m = a)) : ((c = a), (m = this))
                for (var _ = 0; _ < m.length; _++) this.words[_] = c.words[_] ^ m.words[_]
                if (this !== c) for (; _ < c.length; _++) this.words[_] = c.words[_]
                return (this.length = c.length), this._strip()
            }),
            (s.prototype.ixor = function (a) {
                return n((this.negative | a.negative) === 0), this.iuxor(a)
            }),
            (s.prototype.xor = function (a) {
                return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this)
            }),
            (s.prototype.uxor = function (a) {
                return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this)
            }),
            (s.prototype.inotn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = Math.ceil(a / 26) | 0,
                    m = a % 26
                this._expand(c), m > 0 && c--
                for (var _ = 0; _ < c; _++) this.words[_] = ~this.words[_] & 67108863
                return m > 0 && (this.words[_] = ~this.words[_] & (67108863 >> (26 - m))), this._strip()
            }),
            (s.prototype.notn = function (a) {
                return this.clone().inotn(a)
            }),
            (s.prototype.setn = function (a, c) {
                n(typeof a == "number" && a >= 0)
                var m = (a / 26) | 0,
                    _ = a % 26
                return (
                    this._expand(m + 1),
                    c ? (this.words[m] = this.words[m] | (1 << _)) : (this.words[m] = this.words[m] & ~(1 << _)),
                    this._strip()
                )
            }),
            (s.prototype.iadd = function (a) {
                var c
                if (this.negative !== 0 && a.negative === 0)
                    return (this.negative = 0), (c = this.isub(a)), (this.negative ^= 1), this._normSign()
                if (this.negative === 0 && a.negative !== 0) return (a.negative = 0), (c = this.isub(a)), (a.negative = 1), c._normSign()
                var m, _
                this.length > a.length ? ((m = this), (_ = a)) : ((m = a), (_ = this))
                for (var A = 0, w = 0; w < _.length; w++)
                    (c = (m.words[w] | 0) + (_.words[w] | 0) + A), (this.words[w] = c & 67108863), (A = c >>> 26)
                for (; A !== 0 && w < m.length; w++) (c = (m.words[w] | 0) + A), (this.words[w] = c & 67108863), (A = c >>> 26)
                if (((this.length = m.length), A !== 0)) (this.words[this.length] = A), this.length++
                else if (m !== this) for (; w < m.length; w++) this.words[w] = m.words[w]
                return this
            }),
            (s.prototype.add = function (a) {
                var c
                return a.negative !== 0 && this.negative === 0
                    ? ((a.negative = 0), (c = this.sub(a)), (a.negative ^= 1), c)
                    : a.negative === 0 && this.negative !== 0
                    ? ((this.negative = 0), (c = a.sub(this)), (this.negative = 1), c)
                    : this.length > a.length
                    ? this.clone().iadd(a)
                    : a.clone().iadd(this)
            }),
            (s.prototype.isub = function (a) {
                if (a.negative !== 0) {
                    a.negative = 0
                    var c = this.iadd(a)
                    return (a.negative = 1), c._normSign()
                } else if (this.negative !== 0) return (this.negative = 0), this.iadd(a), (this.negative = 1), this._normSign()
                var m = this.cmp(a)
                if (m === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
                var _, A
                m > 0 ? ((_ = this), (A = a)) : ((_ = a), (A = this))
                for (var w = 0, v = 0; v < A.length; v++)
                    (c = (_.words[v] | 0) - (A.words[v] | 0) + w), (w = c >> 26), (this.words[v] = c & 67108863)
                for (; w !== 0 && v < _.length; v++) (c = (_.words[v] | 0) + w), (w = c >> 26), (this.words[v] = c & 67108863)
                if (w === 0 && v < _.length && _ !== this) for (; v < _.length; v++) this.words[v] = _.words[v]
                return (this.length = Math.max(this.length, v)), _ !== this && (this.negative = 1), this._strip()
            }),
            (s.prototype.sub = function (a) {
                return this.clone().isub(a)
            })
        function M(x, a, c) {
            c.negative = a.negative ^ x.negative
            var m = (x.length + a.length) | 0
            ;(c.length = m), (m = (m - 1) | 0)
            var _ = x.words[0] | 0,
                A = a.words[0] | 0,
                w = _ * A,
                v = w & 67108863,
                g = (w / 67108864) | 0
            c.words[0] = v
            for (var u = 1; u < m; u++) {
                for (var p = g >>> 26, H = g & 67108863, b = Math.min(u, a.length - 1), B = Math.max(0, u - x.length + 1); B <= b; B++) {
                    var D = (u - B) | 0
                    ;(_ = x.words[D] | 0), (A = a.words[B] | 0), (w = _ * A + H), (p += (w / 67108864) | 0), (H = w & 67108863)
                }
                ;(c.words[u] = H | 0), (g = p | 0)
            }
            return g !== 0 ? (c.words[u] = g | 0) : c.length--, c._strip()
        }
        var k = function (a, c, m) {
            var _ = a.words,
                A = c.words,
                w = m.words,
                v = 0,
                g,
                u,
                p,
                H = _[0] | 0,
                b = H & 8191,
                B = H >>> 13,
                D = _[1] | 0,
                U = D & 8191,
                j = D >>> 13,
                dt = _[2] | 0,
                Z = dt & 8191,
                et = dt >>> 13,
                C = _[3] | 0,
                O = C & 8191,
                I = C >>> 13,
                G = _[4] | 0,
                q = G & 8191,
                X = G >>> 13,
                lt = _[5] | 0,
                tt = lt & 8191,
                rt = lt >>> 13,
                st = _[6] | 0,
                ct = st & 8191,
                ht = st >>> 13,
                gt = _[7] | 0,
                pt = gt & 8191,
                vt = gt >>> 13,
                Tt = _[8] | 0,
                Et = Tt & 8191,
                At = Tt >>> 13,
                Ft = _[9] | 0,
                Ot = Ft & 8191,
                Bt = Ft >>> 13,
                ke = A[0] | 0,
                Vt = ke & 8191,
                Mt = ke >>> 13,
                ge = A[1] | 0,
                Rt = ge & 8191,
                qt = ge >>> 13,
                vr = A[2] | 0,
                Gt = vr & 8191,
                zt = vr >>> 13,
                vn = A[3] | 0,
                Jt = vn & 8191,
                Qt = vn >>> 13,
                bn = A[4] | 0,
                Xt = bn & 8191,
                Zt = bn >>> 13,
                yn = A[5] | 0,
                te = yn & 8191,
                ee = yn >>> 13,
                _n = A[6] | 0,
                re = _n & 8191,
                ne = _n >>> 13,
                wn = A[7] | 0,
                ie = wn & 8191,
                se = wn >>> 13,
                An = A[8] | 0,
                oe = An & 8191,
                ae = An >>> 13,
                En = A[9] | 0,
                le = En & 8191,
                ue = En >>> 13
            ;(m.negative = a.negative ^ c.negative),
                (m.length = 19),
                (g = Math.imul(b, Vt)),
                (u = Math.imul(b, Mt)),
                (u = (u + Math.imul(B, Vt)) | 0),
                (p = Math.imul(B, Mt))
            var Vr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Vr >>> 26)) | 0),
                (Vr &= 67108863),
                (g = Math.imul(U, Vt)),
                (u = Math.imul(U, Mt)),
                (u = (u + Math.imul(j, Vt)) | 0),
                (p = Math.imul(j, Mt)),
                (g = (g + Math.imul(b, Rt)) | 0),
                (u = (u + Math.imul(b, qt)) | 0),
                (u = (u + Math.imul(B, Rt)) | 0),
                (p = (p + Math.imul(B, qt)) | 0)
            var Ur = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Ur >>> 26)) | 0),
                (Ur &= 67108863),
                (g = Math.imul(Z, Vt)),
                (u = Math.imul(Z, Mt)),
                (u = (u + Math.imul(et, Vt)) | 0),
                (p = Math.imul(et, Mt)),
                (g = (g + Math.imul(U, Rt)) | 0),
                (u = (u + Math.imul(U, qt)) | 0),
                (u = (u + Math.imul(j, Rt)) | 0),
                (p = (p + Math.imul(j, qt)) | 0),
                (g = (g + Math.imul(b, Gt)) | 0),
                (u = (u + Math.imul(b, zt)) | 0),
                (u = (u + Math.imul(B, Gt)) | 0),
                (p = (p + Math.imul(B, zt)) | 0)
            var Hr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (Hr >>> 26)) | 0),
                (Hr &= 67108863),
                (g = Math.imul(O, Vt)),
                (u = Math.imul(O, Mt)),
                (u = (u + Math.imul(I, Vt)) | 0),
                (p = Math.imul(I, Mt)),
                (g = (g + Math.imul(Z, Rt)) | 0),
                (u = (u + Math.imul(Z, qt)) | 0),
                (u = (u + Math.imul(et, Rt)) | 0),
                (p = (p + Math.imul(et, qt)) | 0),
                (g = (g + Math.imul(U, Gt)) | 0),
                (u = (u + Math.imul(U, zt)) | 0),
                (u = (u + Math.imul(j, Gt)) | 0),
                (p = (p + Math.imul(j, zt)) | 0),
                (g = (g + Math.imul(b, Jt)) | 0),
                (u = (u + Math.imul(b, Qt)) | 0),
                (u = (u + Math.imul(B, Jt)) | 0),
                (p = (p + Math.imul(B, Qt)) | 0)
            var qr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (qr >>> 26)) | 0),
                (qr &= 67108863),
                (g = Math.imul(q, Vt)),
                (u = Math.imul(q, Mt)),
                (u = (u + Math.imul(X, Vt)) | 0),
                (p = Math.imul(X, Mt)),
                (g = (g + Math.imul(O, Rt)) | 0),
                (u = (u + Math.imul(O, qt)) | 0),
                (u = (u + Math.imul(I, Rt)) | 0),
                (p = (p + Math.imul(I, qt)) | 0),
                (g = (g + Math.imul(Z, Gt)) | 0),
                (u = (u + Math.imul(Z, zt)) | 0),
                (u = (u + Math.imul(et, Gt)) | 0),
                (p = (p + Math.imul(et, zt)) | 0),
                (g = (g + Math.imul(U, Jt)) | 0),
                (u = (u + Math.imul(U, Qt)) | 0),
                (u = (u + Math.imul(j, Jt)) | 0),
                (p = (p + Math.imul(j, Qt)) | 0),
                (g = (g + Math.imul(b, Xt)) | 0),
                (u = (u + Math.imul(b, Zt)) | 0),
                (u = (u + Math.imul(B, Xt)) | 0),
                (p = (p + Math.imul(B, Zt)) | 0)
            var zr = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (zr >>> 26)) | 0),
                (zr &= 67108863),
                (g = Math.imul(tt, Vt)),
                (u = Math.imul(tt, Mt)),
                (u = (u + Math.imul(rt, Vt)) | 0),
                (p = Math.imul(rt, Mt)),
                (g = (g + Math.imul(q, Rt)) | 0),
                (u = (u + Math.imul(q, qt)) | 0),
                (u = (u + Math.imul(X, Rt)) | 0),
                (p = (p + Math.imul(X, qt)) | 0),
                (g = (g + Math.imul(O, Gt)) | 0),
                (u = (u + Math.imul(O, zt)) | 0),
                (u = (u + Math.imul(I, Gt)) | 0),
                (p = (p + Math.imul(I, zt)) | 0),
                (g = (g + Math.imul(Z, Jt)) | 0),
                (u = (u + Math.imul(Z, Qt)) | 0),
                (u = (u + Math.imul(et, Jt)) | 0),
                (p = (p + Math.imul(et, Qt)) | 0),
                (g = (g + Math.imul(U, Xt)) | 0),
                (u = (u + Math.imul(U, Zt)) | 0),
                (u = (u + Math.imul(j, Xt)) | 0),
                (p = (p + Math.imul(j, Zt)) | 0),
                (g = (g + Math.imul(b, te)) | 0),
                (u = (u + Math.imul(b, ee)) | 0),
                (u = (u + Math.imul(B, te)) | 0),
                (p = (p + Math.imul(B, ee)) | 0)
            var ns = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ns >>> 26)) | 0),
                (ns &= 67108863),
                (g = Math.imul(ct, Vt)),
                (u = Math.imul(ct, Mt)),
                (u = (u + Math.imul(ht, Vt)) | 0),
                (p = Math.imul(ht, Mt)),
                (g = (g + Math.imul(tt, Rt)) | 0),
                (u = (u + Math.imul(tt, qt)) | 0),
                (u = (u + Math.imul(rt, Rt)) | 0),
                (p = (p + Math.imul(rt, qt)) | 0),
                (g = (g + Math.imul(q, Gt)) | 0),
                (u = (u + Math.imul(q, zt)) | 0),
                (u = (u + Math.imul(X, Gt)) | 0),
                (p = (p + Math.imul(X, zt)) | 0),
                (g = (g + Math.imul(O, Jt)) | 0),
                (u = (u + Math.imul(O, Qt)) | 0),
                (u = (u + Math.imul(I, Jt)) | 0),
                (p = (p + Math.imul(I, Qt)) | 0),
                (g = (g + Math.imul(Z, Xt)) | 0),
                (u = (u + Math.imul(Z, Zt)) | 0),
                (u = (u + Math.imul(et, Xt)) | 0),
                (p = (p + Math.imul(et, Zt)) | 0),
                (g = (g + Math.imul(U, te)) | 0),
                (u = (u + Math.imul(U, ee)) | 0),
                (u = (u + Math.imul(j, te)) | 0),
                (p = (p + Math.imul(j, ee)) | 0),
                (g = (g + Math.imul(b, re)) | 0),
                (u = (u + Math.imul(b, ne)) | 0),
                (u = (u + Math.imul(B, re)) | 0),
                (p = (p + Math.imul(B, ne)) | 0)
            var is = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (is >>> 26)) | 0),
                (is &= 67108863),
                (g = Math.imul(pt, Vt)),
                (u = Math.imul(pt, Mt)),
                (u = (u + Math.imul(vt, Vt)) | 0),
                (p = Math.imul(vt, Mt)),
                (g = (g + Math.imul(ct, Rt)) | 0),
                (u = (u + Math.imul(ct, qt)) | 0),
                (u = (u + Math.imul(ht, Rt)) | 0),
                (p = (p + Math.imul(ht, qt)) | 0),
                (g = (g + Math.imul(tt, Gt)) | 0),
                (u = (u + Math.imul(tt, zt)) | 0),
                (u = (u + Math.imul(rt, Gt)) | 0),
                (p = (p + Math.imul(rt, zt)) | 0),
                (g = (g + Math.imul(q, Jt)) | 0),
                (u = (u + Math.imul(q, Qt)) | 0),
                (u = (u + Math.imul(X, Jt)) | 0),
                (p = (p + Math.imul(X, Qt)) | 0),
                (g = (g + Math.imul(O, Xt)) | 0),
                (u = (u + Math.imul(O, Zt)) | 0),
                (u = (u + Math.imul(I, Xt)) | 0),
                (p = (p + Math.imul(I, Zt)) | 0),
                (g = (g + Math.imul(Z, te)) | 0),
                (u = (u + Math.imul(Z, ee)) | 0),
                (u = (u + Math.imul(et, te)) | 0),
                (p = (p + Math.imul(et, ee)) | 0),
                (g = (g + Math.imul(U, re)) | 0),
                (u = (u + Math.imul(U, ne)) | 0),
                (u = (u + Math.imul(j, re)) | 0),
                (p = (p + Math.imul(j, ne)) | 0),
                (g = (g + Math.imul(b, ie)) | 0),
                (u = (u + Math.imul(b, se)) | 0),
                (u = (u + Math.imul(B, ie)) | 0),
                (p = (p + Math.imul(B, se)) | 0)
            var ss = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ss >>> 26)) | 0),
                (ss &= 67108863),
                (g = Math.imul(Et, Vt)),
                (u = Math.imul(Et, Mt)),
                (u = (u + Math.imul(At, Vt)) | 0),
                (p = Math.imul(At, Mt)),
                (g = (g + Math.imul(pt, Rt)) | 0),
                (u = (u + Math.imul(pt, qt)) | 0),
                (u = (u + Math.imul(vt, Rt)) | 0),
                (p = (p + Math.imul(vt, qt)) | 0),
                (g = (g + Math.imul(ct, Gt)) | 0),
                (u = (u + Math.imul(ct, zt)) | 0),
                (u = (u + Math.imul(ht, Gt)) | 0),
                (p = (p + Math.imul(ht, zt)) | 0),
                (g = (g + Math.imul(tt, Jt)) | 0),
                (u = (u + Math.imul(tt, Qt)) | 0),
                (u = (u + Math.imul(rt, Jt)) | 0),
                (p = (p + Math.imul(rt, Qt)) | 0),
                (g = (g + Math.imul(q, Xt)) | 0),
                (u = (u + Math.imul(q, Zt)) | 0),
                (u = (u + Math.imul(X, Xt)) | 0),
                (p = (p + Math.imul(X, Zt)) | 0),
                (g = (g + Math.imul(O, te)) | 0),
                (u = (u + Math.imul(O, ee)) | 0),
                (u = (u + Math.imul(I, te)) | 0),
                (p = (p + Math.imul(I, ee)) | 0),
                (g = (g + Math.imul(Z, re)) | 0),
                (u = (u + Math.imul(Z, ne)) | 0),
                (u = (u + Math.imul(et, re)) | 0),
                (p = (p + Math.imul(et, ne)) | 0),
                (g = (g + Math.imul(U, ie)) | 0),
                (u = (u + Math.imul(U, se)) | 0),
                (u = (u + Math.imul(j, ie)) | 0),
                (p = (p + Math.imul(j, se)) | 0),
                (g = (g + Math.imul(b, oe)) | 0),
                (u = (u + Math.imul(b, ae)) | 0),
                (u = (u + Math.imul(B, oe)) | 0),
                (p = (p + Math.imul(B, ae)) | 0)
            var os = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (os >>> 26)) | 0),
                (os &= 67108863),
                (g = Math.imul(Ot, Vt)),
                (u = Math.imul(Ot, Mt)),
                (u = (u + Math.imul(Bt, Vt)) | 0),
                (p = Math.imul(Bt, Mt)),
                (g = (g + Math.imul(Et, Rt)) | 0),
                (u = (u + Math.imul(Et, qt)) | 0),
                (u = (u + Math.imul(At, Rt)) | 0),
                (p = (p + Math.imul(At, qt)) | 0),
                (g = (g + Math.imul(pt, Gt)) | 0),
                (u = (u + Math.imul(pt, zt)) | 0),
                (u = (u + Math.imul(vt, Gt)) | 0),
                (p = (p + Math.imul(vt, zt)) | 0),
                (g = (g + Math.imul(ct, Jt)) | 0),
                (u = (u + Math.imul(ct, Qt)) | 0),
                (u = (u + Math.imul(ht, Jt)) | 0),
                (p = (p + Math.imul(ht, Qt)) | 0),
                (g = (g + Math.imul(tt, Xt)) | 0),
                (u = (u + Math.imul(tt, Zt)) | 0),
                (u = (u + Math.imul(rt, Xt)) | 0),
                (p = (p + Math.imul(rt, Zt)) | 0),
                (g = (g + Math.imul(q, te)) | 0),
                (u = (u + Math.imul(q, ee)) | 0),
                (u = (u + Math.imul(X, te)) | 0),
                (p = (p + Math.imul(X, ee)) | 0),
                (g = (g + Math.imul(O, re)) | 0),
                (u = (u + Math.imul(O, ne)) | 0),
                (u = (u + Math.imul(I, re)) | 0),
                (p = (p + Math.imul(I, ne)) | 0),
                (g = (g + Math.imul(Z, ie)) | 0),
                (u = (u + Math.imul(Z, se)) | 0),
                (u = (u + Math.imul(et, ie)) | 0),
                (p = (p + Math.imul(et, se)) | 0),
                (g = (g + Math.imul(U, oe)) | 0),
                (u = (u + Math.imul(U, ae)) | 0),
                (u = (u + Math.imul(j, oe)) | 0),
                (p = (p + Math.imul(j, ae)) | 0),
                (g = (g + Math.imul(b, le)) | 0),
                (u = (u + Math.imul(b, ue)) | 0),
                (u = (u + Math.imul(B, le)) | 0),
                (p = (p + Math.imul(B, ue)) | 0)
            var as = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (as >>> 26)) | 0),
                (as &= 67108863),
                (g = Math.imul(Ot, Rt)),
                (u = Math.imul(Ot, qt)),
                (u = (u + Math.imul(Bt, Rt)) | 0),
                (p = Math.imul(Bt, qt)),
                (g = (g + Math.imul(Et, Gt)) | 0),
                (u = (u + Math.imul(Et, zt)) | 0),
                (u = (u + Math.imul(At, Gt)) | 0),
                (p = (p + Math.imul(At, zt)) | 0),
                (g = (g + Math.imul(pt, Jt)) | 0),
                (u = (u + Math.imul(pt, Qt)) | 0),
                (u = (u + Math.imul(vt, Jt)) | 0),
                (p = (p + Math.imul(vt, Qt)) | 0),
                (g = (g + Math.imul(ct, Xt)) | 0),
                (u = (u + Math.imul(ct, Zt)) | 0),
                (u = (u + Math.imul(ht, Xt)) | 0),
                (p = (p + Math.imul(ht, Zt)) | 0),
                (g = (g + Math.imul(tt, te)) | 0),
                (u = (u + Math.imul(tt, ee)) | 0),
                (u = (u + Math.imul(rt, te)) | 0),
                (p = (p + Math.imul(rt, ee)) | 0),
                (g = (g + Math.imul(q, re)) | 0),
                (u = (u + Math.imul(q, ne)) | 0),
                (u = (u + Math.imul(X, re)) | 0),
                (p = (p + Math.imul(X, ne)) | 0),
                (g = (g + Math.imul(O, ie)) | 0),
                (u = (u + Math.imul(O, se)) | 0),
                (u = (u + Math.imul(I, ie)) | 0),
                (p = (p + Math.imul(I, se)) | 0),
                (g = (g + Math.imul(Z, oe)) | 0),
                (u = (u + Math.imul(Z, ae)) | 0),
                (u = (u + Math.imul(et, oe)) | 0),
                (p = (p + Math.imul(et, ae)) | 0),
                (g = (g + Math.imul(U, le)) | 0),
                (u = (u + Math.imul(U, ue)) | 0),
                (u = (u + Math.imul(j, le)) | 0),
                (p = (p + Math.imul(j, ue)) | 0)
            var ls = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ls >>> 26)) | 0),
                (ls &= 67108863),
                (g = Math.imul(Ot, Gt)),
                (u = Math.imul(Ot, zt)),
                (u = (u + Math.imul(Bt, Gt)) | 0),
                (p = Math.imul(Bt, zt)),
                (g = (g + Math.imul(Et, Jt)) | 0),
                (u = (u + Math.imul(Et, Qt)) | 0),
                (u = (u + Math.imul(At, Jt)) | 0),
                (p = (p + Math.imul(At, Qt)) | 0),
                (g = (g + Math.imul(pt, Xt)) | 0),
                (u = (u + Math.imul(pt, Zt)) | 0),
                (u = (u + Math.imul(vt, Xt)) | 0),
                (p = (p + Math.imul(vt, Zt)) | 0),
                (g = (g + Math.imul(ct, te)) | 0),
                (u = (u + Math.imul(ct, ee)) | 0),
                (u = (u + Math.imul(ht, te)) | 0),
                (p = (p + Math.imul(ht, ee)) | 0),
                (g = (g + Math.imul(tt, re)) | 0),
                (u = (u + Math.imul(tt, ne)) | 0),
                (u = (u + Math.imul(rt, re)) | 0),
                (p = (p + Math.imul(rt, ne)) | 0),
                (g = (g + Math.imul(q, ie)) | 0),
                (u = (u + Math.imul(q, se)) | 0),
                (u = (u + Math.imul(X, ie)) | 0),
                (p = (p + Math.imul(X, se)) | 0),
                (g = (g + Math.imul(O, oe)) | 0),
                (u = (u + Math.imul(O, ae)) | 0),
                (u = (u + Math.imul(I, oe)) | 0),
                (p = (p + Math.imul(I, ae)) | 0),
                (g = (g + Math.imul(Z, le)) | 0),
                (u = (u + Math.imul(Z, ue)) | 0),
                (u = (u + Math.imul(et, le)) | 0),
                (p = (p + Math.imul(et, ue)) | 0)
            var us = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (us >>> 26)) | 0),
                (us &= 67108863),
                (g = Math.imul(Ot, Jt)),
                (u = Math.imul(Ot, Qt)),
                (u = (u + Math.imul(Bt, Jt)) | 0),
                (p = Math.imul(Bt, Qt)),
                (g = (g + Math.imul(Et, Xt)) | 0),
                (u = (u + Math.imul(Et, Zt)) | 0),
                (u = (u + Math.imul(At, Xt)) | 0),
                (p = (p + Math.imul(At, Zt)) | 0),
                (g = (g + Math.imul(pt, te)) | 0),
                (u = (u + Math.imul(pt, ee)) | 0),
                (u = (u + Math.imul(vt, te)) | 0),
                (p = (p + Math.imul(vt, ee)) | 0),
                (g = (g + Math.imul(ct, re)) | 0),
                (u = (u + Math.imul(ct, ne)) | 0),
                (u = (u + Math.imul(ht, re)) | 0),
                (p = (p + Math.imul(ht, ne)) | 0),
                (g = (g + Math.imul(tt, ie)) | 0),
                (u = (u + Math.imul(tt, se)) | 0),
                (u = (u + Math.imul(rt, ie)) | 0),
                (p = (p + Math.imul(rt, se)) | 0),
                (g = (g + Math.imul(q, oe)) | 0),
                (u = (u + Math.imul(q, ae)) | 0),
                (u = (u + Math.imul(X, oe)) | 0),
                (p = (p + Math.imul(X, ae)) | 0),
                (g = (g + Math.imul(O, le)) | 0),
                (u = (u + Math.imul(O, ue)) | 0),
                (u = (u + Math.imul(I, le)) | 0),
                (p = (p + Math.imul(I, ue)) | 0)
            var fs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (fs >>> 26)) | 0),
                (fs &= 67108863),
                (g = Math.imul(Ot, Xt)),
                (u = Math.imul(Ot, Zt)),
                (u = (u + Math.imul(Bt, Xt)) | 0),
                (p = Math.imul(Bt, Zt)),
                (g = (g + Math.imul(Et, te)) | 0),
                (u = (u + Math.imul(Et, ee)) | 0),
                (u = (u + Math.imul(At, te)) | 0),
                (p = (p + Math.imul(At, ee)) | 0),
                (g = (g + Math.imul(pt, re)) | 0),
                (u = (u + Math.imul(pt, ne)) | 0),
                (u = (u + Math.imul(vt, re)) | 0),
                (p = (p + Math.imul(vt, ne)) | 0),
                (g = (g + Math.imul(ct, ie)) | 0),
                (u = (u + Math.imul(ct, se)) | 0),
                (u = (u + Math.imul(ht, ie)) | 0),
                (p = (p + Math.imul(ht, se)) | 0),
                (g = (g + Math.imul(tt, oe)) | 0),
                (u = (u + Math.imul(tt, ae)) | 0),
                (u = (u + Math.imul(rt, oe)) | 0),
                (p = (p + Math.imul(rt, ae)) | 0),
                (g = (g + Math.imul(q, le)) | 0),
                (u = (u + Math.imul(q, ue)) | 0),
                (u = (u + Math.imul(X, le)) | 0),
                (p = (p + Math.imul(X, ue)) | 0)
            var cs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (cs >>> 26)) | 0),
                (cs &= 67108863),
                (g = Math.imul(Ot, te)),
                (u = Math.imul(Ot, ee)),
                (u = (u + Math.imul(Bt, te)) | 0),
                (p = Math.imul(Bt, ee)),
                (g = (g + Math.imul(Et, re)) | 0),
                (u = (u + Math.imul(Et, ne)) | 0),
                (u = (u + Math.imul(At, re)) | 0),
                (p = (p + Math.imul(At, ne)) | 0),
                (g = (g + Math.imul(pt, ie)) | 0),
                (u = (u + Math.imul(pt, se)) | 0),
                (u = (u + Math.imul(vt, ie)) | 0),
                (p = (p + Math.imul(vt, se)) | 0),
                (g = (g + Math.imul(ct, oe)) | 0),
                (u = (u + Math.imul(ct, ae)) | 0),
                (u = (u + Math.imul(ht, oe)) | 0),
                (p = (p + Math.imul(ht, ae)) | 0),
                (g = (g + Math.imul(tt, le)) | 0),
                (u = (u + Math.imul(tt, ue)) | 0),
                (u = (u + Math.imul(rt, le)) | 0),
                (p = (p + Math.imul(rt, ue)) | 0)
            var ds = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ds >>> 26)) | 0),
                (ds &= 67108863),
                (g = Math.imul(Ot, re)),
                (u = Math.imul(Ot, ne)),
                (u = (u + Math.imul(Bt, re)) | 0),
                (p = Math.imul(Bt, ne)),
                (g = (g + Math.imul(Et, ie)) | 0),
                (u = (u + Math.imul(Et, se)) | 0),
                (u = (u + Math.imul(At, ie)) | 0),
                (p = (p + Math.imul(At, se)) | 0),
                (g = (g + Math.imul(pt, oe)) | 0),
                (u = (u + Math.imul(pt, ae)) | 0),
                (u = (u + Math.imul(vt, oe)) | 0),
                (p = (p + Math.imul(vt, ae)) | 0),
                (g = (g + Math.imul(ct, le)) | 0),
                (u = (u + Math.imul(ct, ue)) | 0),
                (u = (u + Math.imul(ht, le)) | 0),
                (p = (p + Math.imul(ht, ue)) | 0)
            var hs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (hs >>> 26)) | 0),
                (hs &= 67108863),
                (g = Math.imul(Ot, ie)),
                (u = Math.imul(Ot, se)),
                (u = (u + Math.imul(Bt, ie)) | 0),
                (p = Math.imul(Bt, se)),
                (g = (g + Math.imul(Et, oe)) | 0),
                (u = (u + Math.imul(Et, ae)) | 0),
                (u = (u + Math.imul(At, oe)) | 0),
                (p = (p + Math.imul(At, ae)) | 0),
                (g = (g + Math.imul(pt, le)) | 0),
                (u = (u + Math.imul(pt, ue)) | 0),
                (u = (u + Math.imul(vt, le)) | 0),
                (p = (p + Math.imul(vt, ue)) | 0)
            var ps = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (ps >>> 26)) | 0),
                (ps &= 67108863),
                (g = Math.imul(Ot, oe)),
                (u = Math.imul(Ot, ae)),
                (u = (u + Math.imul(Bt, oe)) | 0),
                (p = Math.imul(Bt, ae)),
                (g = (g + Math.imul(Et, le)) | 0),
                (u = (u + Math.imul(Et, ue)) | 0),
                (u = (u + Math.imul(At, le)) | 0),
                (p = (p + Math.imul(At, ue)) | 0)
            var gs = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            ;(v = (((p + (u >>> 13)) | 0) + (gs >>> 26)) | 0),
                (gs &= 67108863),
                (g = Math.imul(Ot, le)),
                (u = Math.imul(Ot, ue)),
                (u = (u + Math.imul(Bt, le)) | 0),
                (p = Math.imul(Bt, ue))
            var ms = (((v + g) | 0) + ((u & 8191) << 13)) | 0
            return (
                (v = (((p + (u >>> 13)) | 0) + (ms >>> 26)) | 0),
                (ms &= 67108863),
                (w[0] = Vr),
                (w[1] = Ur),
                (w[2] = Hr),
                (w[3] = qr),
                (w[4] = zr),
                (w[5] = ns),
                (w[6] = is),
                (w[7] = ss),
                (w[8] = os),
                (w[9] = as),
                (w[10] = ls),
                (w[11] = us),
                (w[12] = fs),
                (w[13] = cs),
                (w[14] = ds),
                (w[15] = hs),
                (w[16] = ps),
                (w[17] = gs),
                (w[18] = ms),
                v !== 0 && ((w[19] = v), m.length++),
                m
            )
        }
        Math.imul || (k = M)
        function F(x, a, c) {
            ;(c.negative = a.negative ^ x.negative), (c.length = x.length + a.length)
            for (var m = 0, _ = 0, A = 0; A < c.length - 1; A++) {
                var w = _
                _ = 0
                for (var v = m & 67108863, g = Math.min(A, a.length - 1), u = Math.max(0, A - x.length + 1); u <= g; u++) {
                    var p = A - u,
                        H = x.words[p] | 0,
                        b = a.words[u] | 0,
                        B = H * b,
                        D = B & 67108863
                    ;(w = (w + ((B / 67108864) | 0)) | 0),
                        (D = (D + v) | 0),
                        (v = D & 67108863),
                        (w = (w + (D >>> 26)) | 0),
                        (_ += w >>> 26),
                        (w &= 67108863)
                }
                ;(c.words[A] = v), (m = w), (w = _)
            }
            return m !== 0 ? (c.words[A] = m) : c.length--, c._strip()
        }
        function $(x, a, c) {
            return F(x, a, c)
        }
        ;(s.prototype.mulTo = function (a, c) {
            var m,
                _ = this.length + a.length
            return (
                this.length === 10 && a.length === 10
                    ? (m = k(this, a, c))
                    : _ < 63
                    ? (m = M(this, a, c))
                    : _ < 1024
                    ? (m = F(this, a, c))
                    : (m = $(this, a, c)),
                m
            )
        }),
            (s.prototype.mul = function (a) {
                var c = new s(null)
                return (c.words = new Array(this.length + a.length)), this.mulTo(a, c)
            }),
            (s.prototype.mulf = function (a) {
                var c = new s(null)
                return (c.words = new Array(this.length + a.length)), $(this, a, c)
            }),
            (s.prototype.imul = function (a) {
                return this.clone().mulTo(a, this)
            }),
            (s.prototype.imuln = function (a) {
                var c = a < 0
                c && (a = -a), n(typeof a == "number"), n(a < 67108864)
                for (var m = 0, _ = 0; _ < this.length; _++) {
                    var A = (this.words[_] | 0) * a,
                        w = (A & 67108863) + (m & 67108863)
                    ;(m >>= 26), (m += (A / 67108864) | 0), (m += w >>> 26), (this.words[_] = w & 67108863)
                }
                return m !== 0 && ((this.words[_] = m), this.length++), c ? this.ineg() : this
            }),
            (s.prototype.muln = function (a) {
                return this.clone().imuln(a)
            }),
            (s.prototype.sqr = function () {
                return this.mul(this)
            }),
            (s.prototype.isqr = function () {
                return this.imul(this.clone())
            }),
            (s.prototype.pow = function (a) {
                var c = P(a)
                if (c.length === 0) return new s(1)
                for (var m = this, _ = 0; _ < c.length && c[_] === 0; _++, m = m.sqr());
                if (++_ < c.length) for (var A = m.sqr(); _ < c.length; _++, A = A.sqr()) c[_] !== 0 && (m = m.mul(A))
                return m
            }),
            (s.prototype.iushln = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = (67108863 >>> (26 - c)) << (26 - c),
                    A
                if (c !== 0) {
                    var w = 0
                    for (A = 0; A < this.length; A++) {
                        var v = this.words[A] & _,
                            g = ((this.words[A] | 0) - v) << c
                        ;(this.words[A] = g | w), (w = v >>> (26 - c))
                    }
                    w && ((this.words[A] = w), this.length++)
                }
                if (m !== 0) {
                    for (A = this.length - 1; A >= 0; A--) this.words[A + m] = this.words[A]
                    for (A = 0; A < m; A++) this.words[A] = 0
                    this.length += m
                }
                return this._strip()
            }),
            (s.prototype.ishln = function (a) {
                return n(this.negative === 0), this.iushln(a)
            }),
            (s.prototype.iushrn = function (a, c, m) {
                n(typeof a == "number" && a >= 0)
                var _
                c ? (_ = (c - (c % 26)) / 26) : (_ = 0)
                var A = a % 26,
                    w = Math.min((a - A) / 26, this.length),
                    v = 67108863 ^ ((67108863 >>> A) << A),
                    g = m
                if (((_ -= w), (_ = Math.max(0, _)), g)) {
                    for (var u = 0; u < w; u++) g.words[u] = this.words[u]
                    g.length = w
                }
                if (w !== 0)
                    if (this.length > w) for (this.length -= w, u = 0; u < this.length; u++) this.words[u] = this.words[u + w]
                    else (this.words[0] = 0), (this.length = 1)
                var p = 0
                for (u = this.length - 1; u >= 0 && (p !== 0 || u >= _); u--) {
                    var H = this.words[u] | 0
                    ;(this.words[u] = (p << (26 - A)) | (H >>> A)), (p = H & v)
                }
                return g && p !== 0 && (g.words[g.length++] = p), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip()
            }),
            (s.prototype.ishrn = function (a, c, m) {
                return n(this.negative === 0), this.iushrn(a, c, m)
            }),
            (s.prototype.shln = function (a) {
                return this.clone().ishln(a)
            }),
            (s.prototype.ushln = function (a) {
                return this.clone().iushln(a)
            }),
            (s.prototype.shrn = function (a) {
                return this.clone().ishrn(a)
            }),
            (s.prototype.ushrn = function (a) {
                return this.clone().iushrn(a)
            }),
            (s.prototype.testn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = 1 << c
                if (this.length <= m) return !1
                var A = this.words[m]
                return !!(A & _)
            }),
            (s.prototype.imaskn = function (a) {
                n(typeof a == "number" && a >= 0)
                var c = a % 26,
                    m = (a - c) / 26
                if ((n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)) return this
                if ((c !== 0 && m++, (this.length = Math.min(m, this.length)), c !== 0)) {
                    var _ = 67108863 ^ ((67108863 >>> c) << c)
                    this.words[this.length - 1] &= _
                }
                return this._strip()
            }),
            (s.prototype.maskn = function (a) {
                return this.clone().imaskn(a)
            }),
            (s.prototype.iaddn = function (a) {
                return (
                    n(typeof a == "number"),
                    n(a < 67108864),
                    a < 0
                        ? this.isubn(-a)
                        : this.negative !== 0
                        ? this.length === 1 && (this.words[0] | 0) <= a
                            ? ((this.words[0] = a - (this.words[0] | 0)), (this.negative = 0), this)
                            : ((this.negative = 0), this.isubn(a), (this.negative = 1), this)
                        : this._iaddn(a)
                )
            }),
            (s.prototype._iaddn = function (a) {
                this.words[0] += a
                for (var c = 0; c < this.length && this.words[c] >= 67108864; c++)
                    (this.words[c] -= 67108864), c === this.length - 1 ? (this.words[c + 1] = 1) : this.words[c + 1]++
                return (this.length = Math.max(this.length, c + 1)), this
            }),
            (s.prototype.isubn = function (a) {
                if ((n(typeof a == "number"), n(a < 67108864), a < 0)) return this.iaddn(-a)
                if (this.negative !== 0) return (this.negative = 0), this.iaddn(a), (this.negative = 1), this
                if (((this.words[0] -= a), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1)
                else for (var c = 0; c < this.length && this.words[c] < 0; c++) (this.words[c] += 67108864), (this.words[c + 1] -= 1)
                return this._strip()
            }),
            (s.prototype.addn = function (a) {
                return this.clone().iaddn(a)
            }),
            (s.prototype.subn = function (a) {
                return this.clone().isubn(a)
            }),
            (s.prototype.iabs = function () {
                return (this.negative = 0), this
            }),
            (s.prototype.abs = function () {
                return this.clone().iabs()
            }),
            (s.prototype._ishlnsubmul = function (a, c, m) {
                var _ = a.length + m,
                    A
                this._expand(_)
                var w,
                    v = 0
                for (A = 0; A < a.length; A++) {
                    w = (this.words[A + m] | 0) + v
                    var g = (a.words[A] | 0) * c
                    ;(w -= g & 67108863), (v = (w >> 26) - ((g / 67108864) | 0)), (this.words[A + m] = w & 67108863)
                }
                for (; A < this.length - m; A++) (w = (this.words[A + m] | 0) + v), (v = w >> 26), (this.words[A + m] = w & 67108863)
                if (v === 0) return this._strip()
                for (n(v === -1), v = 0, A = 0; A < this.length; A++)
                    (w = -(this.words[A] | 0) + v), (v = w >> 26), (this.words[A] = w & 67108863)
                return (this.negative = 1), this._strip()
            }),
            (s.prototype._wordDiv = function (a, c) {
                var m = this.length - a.length,
                    _ = this.clone(),
                    A = a,
                    w = A.words[A.length - 1] | 0,
                    v = this._countBits(w)
                ;(m = 26 - v), m !== 0 && ((A = A.ushln(m)), _.iushln(m), (w = A.words[A.length - 1] | 0))
                var g = _.length - A.length,
                    u
                if (c !== "mod") {
                    ;(u = new s(null)), (u.length = g + 1), (u.words = new Array(u.length))
                    for (var p = 0; p < u.length; p++) u.words[p] = 0
                }
                var H = _.clone()._ishlnsubmul(A, 1, g)
                H.negative === 0 && ((_ = H), u && (u.words[g] = 1))
                for (var b = g - 1; b >= 0; b--) {
                    var B = (_.words[A.length + b] | 0) * 67108864 + (_.words[A.length + b - 1] | 0)
                    for (B = Math.min((B / w) | 0, 67108863), _._ishlnsubmul(A, B, b); _.negative !== 0; )
                        B--, (_.negative = 0), _._ishlnsubmul(A, 1, b), _.isZero() || (_.negative ^= 1)
                    u && (u.words[b] = B)
                }
                return u && u._strip(), _._strip(), c !== "div" && m !== 0 && _.iushrn(m), { div: u || null, mod: _ }
            }),
            (s.prototype.divmod = function (a, c, m) {
                if ((n(!a.isZero()), this.isZero())) return { div: new s(0), mod: new s(0) }
                var _, A, w
                return this.negative !== 0 && a.negative === 0
                    ? ((w = this.neg().divmod(a, c)),
                      c !== "mod" && (_ = w.div.neg()),
                      c !== "div" && ((A = w.mod.neg()), m && A.negative !== 0 && A.iadd(a)),
                      { div: _, mod: A })
                    : this.negative === 0 && a.negative !== 0
                    ? ((w = this.divmod(a.neg(), c)), c !== "mod" && (_ = w.div.neg()), { div: _, mod: w.mod })
                    : (this.negative & a.negative) !== 0
                    ? ((w = this.neg().divmod(a.neg(), c)),
                      c !== "div" && ((A = w.mod.neg()), m && A.negative !== 0 && A.isub(a)),
                      { div: w.div, mod: A })
                    : a.length > this.length || this.cmp(a) < 0
                    ? { div: new s(0), mod: this }
                    : a.length === 1
                    ? c === "div"
                        ? { div: this.divn(a.words[0]), mod: null }
                        : c === "mod"
                        ? { div: null, mod: new s(this.modrn(a.words[0])) }
                        : { div: this.divn(a.words[0]), mod: new s(this.modrn(a.words[0])) }
                    : this._wordDiv(a, c)
            }),
            (s.prototype.div = function (a) {
                return this.divmod(a, "div", !1).div
            }),
            (s.prototype.mod = function (a) {
                return this.divmod(a, "mod", !1).mod
            }),
            (s.prototype.umod = function (a) {
                return this.divmod(a, "mod", !0).mod
            }),
            (s.prototype.divRound = function (a) {
                var c = this.divmod(a)
                if (c.mod.isZero()) return c.div
                var m = c.div.negative !== 0 ? c.mod.isub(a) : c.mod,
                    _ = a.ushrn(1),
                    A = a.andln(1),
                    w = m.cmp(_)
                return w < 0 || (A === 1 && w === 0) ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1)
            }),
            (s.prototype.modrn = function (a) {
                var c = a < 0
                c && (a = -a), n(a <= 67108863)
                for (var m = (1 << 26) % a, _ = 0, A = this.length - 1; A >= 0; A--) _ = (m * _ + (this.words[A] | 0)) % a
                return c ? -_ : _
            }),
            (s.prototype.modn = function (a) {
                return this.modrn(a)
            }),
            (s.prototype.idivn = function (a) {
                var c = a < 0
                c && (a = -a), n(a <= 67108863)
                for (var m = 0, _ = this.length - 1; _ >= 0; _--) {
                    var A = (this.words[_] | 0) + m * 67108864
                    ;(this.words[_] = (A / a) | 0), (m = A % a)
                }
                return this._strip(), c ? this.ineg() : this
            }),
            (s.prototype.divn = function (a) {
                return this.clone().idivn(a)
            }),
            (s.prototype.egcd = function (a) {
                n(a.negative === 0), n(!a.isZero())
                var c = this,
                    m = a.clone()
                c.negative !== 0 ? (c = c.umod(a)) : (c = c.clone())
                for (var _ = new s(1), A = new s(0), w = new s(0), v = new s(1), g = 0; c.isEven() && m.isEven(); ) c.iushrn(1), m.iushrn(1), ++g
                for (var u = m.clone(), p = c.clone(); !c.isZero(); ) {
                    for (var H = 0, b = 1; (c.words[0] & b) === 0 && H < 26; ++H, b <<= 1);
                    if (H > 0) for (c.iushrn(H); H-- > 0; ) (_.isOdd() || A.isOdd()) && (_.iadd(u), A.isub(p)), _.iushrn(1), A.iushrn(1)
                    for (var B = 0, D = 1; (m.words[0] & D) === 0 && B < 26; ++B, D <<= 1);
                    if (B > 0) for (m.iushrn(B); B-- > 0; ) (w.isOdd() || v.isOdd()) && (w.iadd(u), v.isub(p)), w.iushrn(1), v.iushrn(1)
                    c.cmp(m) >= 0 ? (c.isub(m), _.isub(w), A.isub(v)) : (m.isub(c), w.isub(_), v.isub(A))
                }
                return { a: w, b: v, gcd: m.iushln(g) }
            }),
            (s.prototype._invmp = function (a) {
                n(a.negative === 0), n(!a.isZero())
                var c = this,
                    m = a.clone()
                c.negative !== 0 ? (c = c.umod(a)) : (c = c.clone())
                for (var _ = new s(1), A = new s(0), w = m.clone(); c.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
                    for (var v = 0, g = 1; (c.words[0] & g) === 0 && v < 26; ++v, g <<= 1);
                    if (v > 0) for (c.iushrn(v); v-- > 0; ) _.isOdd() && _.iadd(w), _.iushrn(1)
                    for (var u = 0, p = 1; (m.words[0] & p) === 0 && u < 26; ++u, p <<= 1);
                    if (u > 0) for (m.iushrn(u); u-- > 0; ) A.isOdd() && A.iadd(w), A.iushrn(1)
                    c.cmp(m) >= 0 ? (c.isub(m), _.isub(A)) : (m.isub(c), A.isub(_))
                }
                var H
                return c.cmpn(1) === 0 ? (H = _) : (H = A), H.cmpn(0) < 0 && H.iadd(a), H
            }),
            (s.prototype.gcd = function (a) {
                if (this.isZero()) return a.abs()
                if (a.isZero()) return this.abs()
                var c = this.clone(),
                    m = a.clone()
                ;(c.negative = 0), (m.negative = 0)
                for (var _ = 0; c.isEven() && m.isEven(); _++) c.iushrn(1), m.iushrn(1)
                do {
                    for (; c.isEven(); ) c.iushrn(1)
                    for (; m.isEven(); ) m.iushrn(1)
                    var A = c.cmp(m)
                    if (A < 0) {
                        var w = c
                        ;(c = m), (m = w)
                    } else if (A === 0 || m.cmpn(1) === 0) break
                    c.isub(m)
                } while (!0)
                return m.iushln(_)
            }),
            (s.prototype.invm = function (a) {
                return this.egcd(a).a.umod(a)
            }),
            (s.prototype.isEven = function () {
                return (this.words[0] & 1) === 0
            }),
            (s.prototype.isOdd = function () {
                return (this.words[0] & 1) === 1
            }),
            (s.prototype.andln = function (a) {
                return this.words[0] & a
            }),
            (s.prototype.bincn = function (a) {
                n(typeof a == "number")
                var c = a % 26,
                    m = (a - c) / 26,
                    _ = 1 << c
                if (this.length <= m) return this._expand(m + 1), (this.words[m] |= _), this
                for (var A = _, w = m; A !== 0 && w < this.length; w++) {
                    var v = this.words[w] | 0
                    ;(v += A), (A = v >>> 26), (v &= 67108863), (this.words[w] = v)
                }
                return A !== 0 && ((this.words[w] = A), this.length++), this
            }),
            (s.prototype.isZero = function () {
                return this.length === 1 && this.words[0] === 0
            }),
            (s.prototype.cmpn = function (a) {
                var c = a < 0
                if (this.negative !== 0 && !c) return -1
                if (this.negative === 0 && c) return 1
                this._strip()
                var m
                if (this.length > 1) m = 1
                else {
                    c && (a = -a), n(a <= 67108863, "Number is too big")
                    var _ = this.words[0] | 0
                    m = _ === a ? 0 : _ < a ? -1 : 1
                }
                return this.negative !== 0 ? -m | 0 : m
            }),
            (s.prototype.cmp = function (a) {
                if (this.negative !== 0 && a.negative === 0) return -1
                if (this.negative === 0 && a.negative !== 0) return 1
                var c = this.ucmp(a)
                return this.negative !== 0 ? -c | 0 : c
            }),
            (s.prototype.ucmp = function (a) {
                if (this.length > a.length) return 1
                if (this.length < a.length) return -1
                for (var c = 0, m = this.length - 1; m >= 0; m--) {
                    var _ = this.words[m] | 0,
                        A = a.words[m] | 0
                    if (_ !== A) {
                        _ < A ? (c = -1) : _ > A && (c = 1)
                        break
                    }
                }
                return c
            }),
            (s.prototype.gtn = function (a) {
                return this.cmpn(a) === 1
            }),
            (s.prototype.gt = function (a) {
                return this.cmp(a) === 1
            }),
            (s.prototype.gten = function (a) {
                return this.cmpn(a) >= 0
            }),
            (s.prototype.gte = function (a) {
                return this.cmp(a) >= 0
            }),
            (s.prototype.ltn = function (a) {
                return this.cmpn(a) === -1
            }),
            (s.prototype.lt = function (a) {
                return this.cmp(a) === -1
            }),
            (s.prototype.lten = function (a) {
                return this.cmpn(a) <= 0
            }),
            (s.prototype.lte = function (a) {
                return this.cmp(a) <= 0
            }),
            (s.prototype.eqn = function (a) {
                return this.cmpn(a) === 0
            }),
            (s.prototype.eq = function (a) {
                return this.cmp(a) === 0
            }),
            (s.red = function (a) {
                return new it(a)
            }),
            (s.prototype.toRed = function (a) {
                return (
                    n(!this.red, "Already a number in reduction context"),
                    n(this.negative === 0, "red works only with positives"),
                    a.convertTo(this)._forceRed(a)
                )
            }),
            (s.prototype.fromRed = function () {
                return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
            }),
            (s.prototype._forceRed = function (a) {
                return (this.red = a), this
            }),
            (s.prototype.forceRed = function (a) {
                return n(!this.red, "Already a number in reduction context"), this._forceRed(a)
            }),
            (s.prototype.redAdd = function (a) {
                return n(this.red, "redAdd works only with red numbers"), this.red.add(this, a)
            }),
            (s.prototype.redIAdd = function (a) {
                return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a)
            }),
            (s.prototype.redSub = function (a) {
                return n(this.red, "redSub works only with red numbers"), this.red.sub(this, a)
            }),
            (s.prototype.redISub = function (a) {
                return n(this.red, "redISub works only with red numbers"), this.red.isub(this, a)
            }),
            (s.prototype.redShl = function (a) {
                return n(this.red, "redShl works only with red numbers"), this.red.shl(this, a)
            }),
            (s.prototype.redMul = function (a) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a)
            }),
            (s.prototype.redIMul = function (a) {
                return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a)
            }),
            (s.prototype.redSqr = function () {
                return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
            }),
            (s.prototype.redISqr = function () {
                return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
            }),
            (s.prototype.redSqrt = function () {
                return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
            }),
            (s.prototype.redInvm = function () {
                return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
            }),
            (s.prototype.redNeg = function () {
                return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
            }),
            (s.prototype.redPow = function (a) {
                return n(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a)
            })
        var R = { k256: null, p224: null, p192: null, p25519: null }
        function W(x, a) {
            ;(this.name = x),
                (this.p = new s(a, 16)),
                (this.n = this.p.bitLength()),
                (this.k = new s(1).iushln(this.n).isub(this.p)),
                (this.tmp = this._tmp())
        }
        ;(W.prototype._tmp = function () {
            var a = new s(null)
            return (a.words = new Array(Math.ceil(this.n / 13))), a
        }),
            (W.prototype.ireduce = function (a) {
                var c = a,
                    m
                do this.split(c, this.tmp), (c = this.imulK(c)), (c = c.iadd(this.tmp)), (m = c.bitLength())
                while (m > this.n)
                var _ = m < this.n ? -1 : c.ucmp(this.p)
                return _ === 0 ? ((c.words[0] = 0), (c.length = 1)) : _ > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c
            }),
            (W.prototype.split = function (a, c) {
                a.iushrn(this.n, 0, c)
            }),
            (W.prototype.imulK = function (a) {
                return a.imul(this.k)
            })
        function nt() {
            W.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(nt, W),
            (nt.prototype.split = function (a, c) {
                for (var m = 4194303, _ = Math.min(a.length, 9), A = 0; A < _; A++) c.words[A] = a.words[A]
                if (((c.length = _), a.length <= 9)) {
                    ;(a.words[0] = 0), (a.length = 1)
                    return
                }
                var w = a.words[9]
                for (c.words[c.length++] = w & m, A = 10; A < a.length; A++) {
                    var v = a.words[A] | 0
                    ;(a.words[A - 10] = ((v & m) << 4) | (w >>> 22)), (w = v)
                }
                ;(w >>>= 22), (a.words[A - 10] = w), w === 0 && a.length > 10 ? (a.length -= 10) : (a.length -= 9)
            }),
            (nt.prototype.imulK = function (a) {
                ;(a.words[a.length] = 0), (a.words[a.length + 1] = 0), (a.length += 2)
                for (var c = 0, m = 0; m < a.length; m++) {
                    var _ = a.words[m] | 0
                    ;(c += _ * 977), (a.words[m] = c & 67108863), (c = _ * 64 + ((c / 67108864) | 0))
                }
                return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a
            })
        function J() {
            W.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(J, W)
        function Q() {
            W.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(Q, W)
        function ot() {
            W.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(ot, W),
            (ot.prototype.imulK = function (a) {
                for (var c = 0, m = 0; m < a.length; m++) {
                    var _ = (a.words[m] | 0) * 19 + c,
                        A = _ & 67108863
                    ;(_ >>>= 26), (a.words[m] = A), (c = _)
                }
                return c !== 0 && (a.words[a.length++] = c), a
            }),
            (s._prime = function (a) {
                if (R[a]) return R[a]
                var c
                if (a === "k256") c = new nt()
                else if (a === "p224") c = new J()
                else if (a === "p192") c = new Q()
                else if (a === "p25519") c = new ot()
                else throw new Error("Unknown prime " + a)
                return (R[a] = c), c
            })
        function it(x) {
            if (typeof x == "string") {
                var a = s._prime(x)
                ;(this.m = a.p), (this.prime = a)
            } else n(x.gtn(1), "modulus must be greater than 1"), (this.m = x), (this.prime = null)
        }
        ;(it.prototype._verify1 = function (a) {
            n(a.negative === 0, "red works only with positives"), n(a.red, "red works only with red numbers")
        }),
            (it.prototype._verify2 = function (a, c) {
                n((a.negative | c.negative) === 0, "red works only with positives"),
                    n(a.red && a.red === c.red, "red works only with red numbers")
            }),
            (it.prototype.imod = function (a) {
                return this.prime ? this.prime.ireduce(a)._forceRed(this) : (h(a, a.umod(this.m)._forceRed(this)), a)
            }),
            (it.prototype.neg = function (a) {
                return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
            }),
            (it.prototype.add = function (a, c) {
                this._verify2(a, c)
                var m = a.add(c)
                return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this)
            }),
            (it.prototype.iadd = function (a, c) {
                this._verify2(a, c)
                var m = a.iadd(c)
                return m.cmp(this.m) >= 0 && m.isub(this.m), m
            }),
            (it.prototype.sub = function (a, c) {
                this._verify2(a, c)
                var m = a.sub(c)
                return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this)
            }),
            (it.prototype.isub = function (a, c) {
                this._verify2(a, c)
                var m = a.isub(c)
                return m.cmpn(0) < 0 && m.iadd(this.m), m
            }),
            (it.prototype.shl = function (a, c) {
                return this._verify1(a), this.imod(a.ushln(c))
            }),
            (it.prototype.imul = function (a, c) {
                return this._verify2(a, c), this.imod(a.imul(c))
            }),
            (it.prototype.mul = function (a, c) {
                return this._verify2(a, c), this.imod(a.mul(c))
            }),
            (it.prototype.isqr = function (a) {
                return this.imul(a, a.clone())
            }),
            (it.prototype.sqr = function (a) {
                return this.mul(a, a)
            }),
            (it.prototype.sqrt = function (a) {
                if (a.isZero()) return a.clone()
                var c = this.m.andln(3)
                if ((n(c % 2 === 1), c === 3)) {
                    var m = this.m.add(new s(1)).iushrn(2)
                    return this.pow(a, m)
                }
                for (var _ = this.m.subn(1), A = 0; !_.isZero() && _.andln(1) === 0; ) A++, _.iushrn(1)
                n(!_.isZero())
                var w = new s(1).toRed(this),
                    v = w.redNeg(),
                    g = this.m.subn(1).iushrn(1),
                    u = this.m.bitLength()
                for (u = new s(2 * u * u).toRed(this); this.pow(u, g).cmp(v) !== 0; ) u.redIAdd(v)
                for (var p = this.pow(u, _), H = this.pow(a, _.addn(1).iushrn(1)), b = this.pow(a, _), B = A; b.cmp(w) !== 0; ) {
                    for (var D = b, U = 0; D.cmp(w) !== 0; U++) D = D.redSqr()
                    n(U < B)
                    var j = this.pow(p, new s(1).iushln(B - U - 1))
                    ;(H = H.redMul(j)), (p = j.redSqr()), (b = b.redMul(p)), (B = U)
                }
                return H
            }),
            (it.prototype.invm = function (a) {
                var c = a._invmp(this.m)
                return c.negative !== 0 ? ((c.negative = 0), this.imod(c).redNeg()) : this.imod(c)
            }),
            (it.prototype.pow = function (a, c) {
                if (c.isZero()) return new s(1).toRed(this)
                if (c.cmpn(1) === 0) return a.clone()
                var m = 4,
                    _ = new Array(1 << m)
                ;(_[0] = new s(1).toRed(this)), (_[1] = a)
                for (var A = 2; A < _.length; A++) _[A] = this.mul(_[A - 1], a)
                var w = _[0],
                    v = 0,
                    g = 0,
                    u = c.bitLength() % 26
                for (u === 0 && (u = 26), A = c.length - 1; A >= 0; A--) {
                    for (var p = c.words[A], H = u - 1; H >= 0; H--) {
                        var b = (p >> H) & 1
                        if ((w !== _[0] && (w = this.sqr(w)), b === 0 && v === 0)) {
                            g = 0
                            continue
                        }
                        ;(v <<= 1), (v |= b), g++, !(g !== m && (A !== 0 || H !== 0)) && ((w = this.mul(w, _[v])), (g = 0), (v = 0))
                    }
                    u = 26
                }
                return w
            }),
            (it.prototype.convertTo = function (a) {
                var c = a.umod(this.m)
                return c === a ? c.clone() : c
            }),
            (it.prototype.convertFrom = function (a) {
                var c = a.clone()
                return (c.red = null), c
            }),
            (s.mont = function (a) {
                return new at(a)
            })
        function at(x) {
            it.call(this, x),
                (this.shift = this.m.bitLength()),
                this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
                (this.r = new s(1).iushln(this.shift)),
                (this.r2 = this.imod(this.r.sqr())),
                (this.rinv = this.r._invmp(this.m)),
                (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
                (this.minv = this.minv.umod(this.r)),
                (this.minv = this.r.sub(this.minv))
        }
        i(at, it),
            (at.prototype.convertTo = function (a) {
                return this.imod(a.ushln(this.shift))
            }),
            (at.prototype.convertFrom = function (a) {
                var c = this.imod(a.mul(this.rinv))
                return (c.red = null), c
            }),
            (at.prototype.imul = function (a, c) {
                if (a.isZero() || c.isZero()) return (a.words[0] = 0), (a.length = 1), a
                var m = a.imul(c),
                    _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    A = m.isub(_).iushrn(this.shift),
                    w = A
                return A.cmp(this.m) >= 0 ? (w = A.isub(this.m)) : A.cmpn(0) < 0 && (w = A.iadd(this.m)), w._forceRed(this)
            }),
            (at.prototype.mul = function (a, c) {
                if (a.isZero() || c.isZero()) return new s(0)._forceRed(this)
                var m = a.mul(c),
                    _ = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                    A = m.isub(_).iushrn(this.shift),
                    w = A
                return A.cmp(this.m) >= 0 ? (w = A.isub(this.m)) : A.cmpn(0) < 0 && (w = A.iadd(this.m)), w._forceRed(this)
            }),
            (at.prototype.invm = function (a) {
                var c = this.imod(a._invmp(this.m).mul(this.r2))
                return c._forceRed(this)
            })
    })(e, Bd)
})(Ov)
var pe = Ov.exports,
    Iv = {},
    _e = {},
    ol = Bv
function Bv(e, t) {
    if (!e) throw new Error(t || "Assertion failed")
}
Bv.equal = function (t, r, n) {
    if (t != r) throw new Error(n || "Assertion failed: " + t + " != " + r)
}
var Pc = { exports: {} }
typeof Object.create == "function"
    ? (Pc.exports = function (t, r) {
          r &&
              ((t.super_ = r),
              (t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } })))
      })
    : (Pc.exports = function (t, r) {
          if (r) {
              t.super_ = r
              var n = function () {}
              ;(n.prototype = r.prototype), (t.prototype = new n()), (t.prototype.constructor = t)
          }
      })
var kx = ol,
    Nx = Pc.exports
_e.inherits = Nx
function Ox(e, t) {
    return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320
}
function Ix(e, t) {
    if (Array.isArray(e)) return e.slice()
    if (!e) return []
    var r = []
    if (typeof e == "string")
        if (t) {
            if (t === "hex")
                for (e = e.replace(/[^a-z0-9]+/gi, ""), e.length % 2 !== 0 && (e = "0" + e), i = 0; i < e.length; i += 2)
                    r.push(parseInt(e[i] + e[i + 1], 16))
        } else
            for (var n = 0, i = 0; i < e.length; i++) {
                var s = e.charCodeAt(i)
                s < 128
                    ? (r[n++] = s)
                    : s < 2048
                    ? ((r[n++] = (s >> 6) | 192), (r[n++] = (s & 63) | 128))
                    : Ox(e, i)
                    ? ((s = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++i) & 1023)),
                      (r[n++] = (s >> 18) | 240),
                      (r[n++] = ((s >> 12) & 63) | 128),
                      (r[n++] = ((s >> 6) & 63) | 128),
                      (r[n++] = (s & 63) | 128))
                    : ((r[n++] = (s >> 12) | 224), (r[n++] = ((s >> 6) & 63) | 128), (r[n++] = (s & 63) | 128))
            }
    else for (i = 0; i < e.length; i++) r[i] = e[i] | 0
    return r
}
_e.toArray = Ix
function Bx(e) {
    for (var t = "", r = 0; r < e.length; r++) t += Rv(e[r].toString(16))
    return t
}
_e.toHex = Bx
function Pv(e) {
    var t = (e >>> 24) | ((e >>> 8) & 65280) | ((e << 8) & 16711680) | ((e & 255) << 24)
    return t >>> 0
}
_e.htonl = Pv
function Px(e, t) {
    for (var r = "", n = 0; n < e.length; n++) {
        var i = e[n]
        t === "little" && (i = Pv(i)), (r += Lv(i.toString(16)))
    }
    return r
}
_e.toHex32 = Px
function Rv(e) {
    return e.length === 1 ? "0" + e : e
}
_e.zero2 = Rv
function Lv(e) {
    return e.length === 7
        ? "0" + e
        : e.length === 6
        ? "00" + e
        : e.length === 5
        ? "000" + e
        : e.length === 4
        ? "0000" + e
        : e.length === 3
        ? "00000" + e
        : e.length === 2
        ? "000000" + e
        : e.length === 1
        ? "0000000" + e
        : e
}
_e.zero8 = Lv
function Rx(e, t, r, n) {
    var i = r - t
    kx(i % 4 === 0)
    for (var s = new Array(i / 4), o = 0, l = t; o < s.length; o++, l += 4) {
        var f
        n === "big"
            ? (f = (e[l] << 24) | (e[l + 1] << 16) | (e[l + 2] << 8) | e[l + 3])
            : (f = (e[l + 3] << 24) | (e[l + 2] << 16) | (e[l + 1] << 8) | e[l]),
            (s[o] = f >>> 0)
    }
    return s
}
_e.join32 = Rx
function Lx(e, t) {
    for (var r = new Array(e.length * 4), n = 0, i = 0; n < e.length; n++, i += 4) {
        var s = e[n]
        t === "big"
            ? ((r[i] = s >>> 24), (r[i + 1] = (s >>> 16) & 255), (r[i + 2] = (s >>> 8) & 255), (r[i + 3] = s & 255))
            : ((r[i + 3] = s >>> 24), (r[i + 2] = (s >>> 16) & 255), (r[i + 1] = (s >>> 8) & 255), (r[i] = s & 255))
    }
    return r
}
_e.split32 = Lx
function Dx(e, t) {
    return (e >>> t) | (e << (32 - t))
}
_e.rotr32 = Dx
function $x(e, t) {
    return (e << t) | (e >>> (32 - t))
}
_e.rotl32 = $x
function Fx(e, t) {
    return (e + t) >>> 0
}
_e.sum32 = Fx
function Vx(e, t, r) {
    return (e + t + r) >>> 0
}
_e.sum32_3 = Vx
function Ux(e, t, r, n) {
    return (e + t + r + n) >>> 0
}
_e.sum32_4 = Ux
function Hx(e, t, r, n, i) {
    return (e + t + r + n + i) >>> 0
}
_e.sum32_5 = Hx
function qx(e, t, r, n) {
    var i = e[t],
        s = e[t + 1],
        o = (n + s) >>> 0,
        l = (o < n ? 1 : 0) + r + i
    ;(e[t] = l >>> 0), (e[t + 1] = o)
}
_e.sum64 = qx
function zx(e, t, r, n) {
    var i = (t + n) >>> 0,
        s = (i < t ? 1 : 0) + e + r
    return s >>> 0
}
_e.sum64_hi = zx
function jx(e, t, r, n) {
    var i = t + n
    return i >>> 0
}
_e.sum64_lo = jx
function Kx(e, t, r, n, i, s, o, l) {
    var f = 0,
        d = t
    ;(d = (d + n) >>> 0), (f += d < t ? 1 : 0), (d = (d + s) >>> 0), (f += d < s ? 1 : 0), (d = (d + l) >>> 0), (f += d < l ? 1 : 0)
    var h = e + r + i + o + f
    return h >>> 0
}
_e.sum64_4_hi = Kx
function Gx(e, t, r, n, i, s, o, l) {
    var f = t + n + s + l
    return f >>> 0
}
_e.sum64_4_lo = Gx
function Wx(e, t, r, n, i, s, o, l, f, d) {
    var h = 0,
        y = t
    ;(y = (y + n) >>> 0),
        (h += y < t ? 1 : 0),
        (y = (y + s) >>> 0),
        (h += y < s ? 1 : 0),
        (y = (y + l) >>> 0),
        (h += y < l ? 1 : 0),
        (y = (y + d) >>> 0),
        (h += y < d ? 1 : 0)
    var E = e + r + i + o + f + h
    return E >>> 0
}
_e.sum64_5_hi = Wx
function Yx(e, t, r, n, i, s, o, l, f, d) {
    var h = t + n + s + l + d
    return h >>> 0
}
_e.sum64_5_lo = Yx
function Jx(e, t, r) {
    var n = (t << (32 - r)) | (e >>> r)
    return n >>> 0
}
_e.rotr64_hi = Jx
function Qx(e, t, r) {
    var n = (e << (32 - r)) | (t >>> r)
    return n >>> 0
}
_e.rotr64_lo = Qx
function Xx(e, t, r) {
    return e >>> r
}
_e.shr64_hi = Xx
function Zx(e, t, r) {
    var n = (e << (32 - r)) | (t >>> r)
    return n >>> 0
}
_e.shr64_lo = Zx
var zo = {},
    U0 = _e,
    t6 = ol
function Zu() {
    ;(this.pending = null),
        (this.pendingTotal = 0),
        (this.blockSize = this.constructor.blockSize),
        (this.outSize = this.constructor.outSize),
        (this.hmacStrength = this.constructor.hmacStrength),
        (this.padLength = this.constructor.padLength / 8),
        (this.endian = "big"),
        (this._delta8 = this.blockSize / 8),
        (this._delta32 = this.blockSize / 32)
}
zo.BlockHash = Zu
Zu.prototype.update = function (t, r) {
    if (
        ((t = U0.toArray(t, r)),
        this.pending ? (this.pending = this.pending.concat(t)) : (this.pending = t),
        (this.pendingTotal += t.length),
        this.pending.length >= this._delta8)
    ) {
        t = this.pending
        var n = t.length % this._delta8
        ;(this.pending = t.slice(t.length - n, t.length)),
            this.pending.length === 0 && (this.pending = null),
            (t = U0.join32(t, 0, t.length - n, this.endian))
        for (var i = 0; i < t.length; i += this._delta32) this._update(t, i, i + this._delta32)
    }
    return this
}
Zu.prototype.digest = function (t) {
    return this.update(this._pad()), t6(this.pending === null), this._digest(t)
}
Zu.prototype._pad = function () {
    var t = this.pendingTotal,
        r = this._delta8,
        n = r - ((t + this.padLength) % r),
        i = new Array(n + this.padLength)
    i[0] = 128
    for (var s = 1; s < n; s++) i[s] = 0
    if (((t <<= 3), this.endian === "big")) {
        for (var o = 8; o < this.padLength; o++) i[s++] = 0
        ;(i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = 0),
            (i[s++] = (t >>> 24) & 255),
            (i[s++] = (t >>> 16) & 255),
            (i[s++] = (t >>> 8) & 255),
            (i[s++] = t & 255)
    } else
        for (
            i[s++] = t & 255,
                i[s++] = (t >>> 8) & 255,
                i[s++] = (t >>> 16) & 255,
                i[s++] = (t >>> 24) & 255,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0,
                i[s++] = 0,
                o = 8;
            o < this.padLength;
            o++
        )
            i[s++] = 0
    return i
}
var jo = {},
    jn = {},
    e6 = _e,
    Rn = e6.rotr32
function r6(e, t, r, n) {
    if (e === 0) return Dv(t, r, n)
    if (e === 1 || e === 3) return Fv(t, r, n)
    if (e === 2) return $v(t, r, n)
}
jn.ft_1 = r6
function Dv(e, t, r) {
    return (e & t) ^ (~e & r)
}
jn.ch32 = Dv
function $v(e, t, r) {
    return (e & t) ^ (e & r) ^ (t & r)
}
jn.maj32 = $v
function Fv(e, t, r) {
    return e ^ t ^ r
}
jn.p32 = Fv
function n6(e) {
    return Rn(e, 2) ^ Rn(e, 13) ^ Rn(e, 22)
}
jn.s0_256 = n6
function i6(e) {
    return Rn(e, 6) ^ Rn(e, 11) ^ Rn(e, 25)
}
jn.s1_256 = i6
function s6(e) {
    return Rn(e, 7) ^ Rn(e, 18) ^ (e >>> 3)
}
jn.g0_256 = s6
function o6(e) {
    return Rn(e, 17) ^ Rn(e, 19) ^ (e >>> 10)
}
jn.g1_256 = o6
var ko = _e,
    a6 = zo,
    l6 = jn,
    Of = ko.rotl32,
    ia = ko.sum32,
    u6 = ko.sum32_5,
    f6 = l6.ft_1,
    Vv = a6.BlockHash,
    c6 = [1518500249, 1859775393, 2400959708, 3395469782]
function Vn() {
    if (!(this instanceof Vn)) return new Vn()
    Vv.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80))
}
ko.inherits(Vn, Vv)
var d6 = Vn
Vn.blockSize = 512
Vn.outSize = 160
Vn.hmacStrength = 80
Vn.padLength = 64
Vn.prototype._update = function (t, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = t[r + i]
    for (; i < n.length; i++) n[i] = Of(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1)
    var s = this.h[0],
        o = this.h[1],
        l = this.h[2],
        f = this.h[3],
        d = this.h[4]
    for (i = 0; i < n.length; i++) {
        var h = ~~(i / 20),
            y = u6(Of(s, 5), f6(h, o, l, f), d, n[i], c6[h])
        ;(d = f), (f = l), (l = Of(o, 30)), (o = s), (s = y)
    }
    ;(this.h[0] = ia(this.h[0], s)),
        (this.h[1] = ia(this.h[1], o)),
        (this.h[2] = ia(this.h[2], l)),
        (this.h[3] = ia(this.h[3], f)),
        (this.h[4] = ia(this.h[4], d))
}
Vn.prototype._digest = function (t) {
    return t === "hex" ? ko.toHex32(this.h, "big") : ko.split32(this.h, "big")
}
var No = _e,
    h6 = zo,
    Ko = jn,
    p6 = ol,
    sn = No.sum32,
    g6 = No.sum32_4,
    m6 = No.sum32_5,
    v6 = Ko.ch32,
    b6 = Ko.maj32,
    y6 = Ko.s0_256,
    _6 = Ko.s1_256,
    w6 = Ko.g0_256,
    A6 = Ko.g1_256,
    Uv = h6.BlockHash,
    E6 = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278,
        1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122,
        1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205,
        773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
        3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
    ]
function Un() {
    if (!(this instanceof Un)) return new Un()
    Uv.call(this),
        (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
        (this.k = E6),
        (this.W = new Array(64))
}
No.inherits(Un, Uv)
var Hv = Un
Un.blockSize = 512
Un.outSize = 256
Un.hmacStrength = 192
Un.padLength = 64
Un.prototype._update = function (t, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = t[r + i]
    for (; i < n.length; i++) n[i] = g6(A6(n[i - 2]), n[i - 7], w6(n[i - 15]), n[i - 16])
    var s = this.h[0],
        o = this.h[1],
        l = this.h[2],
        f = this.h[3],
        d = this.h[4],
        h = this.h[5],
        y = this.h[6],
        E = this.h[7]
    for (p6(this.k.length === n.length), i = 0; i < n.length; i++) {
        var T = m6(E, _6(d), v6(d, h, y), this.k[i], n[i]),
            S = sn(y6(s), b6(s, o, l))
        ;(E = y), (y = h), (h = d), (d = sn(f, T)), (f = l), (l = o), (o = s), (s = sn(T, S))
    }
    ;(this.h[0] = sn(this.h[0], s)),
        (this.h[1] = sn(this.h[1], o)),
        (this.h[2] = sn(this.h[2], l)),
        (this.h[3] = sn(this.h[3], f)),
        (this.h[4] = sn(this.h[4], d)),
        (this.h[5] = sn(this.h[5], h)),
        (this.h[6] = sn(this.h[6], y)),
        (this.h[7] = sn(this.h[7], E))
}
Un.prototype._digest = function (t) {
    return t === "hex" ? No.toHex32(this.h, "big") : No.split32(this.h, "big")
}
var Rc = _e,
    qv = Hv
function di() {
    if (!(this instanceof di)) return new di()
    qv.call(this), (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
}
Rc.inherits(di, qv)
var x6 = di
di.blockSize = 512
di.outSize = 224
di.hmacStrength = 192
di.padLength = 64
di.prototype._digest = function (t) {
    return t === "hex" ? Rc.toHex32(this.h.slice(0, 7), "big") : Rc.split32(this.h.slice(0, 7), "big")
}
var Er = _e,
    T6 = zo,
    C6 = ol,
    Ln = Er.rotr64_hi,
    Dn = Er.rotr64_lo,
    zv = Er.shr64_hi,
    jv = Er.shr64_lo,
    Ti = Er.sum64,
    If = Er.sum64_hi,
    Bf = Er.sum64_lo,
    M6 = Er.sum64_4_hi,
    S6 = Er.sum64_4_lo,
    k6 = Er.sum64_5_hi,
    N6 = Er.sum64_5_lo,
    Kv = T6.BlockHash,
    O6 = [
        1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993,
        3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764,
        1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401,
        2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235,
        1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671,
        3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
        773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350,
        1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008,
        3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616,
        1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995,
        1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474,
        593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
        3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269,
        320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158,
        1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
    ]
function gn() {
    if (!(this instanceof gn)) return new gn()
    Kv.call(this),
        (this.h = [
            1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924,
            725511199, 528734635, 4215389547, 1541459225, 327033209,
        ]),
        (this.k = O6),
        (this.W = new Array(160))
}
Er.inherits(gn, Kv)
var Gv = gn
gn.blockSize = 1024
gn.outSize = 512
gn.hmacStrength = 192
gn.padLength = 128
gn.prototype._prepareBlock = function (t, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = t[r + i]
    for (; i < n.length; i += 2) {
        var s = H6(n[i - 4], n[i - 3]),
            o = q6(n[i - 4], n[i - 3]),
            l = n[i - 14],
            f = n[i - 13],
            d = V6(n[i - 30], n[i - 29]),
            h = U6(n[i - 30], n[i - 29]),
            y = n[i - 32],
            E = n[i - 31]
        ;(n[i] = M6(s, o, l, f, d, h, y, E)), (n[i + 1] = S6(s, o, l, f, d, h, y, E))
    }
}
gn.prototype._update = function (t, r) {
    this._prepareBlock(t, r)
    var n = this.W,
        i = this.h[0],
        s = this.h[1],
        o = this.h[2],
        l = this.h[3],
        f = this.h[4],
        d = this.h[5],
        h = this.h[6],
        y = this.h[7],
        E = this.h[8],
        T = this.h[9],
        S = this.h[10],
        N = this.h[11],
        P = this.h[12],
        M = this.h[13],
        k = this.h[14],
        F = this.h[15]
    C6(this.k.length === n.length)
    for (var $ = 0; $ < n.length; $ += 2) {
        var R = k,
            W = F,
            nt = $6(E, T),
            J = F6(E, T),
            Q = I6(E, T, S, N, P),
            ot = B6(E, T, S, N, P, M),
            it = this.k[$],
            at = this.k[$ + 1],
            x = n[$],
            a = n[$ + 1],
            c = k6(R, W, nt, J, Q, ot, it, at, x, a),
            m = N6(R, W, nt, J, Q, ot, it, at, x, a)
        ;(R = L6(i, s)), (W = D6(i, s)), (nt = P6(i, s, o, l, f)), (J = R6(i, s, o, l, f, d))
        var _ = If(R, W, nt, J),
            A = Bf(R, W, nt, J)
        ;(k = P),
            (F = M),
            (P = S),
            (M = N),
            (S = E),
            (N = T),
            (E = If(h, y, c, m)),
            (T = Bf(y, y, c, m)),
            (h = f),
            (y = d),
            (f = o),
            (d = l),
            (o = i),
            (l = s),
            (i = If(c, m, _, A)),
            (s = Bf(c, m, _, A))
    }
    Ti(this.h, 0, i, s),
        Ti(this.h, 2, o, l),
        Ti(this.h, 4, f, d),
        Ti(this.h, 6, h, y),
        Ti(this.h, 8, E, T),
        Ti(this.h, 10, S, N),
        Ti(this.h, 12, P, M),
        Ti(this.h, 14, k, F)
}
gn.prototype._digest = function (t) {
    return t === "hex" ? Er.toHex32(this.h, "big") : Er.split32(this.h, "big")
}
function I6(e, t, r, n, i) {
    var s = (e & r) ^ (~e & i)
    return s < 0 && (s += 4294967296), s
}
function B6(e, t, r, n, i, s) {
    var o = (t & n) ^ (~t & s)
    return o < 0 && (o += 4294967296), o
}
function P6(e, t, r, n, i) {
    var s = (e & r) ^ (e & i) ^ (r & i)
    return s < 0 && (s += 4294967296), s
}
function R6(e, t, r, n, i, s) {
    var o = (t & n) ^ (t & s) ^ (n & s)
    return o < 0 && (o += 4294967296), o
}
function L6(e, t) {
    var r = Ln(e, t, 28),
        n = Ln(t, e, 2),
        i = Ln(t, e, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function D6(e, t) {
    var r = Dn(e, t, 28),
        n = Dn(t, e, 2),
        i = Dn(t, e, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function $6(e, t) {
    var r = Ln(e, t, 14),
        n = Ln(e, t, 18),
        i = Ln(t, e, 9),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function F6(e, t) {
    var r = Dn(e, t, 14),
        n = Dn(e, t, 18),
        i = Dn(t, e, 9),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function V6(e, t) {
    var r = Ln(e, t, 1),
        n = Ln(e, t, 8),
        i = zv(e, t, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function U6(e, t) {
    var r = Dn(e, t, 1),
        n = Dn(e, t, 8),
        i = jv(e, t, 7),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function H6(e, t) {
    var r = Ln(e, t, 19),
        n = Ln(t, e, 29),
        i = zv(e, t, 6),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
function q6(e, t) {
    var r = Dn(e, t, 19),
        n = Dn(t, e, 29),
        i = jv(e, t, 6),
        s = r ^ n ^ i
    return s < 0 && (s += 4294967296), s
}
var Lc = _e,
    Wv = Gv
function hi() {
    if (!(this instanceof hi)) return new hi()
    Wv.call(this),
        (this.h = [
            3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231,
            1750603025, 3675008525, 1694076839, 1203062813, 3204075428,
        ])
}
Lc.inherits(hi, Wv)
var z6 = hi
hi.blockSize = 1024
hi.outSize = 384
hi.hmacStrength = 192
hi.padLength = 128
hi.prototype._digest = function (t) {
    return t === "hex" ? Lc.toHex32(this.h.slice(0, 12), "big") : Lc.split32(this.h.slice(0, 12), "big")
}
jo.sha1 = d6
jo.sha224 = x6
jo.sha256 = Hv
jo.sha384 = z6
jo.sha512 = Gv
var Yv = {},
    Ps = _e,
    j6 = zo,
    Cl = Ps.rotl32,
    H0 = Ps.sum32,
    sa = Ps.sum32_3,
    q0 = Ps.sum32_4,
    Jv = j6.BlockHash
function Hn() {
    if (!(this instanceof Hn)) return new Hn()
    Jv.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = "little")
}
Ps.inherits(Hn, Jv)
Yv.ripemd160 = Hn
Hn.blockSize = 512
Hn.outSize = 160
Hn.hmacStrength = 192
Hn.padLength = 64
Hn.prototype._update = function (t, r) {
    for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], l = this.h[4], f = n, d = i, h = s, y = o, E = l, T = 0; T < 80; T++) {
        var S = H0(Cl(q0(n, z0(T, i, s, o), t[W6[T] + r], K6(T)), J6[T]), l)
        ;(n = l),
            (l = o),
            (o = Cl(s, 10)),
            (s = i),
            (i = S),
            (S = H0(Cl(q0(f, z0(79 - T, d, h, y), t[Y6[T] + r], G6(T)), Q6[T]), E)),
            (f = E),
            (E = y),
            (y = Cl(h, 10)),
            (h = d),
            (d = S)
    }
    ;(S = sa(this.h[1], s, y)),
        (this.h[1] = sa(this.h[2], o, E)),
        (this.h[2] = sa(this.h[3], l, f)),
        (this.h[3] = sa(this.h[4], n, d)),
        (this.h[4] = sa(this.h[0], i, h)),
        (this.h[0] = S)
}
Hn.prototype._digest = function (t) {
    return t === "hex" ? Ps.toHex32(this.h, "little") : Ps.split32(this.h, "little")
}
function z0(e, t, r, n) {
    return e <= 15 ? t ^ r ^ n : e <= 31 ? (t & r) | (~t & n) : e <= 47 ? (t | ~r) ^ n : e <= 63 ? (t & n) | (r & ~n) : t ^ (r | ~n)
}
function K6(e) {
    return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838
}
function G6(e) {
    return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0
}
var W6 = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2,
        7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
    ],
    Y6 = [
        5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11,
        8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
    ],
    J6 = [
        11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13,
        15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8,
        5, 6,
    ],
    Q6 = [
        8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6,
        14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13,
        11, 11,
    ],
    X6 = _e,
    Z6 = ol
function Oo(e, t, r) {
    if (!(this instanceof Oo)) return new Oo(e, t, r)
    ;(this.Hash = e),
        (this.blockSize = e.blockSize / 8),
        (this.outSize = e.outSize / 8),
        (this.inner = null),
        (this.outer = null),
        this._init(X6.toArray(t, r))
}
var t5 = Oo
Oo.prototype._init = function (t) {
    t.length > this.blockSize && (t = new this.Hash().update(t).digest()), Z6(t.length <= this.blockSize)
    for (var r = t.length; r < this.blockSize; r++) t.push(0)
    for (r = 0; r < t.length; r++) t[r] ^= 54
    for (this.inner = new this.Hash().update(t), r = 0; r < t.length; r++) t[r] ^= 106
    this.outer = new this.Hash().update(t)
}
Oo.prototype.update = function (t, r) {
    return this.inner.update(t, r), this
}
Oo.prototype.digest = function (t) {
    return this.outer.update(this.inner.digest()), this.outer.digest(t)
}
;(function (e) {
    var t = e
    ;(t.utils = _e),
        (t.common = zo),
        (t.sha = jo),
        (t.ripemd = Yv),
        (t.hmac = t5),
        (t.sha1 = t.sha.sha1),
        (t.sha256 = t.sha.sha256),
        (t.sha224 = t.sha.sha224),
        (t.sha384 = t.sha.sha384),
        (t.sha512 = t.sha.sha512),
        (t.ripemd160 = t.ripemd.ripemd160)
})(Iv)
var Tn = Iv
function Go(e, t, r) {
    return (
        (r = {
            path: t,
            exports: {},
            require: function (n, i) {
                return e5(n, i == null ? r.path : i)
            },
        }),
        e(r, r.exports),
        r.exports
    )
}
function e5() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var Hd = Qv
function Qv(e, t) {
    if (!e) throw new Error(t || "Assertion failed")
}
Qv.equal = function (t, r, n) {
    if (t != r) throw new Error(n || "Assertion failed: " + t + " != " + r)
}
var un = Go(function (e, t) {
        var r = t
        function n(o, l) {
            if (Array.isArray(o)) return o.slice()
            if (!o) return []
            var f = []
            if (typeof o != "string") {
                for (var d = 0; d < o.length; d++) f[d] = o[d] | 0
                return f
            }
            if (l === "hex") {
                ;(o = o.replace(/[^a-z0-9]+/gi, "")), o.length % 2 !== 0 && (o = "0" + o)
                for (var d = 0; d < o.length; d += 2) f.push(parseInt(o[d] + o[d + 1], 16))
            } else
                for (var d = 0; d < o.length; d++) {
                    var h = o.charCodeAt(d),
                        y = h >> 8,
                        E = h & 255
                    y ? f.push(y, E) : f.push(E)
                }
            return f
        }
        r.toArray = n
        function i(o) {
            return o.length === 1 ? "0" + o : o
        }
        r.zero2 = i
        function s(o) {
            for (var l = "", f = 0; f < o.length; f++) l += i(o[f].toString(16))
            return l
        }
        ;(r.toHex = s),
            (r.encode = function (l, f) {
                return f === "hex" ? s(l) : l
            })
    }),
    Fr = Go(function (e, t) {
        var r = t
        ;(r.assert = Hd), (r.toArray = un.toArray), (r.zero2 = un.zero2), (r.toHex = un.toHex), (r.encode = un.encode)
        function n(f, d, h) {
            var y = new Array(Math.max(f.bitLength(), h) + 1)
            y.fill(0)
            for (var E = 1 << (d + 1), T = f.clone(), S = 0; S < y.length; S++) {
                var N,
                    P = T.andln(E - 1)
                T.isOdd() ? (P > (E >> 1) - 1 ? (N = (E >> 1) - P) : (N = P), T.isubn(N)) : (N = 0), (y[S] = N), T.iushrn(1)
            }
            return y
        }
        r.getNAF = n
        function i(f, d) {
            var h = [[], []]
            ;(f = f.clone()), (d = d.clone())
            for (var y = 0, E = 0, T; f.cmpn(-y) > 0 || d.cmpn(-E) > 0; ) {
                var S = (f.andln(3) + y) & 3,
                    N = (d.andln(3) + E) & 3
                S === 3 && (S = -1), N === 3 && (N = -1)
                var P
                ;(S & 1) === 0 ? (P = 0) : ((T = (f.andln(7) + y) & 7), (T === 3 || T === 5) && N === 2 ? (P = -S) : (P = S)), h[0].push(P)
                var M
                ;(N & 1) === 0 ? (M = 0) : ((T = (d.andln(7) + E) & 7), (T === 3 || T === 5) && S === 2 ? (M = -N) : (M = N)),
                    h[1].push(M),
                    2 * y === P + 1 && (y = 1 - y),
                    2 * E === M + 1 && (E = 1 - E),
                    f.iushrn(1),
                    d.iushrn(1)
            }
            return h
        }
        r.getJSF = i
        function s(f, d, h) {
            var y = "_" + d
            f.prototype[d] = function () {
                return this[y] !== void 0 ? this[y] : (this[y] = h.call(this))
            }
        }
        r.cachedProperty = s
        function o(f) {
            return typeof f == "string" ? r.toArray(f, "hex") : f
        }
        r.parseBytes = o
        function l(f) {
            return new pe(f, "hex", "le")
        }
        r.intFromLE = l
    }),
    gu = Fr.getNAF,
    r5 = Fr.getJSF,
    mu = Fr.assert
function Xi(e, t) {
    ;(this.type = e),
        (this.p = new pe(t.p, 16)),
        (this.red = t.prime ? pe.red(t.prime) : pe.mont(this.p)),
        (this.zero = new pe(0).toRed(this.red)),
        (this.one = new pe(1).toRed(this.red)),
        (this.two = new pe(2).toRed(this.red)),
        (this.n = t.n && new pe(t.n, 16)),
        (this.g = t.g && this.pointFromJSON(t.g, t.gRed)),
        (this._wnafT1 = new Array(4)),
        (this._wnafT2 = new Array(4)),
        (this._wnafT3 = new Array(4)),
        (this._wnafT4 = new Array(4)),
        (this._bitLength = this.n ? this.n.bitLength() : 0)
    var r = this.n && this.p.div(this.n)
    !r || r.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
}
var zs = Xi
Xi.prototype.point = function () {
    throw new Error("Not implemented")
}
Xi.prototype.validate = function () {
    throw new Error("Not implemented")
}
Xi.prototype._fixedNafMul = function (t, r) {
    mu(t.precomputed)
    var n = t._getDoubles(),
        i = gu(r, 1, this._bitLength),
        s = (1 << (n.step + 1)) - (n.step % 2 === 0 ? 2 : 1)
    s /= 3
    var o = [],
        l,
        f
    for (l = 0; l < i.length; l += n.step) {
        f = 0
        for (var d = l + n.step - 1; d >= l; d--) f = (f << 1) + i[d]
        o.push(f)
    }
    for (var h = this.jpoint(null, null, null), y = this.jpoint(null, null, null), E = s; E > 0; E--) {
        for (l = 0; l < o.length; l++) (f = o[l]), f === E ? (y = y.mixedAdd(n.points[l])) : f === -E && (y = y.mixedAdd(n.points[l].neg()))
        h = h.add(y)
    }
    return h.toP()
}
Xi.prototype._wnafMul = function (t, r) {
    var n = 4,
        i = t._getNAFPoints(n)
    n = i.wnd
    for (var s = i.points, o = gu(r, n, this._bitLength), l = this.jpoint(null, null, null), f = o.length - 1; f >= 0; f--) {
        for (var d = 0; f >= 0 && o[f] === 0; f--) d++
        if ((f >= 0 && d++, (l = l.dblp(d)), f < 0)) break
        var h = o[f]
        mu(h !== 0),
            t.type === "affine"
                ? h > 0
                    ? (l = l.mixedAdd(s[(h - 1) >> 1]))
                    : (l = l.mixedAdd(s[(-h - 1) >> 1].neg()))
                : h > 0
                ? (l = l.add(s[(h - 1) >> 1]))
                : (l = l.add(s[(-h - 1) >> 1].neg()))
    }
    return t.type === "affine" ? l.toP() : l
}
Xi.prototype._wnafMulAdd = function (t, r, n, i, s) {
    var o = this._wnafT1,
        l = this._wnafT2,
        f = this._wnafT3,
        d = 0,
        h,
        y,
        E
    for (h = 0; h < i; h++) {
        E = r[h]
        var T = E._getNAFPoints(t)
        ;(o[h] = T.wnd), (l[h] = T.points)
    }
    for (h = i - 1; h >= 1; h -= 2) {
        var S = h - 1,
            N = h
        if (o[S] !== 1 || o[N] !== 1) {
            ;(f[S] = gu(n[S], o[S], this._bitLength)),
                (f[N] = gu(n[N], o[N], this._bitLength)),
                (d = Math.max(f[S].length, d)),
                (d = Math.max(f[N].length, d))
            continue
        }
        var P = [r[S], null, null, r[N]]
        r[S].y.cmp(r[N].y) === 0
            ? ((P[1] = r[S].add(r[N])), (P[2] = r[S].toJ().mixedAdd(r[N].neg())))
            : r[S].y.cmp(r[N].y.redNeg()) === 0
            ? ((P[1] = r[S].toJ().mixedAdd(r[N])), (P[2] = r[S].add(r[N].neg())))
            : ((P[1] = r[S].toJ().mixedAdd(r[N])), (P[2] = r[S].toJ().mixedAdd(r[N].neg())))
        var M = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            k = r5(n[S], n[N])
        for (d = Math.max(k[0].length, d), f[S] = new Array(d), f[N] = new Array(d), y = 0; y < d; y++) {
            var F = k[0][y] | 0,
                $ = k[1][y] | 0
            ;(f[S][y] = M[(F + 1) * 3 + ($ + 1)]), (f[N][y] = 0), (l[S] = P)
        }
    }
    var R = this.jpoint(null, null, null),
        W = this._wnafT4
    for (h = d; h >= 0; h--) {
        for (var nt = 0; h >= 0; ) {
            var J = !0
            for (y = 0; y < i; y++) (W[y] = f[y][h] | 0), W[y] !== 0 && (J = !1)
            if (!J) break
            nt++, h--
        }
        if ((h >= 0 && nt++, (R = R.dblp(nt)), h < 0)) break
        for (y = 0; y < i; y++) {
            var Q = W[y]
            Q !== 0 &&
                (Q > 0 ? (E = l[y][(Q - 1) >> 1]) : Q < 0 && (E = l[y][(-Q - 1) >> 1].neg()),
                E.type === "affine" ? (R = R.mixedAdd(E)) : (R = R.add(E)))
        }
    }
    for (h = 0; h < i; h++) l[h] = null
    return s ? R : R.toP()
}
function Zr(e, t) {
    ;(this.curve = e), (this.type = t), (this.precomputed = null)
}
Xi.BasePoint = Zr
Zr.prototype.eq = function () {
    throw new Error("Not implemented")
}
Zr.prototype.validate = function () {
    return this.curve.validate(this)
}
Xi.prototype.decodePoint = function (t, r) {
    t = Fr.toArray(t, r)
    var n = this.p.byteLength()
    if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * n) {
        t[0] === 6 ? mu(t[t.length - 1] % 2 === 0) : t[0] === 7 && mu(t[t.length - 1] % 2 === 1)
        var i = this.point(t.slice(1, 1 + n), t.slice(1 + n, 1 + 2 * n))
        return i
    } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === n) return this.pointFromX(t.slice(1, 1 + n), t[0] === 3)
    throw new Error("Unknown point format")
}
Zr.prototype.encodeCompressed = function (t) {
    return this.encode(t, !0)
}
Zr.prototype._encode = function (t) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r)
    return t ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
}
Zr.prototype.encode = function (t, r) {
    return Fr.encode(this._encode(r), t)
}
Zr.prototype.precompute = function (t) {
    if (this.precomputed) return this
    var r = { doubles: null, naf: null, beta: null }
    return (r.naf = this._getNAFPoints(8)), (r.doubles = this._getDoubles(4, t)), (r.beta = this._getBeta()), (this.precomputed = r), this
}
Zr.prototype._hasDoubles = function (t) {
    if (!this.precomputed) return !1
    var r = this.precomputed.doubles
    return r ? r.points.length >= Math.ceil((t.bitLength() + 1) / r.step) : !1
}
Zr.prototype._getDoubles = function (t, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
    for (var n = [this], i = this, s = 0; s < r; s += t) {
        for (var o = 0; o < t; o++) i = i.dbl()
        n.push(i)
    }
    return { step: t, points: n }
}
Zr.prototype._getNAFPoints = function (t) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
    for (var r = [this], n = (1 << t) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i)
    return { wnd: t, points: r }
}
Zr.prototype._getBeta = function () {
    return null
}
Zr.prototype.dblp = function (t) {
    for (var r = this, n = 0; n < t; n++) r = r.dbl()
    return r
}
var qd = Go(function (e) {
        typeof Object.create == "function"
            ? (e.exports = function (r, n) {
                  n &&
                      ((r.super_ = n),
                      (r.prototype = Object.create(n.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } })))
              })
            : (e.exports = function (r, n) {
                  if (n) {
                      r.super_ = n
                      var i = function () {}
                      ;(i.prototype = n.prototype), (r.prototype = new i()), (r.prototype.constructor = r)
                  }
              })
    }),
    n5 = Fr.assert
function tn(e) {
    zs.call(this, "short", e),
        (this.a = new pe(e.a, 16).toRed(this.red)),
        (this.b = new pe(e.b, 16).toRed(this.red)),
        (this.tinv = this.two.redInvm()),
        (this.zeroA = this.a.fromRed().cmpn(0) === 0),
        (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
        (this.endo = this._getEndomorphism(e)),
        (this._endoWnafT1 = new Array(4)),
        (this._endoWnafT2 = new Array(4))
}
qd(tn, zs)
var i5 = tn
tn.prototype._getEndomorphism = function (t) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n
        if (t.beta) r = new pe(t.beta, 16).toRed(this.red)
        else {
            var i = this._getEndoRoots(this.p)
            ;(r = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (r = r.toRed(this.red))
        }
        if (t.lambda) n = new pe(t.lambda, 16)
        else {
            var s = this._getEndoRoots(this.n)
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? (n = s[0]) : ((n = s[1]), n5(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o
        return (
            t.basis
                ? (o = t.basis.map(function (l) {
                      return { a: new pe(l.a, 16), b: new pe(l.b, 16) }
                  }))
                : (o = this._getEndoBasis(n)),
            { beta: r, lambda: n, basis: o }
        )
    }
}
tn.prototype._getEndoRoots = function (t) {
    var r = t === this.p ? this.red : pe.mont(t),
        n = new pe(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new pe(3).toRed(r).redNeg().redSqrt().redMul(n),
        o = i.redAdd(s).fromRed(),
        l = i.redSub(s).fromRed()
    return [o, l]
}
tn.prototype._getEndoBasis = function (t) {
    for (
        var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
            n = t,
            i = this.n.clone(),
            s = new pe(1),
            o = new pe(0),
            l = new pe(0),
            f = new pe(1),
            d,
            h,
            y,
            E,
            T,
            S,
            N,
            P = 0,
            M,
            k;
        n.cmpn(0) !== 0;

    ) {
        var F = i.div(n)
        ;(M = i.sub(F.mul(n))), (k = l.sub(F.mul(s)))
        var $ = f.sub(F.mul(o))
        if (!y && M.cmp(r) < 0) (d = N.neg()), (h = s), (y = M.neg()), (E = k)
        else if (y && ++P === 2) break
        ;(N = M), (i = n), (n = M), (l = s), (s = k), (f = o), (o = $)
    }
    ;(T = M.neg()), (S = k)
    var R = y.sqr().add(E.sqr()),
        W = T.sqr().add(S.sqr())
    return (
        W.cmp(R) >= 0 && ((T = d), (S = h)),
        y.negative && ((y = y.neg()), (E = E.neg())),
        T.negative && ((T = T.neg()), (S = S.neg())),
        [
            { a: y, b: E },
            { a: T, b: S },
        ]
    )
}
tn.prototype._endoSplit = function (t) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(t).divRound(this.n),
        o = n.b.neg().mul(t).divRound(this.n),
        l = s.mul(n.a),
        f = o.mul(i.a),
        d = s.mul(n.b),
        h = o.mul(i.b),
        y = t.sub(l).sub(f),
        E = d.add(h).neg()
    return { k1: y, k2: E }
}
tn.prototype.pointFromX = function (t, r) {
    ;(t = new pe(t, 16)), t.red || (t = t.toRed(this.red))
    var n = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt()
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point")
    var s = i.fromRed().isOdd()
    return ((r && !s) || (!r && s)) && (i = i.redNeg()), this.point(t, i)
}
tn.prototype.validate = function (t) {
    if (t.inf) return !0
    var r = t.x,
        n = t.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b)
    return n.redSqr().redISub(s).cmpn(0) === 0
}
tn.prototype._endoWnafMulAdd = function (t, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < t.length; o++) {
        var l = this._endoSplit(r[o]),
            f = t[o],
            d = f._getBeta()
        l.k1.negative && (l.k1.ineg(), (f = f.neg(!0))),
            l.k2.negative && (l.k2.ineg(), (d = d.neg(!0))),
            (i[o * 2] = f),
            (i[o * 2 + 1] = d),
            (s[o * 2] = l.k1),
            (s[o * 2 + 1] = l.k2)
    }
    for (var h = this._wnafMulAdd(1, i, s, o * 2, n), y = 0; y < o * 2; y++) (i[y] = null), (s[y] = null)
    return h
}
function nr(e, t, r, n) {
    zs.BasePoint.call(this, e, "affine"),
        t === null && r === null
            ? ((this.x = null), (this.y = null), (this.inf = !0))
            : ((this.x = new pe(t, 16)),
              (this.y = new pe(r, 16)),
              n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1))
}
qd(nr, zs.BasePoint)
tn.prototype.point = function (t, r, n) {
    return new nr(this, t, r, n)
}
tn.prototype.pointFromJSON = function (t, r) {
    return nr.fromJSON(this, t, r)
}
nr.prototype._getBeta = function () {
    if (!!this.curve.endo) {
        var t = this.precomputed
        if (t && t.beta) return t.beta
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
        if (t) {
            var n = this.curve,
                i = function (s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                }
            ;(t.beta = r),
                (r.precomputed = {
                    beta: null,
                    naf: t.naf && { wnd: t.naf.wnd, points: t.naf.points.map(i) },
                    doubles: t.doubles && { step: t.doubles.step, points: t.doubles.points.map(i) },
                })
        }
        return r
    }
}
nr.prototype.toJSON = function () {
    return this.precomputed
        ? [
              this.x,
              this.y,
              this.precomputed && {
                  doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) },
                  naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) },
              },
          ]
        : [this.x, this.y]
}
nr.fromJSON = function (t, r, n) {
    typeof r == "string" && (r = JSON.parse(r))
    var i = t.point(r[0], r[1], n)
    if (!r[2]) return i
    function s(l) {
        return t.point(l[0], l[1], n)
    }
    var o = r[2]
    return (
        (i.precomputed = {
            beta: null,
            doubles: o.doubles && { step: o.doubles.step, points: [i].concat(o.doubles.points.map(s)) },
            naf: o.naf && { wnd: o.naf.wnd, points: [i].concat(o.naf.points.map(s)) },
        }),
        i
    )
}
nr.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC Point Infinity>"
        : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
}
nr.prototype.isInfinity = function () {
    return this.inf
}
nr.prototype.add = function (t) {
    if (this.inf) return t
    if (t.inf) return this
    if (this.eq(t)) return this.dbl()
    if (this.neg().eq(t)) return this.curve.point(null, null)
    if (this.x.cmp(t.x) === 0) return this.curve.point(null, null)
    var r = this.y.redSub(t.y)
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(t.x).redInvm()))
    var n = r.redSqr().redISub(this.x).redISub(t.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y)
    return this.curve.point(n, i)
}
nr.prototype.dbl = function () {
    if (this.inf) return this
    var t = this.y.redAdd(this.y)
    if (t.cmpn(0) === 0) return this.curve.point(null, null)
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = t.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = s.redSqr().redISub(this.x.redAdd(this.x)),
        l = s.redMul(this.x.redSub(o)).redISub(this.y)
    return this.curve.point(o, l)
}
nr.prototype.getX = function () {
    return this.x.fromRed()
}
nr.prototype.getY = function () {
    return this.y.fromRed()
}
nr.prototype.mul = function (t) {
    return (
        (t = new pe(t, 16)),
        this.isInfinity()
            ? this
            : this._hasDoubles(t)
            ? this.curve._fixedNafMul(this, t)
            : this.curve.endo
            ? this.curve._endoWnafMulAdd([this], [t])
            : this.curve._wnafMul(this, t)
    )
}
nr.prototype.mulAdd = function (t, r, n) {
    var i = [this, r],
        s = [t, n]
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
}
nr.prototype.jmulAdd = function (t, r, n) {
    var i = [this, r],
        s = [t, n]
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
}
nr.prototype.eq = function (t) {
    return this === t || (this.inf === t.inf && (this.inf || (this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0)))
}
nr.prototype.neg = function (t) {
    if (this.inf) return this
    var r = this.curve.point(this.x, this.y.redNeg())
    if (t && this.precomputed) {
        var n = this.precomputed,
            i = function (s) {
                return s.neg()
            }
        r.precomputed = {
            naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(i) },
            doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(i) },
        }
    }
    return r
}
nr.prototype.toJ = function () {
    if (this.inf) return this.curve.jpoint(null, null, null)
    var t = this.curve.jpoint(this.x, this.y, this.curve.one)
    return t
}
function lr(e, t, r, n) {
    zs.BasePoint.call(this, e, "jacobian"),
        t === null && r === null && n === null
            ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new pe(0)))
            : ((this.x = new pe(t, 16)), (this.y = new pe(r, 16)), (this.z = new pe(n, 16))),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        this.z.red || (this.z = this.z.toRed(this.curve.red)),
        (this.zOne = this.z === this.curve.one)
}
qd(lr, zs.BasePoint)
tn.prototype.jpoint = function (t, r, n) {
    return new lr(this, t, r, n)
}
lr.prototype.toP = function () {
    if (this.isInfinity()) return this.curve.point(null, null)
    var t = this.z.redInvm(),
        r = t.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(t)
    return this.curve.point(n, i)
}
lr.prototype.neg = function () {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
}
lr.prototype.add = function (t) {
    if (this.isInfinity()) return t
    if (t.isInfinity()) return this
    var r = t.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = t.x.redMul(n),
        o = this.y.redMul(r.redMul(t.z)),
        l = t.y.redMul(n.redMul(this.z)),
        f = i.redSub(s),
        d = o.redSub(l)
    if (f.cmpn(0) === 0) return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var h = f.redSqr(),
        y = h.redMul(f),
        E = i.redMul(h),
        T = d.redSqr().redIAdd(y).redISub(E).redISub(E),
        S = d.redMul(E.redISub(T)).redISub(o.redMul(y)),
        N = this.z.redMul(t.z).redMul(f)
    return this.curve.jpoint(T, S, N)
}
lr.prototype.mixedAdd = function (t) {
    if (this.isInfinity()) return t.toJ()
    if (t.isInfinity()) return this
    var r = this.z.redSqr(),
        n = this.x,
        i = t.x.redMul(r),
        s = this.y,
        o = t.y.redMul(r).redMul(this.z),
        l = n.redSub(i),
        f = s.redSub(o)
    if (l.cmpn(0) === 0) return f.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
    var d = l.redSqr(),
        h = d.redMul(l),
        y = n.redMul(d),
        E = f.redSqr().redIAdd(h).redISub(y).redISub(y),
        T = f.redMul(y.redISub(E)).redISub(s.redMul(h)),
        S = this.z.redMul(l)
    return this.curve.jpoint(E, T, S)
}
lr.prototype.dblp = function (t) {
    if (t === 0) return this
    if (this.isInfinity()) return this
    if (!t) return this.dbl()
    var r
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this
        for (r = 0; r < t; r++) n = n.dbl()
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        o = this.x,
        l = this.y,
        f = this.z,
        d = f.redSqr().redSqr(),
        h = l.redAdd(l)
    for (r = 0; r < t; r++) {
        var y = o.redSqr(),
            E = h.redSqr(),
            T = E.redSqr(),
            S = y.redAdd(y).redIAdd(y).redIAdd(i.redMul(d)),
            N = o.redMul(E),
            P = S.redSqr().redISub(N.redAdd(N)),
            M = N.redISub(P),
            k = S.redMul(M)
        k = k.redIAdd(k).redISub(T)
        var F = h.redMul(f)
        r + 1 < t && (d = d.redMul(T)), (o = P), (f = F), (h = k)
    }
    return this.curve.jpoint(o, h.redMul(s), f)
}
lr.prototype.dbl = function () {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
}
lr.prototype._zeroDbl = function () {
    var t, r, n
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            l = this.x.redAdd(s).redSqr().redISub(i).redISub(o)
        l = l.redIAdd(l)
        var f = i.redAdd(i).redIAdd(i),
            d = f.redSqr().redISub(l).redISub(l),
            h = o.redIAdd(o)
        ;(h = h.redIAdd(h)), (h = h.redIAdd(h)), (t = d), (r = f.redMul(l.redISub(d)).redISub(h)), (n = this.y.redAdd(this.y))
    } else {
        var y = this.x.redSqr(),
            E = this.y.redSqr(),
            T = E.redSqr(),
            S = this.x.redAdd(E).redSqr().redISub(y).redISub(T)
        S = S.redIAdd(S)
        var N = y.redAdd(y).redIAdd(y),
            P = N.redSqr(),
            M = T.redIAdd(T)
        ;(M = M.redIAdd(M)),
            (M = M.redIAdd(M)),
            (t = P.redISub(S).redISub(S)),
            (r = N.redMul(S.redISub(t)).redISub(M)),
            (n = this.y.redMul(this.z)),
            (n = n.redIAdd(n))
    }
    return this.curve.jpoint(t, r, n)
}
lr.prototype._threeDbl = function () {
    var t, r, n
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            l = this.x.redAdd(s).redSqr().redISub(i).redISub(o)
        l = l.redIAdd(l)
        var f = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            d = f.redSqr().redISub(l).redISub(l)
        t = d
        var h = o.redIAdd(o)
        ;(h = h.redIAdd(h)), (h = h.redIAdd(h)), (r = f.redMul(l.redISub(d)).redISub(h)), (n = this.y.redAdd(this.y))
    } else {
        var y = this.z.redSqr(),
            E = this.y.redSqr(),
            T = this.x.redMul(E),
            S = this.x.redSub(y).redMul(this.x.redAdd(y))
        S = S.redAdd(S).redIAdd(S)
        var N = T.redIAdd(T)
        N = N.redIAdd(N)
        var P = N.redAdd(N)
        ;(t = S.redSqr().redISub(P)), (n = this.y.redAdd(this.z).redSqr().redISub(E).redISub(y))
        var M = E.redSqr()
        ;(M = M.redIAdd(M)), (M = M.redIAdd(M)), (M = M.redIAdd(M)), (r = S.redMul(N.redISub(t)).redISub(M))
    }
    return this.curve.jpoint(t, r, n)
}
lr.prototype._dbl = function () {
    var t = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        o = r.redSqr(),
        l = n.redSqr(),
        f = o.redAdd(o).redIAdd(o).redIAdd(t.redMul(s)),
        d = r.redAdd(r)
    d = d.redIAdd(d)
    var h = d.redMul(l),
        y = f.redSqr().redISub(h.redAdd(h)),
        E = h.redISub(y),
        T = l.redSqr()
    ;(T = T.redIAdd(T)), (T = T.redIAdd(T)), (T = T.redIAdd(T))
    var S = f.redMul(E).redISub(T),
        N = n.redAdd(n).redMul(i)
    return this.curve.jpoint(y, S, N)
}
lr.prototype.trpl = function () {
    if (!this.curve.zeroA) return this.dbl().add(this)
    var t = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = t.redAdd(t).redIAdd(t),
        o = s.redSqr(),
        l = this.x.redAdd(r).redSqr().redISub(t).redISub(i)
    ;(l = l.redIAdd(l)), (l = l.redAdd(l).redIAdd(l)), (l = l.redISub(o))
    var f = l.redSqr(),
        d = i.redIAdd(i)
    ;(d = d.redIAdd(d)), (d = d.redIAdd(d)), (d = d.redIAdd(d))
    var h = s.redIAdd(l).redSqr().redISub(o).redISub(f).redISub(d),
        y = r.redMul(h)
    ;(y = y.redIAdd(y)), (y = y.redIAdd(y))
    var E = this.x.redMul(f).redISub(y)
    ;(E = E.redIAdd(E)), (E = E.redIAdd(E))
    var T = this.y.redMul(h.redMul(d.redISub(h)).redISub(l.redMul(f)))
    ;(T = T.redIAdd(T)), (T = T.redIAdd(T)), (T = T.redIAdd(T))
    var S = this.z.redAdd(l).redSqr().redISub(n).redISub(f)
    return this.curve.jpoint(E, T, S)
}
lr.prototype.mul = function (t, r) {
    return (t = new pe(t, r)), this.curve._wnafMul(this, t)
}
lr.prototype.eq = function (t) {
    if (t.type === "affine") return this.eq(t.toJ())
    if (this === t) return !0
    var r = this.z.redSqr(),
        n = t.z.redSqr()
    if (this.x.redMul(n).redISub(t.x.redMul(r)).cmpn(0) !== 0) return !1
    var i = r.redMul(this.z),
        s = n.redMul(t.z)
    return this.y.redMul(s).redISub(t.y.redMul(i)).cmpn(0) === 0
}
lr.prototype.eqXToP = function (t) {
    var r = this.z.redSqr(),
        n = t.toRed(this.curve.red).redMul(r)
    if (this.x.cmp(n) === 0) return !0
    for (var i = t.clone(), s = this.curve.redN.redMul(r); ; ) {
        if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1
        if ((n.redIAdd(s), this.x.cmp(n) === 0)) return !0
    }
}
lr.prototype.inspect = function () {
    return this.isInfinity()
        ? "<EC JPoint Infinity>"
        : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
}
lr.prototype.isInfinity = function () {
    return this.z.cmpn(0) === 0
}
var ql = Go(function (e, t) {
        var r = t
        ;(r.base = zs), (r.short = i5), (r.mont = null), (r.edwards = null)
    }),
    zl = Go(function (e, t) {
        var r = t,
            n = Fr.assert
        function i(l) {
            l.type === "short"
                ? (this.curve = new ql.short(l))
                : l.type === "edwards"
                ? (this.curve = new ql.edwards(l))
                : (this.curve = new ql.mont(l)),
                (this.g = this.curve.g),
                (this.n = this.curve.n),
                (this.hash = l.hash),
                n(this.g.validate(), "Invalid curve"),
                n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        r.PresetCurve = i
        function s(l, f) {
            Object.defineProperty(r, l, {
                configurable: !0,
                enumerable: !0,
                get: function () {
                    var d = new i(f)
                    return Object.defineProperty(r, l, { configurable: !0, enumerable: !0, value: d }), d
                },
            })
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: Tn.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"],
        }),
            s("p224", {
                type: "short",
                prime: "p224",
                p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                hash: Tn.sha256,
                gRed: !1,
                g: [
                    "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
                    "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34",
                ],
            }),
            s("p256", {
                type: "short",
                prime: null,
                p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                hash: Tn.sha256,
                gRed: !1,
                g: [
                    "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
                    "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5",
                ],
            }),
            s("p384", {
                type: "short",
                prime: null,
                p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                hash: Tn.sha384,
                gRed: !1,
                g: [
                    "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
                    "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f",
                ],
            }),
            s("p521", {
                type: "short",
                prime: null,
                p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                hash: Tn.sha512,
                gRed: !1,
                g: [
                    "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
                    "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650",
                ],
            }),
            s("curve25519", {
                type: "mont",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "76d06",
                b: "1",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: Tn.sha256,
                gRed: !1,
                g: ["9"],
            }),
            s("ed25519", {
                type: "edwards",
                prime: "p25519",
                p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                a: "-1",
                c: "1",
                d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                hash: Tn.sha256,
                gRed: !1,
                g: [
                    "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
                    "6666666666666666666666666666666666666666666666666666666666666658",
                ],
            })
        var o
        try {
            o = null.crash()
        } catch {
            o = void 0
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: Tn.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [
                { a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" },
                { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" },
            ],
            gRed: !1,
            g: [
                "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
                "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
                o,
            ],
        })
    })
function Gi(e) {
    if (!(this instanceof Gi)) return new Gi(e)
    ;(this.hash = e.hash),
        (this.predResist = !!e.predResist),
        (this.outLen = this.hash.outSize),
        (this.minEntropy = e.minEntropy || this.hash.hmacStrength),
        (this._reseed = null),
        (this.reseedInterval = null),
        (this.K = null),
        (this.V = null)
    var t = un.toArray(e.entropy, e.entropyEnc || "hex"),
        r = un.toArray(e.nonce, e.nonceEnc || "hex"),
        n = un.toArray(e.pers, e.persEnc || "hex")
    Hd(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, r, n)
}
var Xv = Gi
Gi.prototype._init = function (t, r, n) {
    var i = t.concat(r).concat(n)
    ;(this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8))
    for (var s = 0; s < this.V.length; s++) (this.K[s] = 0), (this.V[s] = 1)
    this._update(i), (this._reseed = 1), (this.reseedInterval = 281474976710656)
}
Gi.prototype._hmac = function () {
    return new Tn.hmac(this.hash, this.K)
}
Gi.prototype._update = function (t) {
    var r = this._hmac().update(this.V).update([0])
    t && (r = r.update(t)),
        (this.K = r.digest()),
        (this.V = this._hmac().update(this.V).digest()),
        t && ((this.K = this._hmac().update(this.V).update([1]).update(t).digest()), (this.V = this._hmac().update(this.V).digest()))
}
Gi.prototype.reseed = function (t, r, n, i) {
    typeof r != "string" && ((i = n), (n = r), (r = null)),
        (t = un.toArray(t, r)),
        (n = un.toArray(n, i)),
        Hd(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
        this._update(t.concat(n || [])),
        (this._reseed = 1)
}
Gi.prototype.generate = function (t, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required")
    typeof r != "string" && ((i = n), (n = r), (r = null)), n && ((n = un.toArray(n, i || "hex")), this._update(n))
    for (var s = []; s.length < t; ) (this.V = this._hmac().update(this.V).digest()), (s = s.concat(this.V))
    var o = s.slice(0, t)
    return this._update(n), this._reseed++, un.encode(o, r)
}
var Dc = Fr.assert
function hr(e, t) {
    ;(this.ec = e),
        (this.priv = null),
        (this.pub = null),
        t.priv && this._importPrivate(t.priv, t.privEnc),
        t.pub && this._importPublic(t.pub, t.pubEnc)
}
var zd = hr
hr.fromPublic = function (t, r, n) {
    return r instanceof hr ? r : new hr(t, { pub: r, pubEnc: n })
}
hr.fromPrivate = function (t, r, n) {
    return r instanceof hr ? r : new hr(t, { priv: r, privEnc: n })
}
hr.prototype.validate = function () {
    var t = this.getPublic()
    return t.isInfinity()
        ? { result: !1, reason: "Invalid public key" }
        : t.validate()
        ? t.mul(this.ec.curve.n).isInfinity()
            ? { result: !0, reason: null }
            : { result: !1, reason: "Public key * N != O" }
        : { result: !1, reason: "Public key is not a point" }
}
hr.prototype.getPublic = function (t, r) {
    return typeof t == "string" && ((r = t), (t = null)), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, t) : this.pub
}
hr.prototype.getPrivate = function (t) {
    return t === "hex" ? this.priv.toString(16, 2) : this.priv
}
hr.prototype._importPrivate = function (t, r) {
    ;(this.priv = new pe(t, r || 16)), (this.priv = this.priv.umod(this.ec.curve.n))
}
hr.prototype._importPublic = function (t, r) {
    if (t.x || t.y) {
        this.ec.curve.type === "mont"
            ? Dc(t.x, "Need x coordinate")
            : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Dc(t.x && t.y, "Need both x and y coordinate"),
            (this.pub = this.ec.curve.point(t.x, t.y))
        return
    }
    this.pub = this.ec.curve.decodePoint(t, r)
}
hr.prototype.derive = function (t) {
    return t.validate() || Dc(t.validate(), "public point not validated"), t.mul(this.priv).getX()
}
hr.prototype.sign = function (t, r, n) {
    return this.ec.sign(t, this, r, n)
}
hr.prototype.verify = function (t, r) {
    return this.ec.verify(t, r, this)
}
hr.prototype.inspect = function () {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
}
var s5 = Fr.assert
function tf(e, t) {
    if (e instanceof tf) return e
    this._importDER(e, t) ||
        (s5(e.r && e.s, "Signature without r or s"),
        (this.r = new pe(e.r, 16)),
        (this.s = new pe(e.s, 16)),
        e.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = e.recoveryParam))
}
var ef = tf
function o5() {
    this.place = 0
}
function Pf(e, t) {
    var r = e[t.place++]
    if (!(r & 128)) return r
    var n = r & 15
    if (n === 0 || n > 4) return !1
    for (var i = 0, s = 0, o = t.place; s < n; s++, o++) (i <<= 8), (i |= e[o]), (i >>>= 0)
    return i <= 127 ? !1 : ((t.place = o), i)
}
function j0(e) {
    for (var t = 0, r = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < r; ) t++
    return t === 0 ? e : e.slice(t)
}
tf.prototype._importDER = function (t, r) {
    t = Fr.toArray(t, r)
    var n = new o5()
    if (t[n.place++] !== 48) return !1
    var i = Pf(t, n)
    if (i === !1 || i + n.place !== t.length || t[n.place++] !== 2) return !1
    var s = Pf(t, n)
    if (s === !1) return !1
    var o = t.slice(n.place, s + n.place)
    if (((n.place += s), t[n.place++] !== 2)) return !1
    var l = Pf(t, n)
    if (l === !1 || t.length !== l + n.place) return !1
    var f = t.slice(n.place, l + n.place)
    if (o[0] === 0)
        if (o[1] & 128) o = o.slice(1)
        else return !1
    if (f[0] === 0)
        if (f[1] & 128) f = f.slice(1)
        else return !1
    return (this.r = new pe(o)), (this.s = new pe(f)), (this.recoveryParam = null), !0
}
function Rf(e, t) {
    if (t < 128) {
        e.push(t)
        return
    }
    var r = 1 + ((Math.log(t) / Math.LN2) >>> 3)
    for (e.push(r | 128); --r; ) e.push((t >>> (r << 3)) & 255)
    e.push(t)
}
tf.prototype.toDER = function (t) {
    var r = this.r.toArray(),
        n = this.s.toArray()
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = j0(r), n = j0(n); !n[0] && !(n[1] & 128); ) n = n.slice(1)
    var i = [2]
    Rf(i, r.length), (i = i.concat(r)), i.push(2), Rf(i, n.length)
    var s = i.concat(n),
        o = [48]
    return Rf(o, s.length), (o = o.concat(s)), Fr.encode(o, t)
}
var a5 = function () {
        throw new Error("unsupported")
    },
    Zv = Fr.assert
function Jr(e) {
    if (!(this instanceof Jr)) return new Jr(e)
    typeof e == "string" && (Zv(Object.prototype.hasOwnProperty.call(zl, e), "Unknown curve " + e), (e = zl[e])),
        e instanceof zl.PresetCurve && (e = { curve: e }),
        (this.curve = e.curve.curve),
        (this.n = this.curve.n),
        (this.nh = this.n.ushrn(1)),
        (this.g = this.curve.g),
        (this.g = e.curve.g),
        this.g.precompute(e.curve.n.bitLength() + 1),
        (this.hash = e.hash || e.curve.hash)
}
var l5 = Jr
Jr.prototype.keyPair = function (t) {
    return new zd(this, t)
}
Jr.prototype.keyFromPrivate = function (t, r) {
    return zd.fromPrivate(this, t, r)
}
Jr.prototype.keyFromPublic = function (t, r) {
    return zd.fromPublic(this, t, r)
}
Jr.prototype.genKeyPair = function (t) {
    t || (t = {})
    for (
        var r = new Xv({
                hash: this.hash,
                pers: t.pers,
                persEnc: t.persEnc || "utf8",
                entropy: t.entropy || a5(this.hash.hmacStrength),
                entropyEnc: (t.entropy && t.entropyEnc) || "utf8",
                nonce: this.n.toArray(),
            }),
            n = this.n.byteLength(),
            i = this.n.sub(new pe(2));
        ;

    ) {
        var s = new pe(r.generate(n))
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
}
Jr.prototype._truncateToN = function (t, r) {
    var n = t.byteLength() * 8 - this.n.bitLength()
    return n > 0 && (t = t.ushrn(n)), !r && t.cmp(this.n) >= 0 ? t.sub(this.n) : t
}
Jr.prototype.sign = function (t, r, n, i) {
    typeof n == "object" && ((i = n), (n = null)), i || (i = {}), (r = this.keyFromPrivate(r, n)), (t = this._truncateToN(new pe(t, 16)))
    for (
        var s = this.n.byteLength(),
            o = r.getPrivate().toArray("be", s),
            l = t.toArray("be", s),
            f = new Xv({ hash: this.hash, entropy: o, nonce: l, pers: i.pers, persEnc: i.persEnc || "utf8" }),
            d = this.n.sub(new pe(1)),
            h = 0;
        ;
        h++
    ) {
        var y = i.k ? i.k(h) : new pe(f.generate(this.n.byteLength()))
        if (((y = this._truncateToN(y, !0)), !(y.cmpn(1) <= 0 || y.cmp(d) >= 0))) {
            var E = this.g.mul(y)
            if (!E.isInfinity()) {
                var T = E.getX(),
                    S = T.umod(this.n)
                if (S.cmpn(0) !== 0) {
                    var N = y.invm(this.n).mul(S.mul(r.getPrivate()).iadd(t))
                    if (((N = N.umod(this.n)), N.cmpn(0) !== 0)) {
                        var P = (E.getY().isOdd() ? 1 : 0) | (T.cmp(S) !== 0 ? 2 : 0)
                        return i.canonical && N.cmp(this.nh) > 0 && ((N = this.n.sub(N)), (P ^= 1)), new ef({ r: S, s: N, recoveryParam: P })
                    }
                }
            }
        }
    }
}
Jr.prototype.verify = function (t, r, n, i) {
    ;(t = this._truncateToN(new pe(t, 16))), (n = this.keyFromPublic(n, i)), (r = new ef(r, "hex"))
    var s = r.r,
        o = r.s
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1
    var l = o.invm(this.n),
        f = l.mul(t).umod(this.n),
        d = l.mul(s).umod(this.n),
        h
    return this.curve._maxwellTrick
        ? ((h = this.g.jmulAdd(f, n.getPublic(), d)), h.isInfinity() ? !1 : h.eqXToP(s))
        : ((h = this.g.mulAdd(f, n.getPublic(), d)), h.isInfinity() ? !1 : h.getX().umod(this.n).cmp(s) === 0)
}
Jr.prototype.recoverPubKey = function (e, t, r, n) {
    Zv((3 & r) === r, "The recovery param is more than two bits"), (t = new ef(t, n))
    var i = this.n,
        s = new pe(e),
        o = t.r,
        l = t.s,
        f = r & 1,
        d = r >> 1
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d) throw new Error("Unable to find sencond key candinate")
    d ? (o = this.curve.pointFromX(o.add(this.curve.n), f)) : (o = this.curve.pointFromX(o, f))
    var h = t.r.invm(i),
        y = i.sub(s).mul(h).umod(i),
        E = l.mul(h).umod(i)
    return this.g.mulAdd(y, o, E)
}
Jr.prototype.getKeyRecoveryParam = function (e, t, r, n) {
    if (((t = new ef(t, n)), t.recoveryParam !== null)) return t.recoveryParam
    for (var i = 0; i < 4; i++) {
        var s
        try {
            s = this.recoverPubKey(e, t, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
}
var u5 = Go(function (e, t) {
        var r = t
        ;(r.version = "6.5.4"),
            (r.utils = Fr),
            (r.rand = function () {
                throw new Error("unsupported")
            }),
            (r.curve = ql),
            (r.curves = zl),
            (r.ec = l5),
            (r.eddsa = null)
    }),
    f5 = u5.ec
const c5 = "signing-key/5.7.0",
    $c = new ut(c5)
let Lf = null
function Sn() {
    return Lf || (Lf = new f5("secp256k1")), Lf
}
class d5 {
    constructor(t) {
        _t(this, "curve", "secp256k1"),
            _t(this, "privateKey", Lt(t)),
            Is(this.privateKey) !== 32 && $c.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]")
        const r = Sn().keyFromPrivate(Wt(this.privateKey))
        _t(this, "publicKey", "0x" + r.getPublic(!1, "hex")),
            _t(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")),
            _t(this, "_isSigningKey", !0)
    }
    _addPoint(t) {
        const r = Sn().keyFromPublic(Wt(this.publicKey)),
            n = Sn().keyFromPublic(Wt(t))
        return "0x" + r.pub.add(n.pub).encodeCompressed("hex")
    }
    signDigest(t) {
        const r = Sn().keyFromPrivate(Wt(this.privateKey)),
            n = Wt(t)
        n.length !== 32 && $c.throwArgumentError("bad digest length", "digest", t)
        const i = r.sign(n, { canonical: !0 })
        return Yu({ recoveryParam: i.recoveryParam, r: He("0x" + i.r.toString(16), 32), s: He("0x" + i.s.toString(16), 32) })
    }
    computeSharedSecret(t) {
        const r = Sn().keyFromPrivate(Wt(this.privateKey)),
            n = Sn().keyFromPublic(Wt(t1(t)))
        return He("0x" + r.derive(n.getPublic()).toString(16), 32)
    }
    static isSigningKey(t) {
        return !!(t && t._isSigningKey)
    }
}
function h5(e, t) {
    const r = Yu(t),
        n = { r: Wt(r.r), s: Wt(r.s) }
    return "0x" + Sn().recoverPubKey(Wt(e), n, r.recoveryParam).encode("hex", !1)
}
function t1(e, t) {
    const r = Wt(e)
    if (r.length === 32) {
        const n = new d5(r)
        return t ? "0x" + Sn().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey
    } else {
        if (r.length === 33) return t ? Lt(r) : "0x" + Sn().keyFromPublic(r).getPublic(!1, "hex")
        if (r.length === 65) return t ? "0x" + Sn().keyFromPublic(r).getPublic(!0, "hex") : Lt(r)
    }
    return $c.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const p5 = "transactions/5.7.0",
    yi = new ut(p5)
var K0
;(function (e) {
    ;(e[(e.legacy = 0)] = "legacy"), (e[(e.eip2930 = 1)] = "eip2930"), (e[(e.eip1559 = 2)] = "eip1559")
})(K0 || (K0 = {}))
function jd(e) {
    return e === "0x" ? null : rr(e)
}
function cr(e) {
    return e === "0x" ? gv : St.from(e)
}
function g5(e) {
    const t = t1(e)
    return rr(fr(Xe(fr(t, 1)), 12))
}
function e1(e, t) {
    return g5(h5(Wt(e), t))
}
function Mr(e, t) {
    const r = So(St.from(e).toHexString())
    return r.length > 32 && yi.throwArgumentError("invalid length for " + t, "transaction:" + t, e), r
}
function Df(e, t) {
    return {
        address: rr(e),
        storageKeys: (t || []).map(
            (r, n) => (Is(r) !== 32 && yi.throwArgumentError("invalid access list storageKey", `accessList[${e}:${n}]`, r), r.toLowerCase())
        ),
    }
}
function Wo(e) {
    if (Array.isArray(e))
        return e.map((r, n) =>
            Array.isArray(r)
                ? (r.length > 2 && yi.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r),
                  Df(r[0], r[1]))
                : Df(r.address, r.storageKeys)
        )
    const t = Object.keys(e).map((r) => {
        const n = e[r].reduce((i, s) => ((i[s] = !0), i), {})
        return Df(r, Object.keys(n).sort())
    })
    return t.sort((r, n) => r.address.localeCompare(n.address)), t
}
function r1(e) {
    return Wo(e).map((t) => [t.address, t.storageKeys])
}
function m5(e, t) {
    if (e.gasPrice != null) {
        const n = St.from(e.gasPrice),
            i = St.from(e.maxFeePerGas || 0)
        n.eq(i) || yi.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", { gasPrice: n, maxFeePerGas: i })
    }
    const r = [
        Mr(e.chainId || 0, "chainId"),
        Mr(e.nonce || 0, "nonce"),
        Mr(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        Mr(e.maxFeePerGas || 0, "maxFeePerGas"),
        Mr(e.gasLimit || 0, "gasLimit"),
        e.to != null ? rr(e.to) : "0x",
        Mr(e.value || 0, "value"),
        e.data || "0x",
        r1(e.accessList || []),
    ]
    if (t) {
        const n = Yu(t)
        r.push(Mr(n.recoveryParam, "recoveryParam")), r.push(So(n.r)), r.push(So(n.s))
    }
    return _r(["0x02", Ju(r)])
}
function v5(e, t) {
    const r = [
        Mr(e.chainId || 0, "chainId"),
        Mr(e.nonce || 0, "nonce"),
        Mr(e.gasPrice || 0, "gasPrice"),
        Mr(e.gasLimit || 0, "gasLimit"),
        e.to != null ? rr(e.to) : "0x",
        Mr(e.value || 0, "value"),
        e.data || "0x",
        r1(e.accessList || []),
    ]
    if (t) {
        const n = Yu(t)
        r.push(Mr(n.recoveryParam, "recoveryParam")), r.push(So(n.r)), r.push(So(n.s))
    }
    return _r(["0x01", Ju(r)])
}
function n1(e, t, r) {
    try {
        const n = cr(t[0]).toNumber()
        if (n !== 0 && n !== 1) throw new Error("bad recid")
        e.v = n
    } catch {
        yi.throwArgumentError("invalid v for transaction type: 1", "v", t[0])
    }
    ;(e.r = He(t[1], 32)), (e.s = He(t[2], 32))
    try {
        const n = Xe(r(e))
        e.from = e1(n, { r: e.r, s: e.s, recoveryParam: e.v })
    } catch {}
}
function b5(e) {
    const t = $d(e.slice(1))
    t.length !== 9 && t.length !== 12 && yi.throwArgumentError("invalid component count for transaction type: 2", "payload", Lt(e))
    const r = cr(t[2]),
        n = cr(t[3]),
        i = {
            type: 2,
            chainId: cr(t[0]).toNumber(),
            nonce: cr(t[1]).toNumber(),
            maxPriorityFeePerGas: r,
            maxFeePerGas: n,
            gasPrice: null,
            gasLimit: cr(t[4]),
            to: jd(t[5]),
            value: cr(t[6]),
            data: t[7],
            accessList: Wo(t[8]),
        }
    return t.length === 9 || ((i.hash = Xe(e)), n1(i, t.slice(9), m5)), i
}
function y5(e) {
    const t = $d(e.slice(1))
    t.length !== 8 && t.length !== 11 && yi.throwArgumentError("invalid component count for transaction type: 1", "payload", Lt(e))
    const r = {
        type: 1,
        chainId: cr(t[0]).toNumber(),
        nonce: cr(t[1]).toNumber(),
        gasPrice: cr(t[2]),
        gasLimit: cr(t[3]),
        to: jd(t[4]),
        value: cr(t[5]),
        data: t[6],
        accessList: Wo(t[7]),
    }
    return t.length === 8 || ((r.hash = Xe(e)), n1(r, t.slice(8), v5)), r
}
function _5(e) {
    const t = $d(e)
    t.length !== 9 && t.length !== 6 && yi.throwArgumentError("invalid raw transaction", "rawTransaction", e)
    const r = { nonce: cr(t[0]).toNumber(), gasPrice: cr(t[1]), gasLimit: cr(t[2]), to: jd(t[3]), value: cr(t[4]), data: t[5], chainId: 0 }
    if (t.length === 6) return r
    try {
        r.v = St.from(t[6]).toNumber()
    } catch {
        return r
    }
    if (((r.r = He(t[7], 32)), (r.s = He(t[8], 32)), St.from(r.r).isZero() && St.from(r.s).isZero())) (r.chainId = r.v), (r.v = 0)
    else {
        ;(r.chainId = Math.floor((r.v - 35) / 2)), r.chainId < 0 && (r.chainId = 0)
        let n = r.v - 27
        const i = t.slice(0, 6)
        r.chainId !== 0 && (i.push(Lt(r.chainId)), i.push("0x"), i.push("0x"), (n -= r.chainId * 2 + 8))
        const s = Xe(Ju(i))
        try {
            r.from = e1(s, { r: Lt(r.r), s: Lt(r.s), recoveryParam: n })
        } catch {}
        r.hash = Xe(e)
    }
    return (r.type = null), r
}
function w5(e) {
    const t = Wt(e)
    if (t[0] > 127) return _5(t)
    switch (t[0]) {
        case 1:
            return y5(t)
        case 2:
            return b5(t)
    }
    return yi.throwError(`unsupported transaction type: ${t[0]}`, ut.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: t[0],
    })
}
const A5 = "contracts/5.7.0"
var Wi =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const Se = new ut(A5),
    E5 = {
        chainId: !0,
        data: !0,
        from: !0,
        gasLimit: !0,
        gasPrice: !0,
        nonce: !0,
        to: !0,
        value: !0,
        type: !0,
        accessList: !0,
        maxFeePerGas: !0,
        maxPriorityFeePerGas: !0,
        customData: !0,
        ccipReadEnabled: !0,
    }
function vu(e, t) {
    return Wi(this, void 0, void 0, function* () {
        const r = yield t
        typeof r != "string" && Se.throwArgumentError("invalid address or ENS name", "name", r)
        try {
            return rr(r)
        } catch {}
        e || Se.throwError("a provider or signer is needed to resolve ENS names", ut.errors.UNSUPPORTED_OPERATION, { operation: "resolveName" })
        const n = yield e.resolveName(r)
        return n == null && Se.throwArgumentError("resolver or addr is not configured for ENS name", "name", r), n
    })
}
function Ca(e, t, r) {
    return Wi(this, void 0, void 0, function* () {
        return Array.isArray(r)
            ? yield Promise.all(r.map((n, i) => Ca(e, Array.isArray(t) ? t[i] : t[n.name], n)))
            : r.type === "address"
            ? yield vu(e, t)
            : r.type === "tuple"
            ? yield Ca(e, t, r.components)
            : r.baseType === "array"
            ? Array.isArray(t)
                ? yield Promise.all(t.map((n) => Ca(e, n, r.arrayChildren)))
                : Promise.reject(Se.makeError("invalid value for array", ut.errors.INVALID_ARGUMENT, { argument: "value", value: t }))
            : t
    })
}
function rf(e, t, r) {
    return Wi(this, void 0, void 0, function* () {
        let n = {}
        r.length === t.inputs.length + 1 && typeof r[r.length - 1] == "object" && (n = Ye(r.pop())),
            Se.checkArgumentCount(r.length, t.inputs.length, "passed to contract"),
            e.signer
                ? n.from
                    ? (n.from = Ge({ override: vu(e.signer, n.from), signer: e.signer.getAddress() }).then((d) =>
                          Wi(this, void 0, void 0, function* () {
                              return (
                                  rr(d.signer) !== d.override &&
                                      Se.throwError("Contract with a Signer cannot override from", ut.errors.UNSUPPORTED_OPERATION, {
                                          operation: "overrides.from",
                                      }),
                                  d.override
                              )
                          })
                      ))
                    : (n.from = e.signer.getAddress())
                : n.from && (n.from = vu(e.provider, n.from))
        const i = yield Ge({ args: Ca(e.signer || e.provider, r, t.inputs), address: e.resolvedAddress, overrides: Ge(n) || {} }),
            s = e.interface.encodeFunctionData(t, i.args),
            o = { data: s, to: i.address },
            l = i.overrides
        if (
            (l.nonce != null && (o.nonce = St.from(l.nonce).toNumber()),
            l.gasLimit != null && (o.gasLimit = St.from(l.gasLimit)),
            l.gasPrice != null && (o.gasPrice = St.from(l.gasPrice)),
            l.maxFeePerGas != null && (o.maxFeePerGas = St.from(l.maxFeePerGas)),
            l.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = St.from(l.maxPriorityFeePerGas)),
            l.from != null && (o.from = l.from),
            l.type != null && (o.type = l.type),
            l.accessList != null && (o.accessList = Wo(l.accessList)),
            o.gasLimit == null && t.gas != null)
        ) {
            let d = 21e3
            const h = Wt(s)
            for (let y = 0; y < h.length; y++) (d += 4), h[y] && (d += 64)
            o.gasLimit = St.from(t.gas).add(d)
        }
        if (l.value) {
            const d = St.from(l.value)
            !d.isZero() &&
                !t.payable &&
                Se.throwError("non-payable method cannot override value", ut.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: n.value,
                }),
                (o.value = d)
        }
        l.customData && (o.customData = Ye(l.customData)),
            l.ccipReadEnabled && (o.ccipReadEnabled = !!l.ccipReadEnabled),
            delete n.nonce,
            delete n.gasLimit,
            delete n.gasPrice,
            delete n.from,
            delete n.value,
            delete n.type,
            delete n.accessList,
            delete n.maxFeePerGas,
            delete n.maxPriorityFeePerGas,
            delete n.customData,
            delete n.ccipReadEnabled
        const f = Object.keys(n).filter((d) => n[d] != null)
        return (
            f.length &&
                Se.throwError(`cannot override ${f.map((d) => JSON.stringify(d)).join(",")}`, ut.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides",
                    overrides: f,
                }),
            o
        )
    })
}
function x5(e, t) {
    return function (...r) {
        return rf(e, t, r)
    }
}
function T5(e, t) {
    const r = e.signer || e.provider
    return function (...n) {
        return Wi(this, void 0, void 0, function* () {
            r || Se.throwError("estimate require a provider or signer", ut.errors.UNSUPPORTED_OPERATION, { operation: "estimateGas" })
            const i = yield rf(e, t, n)
            return yield r.estimateGas(i)
        })
    }
}
function i1(e, t) {
    const r = t.wait.bind(t)
    t.wait = (n) =>
        r(n).then(
            (i) => (
                (i.events = i.logs.map((s) => {
                    let o = fi(s),
                        l = null
                    try {
                        l = e.interface.parseLog(s)
                    } catch {}
                    return (
                        l &&
                            ((o.args = l.args),
                            (o.decode = (f, d) => e.interface.decodeEventLog(l.eventFragment, f, d)),
                            (o.event = l.name),
                            (o.eventSignature = l.signature)),
                        (o.removeListener = () => e.provider),
                        (o.getBlock = () => e.provider.getBlock(i.blockHash)),
                        (o.getTransaction = () => e.provider.getTransaction(i.transactionHash)),
                        (o.getTransactionReceipt = () => Promise.resolve(i)),
                        o
                    )
                })),
                i
            )
        )
}
function s1(e, t, r) {
    const n = e.signer || e.provider
    return function (...i) {
        return Wi(this, void 0, void 0, function* () {
            let s
            if (i.length === t.inputs.length + 1 && typeof i[i.length - 1] == "object") {
                const f = Ye(i.pop())
                f.blockTag != null && (s = yield f.blockTag), delete f.blockTag, i.push(f)
            }
            e.deployTransaction != null && (yield e._deployed(s))
            const o = yield rf(e, t, i),
                l = yield n.call(o, s)
            try {
                let f = e.interface.decodeFunctionResult(t, l)
                return r && t.outputs.length === 1 && (f = f[0]), f
            } catch (f) {
                throw (f.code === ut.errors.CALL_EXCEPTION && ((f.address = e.address), (f.args = i), (f.transaction = o)), f)
            }
        })
    }
}
function C5(e, t) {
    return function (...r) {
        return Wi(this, void 0, void 0, function* () {
            e.signer ||
                Se.throwError("sending a transaction requires a signer", ut.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction" }),
                e.deployTransaction != null && (yield e._deployed())
            const n = yield rf(e, t, r),
                i = yield e.signer.sendTransaction(n)
            return i1(e, i), i
        })
    }
}
function G0(e, t, r) {
    return t.constant ? s1(e, t, r) : C5(e, t)
}
function o1(e) {
    return e.address && (e.topics == null || e.topics.length === 0)
        ? "*"
        : (e.address || "*") + "@" + (e.topics ? e.topics.map((t) => (Array.isArray(t) ? t.join("|") : t)).join(":") : "")
}
class Ha {
    constructor(t, r) {
        _t(this, "tag", t), _t(this, "filter", r), (this._listeners = [])
    }
    addListener(t, r) {
        this._listeners.push({ listener: t, once: r })
    }
    removeListener(t) {
        let r = !1
        this._listeners = this._listeners.filter((n) => (r || n.listener !== t ? !0 : ((r = !0), !1)))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map((t) => t.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(t) {
        const r = this.listenerCount()
        return (
            (this._listeners = this._listeners.filter((n) => {
                const i = t.slice()
                return (
                    setTimeout(() => {
                        n.listener.apply(this, i)
                    }, 0),
                    !n.once
                )
            })),
            r
        )
    }
    prepareEvent(t) {}
    getEmit(t) {
        return [t]
    }
}
class M5 extends Ha {
    constructor() {
        super("error", null)
    }
}
class W0 extends Ha {
    constructor(t, r, n, i) {
        const s = { address: t }
        let o = r.getEventTopic(n)
        i ? (o !== i[0] && Se.throwArgumentError("topic mismatch", "topics", i), (s.topics = i.slice())) : (s.topics = [o]),
            super(o1(s), s),
            _t(this, "address", t),
            _t(this, "interface", r),
            _t(this, "fragment", n)
    }
    prepareEvent(t) {
        super.prepareEvent(t),
            (t.event = this.fragment.name),
            (t.eventSignature = this.fragment.format()),
            (t.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n))
        try {
            t.args = this.interface.decodeEventLog(this.fragment, t.data, t.topics)
        } catch (r) {
            ;(t.args = null), (t.decodeError = r)
        }
    }
    getEmit(t) {
        const r = fE(t.args)
        if (r.length) throw r[0].error
        const n = (t.args || []).slice()
        return n.push(t), n
    }
}
class Y0 extends Ha {
    constructor(t, r) {
        super("*", { address: t }), _t(this, "address", t), _t(this, "interface", r)
    }
    prepareEvent(t) {
        super.prepareEvent(t)
        try {
            const r = this.interface.parseLog(t)
            ;(t.event = r.name),
                (t.eventSignature = r.signature),
                (t.decode = (n, i) => this.interface.decodeEventLog(r.eventFragment, n, i)),
                (t.args = r.args)
        } catch {}
    }
}
class S5 {
    constructor(t, r, n) {
        _t(this, "interface", Ir(new.target, "getInterface")(r)),
            n == null
                ? (_t(this, "provider", null), _t(this, "signer", null))
                : qo.isSigner(n)
                ? (_t(this, "provider", n.provider || null), _t(this, "signer", n))
                : Xu.isProvider(n)
                ? (_t(this, "provider", n), _t(this, "signer", null))
                : Se.throwArgumentError("invalid signer or provider", "signerOrProvider", n),
            _t(this, "callStatic", {}),
            _t(this, "estimateGas", {}),
            _t(this, "functions", {}),
            _t(this, "populateTransaction", {}),
            _t(this, "filters", {})
        {
            const o = {}
            Object.keys(this.interface.events).forEach((l) => {
                const f = this.interface.events[l]
                _t(this.filters, l, (...d) => ({ address: this.address, topics: this.interface.encodeFilterTopics(f, d) })),
                    o[f.name] || (o[f.name] = []),
                    o[f.name].push(l)
            }),
                Object.keys(o).forEach((l) => {
                    const f = o[l]
                    f.length === 1 ? _t(this.filters, l, this.filters[f[0]]) : Se.warn(`Duplicate definition of ${l} (${f.join(", ")})`)
                })
        }
        if (
            (_t(this, "_runningEvents", {}),
            _t(this, "_wrappedEmits", {}),
            t == null && Se.throwArgumentError("invalid contract address or ENS name", "addressOrName", t),
            _t(this, "address", t),
            this.provider)
        )
            _t(this, "resolvedAddress", vu(this.provider, t))
        else
            try {
                _t(this, "resolvedAddress", Promise.resolve(rr(t)))
            } catch {
                Se.throwError("provider is required to use ENS name as contract address", ut.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract",
                })
            }
        this.resolvedAddress.catch((o) => {})
        const i = {},
            s = {}
        Object.keys(this.interface.functions).forEach((o) => {
            const l = this.interface.functions[o]
            if (s[o]) {
                Se.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`)
                return
            }
            s[o] = !0
            {
                const f = l.name
                i[`%${f}`] || (i[`%${f}`] = []), i[`%${f}`].push(o)
            }
            this[o] == null && _t(this, o, G0(this, l, !0)),
                this.functions[o] == null && _t(this.functions, o, G0(this, l, !1)),
                this.callStatic[o] == null && _t(this.callStatic, o, s1(this, l, !0)),
                this.populateTransaction[o] == null && _t(this.populateTransaction, o, x5(this, l)),
                this.estimateGas[o] == null && _t(this.estimateGas, o, T5(this, l))
        }),
            Object.keys(i).forEach((o) => {
                const l = i[o]
                if (l.length > 1) return
                o = o.substring(1)
                const f = l[0]
                try {
                    this[o] == null && _t(this, o, this[f])
                } catch {}
                this.functions[o] == null && _t(this.functions, o, this.functions[f]),
                    this.callStatic[o] == null && _t(this.callStatic, o, this.callStatic[f]),
                    this.populateTransaction[o] == null && _t(this.populateTransaction, o, this.populateTransaction[f]),
                    this.estimateGas[o] == null && _t(this.estimateGas, o, this.estimateGas[f])
            })
    }
    static getContractAddress(t) {
        return Vd(t)
    }
    static getInterface(t) {
        return Bc.isInterface(t) ? t : new Bc(t)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(t) {
        return (
            this._deployedPromise ||
                (this.deployTransaction
                    ? (this._deployedPromise = this.deployTransaction.wait().then(() => this))
                    : (this._deployedPromise = this.provider
                          .getCode(this.address, t)
                          .then(
                              (r) => (
                                  r === "0x" &&
                                      Se.throwError("contract not deployed", ut.errors.UNSUPPORTED_OPERATION, {
                                          contractAddress: this.address,
                                          operation: "getDeployed",
                                      }),
                                  this
                              )
                          ))),
            this._deployedPromise
        )
    }
    fallback(t) {
        this.signer ||
            Se.throwError("sending a transactions require a signer", ut.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" })
        const r = Ye(t || {})
        return (
            ["from", "to"].forEach(function (n) {
                r[n] != null && Se.throwError("cannot override " + n, ut.errors.UNSUPPORTED_OPERATION, { operation: n })
            }),
            (r.to = this.resolvedAddress),
            this.deployed().then(() => this.signer.sendTransaction(r))
        )
    }
    connect(t) {
        typeof t == "string" && (t = new Ud(t, this.provider))
        const r = new this.constructor(this.address, this.interface, t)
        return this.deployTransaction && _t(r, "deployTransaction", this.deployTransaction), r
    }
    attach(t) {
        return new this.constructor(t, this.interface, this.signer || this.provider)
    }
    static isIndexed(t) {
        return Ic.isIndexed(t)
    }
    _normalizeRunningEvent(t) {
        return this._runningEvents[t.tag] ? this._runningEvents[t.tag] : t
    }
    _getRunningEvent(t) {
        if (typeof t == "string") {
            if (t === "error") return this._normalizeRunningEvent(new M5())
            if (t === "event") return this._normalizeRunningEvent(new Ha("event", null))
            if (t === "*") return this._normalizeRunningEvent(new Y0(this.address, this.interface))
            const r = this.interface.getEvent(t)
            return this._normalizeRunningEvent(new W0(this.address, this.interface, r))
        }
        if (t.topics && t.topics.length > 0) {
            try {
                const n = t.topics[0]
                if (typeof n != "string") throw new Error("invalid topic")
                const i = this.interface.getEvent(n)
                return this._normalizeRunningEvent(new W0(this.address, this.interface, i, t.topics))
            } catch {}
            const r = { address: this.address, topics: t.topics }
            return this._normalizeRunningEvent(new Ha(o1(r), r))
        }
        return this._normalizeRunningEvent(new Y0(this.address, this.interface))
    }
    _checkRunningEvents(t) {
        if (t.listenerCount() === 0) {
            delete this._runningEvents[t.tag]
            const r = this._wrappedEmits[t.tag]
            r && t.filter && (this.provider.off(t.filter, r), delete this._wrappedEmits[t.tag])
        }
    }
    _wrapEvent(t, r, n) {
        const i = fi(r)
        return (
            (i.removeListener = () => {
                !n || (t.removeListener(n), this._checkRunningEvents(t))
            }),
            (i.getBlock = () => this.provider.getBlock(r.blockHash)),
            (i.getTransaction = () => this.provider.getTransaction(r.transactionHash)),
            (i.getTransactionReceipt = () => this.provider.getTransactionReceipt(r.transactionHash)),
            t.prepareEvent(i),
            i
        )
    }
    _addEventListener(t, r, n) {
        if (
            (this.provider ||
                Se.throwError("events require a provider or a signer with a provider", ut.errors.UNSUPPORTED_OPERATION, { operation: "once" }),
            t.addListener(r, n),
            (this._runningEvents[t.tag] = t),
            !this._wrappedEmits[t.tag])
        ) {
            const i = (s) => {
                let o = this._wrapEvent(t, s, r)
                if (o.decodeError == null)
                    try {
                        const l = t.getEmit(o)
                        this.emit(t.filter, ...l)
                    } catch (l) {
                        o.decodeError = l.error
                    }
                t.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o)
            }
            ;(this._wrappedEmits[t.tag] = i), t.filter != null && this.provider.on(t.filter, i)
        }
    }
    queryFilter(t, r, n) {
        const i = this._getRunningEvent(t),
            s = Ye(i.filter)
        return (
            typeof r == "string" && Te(r, 32)
                ? (n != null && Se.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), (s.blockHash = r))
                : ((s.fromBlock = r != null ? r : 0), (s.toBlock = n != null ? n : "latest")),
            this.provider.getLogs(s).then((o) => o.map((l) => this._wrapEvent(i, l, null)))
        )
    }
    on(t, r) {
        return this._addEventListener(this._getRunningEvent(t), r, !1), this
    }
    once(t, r) {
        return this._addEventListener(this._getRunningEvent(t), r, !0), this
    }
    emit(t, ...r) {
        if (!this.provider) return !1
        const n = this._getRunningEvent(t),
            i = n.run(r) > 0
        return this._checkRunningEvents(n), i
    }
    listenerCount(t) {
        return this.provider
            ? t == null
                ? Object.keys(this._runningEvents).reduce((r, n) => r + this._runningEvents[n].listenerCount(), 0)
                : this._getRunningEvent(t).listenerCount()
            : 0
    }
    listeners(t) {
        if (!this.provider) return []
        if (t == null) {
            const r = []
            for (let n in this._runningEvents)
                this._runningEvents[n].listeners().forEach((i) => {
                    r.push(i)
                })
            return r
        }
        return this._getRunningEvent(t).listeners()
    }
    removeAllListeners(t) {
        if (!this.provider) return this
        if (t == null) {
            for (const n in this._runningEvents) {
                const i = this._runningEvents[n]
                i.removeAllListeners(), this._checkRunningEvents(i)
            }
            return this
        }
        const r = this._getRunningEvent(t)
        return r.removeAllListeners(), this._checkRunningEvents(r), this
    }
    off(t, r) {
        if (!this.provider) return this
        const n = this._getRunningEvent(t)
        return n.removeListener(r), this._checkRunningEvents(n), this
    }
    removeListener(t, r) {
        return this.off(t, r)
    }
}
class Fc extends S5 {}
class k5 {
    constructor(t, r, n) {
        let i = null
        typeof r == "string" ? (i = r) : rl(r) ? (i = Lt(r)) : r && typeof r.object == "string" ? (i = r.object) : (i = "!"),
            i.substring(0, 2) !== "0x" && (i = "0x" + i),
            (!Te(i) || i.length % 2) && Se.throwArgumentError("invalid bytecode", "bytecode", r),
            n && !qo.isSigner(n) && Se.throwArgumentError("invalid signer", "signer", n),
            _t(this, "bytecode", i),
            _t(this, "interface", Ir(new.target, "getInterface")(t)),
            _t(this, "signer", n || null)
    }
    getDeployTransaction(...t) {
        let r = {}
        if (t.length === this.interface.deploy.inputs.length + 1 && typeof t[t.length - 1] == "object") {
            r = Ye(t.pop())
            for (const n in r) if (!E5[n]) throw new Error("unknown transaction override " + n)
        }
        return (
            ["data", "from", "to"].forEach((n) => {
                r[n] != null && Se.throwError("cannot override " + n, ut.errors.UNSUPPORTED_OPERATION, { operation: n })
            }),
            r.value &&
                !St.from(r.value).isZero() &&
                !this.interface.deploy.payable &&
                Se.throwError("non-payable constructor cannot override value", ut.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: r.value,
                }),
            Se.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor"),
            (r.data = Lt(Ar([this.bytecode, this.interface.encodeDeploy(t)]))),
            r
        )
    }
    deploy(...t) {
        return Wi(this, void 0, void 0, function* () {
            let r = {}
            t.length === this.interface.deploy.inputs.length + 1 && (r = t.pop()),
                Se.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor")
            const n = yield Ca(this.signer, t, this.interface.deploy.inputs)
            n.push(r)
            const i = this.getDeployTransaction(...n),
                s = yield this.signer.sendTransaction(i),
                o = Ir(this.constructor, "getContractAddress")(s),
                l = Ir(this.constructor, "getContract")(o, this.interface, this.signer)
            return i1(l, s), _t(l, "deployTransaction", s), l
        })
    }
    attach(t) {
        return this.constructor.getContract(t, this.interface, this.signer)
    }
    connect(t) {
        return new this.constructor(this.interface, this.bytecode, t)
    }
    static fromSolidity(t, r) {
        t == null && Se.throwError("missing compiler output", ut.errors.MISSING_ARGUMENT, { argument: "compilerOutput" }),
            typeof t == "string" && (t = JSON.parse(t))
        const n = t.abi
        let i = null
        return t.bytecode ? (i = t.bytecode) : t.evm && t.evm.bytecode && (i = t.evm.bytecode), new this(n, i, r)
    }
    static getInterface(t) {
        return Fc.getInterface(t)
    }
    static getContractAddress(t) {
        return Vd(t)
    }
    static getContract(t, r, n) {
        return new Fc(t, r, n)
    }
}
class a1 {
    constructor(t) {
        _t(this, "alphabet", t), _t(this, "base", t.length), _t(this, "_alphabetMap", {}), _t(this, "_leader", t.charAt(0))
        for (let r = 0; r < t.length; r++) this._alphabetMap[t.charAt(r)] = r
    }
    encode(t) {
        let r = Wt(t)
        if (r.length === 0) return ""
        let n = [0]
        for (let s = 0; s < r.length; ++s) {
            let o = r[s]
            for (let l = 0; l < n.length; ++l) (o += n[l] << 8), (n[l] = o % this.base), (o = (o / this.base) | 0)
            for (; o > 0; ) n.push(o % this.base), (o = (o / this.base) | 0)
        }
        let i = ""
        for (let s = 0; r[s] === 0 && s < r.length - 1; ++s) i += this._leader
        for (let s = n.length - 1; s >= 0; --s) i += this.alphabet[n[s]]
        return i
    }
    decode(t) {
        if (typeof t != "string") throw new TypeError("Expected String")
        let r = []
        if (t.length === 0) return new Uint8Array(r)
        r.push(0)
        for (let n = 0; n < t.length; n++) {
            let i = this._alphabetMap[t[n]]
            if (i === void 0) throw new Error("Non-base" + this.base + " character")
            let s = i
            for (let o = 0; o < r.length; ++o) (s += r[o] * this.base), (r[o] = s & 255), (s >>= 8)
            for (; s > 0; ) r.push(s & 255), (s >>= 8)
        }
        for (let n = 0; t[n] === this._leader && n < t.length - 1; ++n) r.push(0)
        return Wt(new Uint8Array(r.reverse()))
    }
}
new a1("abcdefghijklmnopqrstuvwxyz234567")
const Vc = new a1("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    N5 = "sha2/5.7.0"
new ut(N5)
function J0(e) {
    return "0x" + Tn.sha256().update(Wt(e)).digest("hex")
}
const O5 = "networks/5.7.0",
    Q0 = new ut(O5)
function I5(e) {
    return e && typeof e.renetwork == "function"
}
function Pi(e) {
    const t = function (r, n) {
        n == null && (n = {})
        const i = []
        if (r.InfuraProvider && n.infura !== "-")
            try {
                i.push(new r.InfuraProvider(e, n.infura))
            } catch {}
        if (r.EtherscanProvider && n.etherscan !== "-")
            try {
                i.push(new r.EtherscanProvider(e, n.etherscan))
            } catch {}
        if (r.AlchemyProvider && n.alchemy !== "-")
            try {
                i.push(new r.AlchemyProvider(e, n.alchemy))
            } catch {}
        if (r.PocketProvider && n.pocket !== "-") {
            const s = ["goerli", "ropsten", "rinkeby"]
            try {
                const o = new r.PocketProvider(e, n.pocket)
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        }
        if (r.CloudflareProvider && n.cloudflare !== "-")
            try {
                i.push(new r.CloudflareProvider(e))
            } catch {}
        if (r.AnkrProvider && n.ankr !== "-")
            try {
                const s = ["ropsten"],
                    o = new r.AnkrProvider(e, n.ankr)
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        if (i.length === 0) return null
        if (r.FallbackProvider) {
            let s = 1
            return n.quorum != null ? (s = n.quorum) : e === "homestead" && (s = 2), new r.FallbackProvider(i, s)
        }
        return i[0]
    }
    return (
        (t.renetwork = function (r) {
            return Pi(r)
        }),
        t
    )
}
function bu(e, t) {
    const r = function (n, i) {
        return n.JsonRpcProvider ? new n.JsonRpcProvider(e, t) : null
    }
    return (
        (r.renetwork = function (n) {
            return bu(e, n)
        }),
        r
    )
}
const X0 = { chainId: 1, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "homestead", _defaultProvider: Pi("homestead") },
    Z0 = { chainId: 3, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "ropsten", _defaultProvider: Pi("ropsten") },
    tp = { chainId: 63, name: "classicMordor", _defaultProvider: bu("https://www.ethercluster.com/mordor", "classicMordor") },
    Ml = {
        unspecified: { chainId: 0, name: "unspecified" },
        homestead: X0,
        mainnet: X0,
        morden: { chainId: 2, name: "morden" },
        ropsten: Z0,
        testnet: Z0,
        rinkeby: { chainId: 4, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "rinkeby", _defaultProvider: Pi("rinkeby") },
        kovan: { chainId: 42, name: "kovan", _defaultProvider: Pi("kovan") },
        goerli: { chainId: 5, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "goerli", _defaultProvider: Pi("goerli") },
        kintsugi: { chainId: 1337702, name: "kintsugi" },
        classic: { chainId: 61, name: "classic", _defaultProvider: bu("https://www.ethercluster.com/etc", "classic") },
        classicMorden: { chainId: 62, name: "classicMorden" },
        classicMordor: tp,
        classicTestnet: tp,
        classicKotti: { chainId: 6, name: "classicKotti", _defaultProvider: bu("https://www.ethercluster.com/kotti", "classicKotti") },
        xdai: { chainId: 100, name: "xdai" },
        matic: { chainId: 137, name: "matic", _defaultProvider: Pi("matic") },
        maticmum: { chainId: 80001, name: "maticmum" },
        optimism: { chainId: 10, name: "optimism", _defaultProvider: Pi("optimism") },
        "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
        "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
        arbitrum: { chainId: 42161, name: "arbitrum" },
        "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
        "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
        bnb: { chainId: 56, name: "bnb" },
        bnbt: { chainId: 97, name: "bnbt" },
    }
function B5(e) {
    if (e == null) return null
    if (typeof e == "number") {
        for (const n in Ml) {
            const i = Ml[n]
            if (i.chainId === e)
                return { name: i.name, chainId: i.chainId, ensAddress: i.ensAddress || null, _defaultProvider: i._defaultProvider || null }
        }
        return { chainId: e, name: "unknown" }
    }
    if (typeof e == "string") {
        const n = Ml[e]
        return n == null ? null : { name: n.name, chainId: n.chainId, ensAddress: n.ensAddress, _defaultProvider: n._defaultProvider || null }
    }
    const t = Ml[e.name]
    if (!t) return typeof e.chainId != "number" && Q0.throwArgumentError("invalid network chainId", "network", e), e
    e.chainId !== 0 && e.chainId !== t.chainId && Q0.throwArgumentError("network chainId mismatch", "network", e)
    let r = e._defaultProvider || null
    return (
        r == null && t._defaultProvider && (I5(t._defaultProvider) ? (r = t._defaultProvider.renetwork(e)) : (r = t._defaultProvider)),
        { name: e.name, chainId: t.chainId, ensAddress: e.ensAddress || t.ensAddress || null, _defaultProvider: r }
    )
}
const P5 = "web/5.7.0"
var R5 =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
function L5(e, t) {
    return R5(this, void 0, void 0, function* () {
        t == null && (t = {})
        const r = { method: t.method || "GET", headers: t.headers || {}, body: t.body || void 0 }
        if (
            (t.skipFetchSetup !== !0 &&
                ((r.mode = "cors"), (r.cache = "no-cache"), (r.credentials = "same-origin"), (r.redirect = "follow"), (r.referrer = "client")),
            t.fetchOptions != null)
        ) {
            const o = t.fetchOptions
            o.mode && (r.mode = o.mode),
                o.cache && (r.cache = o.cache),
                o.credentials && (r.credentials = o.credentials),
                o.redirect && (r.redirect = o.redirect),
                o.referrer && (r.referrer = o.referrer)
        }
        const n = yield fetch(e, r),
            i = yield n.arrayBuffer(),
            s = {}
        return (
            n.headers.forEach
                ? n.headers.forEach((o, l) => {
                      s[l.toLowerCase()] = o
                  })
                : n.headers.keys().forEach((o) => {
                      s[o.toLowerCase()] = n.headers.get(o)
                  }),
            { headers: s, statusCode: n.status, statusMessage: n.statusText, body: Wt(new Uint8Array(i)) }
        )
    })
}
var D5 =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const on = new ut(P5)
function ep(e) {
    return new Promise((t) => {
        setTimeout(t, e)
    })
}
function Ci(e, t) {
    if (e == null) return null
    if (typeof e == "string") return e
    if (Pd(e)) {
        if (t && (t.split("/")[0] === "text" || t.split(";")[0].trim() === "application/json"))
            try {
                return sl(e)
            } catch {}
        return Lt(e)
    }
    return e
}
function $5(e, t, r) {
    const n = typeof e == "object" && e.throttleLimit != null ? e.throttleLimit : 12
    on.assertArgument(n > 0 && n % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", n)
    const i = typeof e == "object" ? e.throttleCallback : null,
        s = typeof e == "object" && typeof e.throttleSlotInterval == "number" ? e.throttleSlotInterval : 100
    on.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s)
    const o = typeof e == "object" ? !!e.errorPassThrough : !1,
        l = {}
    let f = null
    const d = { method: "GET" }
    let h = !1,
        y = 2 * 60 * 1e3
    if (typeof e == "string") f = e
    else if (typeof e == "object") {
        if (
            ((e == null || e.url == null) && on.throwArgumentError("missing URL", "connection.url", e),
            (f = e.url),
            typeof e.timeout == "number" && e.timeout > 0 && (y = e.timeout),
            e.headers)
        )
            for (const M in e.headers)
                (l[M.toLowerCase()] = { key: M, value: String(e.headers[M]) }),
                    ["if-none-match", "if-modified-since"].indexOf(M.toLowerCase()) >= 0 && (h = !0)
        if (((d.allowGzip = !!e.allowGzip), e.user != null && e.password != null)) {
            f.substring(0, 6) !== "https:" &&
                e.allowInsecureAuthentication !== !0 &&
                on.throwError("basic authentication requires a secure https url", ut.errors.INVALID_ARGUMENT, {
                    argument: "url",
                    url: f,
                    user: e.user,
                    password: "[REDACTED]",
                })
            const M = e.user + ":" + e.password
            l.authorization = { key: "Authorization", value: "Basic " + wv(ci(M)) }
        }
        e.skipFetchSetup != null && (d.skipFetchSetup = !!e.skipFetchSetup), e.fetchOptions != null && (d.fetchOptions = Ye(e.fetchOptions))
    }
    const E = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
        T = f ? f.match(E) : null
    if (T)
        try {
            const M = { statusCode: 200, statusMessage: "OK", headers: { "content-type": T[1] }, body: _v(T[2]) }
            let k = M.body
            return r && (k = r(M.body, M)), Promise.resolve(k)
        } catch (M) {
            on.throwError("processing response error", ut.errors.SERVER_ERROR, {
                body: Ci(T[1], T[2]),
                error: M,
                requestBody: null,
                requestMethod: "GET",
                url: f,
            })
        }
    t &&
        ((d.method = "POST"),
        (d.body = t),
        l["content-type"] == null && (l["content-type"] = { key: "Content-Type", value: "application/octet-stream" }),
        l["content-length"] == null && (l["content-length"] = { key: "Content-Length", value: String(t.length) }))
    const S = {}
    Object.keys(l).forEach((M) => {
        const k = l[M]
        S[k.key] = k.value
    }),
        (d.headers = S)
    const N = (function () {
            let M = null
            return {
                promise: new Promise(function ($, R) {
                    y &&
                        (M = setTimeout(() => {
                            M != null &&
                                ((M = null),
                                R(
                                    on.makeError("timeout", ut.errors.TIMEOUT, {
                                        requestBody: Ci(d.body, S["content-type"]),
                                        requestMethod: d.method,
                                        timeout: y,
                                        url: f,
                                    })
                                ))
                        }, y))
                }),
                cancel: function () {
                    M != null && (clearTimeout(M), (M = null))
                },
            }
        })(),
        P = (function () {
            return D5(this, void 0, void 0, function* () {
                for (let M = 0; M < n; M++) {
                    let k = null
                    try {
                        if (((k = yield L5(f, d)), M < n)) {
                            if (k.statusCode === 301 || k.statusCode === 302) {
                                const $ = k.headers.location || ""
                                if (d.method === "GET" && $.match(/^https:/)) {
                                    f = k.headers.location
                                    continue
                                }
                            } else if (k.statusCode === 429) {
                                let $ = !0
                                if ((i && ($ = yield i(M, f)), $)) {
                                    let R = 0
                                    const W = k.headers["retry-after"]
                                    typeof W == "string" && W.match(/^[1-9][0-9]*$/)
                                        ? (R = parseInt(W) * 1e3)
                                        : (R = s * parseInt(String(Math.random() * Math.pow(2, M)))),
                                        yield ep(R)
                                    continue
                                }
                            }
                        }
                    } catch ($) {
                        ;(k = $.response),
                            k == null &&
                                (N.cancel(),
                                on.throwError("missing response", ut.errors.SERVER_ERROR, {
                                    requestBody: Ci(d.body, S["content-type"]),
                                    requestMethod: d.method,
                                    serverError: $,
                                    url: f,
                                }))
                    }
                    let F = k.body
                    if (
                        (h && k.statusCode === 304
                            ? (F = null)
                            : !o &&
                              (k.statusCode < 200 || k.statusCode >= 300) &&
                              (N.cancel(),
                              on.throwError("bad response", ut.errors.SERVER_ERROR, {
                                  status: k.statusCode,
                                  headers: k.headers,
                                  body: Ci(F, k.headers ? k.headers["content-type"] : null),
                                  requestBody: Ci(d.body, S["content-type"]),
                                  requestMethod: d.method,
                                  url: f,
                              })),
                        r)
                    )
                        try {
                            const $ = yield r(F, k)
                            return N.cancel(), $
                        } catch ($) {
                            if ($.throttleRetry && M < n) {
                                let R = !0
                                if ((i && (R = yield i(M, f)), R)) {
                                    const W = s * parseInt(String(Math.random() * Math.pow(2, M)))
                                    yield ep(W)
                                    continue
                                }
                            }
                            N.cancel(),
                                on.throwError("processing response error", ut.errors.SERVER_ERROR, {
                                    body: Ci(F, k.headers ? k.headers["content-type"] : null),
                                    error: $,
                                    requestBody: Ci(d.body, S["content-type"]),
                                    requestMethod: d.method,
                                    url: f,
                                })
                        }
                    return N.cancel(), F
                }
                return on.throwError("failed response", ut.errors.SERVER_ERROR, {
                    requestBody: Ci(d.body, S["content-type"]),
                    requestMethod: d.method,
                    url: f,
                })
            })
        })()
    return Promise.race([N.promise, P])
}
function Kd(e, t, r) {
    let n = (s, o) => {
            let l = null
            if (s != null)
                try {
                    l = JSON.parse(sl(s))
                } catch (f) {
                    on.throwError("invalid JSON", ut.errors.SERVER_ERROR, { body: s, error: f })
                }
            return r && (l = r(l, o)), l
        },
        i = null
    if (t != null) {
        i = ci(t)
        const s = typeof e == "string" ? { url: e } : Ye(e)
        s.headers
            ? Object.keys(s.headers).filter((l) => l.toLowerCase() === "content-type").length !== 0 ||
              ((s.headers = Ye(s.headers)), (s.headers["content-type"] = "application/json"))
            : (s.headers = { "content-type": "application/json" }),
            (e = s)
    }
    return $5(e, i, n)
}
function pa(e, t) {
    return (
        t || (t = {}),
        (t = Ye(t)),
        t.floor == null && (t.floor = 0),
        t.ceiling == null && (t.ceiling = 1e4),
        t.interval == null && (t.interval = 250),
        new Promise(function (r, n) {
            let i = null,
                s = !1
            const o = () => (s ? !1 : ((s = !0), i && clearTimeout(i), !0))
            t.timeout &&
                (i = setTimeout(() => {
                    o() && n(new Error("timeout"))
                }, t.timeout))
            const l = t.retryLimit
            let f = 0
            function d() {
                return e().then(
                    function (h) {
                        if (h !== void 0) o() && r(h)
                        else if (t.oncePoll) t.oncePoll.once("poll", d)
                        else if (t.onceBlock) t.onceBlock.once("block", d)
                        else if (!s) {
                            if ((f++, f > l)) {
                                o() && n(new Error("retry limit reached"))
                                return
                            }
                            let y = t.interval * parseInt(String(Math.random() * Math.pow(2, f)))
                            y < t.floor && (y = t.floor), y > t.ceiling && (y = t.ceiling), setTimeout(d, y)
                        }
                        return null
                    },
                    function (h) {
                        o() && n(h)
                    }
                )
            }
            d()
        })
    )
}
var yu = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
    Uc = {}
for (var Sl = 0; Sl < yu.length; Sl++) {
    var $f = yu.charAt(Sl)
    if (Uc[$f] !== void 0) throw new TypeError($f + " is ambiguous")
    Uc[$f] = Sl
}
function yo(e) {
    var t = e >> 25
    return (
        ((e & 33554431) << 5) ^
        (-((t >> 0) & 1) & 996825010) ^
        (-((t >> 1) & 1) & 642813549) ^
        (-((t >> 2) & 1) & 513874426) ^
        (-((t >> 3) & 1) & 1027748829) ^
        (-((t >> 4) & 1) & 705979059)
    )
}
function l1(e) {
    for (var t = 1, r = 0; r < e.length; ++r) {
        var n = e.charCodeAt(r)
        if (n < 33 || n > 126) return "Invalid prefix (" + e + ")"
        t = yo(t) ^ (n >> 5)
    }
    for (t = yo(t), r = 0; r < e.length; ++r) {
        var i = e.charCodeAt(r)
        t = yo(t) ^ (i & 31)
    }
    return t
}
function F5(e, t, r) {
    if (((r = r || 90), e.length + 7 + t.length > r)) throw new TypeError("Exceeds length limit")
    e = e.toLowerCase()
    var n = l1(e)
    if (typeof n == "string") throw new Error(n)
    for (var i = e + "1", s = 0; s < t.length; ++s) {
        var o = t[s]
        if (o >> 5 !== 0) throw new Error("Non 5-bit word")
        ;(n = yo(n) ^ o), (i += yu.charAt(o))
    }
    for (s = 0; s < 6; ++s) n = yo(n)
    for (n ^= 1, s = 0; s < 6; ++s) {
        var l = (n >> ((5 - s) * 5)) & 31
        i += yu.charAt(l)
    }
    return i
}
function u1(e, t) {
    if (((t = t || 90), e.length < 8)) return e + " too short"
    if (e.length > t) return "Exceeds length limit"
    var r = e.toLowerCase(),
        n = e.toUpperCase()
    if (e !== r && e !== n) return "Mixed-case string " + e
    e = r
    var i = e.lastIndexOf("1")
    if (i === -1) return "No separator character for " + e
    if (i === 0) return "Missing prefix for " + e
    var s = e.slice(0, i),
        o = e.slice(i + 1)
    if (o.length < 6) return "Data too short"
    var l = l1(s)
    if (typeof l == "string") return l
    for (var f = [], d = 0; d < o.length; ++d) {
        var h = o.charAt(d),
            y = Uc[h]
        if (y === void 0) return "Unknown character " + h
        ;(l = yo(l) ^ y), !(d + 6 >= o.length) && f.push(y)
    }
    return l !== 1 ? "Invalid checksum for " + e : { prefix: s, words: f }
}
function V5() {
    var e = u1.apply(null, arguments)
    if (typeof e == "object") return e
}
function U5(e) {
    var t = u1.apply(null, arguments)
    if (typeof t == "object") return t
    throw new Error(t)
}
function nf(e, t, r, n) {
    for (var i = 0, s = 0, o = (1 << r) - 1, l = [], f = 0; f < e.length; ++f)
        for (i = (i << t) | e[f], s += t; s >= r; ) (s -= r), l.push((i >> s) & o)
    if (n) s > 0 && l.push((i << (r - s)) & o)
    else {
        if (s >= t) return "Excess padding"
        if ((i << (r - s)) & o) return "Non-zero padding"
    }
    return l
}
function H5(e) {
    var t = nf(e, 8, 5, !0)
    if (Array.isArray(t)) return t
}
function q5(e) {
    var t = nf(e, 8, 5, !0)
    if (Array.isArray(t)) return t
    throw new Error(t)
}
function z5(e) {
    var t = nf(e, 5, 8, !1)
    if (Array.isArray(t)) return t
}
function j5(e) {
    var t = nf(e, 5, 8, !1)
    if (Array.isArray(t)) return t
    throw new Error(t)
}
var rp = { decodeUnsafe: V5, decode: U5, encode: F5, toWordsUnsafe: H5, toWords: q5, fromWordsUnsafe: z5, fromWords: j5 }
const al = "providers/5.7.0",
    oa = new ut(al)
class Pt {
    constructor() {
        this.formats = this.getDefaultFormats()
    }
    getDefaultFormats() {
        const t = {},
            r = this.address.bind(this),
            n = this.bigNumber.bind(this),
            i = this.blockTag.bind(this),
            s = this.data.bind(this),
            o = this.hash.bind(this),
            l = this.hex.bind(this),
            f = this.number.bind(this),
            d = this.type.bind(this),
            h = (y) => this.data(y, !0)
        return (
            (t.transaction = {
                hash: o,
                type: d,
                accessList: Pt.allowNull(this.accessList.bind(this), null),
                blockHash: Pt.allowNull(o, null),
                blockNumber: Pt.allowNull(f, null),
                transactionIndex: Pt.allowNull(f, null),
                confirmations: Pt.allowNull(f, null),
                from: r,
                gasPrice: Pt.allowNull(n),
                maxPriorityFeePerGas: Pt.allowNull(n),
                maxFeePerGas: Pt.allowNull(n),
                gasLimit: n,
                to: Pt.allowNull(r, null),
                value: n,
                nonce: f,
                data: s,
                r: Pt.allowNull(this.uint256),
                s: Pt.allowNull(this.uint256),
                v: Pt.allowNull(f),
                creates: Pt.allowNull(r, null),
                raw: Pt.allowNull(s),
            }),
            (t.transactionRequest = {
                from: Pt.allowNull(r),
                nonce: Pt.allowNull(f),
                gasLimit: Pt.allowNull(n),
                gasPrice: Pt.allowNull(n),
                maxPriorityFeePerGas: Pt.allowNull(n),
                maxFeePerGas: Pt.allowNull(n),
                to: Pt.allowNull(r),
                value: Pt.allowNull(n),
                data: Pt.allowNull(h),
                type: Pt.allowNull(f),
                accessList: Pt.allowNull(this.accessList.bind(this), null),
            }),
            (t.receiptLog = {
                transactionIndex: f,
                blockNumber: f,
                transactionHash: o,
                address: r,
                topics: Pt.arrayOf(o),
                data: s,
                logIndex: f,
                blockHash: o,
            }),
            (t.receipt = {
                to: Pt.allowNull(this.address, null),
                from: Pt.allowNull(this.address, null),
                contractAddress: Pt.allowNull(r, null),
                transactionIndex: f,
                root: Pt.allowNull(l),
                gasUsed: n,
                logsBloom: Pt.allowNull(s),
                blockHash: o,
                transactionHash: o,
                logs: Pt.arrayOf(this.receiptLog.bind(this)),
                blockNumber: f,
                confirmations: Pt.allowNull(f, null),
                cumulativeGasUsed: n,
                effectiveGasPrice: Pt.allowNull(n),
                status: Pt.allowNull(f),
                type: d,
            }),
            (t.block = {
                hash: Pt.allowNull(o),
                parentHash: o,
                number: f,
                timestamp: f,
                nonce: Pt.allowNull(l),
                difficulty: this.difficulty.bind(this),
                gasLimit: n,
                gasUsed: n,
                miner: Pt.allowNull(r),
                extraData: s,
                transactions: Pt.allowNull(Pt.arrayOf(o)),
                baseFeePerGas: Pt.allowNull(n),
            }),
            (t.blockWithTransactions = Ye(t.block)),
            (t.blockWithTransactions.transactions = Pt.allowNull(Pt.arrayOf(this.transactionResponse.bind(this)))),
            (t.filter = {
                fromBlock: Pt.allowNull(i, void 0),
                toBlock: Pt.allowNull(i, void 0),
                blockHash: Pt.allowNull(o, void 0),
                address: Pt.allowNull(r, void 0),
                topics: Pt.allowNull(this.topics.bind(this), void 0),
            }),
            (t.filterLog = {
                blockNumber: Pt.allowNull(f),
                blockHash: Pt.allowNull(o),
                transactionIndex: f,
                removed: Pt.allowNull(this.boolean.bind(this)),
                address: r,
                data: Pt.allowFalsish(s, "0x"),
                topics: Pt.arrayOf(o),
                transactionHash: o,
                logIndex: f,
            }),
            t
        )
    }
    accessList(t) {
        return Wo(t || [])
    }
    number(t) {
        return t === "0x" ? 0 : St.from(t).toNumber()
    }
    type(t) {
        return t === "0x" || t == null ? 0 : St.from(t).toNumber()
    }
    bigNumber(t) {
        return St.from(t)
    }
    boolean(t) {
        if (typeof t == "boolean") return t
        if (typeof t == "string") {
            if (((t = t.toLowerCase()), t === "true")) return !0
            if (t === "false") return !1
        }
        throw new Error("invalid boolean - " + t)
    }
    hex(t, r) {
        return typeof t == "string" && (!r && t.substring(0, 2) !== "0x" && (t = "0x" + t), Te(t))
            ? t.toLowerCase()
            : oa.throwArgumentError("invalid hash", "value", t)
    }
    data(t, r) {
        const n = this.hex(t, r)
        if (n.length % 2 !== 0) throw new Error("invalid data; odd-length - " + t)
        return n
    }
    address(t) {
        return rr(t)
    }
    callAddress(t) {
        if (!Te(t, 32)) return null
        const r = rr(fr(t, 12))
        return r === xE ? null : r
    }
    contractAddress(t) {
        return Vd(t)
    }
    blockTag(t) {
        if (t == null) return "latest"
        if (t === "earliest") return "0x0"
        switch (t) {
            case "earliest":
                return "0x0"
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return t
        }
        if (typeof t == "number" || Te(t)) return Rd(t)
        throw new Error("invalid blockTag")
    }
    hash(t, r) {
        const n = this.hex(t, r)
        return Is(n) !== 32 ? oa.throwArgumentError("invalid hash", "value", t) : n
    }
    difficulty(t) {
        if (t == null) return null
        const r = St.from(t)
        try {
            return r.toNumber()
        } catch {}
        return null
    }
    uint256(t) {
        if (!Te(t)) throw new Error("invalid uint256")
        return He(t, 32)
    }
    _block(t, r) {
        t.author != null && t.miner == null && (t.miner = t.author)
        const n = t._difficulty != null ? t._difficulty : t.difficulty,
            i = Pt.check(r, t)
        return (i._difficulty = n == null ? null : St.from(n)), i
    }
    block(t) {
        return this._block(t, this.formats.block)
    }
    blockWithTransactions(t) {
        return this._block(t, this.formats.blockWithTransactions)
    }
    transactionRequest(t) {
        return Pt.check(this.formats.transactionRequest, t)
    }
    transactionResponse(t) {
        t.gas != null && t.gasLimit == null && (t.gasLimit = t.gas),
            t.to && St.from(t.to).isZero() && (t.to = "0x0000000000000000000000000000000000000000"),
            t.input != null && t.data == null && (t.data = t.input),
            t.to == null && t.creates == null && (t.creates = this.contractAddress(t)),
            (t.type === 1 || t.type === 2) && t.accessList == null && (t.accessList = [])
        const r = Pt.check(this.formats.transaction, t)
        if (t.chainId != null) {
            let n = t.chainId
            Te(n) && (n = St.from(n).toNumber()), (r.chainId = n)
        } else {
            let n = t.networkId
            n == null && r.v == null && (n = t.chainId),
                Te(n) && (n = St.from(n).toNumber()),
                typeof n != "number" && r.v != null && ((n = (r.v - 35) / 2), n < 0 && (n = 0), (n = parseInt(n))),
                typeof n != "number" && (n = 0),
                (r.chainId = n)
        }
        return r.blockHash && r.blockHash.replace(/0/g, "") === "x" && (r.blockHash = null), r
    }
    transaction(t) {
        return w5(t)
    }
    receiptLog(t) {
        return Pt.check(this.formats.receiptLog, t)
    }
    receipt(t) {
        const r = Pt.check(this.formats.receipt, t)
        if (r.root != null)
            if (r.root.length <= 4) {
                const n = St.from(r.root).toNumber()
                n === 0 || n === 1
                    ? (r.status != null &&
                          r.status !== n &&
                          oa.throwArgumentError("alt-root-status/status mismatch", "value", { root: r.root, status: r.status }),
                      (r.status = n),
                      delete r.root)
                    : oa.throwArgumentError("invalid alt-root-status", "value.root", r.root)
            } else r.root.length !== 66 && oa.throwArgumentError("invalid root hash", "value.root", r.root)
        return r.status != null && (r.byzantium = !0), r
    }
    topics(t) {
        return Array.isArray(t) ? t.map((r) => this.topics(r)) : t != null ? this.hash(t, !0) : null
    }
    filter(t) {
        return Pt.check(this.formats.filter, t)
    }
    filterLog(t) {
        return Pt.check(this.formats.filterLog, t)
    }
    static check(t, r) {
        const n = {}
        for (const i in t)
            try {
                const s = t[i](r[i])
                s !== void 0 && (n[i] = s)
            } catch (s) {
                throw ((s.checkKey = i), (s.checkValue = r[i]), s)
            }
        return n
    }
    static allowNull(t, r) {
        return function (n) {
            return n == null ? r : t(n)
        }
    }
    static allowFalsish(t, r) {
        return function (n) {
            return n ? t(n) : r
        }
    }
    static arrayOf(t) {
        return function (r) {
            if (!Array.isArray(r)) throw new Error("not an array")
            const n = []
            return (
                r.forEach(function (i) {
                    n.push(t(i))
                }),
                n
            )
        }
    }
}
var de =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const me = new ut(al),
    K5 = 10
function np(e) {
    return e == null ? "null" : (Is(e) !== 32 && me.throwArgumentError("invalid topic", "topic", e), e.toLowerCase())
}
function ip(e) {
    for (e = e.slice(); e.length > 0 && e[e.length - 1] == null; ) e.pop()
    return e
        .map((t) => {
            if (Array.isArray(t)) {
                const r = {}
                t.forEach((i) => {
                    r[np(i)] = !0
                })
                const n = Object.keys(r)
                return n.sort(), n.join("|")
            } else return np(t)
        })
        .join("&")
}
function G5(e) {
    return e === ""
        ? []
        : e.split(/&/g).map((t) => {
              if (t === "") return []
              const r = t.split("|").map((n) => (n === "null" ? null : n))
              return r.length === 1 ? r[0] : r
          })
}
function Js(e) {
    if (typeof e == "string") {
        if (((e = e.toLowerCase()), Is(e) === 32)) return "tx:" + e
        if (e.indexOf(":") === -1) return e
    } else {
        if (Array.isArray(e)) return "filter:*:" + ip(e)
        if (Tx.isForkEvent(e)) throw (me.warn("not implemented"), new Error("not implemented"))
        if (e && typeof e == "object") return "filter:" + (e.address || "*") + ":" + ip(e.topics || [])
    }
    throw new Error("invalid event - " + e)
}
function aa() {
    return new Date().getTime()
}
function sp(e) {
    return new Promise((t) => {
        setTimeout(t, e)
    })
}
const W5 = ["block", "network", "pending", "poll"]
class Y5 {
    constructor(t, r, n) {
        _t(this, "tag", t), _t(this, "listener", r), _t(this, "once", n), (this._lastBlockNumber = -2), (this._inflight = !1)
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash
            case "filter":
                return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const t = this.tag.split(":")
        return t[0] !== "tx" ? null : t[1]
    }
    get filter() {
        const t = this.tag.split(":")
        if (t[0] !== "filter") return null
        const r = t[1],
            n = G5(t[2]),
            i = {}
        return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || W5.indexOf(this.tag) >= 0
    }
}
const J5 = {
    0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
    60: { symbol: "eth", ilk: "eth" },
    61: { symbol: "etc", ilk: "eth" },
    700: { symbol: "xdai", ilk: "eth" },
}
function Ff(e) {
    return He(St.from(e).toHexString(), 32)
}
function op(e) {
    return Vc.encode(Ar([e, fr(J0(J0(e)), 0, 4)]))
}
const f1 = new RegExp("^(ipfs)://(.*)$", "i"),
    ap = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), f1, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")]
function jl(e, t) {
    try {
        return sl(qa(e, t))
    } catch {}
    return null
}
function qa(e, t) {
    if (e === "0x") return null
    const r = St.from(fr(e, t, t + 32)).toNumber(),
        n = St.from(fr(e, r, r + 32)).toNumber()
    return fr(e, r + 32, r + 32 + n)
}
function Vf(e) {
    return (
        e.match(/^ipfs:\/\/ipfs\//i)
            ? (e = e.substring(12))
            : e.match(/^ipfs:\/\//i)
            ? (e = e.substring(7))
            : me.throwArgumentError("unsupported IPFS format", "link", e),
        `https://gateway.ipfs.io/ipfs/${e}`
    )
}
function lp(e) {
    const t = Wt(e)
    if (t.length > 32) throw new Error("internal; should not happen")
    const r = new Uint8Array(32)
    return r.set(t, 32 - t.length), r
}
function Q5(e) {
    if (e.length % 32 === 0) return e
    const t = new Uint8Array(Math.ceil(e.length / 32) * 32)
    return t.set(e), t
}
function c1(e) {
    const t = []
    let r = 0
    for (let n = 0; n < e.length; n++) t.push(null), (r += 32)
    for (let n = 0; n < e.length; n++) {
        const i = Wt(e[n])
        ;(t[n] = lp(r)), t.push(lp(i.length)), t.push(Q5(i)), (r += 32 + Math.ceil(i.length / 32) * 32)
    }
    return _r(t)
}
class up {
    constructor(t, r, n, i) {
        _t(this, "provider", t), _t(this, "name", n), _t(this, "address", t.formatter.address(r)), _t(this, "_resolvedAddress", i)
    }
    supportsWildcard() {
        return (
            this._supportsEip2544 ||
                (this._supportsEip2544 = this.provider
                    .call({ to: this.address, data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000" })
                    .then((t) => St.from(t).eq(1))
                    .catch((t) => {
                        if (t.code === ut.errors.CALL_EXCEPTION) return !1
                        throw ((this._supportsEip2544 = null), t)
                    })),
            this._supportsEip2544
        )
    }
    _fetch(t, r) {
        return de(this, void 0, void 0, function* () {
            const n = { to: this.address, ccipReadEnabled: !0, data: _r([t, Hl(this.name), r || "0x"]) }
            let i = !1
            ;(yield this.supportsWildcard()) && ((i = !0), (n.data = _r(["0x9061b923", c1([fx(this.name), n.data])])))
            try {
                let s = yield this.provider.call(n)
                return (
                    Wt(s).length % 32 === 4 && me.throwError("resolver threw error", ut.errors.CALL_EXCEPTION, { transaction: n, data: s }),
                    i && (s = qa(s, 0)),
                    s
                )
            } catch (s) {
                if (s.code === ut.errors.CALL_EXCEPTION) return null
                throw s
            }
        })
    }
    _fetchBytes(t, r) {
        return de(this, void 0, void 0, function* () {
            const n = yield this._fetch(t, r)
            return n != null ? qa(n, 0) : null
        })
    }
    _getAddress(t, r) {
        const n = J5[String(t)]
        if (
            (n == null && me.throwError(`unsupported coin type: ${t}`, ut.errors.UNSUPPORTED_OPERATION, { operation: `getAddress(${t})` }),
            n.ilk === "eth")
        )
            return this.provider.formatter.address(r)
        const i = Wt(r)
        if (n.p2pkh != null) {
            const s = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/)
            if (s) {
                const o = parseInt(s[1], 16)
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return op(Ar([[n.p2pkh], "0x" + s[2]]))
            }
        }
        if (n.p2sh != null) {
            const s = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/)
            if (s) {
                const o = parseInt(s[1], 16)
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return op(Ar([[n.p2sh], "0x" + s[2]]))
            }
        }
        if (n.prefix != null) {
            const s = i[1]
            let o = i[0]
            if ((o === 0 ? s !== 20 && s !== 32 && (o = -1) : (o = -1), o >= 0 && i.length === 2 + s && s >= 1 && s <= 75)) {
                const l = rp.toWords(i.slice(2))
                return l.unshift(o), rp.encode(n.prefix, l)
            }
        }
        return null
    }
    getAddress(t) {
        return de(this, void 0, void 0, function* () {
            if ((t == null && (t = 60), t === 60))
                try {
                    const i = yield this._fetch("0x3b3b57de")
                    return i === "0x" || i === SE ? null : this.provider.formatter.callAddress(i)
                } catch (i) {
                    if (i.code === ut.errors.CALL_EXCEPTION) return null
                    throw i
                }
            const r = yield this._fetchBytes("0xf1cb7e06", Ff(t))
            if (r == null || r === "0x") return null
            const n = this._getAddress(t, r)
            return (
                n == null &&
                    me.throwError("invalid or unsupported coin data", ut.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${t})`,
                        coinType: t,
                        data: r,
                    }),
                n
            )
        })
    }
    getAvatar() {
        return de(this, void 0, void 0, function* () {
            const t = [{ type: "name", content: this.name }]
            try {
                const r = yield this.getText("avatar")
                if (r == null) return null
                for (let n = 0; n < ap.length; n++) {
                    const i = r.match(ap[n])
                    if (i == null) continue
                    const s = i[1].toLowerCase()
                    switch (s) {
                        case "https":
                            return t.push({ type: "url", content: r }), { linkage: t, url: r }
                        case "data":
                            return t.push({ type: "data", content: r }), { linkage: t, url: r }
                        case "ipfs":
                            return t.push({ type: "ipfs", content: r }), { linkage: t, url: Vf(r) }
                        case "erc721":
                        case "erc1155": {
                            const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c"
                            t.push({ type: s, content: r })
                            const l = this._resolvedAddress || (yield this.getAddress()),
                                f = (i[2] || "").split("/")
                            if (f.length !== 2) return null
                            const d = yield this.provider.formatter.address(f[0]),
                                h = He(St.from(f[1]).toHexString(), 32)
                            if (s === "erc721") {
                                const N = this.provider.formatter.callAddress(yield this.provider.call({ to: d, data: _r(["0x6352211e", h]) }))
                                if (l !== N) return null
                                t.push({ type: "owner", content: N })
                            } else if (s === "erc1155") {
                                const N = St.from(yield this.provider.call({ to: d, data: _r(["0x00fdd58e", He(l, 32), h]) }))
                                if (N.isZero()) return null
                                t.push({ type: "balance", content: N.toString() })
                            }
                            const y = { to: this.provider.formatter.address(f[0]), data: _r([o, h]) }
                            let E = jl(yield this.provider.call(y), 0)
                            if (E == null) return null
                            t.push({ type: "metadata-url-base", content: E }),
                                s === "erc1155" &&
                                    ((E = E.replace("{id}", h.substring(2))), t.push({ type: "metadata-url-expanded", content: E })),
                                E.match(/^ipfs:/i) && (E = Vf(E)),
                                t.push({ type: "metadata-url", content: E })
                            const T = yield Kd(E)
                            if (!T) return null
                            t.push({ type: "metadata", content: JSON.stringify(T) })
                            let S = T.image
                            if (typeof S != "string") return null
                            if (!S.match(/^(https:\/\/|data:)/i)) {
                                if (S.match(f1) == null) return null
                                t.push({ type: "url-ipfs", content: S }), (S = Vf(S))
                            }
                            return t.push({ type: "url", content: S }), { linkage: t, url: S }
                        }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return de(this, void 0, void 0, function* () {
            const t = yield this._fetchBytes("0xbc1c58d1")
            if (t == null || t === "0x") return null
            const r = t.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/)
            if (r) {
                const o = parseInt(r[3], 16)
                if (r[4].length === o * 2) return "ipfs://" + Vc.encode("0x" + r[1])
            }
            const n = t.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/)
            if (n) {
                const o = parseInt(n[3], 16)
                if (n[4].length === o * 2) return "ipns://" + Vc.encode("0x" + n[1])
            }
            const i = t.match(/^0xe40101fa011b20([0-9a-f]*)$/)
            if (i && i[1].length === 32 * 2) return "bzz://" + i[1]
            const s = t.match(/^0x90b2c605([0-9a-f]*)$/)
            if (s && s[1].length === 34 * 2) {
                const o = { "=": "", "+": "-", "/": "_" },
                    l = wv("0x" + s[1]).replace(/[=+\/]/g, (f) => o[f])
                return "sia://" + l
            }
            return me.throwError("invalid or unsupported content hash data", ut.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: t,
            })
        })
    }
    getText(t) {
        return de(this, void 0, void 0, function* () {
            let r = ci(t)
            ;(r = Ar([Ff(64), Ff(r.length), r])), r.length % 32 !== 0 && (r = Ar([r, He("0x", 32 - (t.length % 32))]))
            const n = yield this._fetchBytes("0x59d1d43c", Lt(r))
            return n == null || n === "0x" ? null : sl(n)
        })
    }
}
let Uf = null,
    X5 = 1
class Z5 extends Xu {
    constructor(t) {
        if (
            (super(),
            (this._events = []),
            (this._emitted = { block: -2 }),
            (this.disableCcipRead = !1),
            (this.formatter = new.target.getFormatter()),
            _t(this, "anyNetwork", t === "any"),
            this.anyNetwork && (t = this.detectNetwork()),
            t instanceof Promise)
        )
            (this._networkPromise = t), t.catch((r) => {}), this._ready().catch((r) => {})
        else {
            const r = Ir(new.target, "getNetwork")(t)
            r ? (_t(this, "_network", r), this.emit("network", r, null)) : me.throwArgumentError("invalid network", "network", t)
        }
        ;(this._maxInternalBlockNumber = -1024),
            (this._lastBlockNumber = -2),
            (this._maxFilterBlockRange = 10),
            (this._pollingInterval = 4e3),
            (this._fastQueryDate = 0)
    }
    _ready() {
        return de(this, void 0, void 0, function* () {
            if (this._network == null) {
                let t = null
                if (this._networkPromise)
                    try {
                        t = yield this._networkPromise
                    } catch {}
                t == null && (t = yield this.detectNetwork()),
                    t || me.throwError("no network detected", ut.errors.UNKNOWN_ERROR, {}),
                    this._network == null && (this.anyNetwork ? (this._network = t) : _t(this, "_network", t), this.emit("network", t, null))
            }
            return this._network
        })
    }
    get ready() {
        return pa(() =>
            this._ready().then(
                (t) => t,
                (t) => {
                    if (!(t.code === ut.errors.NETWORK_ERROR && t.event === "noNetwork")) throw t
                }
            )
        )
    }
    static getFormatter() {
        return Uf == null && (Uf = new Pt()), Uf
    }
    static getNetwork(t) {
        return B5(t == null ? "homestead" : t)
    }
    ccipReadFetch(t, r, n) {
        return de(this, void 0, void 0, function* () {
            if (this.disableCcipRead || n.length === 0) return null
            const i = t.to.toLowerCase(),
                s = r.toLowerCase(),
                o = []
            for (let l = 0; l < n.length; l++) {
                const f = n[l],
                    d = f.replace("{sender}", i).replace("{data}", s),
                    h = f.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: s, sender: i }),
                    y = yield Kd({ url: d, errorPassThrough: !0 }, h, (T, S) => ((T.status = S.statusCode), T))
                if (y.data) return y.data
                const E = y.message || "unknown error"
                if (y.status >= 400 && y.status < 500)
                    return me.throwError(`response not found during CCIP fetch: ${E}`, ut.errors.SERVER_ERROR, { url: f, errorMessage: E })
                o.push(E)
            }
            return me.throwError(`error encountered during CCIP fetch: ${o.map((l) => JSON.stringify(l)).join(", ")}`, ut.errors.SERVER_ERROR, {
                urls: n,
                errorMessages: o,
            })
        })
    }
    _getInternalBlockNumber(t) {
        return de(this, void 0, void 0, function* () {
            if ((yield this._ready(), t > 0))
                for (; this._internalBlockNumber; ) {
                    const i = this._internalBlockNumber
                    try {
                        const s = yield i
                        if (aa() - s.respTime <= t) return s.blockNumber
                        break
                    } catch {
                        if (this._internalBlockNumber === i) break
                    }
                }
            const r = aa(),
                n = Ge({
                    blockNumber: this.perform("getBlockNumber", {}),
                    networkError: this.getNetwork().then(
                        (i) => null,
                        (i) => i
                    ),
                }).then(({ blockNumber: i, networkError: s }) => {
                    if (s) throw (this._internalBlockNumber === n && (this._internalBlockNumber = null), s)
                    const o = aa()
                    return (
                        (i = St.from(i).toNumber()),
                        i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber),
                        (this._maxInternalBlockNumber = i),
                        this._setFastBlockNumber(i),
                        { blockNumber: i, reqTime: r, respTime: o }
                    )
                })
            return (
                (this._internalBlockNumber = n),
                n.catch((i) => {
                    this._internalBlockNumber === n && (this._internalBlockNumber = null)
                }),
                (yield n).blockNumber
            )
        })
    }
    poll() {
        return de(this, void 0, void 0, function* () {
            const t = X5++,
                r = []
            let n = null
            try {
                n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (i) {
                this.emit("error", i)
                return
            }
            if ((this._setFastBlockNumber(n), this.emit("poll", t, n), n === this._lastBlockNumber)) {
                this.emit("didPoll", t)
                return
            }
            if ((this._emitted.block === -2 && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3))
                me.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`),
                    this.emit(
                        "error",
                        me.makeError("network block skew detected", ut.errors.NETWORK_ERROR, {
                            blockNumber: n,
                            event: "blockSkew",
                            previousBlockNumber: this._emitted.block,
                        })
                    ),
                    this.emit("block", n)
            else for (let i = this._emitted.block + 1; i <= n; i++) this.emit("block", i)
            this._emitted.block !== n &&
                ((this._emitted.block = n),
                Object.keys(this._emitted).forEach((i) => {
                    if (i === "block") return
                    const s = this._emitted[i]
                    s !== "pending" && n - s > 12 && delete this._emitted[i]
                })),
                this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1),
                this._events.forEach((i) => {
                    switch (i.type) {
                        case "tx": {
                            const s = i.hash
                            let o = this.getTransactionReceipt(s)
                                .then((l) => (!l || l.blockNumber == null || ((this._emitted["t:" + s] = l.blockNumber), this.emit(s, l)), null))
                                .catch((l) => {
                                    this.emit("error", l)
                                })
                            r.push(o)
                            break
                        }
                        case "filter": {
                            if (!i._inflight) {
                                ;(i._inflight = !0), i._lastBlockNumber === -2 && (i._lastBlockNumber = n - 1)
                                const s = i.filter
                                ;(s.fromBlock = i._lastBlockNumber + 1), (s.toBlock = n)
                                const o = s.toBlock - this._maxFilterBlockRange
                                o > s.fromBlock && (s.fromBlock = o), s.fromBlock < 0 && (s.fromBlock = 0)
                                const l = this.getLogs(s)
                                    .then((f) => {
                                        ;(i._inflight = !1),
                                            f.length !== 0 &&
                                                f.forEach((d) => {
                                                    d.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = d.blockNumber),
                                                        (this._emitted["b:" + d.blockHash] = d.blockNumber),
                                                        (this._emitted["t:" + d.transactionHash] = d.blockNumber),
                                                        this.emit(s, d)
                                                })
                                    })
                                    .catch((f) => {
                                        this.emit("error", f), (i._inflight = !1)
                                    })
                                r.push(l)
                            }
                            break
                        }
                    }
                }),
                (this._lastBlockNumber = n),
                Promise.all(r)
                    .then(() => {
                        this.emit("didPoll", t)
                    })
                    .catch((i) => {
                        this.emit("error", i)
                    })
        })
    }
    resetEventsBlock(t) {
        ;(this._lastBlockNumber = t - 1), this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return de(this, void 0, void 0, function* () {
            return me.throwError("provider does not support network detection", ut.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork",
            })
        })
    }
    getNetwork() {
        return de(this, void 0, void 0, function* () {
            const t = yield this._ready(),
                r = yield this.detectNetwork()
            if (t.chainId !== r.chainId) {
                if (this.anyNetwork)
                    return (
                        (this._network = r),
                        (this._lastBlockNumber = -2),
                        (this._fastBlockNumber = null),
                        (this._fastBlockNumberPromise = null),
                        (this._fastQueryDate = 0),
                        (this._emitted.block = -2),
                        (this._maxInternalBlockNumber = -1024),
                        (this._internalBlockNumber = null),
                        this.emit("network", r, t),
                        yield sp(0),
                        this._network
                    )
                const n = me.makeError("underlying network changed", ut.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: t,
                    detectedNetwork: r,
                })
                throw (this.emit("error", n), n)
            }
            return t
        })
    }
    get blockNumber() {
        return (
            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
                (t) => {
                    this._setFastBlockNumber(t)
                },
                (t) => {}
            ),
            this._fastBlockNumber != null ? this._fastBlockNumber : -1
        )
    }
    get polling() {
        return this._poller != null
    }
    set polling(t) {
        t && !this._poller
            ? ((this._poller = setInterval(() => {
                  this.poll()
              }, this.pollingInterval)),
              this._bootstrapPoll ||
                  (this._bootstrapPoll = setTimeout(() => {
                      this.poll(),
                          (this._bootstrapPoll = setTimeout(() => {
                              this._poller || this.poll(), (this._bootstrapPoll = null)
                          }, this.pollingInterval))
                  }, 0)))
            : !t && this._poller && (clearInterval(this._poller), (this._poller = null))
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(t) {
        if (typeof t != "number" || t <= 0 || parseInt(String(t)) != t) throw new Error("invalid polling interval")
        ;(this._pollingInterval = t),
            this._poller &&
                (clearInterval(this._poller),
                (this._poller = setInterval(() => {
                    this.poll()
                }, this._pollingInterval)))
    }
    _getFastBlockNumber() {
        const t = aa()
        return (
            t - this._fastQueryDate > 2 * this._pollingInterval &&
                ((this._fastQueryDate = t),
                (this._fastBlockNumberPromise = this.getBlockNumber().then(
                    (r) => ((this._fastBlockNumber == null || r > this._fastBlockNumber) && (this._fastBlockNumber = r), this._fastBlockNumber)
                ))),
            this._fastBlockNumberPromise
        )
    }
    _setFastBlockNumber(t) {
        ;(this._fastBlockNumber != null && t < this._fastBlockNumber) ||
            ((this._fastQueryDate = aa()),
            (this._fastBlockNumber == null || t > this._fastBlockNumber) &&
                ((this._fastBlockNumber = t), (this._fastBlockNumberPromise = Promise.resolve(t))))
    }
    waitForTransaction(t, r, n) {
        return de(this, void 0, void 0, function* () {
            return this._waitForTransaction(t, r == null ? 1 : r, n || 0, null)
        })
    }
    _waitForTransaction(t, r, n, i) {
        return de(this, void 0, void 0, function* () {
            const s = yield this.getTransactionReceipt(t)
            return (s ? s.confirmations : 0) >= r
                ? s
                : new Promise((o, l) => {
                      const f = []
                      let d = !1
                      const h = function () {
                              return d
                                  ? !0
                                  : ((d = !0),
                                    f.forEach((E) => {
                                        E()
                                    }),
                                    !1)
                          },
                          y = (E) => {
                              E.confirmations < r || h() || o(E)
                          }
                      if (
                          (this.on(t, y),
                          f.push(() => {
                              this.removeListener(t, y)
                          }),
                          i)
                      ) {
                          let E = i.startBlock,
                              T = null
                          const S = (N) =>
                              de(this, void 0, void 0, function* () {
                                  d ||
                                      (yield sp(1e3),
                                      this.getTransactionCount(i.from).then(
                                          (P) =>
                                              de(this, void 0, void 0, function* () {
                                                  if (!d) {
                                                      if (P <= i.nonce) E = N
                                                      else {
                                                          {
                                                              const M = yield this.getTransaction(t)
                                                              if (M && M.blockNumber != null) return
                                                          }
                                                          for (T == null && ((T = E - 3), T < i.startBlock && (T = i.startBlock)); T <= N; ) {
                                                              if (d) return
                                                              const M = yield this.getBlockWithTransactions(T)
                                                              for (let k = 0; k < M.transactions.length; k++) {
                                                                  const F = M.transactions[k]
                                                                  if (F.hash === t) return
                                                                  if (F.from === i.from && F.nonce === i.nonce) {
                                                                      if (d) return
                                                                      const $ = yield this.waitForTransaction(F.hash, r)
                                                                      if (h()) return
                                                                      let R = "replaced"
                                                                      F.data === i.data && F.to === i.to && F.value.eq(i.value)
                                                                          ? (R = "repriced")
                                                                          : F.data === "0x" &&
                                                                            F.from === F.to &&
                                                                            F.value.isZero() &&
                                                                            (R = "cancelled"),
                                                                          l(
                                                                              me.makeError(
                                                                                  "transaction was replaced",
                                                                                  ut.errors.TRANSACTION_REPLACED,
                                                                                  {
                                                                                      cancelled: R === "replaced" || R === "cancelled",
                                                                                      reason: R,
                                                                                      replacement: this._wrapTransaction(F),
                                                                                      hash: t,
                                                                                      receipt: $,
                                                                                  }
                                                                              )
                                                                          )
                                                                      return
                                                                  }
                                                              }
                                                              T++
                                                          }
                                                      }
                                                      d || this.once("block", S)
                                                  }
                                              }),
                                          (P) => {
                                              d || this.once("block", S)
                                          }
                                      ))
                              })
                          if (d) return
                          this.once("block", S),
                              f.push(() => {
                                  this.removeListener("block", S)
                              })
                      }
                      if (typeof n == "number" && n > 0) {
                          const E = setTimeout(() => {
                              h() || l(me.makeError("timeout exceeded", ut.errors.TIMEOUT, { timeout: n }))
                          }, n)
                          E.unref && E.unref(),
                              f.push(() => {
                                  clearTimeout(E)
                              })
                      }
                  })
        })
    }
    getBlockNumber() {
        return de(this, void 0, void 0, function* () {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const t = yield this.perform("getGasPrice", {})
            try {
                return St.from(t)
            } catch (r) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, { method: "getGasPrice", result: t, error: r })
            }
        })
    }
    getBalance(t, r) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Ge({ address: this._getAddress(t), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getBalance", n)
            try {
                return St.from(i)
            } catch (s) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, { method: "getBalance", params: n, result: i, error: s })
            }
        })
    }
    getTransactionCount(t, r) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Ge({ address: this._getAddress(t), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getTransactionCount", n)
            try {
                return St.from(i).toNumber()
            } catch (s) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: n,
                    result: i,
                    error: s,
                })
            }
        })
    }
    getCode(t, r) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Ge({ address: this._getAddress(t), blockTag: this._getBlockTag(r) }),
                i = yield this.perform("getCode", n)
            try {
                return Lt(i)
            } catch (s) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, { method: "getCode", params: n, result: i, error: s })
            }
        })
    }
    getStorageAt(t, r, n) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const i = yield Ge({
                    address: this._getAddress(t),
                    blockTag: this._getBlockTag(n),
                    position: Promise.resolve(r).then((o) => Rd(o)),
                }),
                s = yield this.perform("getStorageAt", i)
            try {
                return Lt(s)
            } catch (o) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: i,
                    result: s,
                    error: o,
                })
            }
        })
    }
    _wrapTransaction(t, r, n) {
        if (r != null && Is(r) !== 32) throw new Error("invalid response - sendTransaction")
        const i = t
        return (
            r != null &&
                t.hash !== r &&
                me.throwError("Transaction hash mismatch from Provider.sendTransaction.", ut.errors.UNKNOWN_ERROR, {
                    expectedHash: t.hash,
                    returnedHash: r,
                }),
            (i.wait = (s, o) =>
                de(this, void 0, void 0, function* () {
                    s == null && (s = 1), o == null && (o = 0)
                    let l
                    s !== 0 && n != null && (l = { data: t.data, from: t.from, nonce: t.nonce, to: t.to, value: t.value, startBlock: n })
                    const f = yield this._waitForTransaction(t.hash, s, o, l)
                    return f == null && s === 0
                        ? null
                        : ((this._emitted["t:" + t.hash] = f.blockNumber),
                          f.status === 0 &&
                              me.throwError("transaction failed", ut.errors.CALL_EXCEPTION, {
                                  transactionHash: t.hash,
                                  transaction: t,
                                  receipt: f,
                              }),
                          f)
                })),
            i
        )
    }
    sendTransaction(t) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Promise.resolve(t).then((s) => Lt(s)),
                n = this.formatter.transaction(t)
            n.confirmations == null && (n.confirmations = 0)
            const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
            try {
                const s = yield this.perform("sendTransaction", { signedTransaction: r })
                return this._wrapTransaction(n, s, i)
            } catch (s) {
                throw ((s.transaction = n), (s.transactionHash = n.hash), s)
            }
        })
    }
    _getTransactionRequest(t) {
        return de(this, void 0, void 0, function* () {
            const r = yield t,
                n = {}
            return (
                ["from", "to"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? this._getAddress(s) : null)))
                }),
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? St.from(s) : null)))
                }),
                ["type"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s != null ? s : null)))
                }),
                r.accessList && (n.accessList = this.formatter.accessList(r.accessList)),
                ["data"].forEach((i) => {
                    r[i] != null && (n[i] = Promise.resolve(r[i]).then((s) => (s ? Lt(s) : null)))
                }),
                this.formatter.transactionRequest(yield Ge(n))
            )
        })
    }
    _getFilter(t) {
        return de(this, void 0, void 0, function* () {
            t = yield t
            const r = {}
            return (
                t.address != null && (r.address = this._getAddress(t.address)),
                ["blockHash", "topics"].forEach((n) => {
                    t[n] != null && (r[n] = t[n])
                }),
                ["fromBlock", "toBlock"].forEach((n) => {
                    t[n] != null && (r[n] = this._getBlockTag(t[n]))
                }),
                this.formatter.filter(yield Ge(r))
            )
        })
    }
    _call(t, r, n) {
        return de(this, void 0, void 0, function* () {
            n >= K5 && me.throwError("CCIP read exceeded maximum redirections", ut.errors.SERVER_ERROR, { redirects: n, transaction: t })
            const i = t.to,
                s = yield this.perform("call", { transaction: t, blockTag: r })
            if (n >= 0 && r === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && Is(s) % 32 === 4)
                try {
                    const o = fr(s, 4),
                        l = fr(o, 0, 32)
                    St.from(l).eq(i) ||
                        me.throwError("CCIP Read sender did not match", ut.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: t,
                            data: s,
                        })
                    const f = [],
                        d = St.from(fr(o, 32, 64)).toNumber(),
                        h = St.from(fr(o, d, d + 32)).toNumber(),
                        y = fr(o, d + 32)
                    for (let M = 0; M < h; M++) {
                        const k = jl(y, M * 32)
                        k == null &&
                            me.throwError("CCIP Read contained corrupt URL string", ut.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: t,
                                data: s,
                            }),
                            f.push(k)
                    }
                    const E = qa(o, 64)
                    St.from(fr(o, 100, 128)).isZero() ||
                        me.throwError("CCIP Read callback selector included junk", ut.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: t,
                            data: s,
                        })
                    const T = fr(o, 96, 100),
                        S = qa(o, 128),
                        N = yield this.ccipReadFetch(t, E, f)
                    N == null &&
                        me.throwError("CCIP Read disabled or provided no URLs", ut.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: t,
                            data: s,
                        })
                    const P = { to: i, data: _r([T, c1([N, S])]) }
                    return this._call(P, r, n + 1)
                } catch (o) {
                    if (o.code === ut.errors.SERVER_ERROR) throw o
                }
            try {
                return Lt(s)
            } catch (o) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, {
                    method: "call",
                    params: { transaction: t, blockTag: r },
                    result: s,
                    error: o,
                })
            }
        })
    }
    call(t, r) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const n = yield Ge({
                transaction: this._getTransactionRequest(t),
                blockTag: this._getBlockTag(r),
                ccipReadEnabled: Promise.resolve(t.ccipReadEnabled),
            })
            return this._call(n.transaction, n.blockTag, n.ccipReadEnabled ? 0 : -1)
        })
    }
    estimateGas(t) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Ge({ transaction: this._getTransactionRequest(t) }),
                n = yield this.perform("estimateGas", r)
            try {
                return St.from(n)
            } catch (i) {
                return me.throwError("bad result from backend", ut.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params: r,
                    result: n,
                    error: i,
                })
            }
        })
    }
    _getAddress(t) {
        return de(this, void 0, void 0, function* () {
            ;(t = yield t), typeof t != "string" && me.throwArgumentError("invalid address or ENS name", "name", t)
            const r = yield this.resolveName(t)
            return (
                r == null &&
                    me.throwError("ENS name not configured", ut.errors.UNSUPPORTED_OPERATION, {
                        operation: `resolveName(${JSON.stringify(t)})`,
                    }),
                r
            )
        })
    }
    _getBlock(t, r) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork(), (t = yield t)
            let n = -128
            const i = { includeTransactions: !!r }
            if (Te(t, 32)) i.blockHash = t
            else
                try {
                    ;(i.blockTag = yield this._getBlockTag(t)), Te(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16))
                } catch {
                    me.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", t)
                }
            return pa(
                () =>
                    de(this, void 0, void 0, function* () {
                        const s = yield this.perform("getBlock", i)
                        if (s == null)
                            return (i.blockHash != null && this._emitted["b:" + i.blockHash] == null) ||
                                (i.blockTag != null && n > this._emitted.block)
                                ? null
                                : void 0
                        if (r) {
                            let o = null
                            for (let f = 0; f < s.transactions.length; f++) {
                                const d = s.transactions[f]
                                if (d.blockNumber == null) d.confirmations = 0
                                else if (d.confirmations == null) {
                                    o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval))
                                    let h = o - d.blockNumber + 1
                                    h <= 0 && (h = 1), (d.confirmations = h)
                                }
                            }
                            const l = this.formatter.blockWithTransactions(s)
                            return (l.transactions = l.transactions.map((f) => this._wrapTransaction(f))), l
                        }
                        return this.formatter.block(s)
                    }),
                { oncePoll: this }
            )
        })
    }
    getBlock(t) {
        return this._getBlock(t, !1)
    }
    getBlockWithTransactions(t) {
        return this._getBlock(t, !0)
    }
    getTransaction(t) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork(), (t = yield t)
            const r = { transactionHash: this.formatter.hash(t, !0) }
            return pa(
                () =>
                    de(this, void 0, void 0, function* () {
                        const n = yield this.perform("getTransaction", r)
                        if (n == null) return this._emitted["t:" + t] == null ? null : void 0
                        const i = this.formatter.transactionResponse(n)
                        if (i.blockNumber == null) i.confirmations = 0
                        else if (i.confirmations == null) {
                            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1
                            o <= 0 && (o = 1), (i.confirmations = o)
                        }
                        return this._wrapTransaction(i)
                    }),
                { oncePoll: this }
            )
        })
    }
    getTransactionReceipt(t) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork(), (t = yield t)
            const r = { transactionHash: this.formatter.hash(t, !0) }
            return pa(
                () =>
                    de(this, void 0, void 0, function* () {
                        const n = yield this.perform("getTransactionReceipt", r)
                        if (n == null) return this._emitted["t:" + t] == null ? null : void 0
                        if (n.blockHash == null) return
                        const i = this.formatter.receipt(n)
                        if (i.blockNumber == null) i.confirmations = 0
                        else if (i.confirmations == null) {
                            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1
                            o <= 0 && (o = 1), (i.confirmations = o)
                        }
                        return i
                    }),
                { oncePoll: this }
            )
        })
    }
    getLogs(t) {
        return de(this, void 0, void 0, function* () {
            yield this.getNetwork()
            const r = yield Ge({ filter: this._getFilter(t) }),
                n = yield this.perform("getLogs", r)
            return (
                n.forEach((i) => {
                    i.removed == null && (i.removed = !1)
                }),
                Pt.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
            )
        })
    }
    getEtherPrice() {
        return de(this, void 0, void 0, function* () {
            return yield this.getNetwork(), this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(t) {
        return de(this, void 0, void 0, function* () {
            if (((t = yield t), typeof t == "number" && t < 0)) {
                t % 1 && me.throwArgumentError("invalid BlockTag", "blockTag", t)
                let r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)
                return (r += t), r < 0 && (r = 0), this.formatter.blockTag(r)
            }
            return this.formatter.blockTag(t)
        })
    }
    getResolver(t) {
        return de(this, void 0, void 0, function* () {
            let r = t
            for (;;) {
                if (r === "" || r === "." || (t !== "eth" && r === "eth")) return null
                const n = yield this._getResolver(r, "getResolver")
                if (n != null) {
                    const i = new up(this, n, t)
                    return r !== t && !(yield i.supportsWildcard()) ? null : i
                }
                r = r.split(".").slice(1).join(".")
            }
        })
    }
    _getResolver(t, r) {
        return de(this, void 0, void 0, function* () {
            r == null && (r = "ENS")
            const n = yield this.getNetwork()
            n.ensAddress || me.throwError("network does not support ENS", ut.errors.UNSUPPORTED_OPERATION, { operation: r, network: n.name })
            try {
                const i = yield this.call({ to: n.ensAddress, data: "0x0178b8bf" + Hl(t).substring(2) })
                return this.formatter.callAddress(i)
            } catch {}
            return null
        })
    }
    resolveName(t) {
        return de(this, void 0, void 0, function* () {
            t = yield t
            try {
                return Promise.resolve(this.formatter.address(t))
            } catch (n) {
                if (Te(t)) throw n
            }
            typeof t != "string" && me.throwArgumentError("invalid ENS name", "name", t)
            const r = yield this.getResolver(t)
            return r ? yield r.getAddress() : null
        })
    }
    lookupAddress(t) {
        return de(this, void 0, void 0, function* () {
            ;(t = yield t), (t = this.formatter.address(t))
            const r = t.substring(2).toLowerCase() + ".addr.reverse",
                n = yield this._getResolver(r, "lookupAddress")
            if (n == null) return null
            const i = jl(yield this.call({ to: n, data: "0x691f3431" + Hl(r).substring(2) }), 0)
            return (yield this.resolveName(i)) != t ? null : i
        })
    }
    getAvatar(t) {
        return de(this, void 0, void 0, function* () {
            let r = null
            if (Te(t)) {
                const s = this.formatter.address(t).substring(2).toLowerCase() + ".addr.reverse",
                    o = yield this._getResolver(s, "getAvatar")
                if (!o) return null
                r = new up(this, o, s)
                try {
                    const l = yield r.getAvatar()
                    if (l) return l.url
                } catch (l) {
                    if (l.code !== ut.errors.CALL_EXCEPTION) throw l
                }
                try {
                    const l = jl(yield this.call({ to: o, data: "0x691f3431" + Hl(s).substring(2) }), 0)
                    r = yield this.getResolver(l)
                } catch (l) {
                    if (l.code !== ut.errors.CALL_EXCEPTION) throw l
                    return null
                }
            } else if (((r = yield this.getResolver(t)), !r)) return null
            const n = yield r.getAvatar()
            return n == null ? null : n.url
        })
    }
    perform(t, r) {
        return me.throwError(t + " not implemented", ut.errors.NOT_IMPLEMENTED, { operation: t })
    }
    _startEvent(t) {
        this.polling = this._events.filter((r) => r.pollable()).length > 0
    }
    _stopEvent(t) {
        this.polling = this._events.filter((r) => r.pollable()).length > 0
    }
    _addEventListener(t, r, n) {
        const i = new Y5(Js(t), r, n)
        return this._events.push(i), this._startEvent(i), this
    }
    on(t, r) {
        return this._addEventListener(t, r, !1)
    }
    once(t, r) {
        return this._addEventListener(t, r, !0)
    }
    emit(t, ...r) {
        let n = !1,
            i = [],
            s = Js(t)
        return (
            (this._events = this._events.filter((o) =>
                o.tag !== s
                    ? !0
                    : (setTimeout(() => {
                          o.listener.apply(this, r)
                      }, 0),
                      (n = !0),
                      o.once ? (i.push(o), !1) : !0)
            )),
            i.forEach((o) => {
                this._stopEvent(o)
            }),
            n
        )
    }
    listenerCount(t) {
        if (!t) return this._events.length
        let r = Js(t)
        return this._events.filter((n) => n.tag === r).length
    }
    listeners(t) {
        if (t == null) return this._events.map((n) => n.listener)
        let r = Js(t)
        return this._events.filter((n) => n.tag === r).map((n) => n.listener)
    }
    off(t, r) {
        if (r == null) return this.removeAllListeners(t)
        const n = []
        let i = !1,
            s = Js(t)
        return (
            (this._events = this._events.filter((o) => (o.tag !== s || o.listener != r || i ? !0 : ((i = !0), n.push(o), !1)))),
            n.forEach((o) => {
                this._stopEvent(o)
            }),
            this
        )
    }
    removeAllListeners(t) {
        let r = []
        if (t == null) (r = this._events), (this._events = [])
        else {
            const n = Js(t)
            this._events = this._events.filter((i) => (i.tag !== n ? !0 : (r.push(i), !1)))
        }
        return (
            r.forEach((n) => {
                this._stopEvent(n)
            }),
            this
        )
    }
}
var Jn =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const We = new ut(al),
    tT = ["call", "estimateGas"]
function Ma(e, t) {
    if (e == null) return null
    if (typeof e.message == "string" && e.message.match("reverted")) {
        const r = Te(e.data) ? e.data : null
        if (!t || r) return { message: e.message, data: r }
    }
    if (typeof e == "object") {
        for (const r in e) {
            const n = Ma(e[r], t)
            if (n) return n
        }
        return null
    }
    if (typeof e == "string")
        try {
            return Ma(JSON.parse(e), t)
        } catch {}
    return null
}
function d1(e, t, r) {
    const n = r.transaction || r.signedTransaction
    if (e === "call") {
        const s = Ma(t, !0)
        if (s) return s.data
        We.throwError("missing revert data in call exception; Transaction reverted without a reason string", ut.errors.CALL_EXCEPTION, {
            data: "0x",
            transaction: n,
            error: t,
        })
    }
    if (e === "estimateGas") {
        let s = Ma(t.body, !1)
        s == null && (s = Ma(t, !1)),
            s &&
                We.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", ut.errors.UNPREDICTABLE_GAS_LIMIT, {
                    reason: s.message,
                    method: e,
                    transaction: n,
                    error: t,
                })
    }
    let i = t.message
    throw (
        (t.code === ut.errors.SERVER_ERROR && t.error && typeof t.error.message == "string"
            ? (i = t.error.message)
            : typeof t.body == "string"
            ? (i = t.body)
            : typeof t.responseText == "string" && (i = t.responseText),
        (i = (i || "").toLowerCase()),
        i.match(/insufficient funds|base fee exceeds gas limit/i) &&
            We.throwError("insufficient funds for intrinsic transaction cost", ut.errors.INSUFFICIENT_FUNDS, {
                error: t,
                method: e,
                transaction: n,
            }),
        i.match(/nonce (is )?too low/i) &&
            We.throwError("nonce has already been used", ut.errors.NONCE_EXPIRED, { error: t, method: e, transaction: n }),
        i.match(/replacement transaction underpriced|transaction gas price.*too low/i) &&
            We.throwError("replacement fee too low", ut.errors.REPLACEMENT_UNDERPRICED, { error: t, method: e, transaction: n }),
        i.match(/only replay-protected/i) &&
            We.throwError("legacy pre-eip-155 transactions not supported", ut.errors.UNSUPPORTED_OPERATION, {
                error: t,
                method: e,
                transaction: n,
            }),
        tT.indexOf(e) >= 0 &&
            i.match(/gas required exceeds allowance|always failing transaction|execution reverted/) &&
            We.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", ut.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: t,
                method: e,
                transaction: n,
            }),
        t)
    )
}
function fp(e) {
    return new Promise(function (t) {
        setTimeout(t, e)
    })
}
function eT(e) {
    if (e.error) {
        const t = new Error(e.error.message)
        throw ((t.code = e.error.code), (t.data = e.error.data), t)
    }
    return e.result
}
function la(e) {
    return e && e.toLowerCase()
}
const Hc = {}
class h1 extends qo {
    constructor(t, r, n) {
        if ((super(), t !== Hc)) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner")
        _t(this, "provider", r),
            n == null && (n = 0),
            typeof n == "string"
                ? (_t(this, "_address", this.provider.formatter.address(n)), _t(this, "_index", null))
                : typeof n == "number"
                ? (_t(this, "_index", n), _t(this, "_address", null))
                : We.throwArgumentError("invalid address or index", "addressOrIndex", n)
    }
    connect(t) {
        return We.throwError("cannot alter JSON-RPC Signer connection", ut.errors.UNSUPPORTED_OPERATION, { operation: "connect" })
    }
    connectUnchecked() {
        return new rT(Hc, this.provider, this._address || this._index)
    }
    getAddress() {
        return this._address
            ? Promise.resolve(this._address)
            : this.provider
                  .send("eth_accounts", [])
                  .then(
                      (t) => (
                          t.length <= this._index &&
                              We.throwError("unknown account #" + this._index, ut.errors.UNSUPPORTED_OPERATION, { operation: "getAddress" }),
                          this.provider.formatter.address(t[this._index])
                      )
                  )
    }
    sendUncheckedTransaction(t) {
        t = Ye(t)
        const r = this.getAddress().then((n) => (n && (n = n.toLowerCase()), n))
        if (t.gasLimit == null) {
            const n = Ye(t)
            ;(n.from = r), (t.gasLimit = this.provider.estimateGas(n))
        }
        return (
            t.to != null &&
                (t.to = Promise.resolve(t.to).then((n) =>
                    Jn(this, void 0, void 0, function* () {
                        if (n == null) return null
                        const i = yield this.provider.resolveName(n)
                        return i == null && We.throwArgumentError("provided ENS name resolves to null", "tx.to", n), i
                    })
                )),
            Ge({ tx: Ge(t), sender: r }).then(({ tx: n, sender: i }) => {
                n.from != null ? n.from.toLowerCase() !== i && We.throwArgumentError("from address mismatch", "transaction", t) : (n.from = i)
                const s = this.provider.constructor.hexlifyTransaction(n, { from: !0 })
                return this.provider.send("eth_sendTransaction", [s]).then(
                    (o) => o,
                    (o) => (
                        typeof o.message == "string" &&
                            o.message.match(/user denied/i) &&
                            We.throwError("user rejected transaction", ut.errors.ACTION_REJECTED, { action: "sendTransaction", transaction: n }),
                        d1("sendTransaction", o, s)
                    )
                )
            })
        )
    }
    signTransaction(t) {
        return We.throwError("signing transactions is unsupported", ut.errors.UNSUPPORTED_OPERATION, { operation: "signTransaction" })
    }
    sendTransaction(t) {
        return Jn(this, void 0, void 0, function* () {
            const r = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
                n = yield this.sendUncheckedTransaction(t)
            try {
                return yield pa(
                    () =>
                        Jn(this, void 0, void 0, function* () {
                            const i = yield this.provider.getTransaction(n)
                            if (i !== null) return this.provider._wrapTransaction(i, n, r)
                        }),
                    { oncePoll: this.provider }
                )
            } catch (i) {
                throw ((i.transactionHash = n), i)
            }
        })
    }
    signMessage(t) {
        return Jn(this, void 0, void 0, function* () {
            const r = typeof t == "string" ? ci(t) : t,
                n = yield this.getAddress()
            try {
                return yield this.provider.send("personal_sign", [Lt(r), n.toLowerCase()])
            } catch (i) {
                throw (
                    (typeof i.message == "string" &&
                        i.message.match(/user denied/i) &&
                        We.throwError("user rejected signing", ut.errors.ACTION_REJECTED, { action: "signMessage", from: n, message: r }),
                    i)
                )
            }
        })
    }
    _legacySignMessage(t) {
        return Jn(this, void 0, void 0, function* () {
            const r = typeof t == "string" ? ci(t) : t,
                n = yield this.getAddress()
            try {
                return yield this.provider.send("eth_sign", [n.toLowerCase(), Lt(r)])
            } catch (i) {
                throw (
                    (typeof i.message == "string" &&
                        i.message.match(/user denied/i) &&
                        We.throwError("user rejected signing", ut.errors.ACTION_REJECTED, { action: "_legacySignMessage", from: n, message: r }),
                    i)
                )
            }
        })
    }
    _signTypedData(t, r, n) {
        return Jn(this, void 0, void 0, function* () {
            const i = yield xr.resolveNames(t, r, n, (o) => this.provider.resolveName(o)),
                s = yield this.getAddress()
            try {
                return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(xr.getPayload(i.domain, r, i.value))])
            } catch (o) {
                throw (
                    (typeof o.message == "string" &&
                        o.message.match(/user denied/i) &&
                        We.throwError("user rejected signing", ut.errors.ACTION_REJECTED, {
                            action: "_signTypedData",
                            from: s,
                            message: { domain: i.domain, types: r, value: i.value },
                        }),
                    o)
                )
            }
        })
    }
    unlock(t) {
        return Jn(this, void 0, void 0, function* () {
            const r = this.provider,
                n = yield this.getAddress()
            return r.send("personal_unlockAccount", [n.toLowerCase(), t, null])
        })
    }
}
class rT extends h1 {
    sendTransaction(t) {
        return this.sendUncheckedTransaction(t).then((r) => ({
            hash: r,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: (n) => this.provider.waitForTransaction(r, n),
        }))
    }
}
const nT = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0,
}
class p1 extends Z5 {
    constructor(t, r) {
        let n = r
        n == null &&
            (n = new Promise((i, s) => {
                setTimeout(() => {
                    this.detectNetwork().then(
                        (o) => {
                            i(o)
                        },
                        (o) => {
                            s(o)
                        }
                    )
                }, 0)
            })),
            super(n),
            t || (t = Ir(this.constructor, "defaultUrl")()),
            typeof t == "string" ? _t(this, "connection", Object.freeze({ url: t })) : _t(this, "connection", Object.freeze(Ye(t))),
            (this._nextId = 42)
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return (
            this._cache.detectNetwork ||
                ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
                setTimeout(() => {
                    this._cache.detectNetwork = null
                }, 0)),
            this._cache.detectNetwork
        )
    }
    _uncachedDetectNetwork() {
        return Jn(this, void 0, void 0, function* () {
            yield fp(0)
            let t = null
            try {
                t = yield this.send("eth_chainId", [])
            } catch {
                try {
                    t = yield this.send("net_version", [])
                } catch {}
            }
            if (t != null) {
                const r = Ir(this.constructor, "getNetwork")
                try {
                    return r(St.from(t).toNumber())
                } catch (n) {
                    return We.throwError("could not detect network", ut.errors.NETWORK_ERROR, {
                        chainId: t,
                        event: "invalidNetwork",
                        serverError: n,
                    })
                }
            }
            return We.throwError("could not detect network", ut.errors.NETWORK_ERROR, { event: "noNetwork" })
        })
    }
    getSigner(t) {
        return new h1(Hc, this, t)
    }
    getUncheckedSigner(t) {
        return this.getSigner(t).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((t) => t.map((r) => this.formatter.address(r)))
    }
    send(t, r) {
        const n = { method: t, params: r, id: this._nextId++, jsonrpc: "2.0" }
        this.emit("debug", { action: "request", request: fi(n), provider: this })
        const i = ["eth_chainId", "eth_blockNumber"].indexOf(t) >= 0
        if (i && this._cache[t]) return this._cache[t]
        const s = Kd(this.connection, JSON.stringify(n), eT).then(
            (o) => (this.emit("debug", { action: "response", request: n, response: o, provider: this }), o),
            (o) => {
                throw (this.emit("debug", { action: "response", error: o, request: n, provider: this }), o)
            }
        )
        return (
            i &&
                ((this._cache[t] = s),
                setTimeout(() => {
                    this._cache[t] = null
                }, 0)),
            s
        )
    }
    prepareRequest(t, r) {
        switch (t) {
            case "getBlockNumber":
                return ["eth_blockNumber", []]
            case "getGasPrice":
                return ["eth_gasPrice", []]
            case "getBalance":
                return ["eth_getBalance", [la(r.address), r.blockTag]]
            case "getTransactionCount":
                return ["eth_getTransactionCount", [la(r.address), r.blockTag]]
            case "getCode":
                return ["eth_getCode", [la(r.address), r.blockTag]]
            case "getStorageAt":
                return ["eth_getStorageAt", [la(r.address), He(r.position, 32), r.blockTag]]
            case "sendTransaction":
                return ["eth_sendRawTransaction", [r.signedTransaction]]
            case "getBlock":
                return r.blockTag
                    ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]]
                    : r.blockHash
                    ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]]
                    : null
            case "getTransaction":
                return ["eth_getTransactionByHash", [r.transactionHash]]
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [r.transactionHash]]
            case "call": {
                const n = Ir(this.constructor, "hexlifyTransaction")
                return ["eth_call", [n(r.transaction, { from: !0 }), r.blockTag]]
            }
            case "estimateGas": {
                const n = Ir(this.constructor, "hexlifyTransaction")
                return ["eth_estimateGas", [n(r.transaction, { from: !0 })]]
            }
            case "getLogs":
                return r.filter && r.filter.address != null && (r.filter.address = la(r.filter.address)), ["eth_getLogs", [r.filter]]
        }
        return null
    }
    perform(t, r) {
        return Jn(this, void 0, void 0, function* () {
            if (t === "call" || t === "estimateGas") {
                const i = r.transaction
                if (i && i.type != null && St.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                    const s = yield this.getFeeData()
                    s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && ((r = Ye(r)), (r.transaction = Ye(i)), delete r.transaction.type)
                }
            }
            const n = this.prepareRequest(t, r)
            n == null && We.throwError(t + " not implemented", ut.errors.NOT_IMPLEMENTED, { operation: t })
            try {
                return yield this.send(n[0], n[1])
            } catch (i) {
                return d1(t, i, r)
            }
        })
    }
    _startEvent(t) {
        t.tag === "pending" && this._startPending(), super._startEvent(t)
    }
    _startPending() {
        if (this._pendingFilter != null) return
        const t = this,
            r = this.send("eth_newPendingTransactionFilter", [])
        ;(this._pendingFilter = r),
            r
                .then(function (n) {
                    function i() {
                        t.send("eth_getFilterChanges", [n])
                            .then(function (s) {
                                if (t._pendingFilter != r) return null
                                let o = Promise.resolve()
                                return (
                                    s.forEach(function (l) {
                                        ;(t._emitted["t:" + l.toLowerCase()] = "pending"),
                                            (o = o.then(function () {
                                                return t.getTransaction(l).then(function (f) {
                                                    return t.emit("pending", f), null
                                                })
                                            }))
                                    }),
                                    o.then(function () {
                                        return fp(1e3)
                                    })
                                )
                            })
                            .then(function () {
                                if (t._pendingFilter != r) {
                                    t.send("eth_uninstallFilter", [n])
                                    return
                                }
                                return (
                                    setTimeout(function () {
                                        i()
                                    }, 0),
                                    null
                                )
                            })
                            .catch((s) => {})
                    }
                    return i(), n
                })
                .catch((n) => {})
    }
    _stopEvent(t) {
        t.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(t)
    }
    static hexlifyTransaction(t, r) {
        const n = Ye(nT)
        if (r) for (const s in r) r[s] && (n[s] = !0)
        rE(t, n)
        const i = {}
        return (
            ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (s) {
                if (t[s] == null) return
                const o = Rd(St.from(t[s]))
                s === "gasLimit" && (s = "gas"), (i[s] = o)
            }),
            ["from", "to", "data"].forEach(function (s) {
                t[s] != null && (i[s] = Lt(t[s]))
            }),
            t.accessList && (i.accessList = Wo(t.accessList)),
            i
        )
    }
}
var iT =
    (globalThis && globalThis.__awaiter) ||
    function (e, t, r, n) {
        function i(s) {
            return s instanceof r
                ? s
                : new r(function (o) {
                      o(s)
                  })
        }
        return new (r || (r = Promise))(function (s, o) {
            function l(h) {
                try {
                    d(n.next(h))
                } catch (y) {
                    o(y)
                }
            }
            function f(h) {
                try {
                    d(n.throw(h))
                } catch (y) {
                    o(y)
                }
            }
            function d(h) {
                h.done ? s(h.value) : i(h.value).then(l, f)
            }
            d((n = n.apply(e, t || [])).next())
        })
    }
const sT = new ut(al)
class oT extends p1 {
    detectNetwork() {
        const t = Object.create(null, { detectNetwork: { get: () => super.detectNetwork } })
        return iT(this, void 0, void 0, function* () {
            let r = this.network
            return (
                r == null &&
                    ((r = yield t.detectNetwork.call(this)),
                    r || sT.throwError("no network detected", ut.errors.UNKNOWN_ERROR, {}),
                    this._network == null && (_t(this, "_network", r), this.emit("network", r, null))),
                r
            )
        })
    }
}
const cp = new ut(al)
let aT = 1
function dp(e, t) {
    const r = "Web3LegacyFetcher"
    return function (n, i) {
        const s = { method: n, params: i, id: aT++, jsonrpc: "2.0" }
        return new Promise((o, l) => {
            this.emit("debug", { action: "request", fetcher: r, request: fi(s), provider: this }),
                t(s, (f, d) => {
                    if (f) return this.emit("debug", { action: "response", fetcher: r, error: f, request: s, provider: this }), l(f)
                    if ((this.emit("debug", { action: "response", fetcher: r, request: s, response: d, provider: this }), d.error)) {
                        const h = new Error(d.error.message)
                        return (h.code = d.error.code), (h.data = d.error.data), l(h)
                    }
                    o(d.result)
                })
        })
    }
}
function lT(e) {
    return function (t, r) {
        r == null && (r = [])
        const n = { method: t, params: r }
        return (
            this.emit("debug", { action: "request", fetcher: "Eip1193Fetcher", request: fi(n), provider: this }),
            e.request(n).then(
                (i) => (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: n, response: i, provider: this }), i),
                (i) => {
                    throw (this.emit("debug", { action: "response", fetcher: "Eip1193Fetcher", request: n, error: i, provider: this }), i)
                }
            )
        )
    }
}
class hp extends p1 {
    constructor(t, r) {
        t == null && cp.throwArgumentError("missing provider", "provider", t)
        let n = null,
            i = null,
            s = null
        typeof t == "function"
            ? ((n = "unknown:"), (i = t))
            : ((n = t.host || t.path || ""),
              !n && t.isMetaMask && (n = "metamask"),
              (s = t),
              t.request
                  ? (n === "" && (n = "eip-1193:"), (i = lT(t)))
                  : t.sendAsync
                  ? (i = dp(t, t.sendAsync.bind(t)))
                  : t.send
                  ? (i = dp(t, t.send.bind(t)))
                  : cp.throwArgumentError("unsupported provider", "provider", t),
              n || (n = "unknown:")),
            super(n, r),
            _t(this, "jsonRpcFetchFunc", i),
            _t(this, "provider", s)
    }
    send(t, r) {
        return this.jsonRpcFetchFunc(t, r)
    }
}
const uT = "ethers/5.7.0"
new ut(uT)
var gr = "top",
    Lr = "bottom",
    Dr = "right",
    mr = "left",
    sf = "auto",
    Yo = [gr, Lr, Dr, mr],
    Rs = "start",
    Io = "end",
    g1 = "clippingParents",
    Gd = "viewport",
    so = "popper",
    m1 = "reference",
    qc = Yo.reduce(function (e, t) {
        return e.concat([t + "-" + Rs, t + "-" + Io])
    }, []),
    Wd = [].concat(Yo, [sf]).reduce(function (e, t) {
        return e.concat([t, t + "-" + Rs, t + "-" + Io])
    }, []),
    v1 = "beforeRead",
    b1 = "read",
    y1 = "afterRead",
    _1 = "beforeMain",
    w1 = "main",
    A1 = "afterMain",
    E1 = "beforeWrite",
    x1 = "write",
    T1 = "afterWrite",
    C1 = [v1, b1, y1, _1, w1, A1, E1, x1, T1]
function qn(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function en(e) {
    if (e == null) return window
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument
        return (t && t.defaultView) || window
    }
    return e
}
function Ls(e) {
    var t = en(e).Element
    return e instanceof t || e instanceof Element
}
function Yr(e) {
    var t = en(e).HTMLElement
    return e instanceof t || e instanceof HTMLElement
}
function Yd(e) {
    if (typeof ShadowRoot == "undefined") return !1
    var t = en(e).ShadowRoot
    return e instanceof t || e instanceof ShadowRoot
}
function fT(e) {
    var t = e.state
    Object.keys(t.elements).forEach(function (r) {
        var n = t.styles[r] || {},
            i = t.attributes[r] || {},
            s = t.elements[r]
        !Yr(s) ||
            !qn(s) ||
            (Object.assign(s.style, n),
            Object.keys(i).forEach(function (o) {
                var l = i[o]
                l === !1 ? s.removeAttribute(o) : s.setAttribute(o, l === !0 ? "" : l)
            }))
    })
}
function cT(e) {
    var t = e.state,
        r = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }
    return (
        Object.assign(t.elements.popper.style, r.popper),
        (t.styles = r),
        t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow),
        function () {
            Object.keys(t.elements).forEach(function (n) {
                var i = t.elements[n],
                    s = t.attributes[n] || {},
                    o = Object.keys(t.styles.hasOwnProperty(n) ? t.styles[n] : r[n]),
                    l = o.reduce(function (f, d) {
                        return (f[d] = ""), f
                    }, {})
                !Yr(i) ||
                    !qn(i) ||
                    (Object.assign(i.style, l),
                    Object.keys(s).forEach(function (f) {
                        i.removeAttribute(f)
                    }))
            })
        }
    )
}
var Jd = { name: "applyStyles", enabled: !0, phase: "write", fn: fT, effect: cT, requires: ["computeStyles"] }
function $n(e) {
    return e.split("-")[0]
}
var Ss = Math.max,
    _u = Math.min,
    Bo = Math.round
function zc() {
    var e = navigator.userAgentData
    return e != null && e.brands
        ? e.brands
              .map(function (t) {
                  return t.brand + "/" + t.version
              })
              .join(" ")
        : navigator.userAgent
}
function M1() {
    return !/^((?!chrome|android).)*safari/i.test(zc())
}
function Po(e, t, r) {
    t === void 0 && (t = !1), r === void 0 && (r = !1)
    var n = e.getBoundingClientRect(),
        i = 1,
        s = 1
    t &&
        Yr(e) &&
        ((i = (e.offsetWidth > 0 && Bo(n.width) / e.offsetWidth) || 1), (s = (e.offsetHeight > 0 && Bo(n.height) / e.offsetHeight) || 1))
    var o = Ls(e) ? en(e) : window,
        l = o.visualViewport,
        f = !M1() && r,
        d = (n.left + (f && l ? l.offsetLeft : 0)) / i,
        h = (n.top + (f && l ? l.offsetTop : 0)) / s,
        y = n.width / i,
        E = n.height / s
    return { width: y, height: E, top: h, right: d + y, bottom: h + E, left: d, x: d, y: h }
}
function Qd(e) {
    var t = Po(e),
        r = e.offsetWidth,
        n = e.offsetHeight
    return (
        Math.abs(t.width - r) <= 1 && (r = t.width),
        Math.abs(t.height - n) <= 1 && (n = t.height),
        { x: e.offsetLeft, y: e.offsetTop, width: r, height: n }
    )
}
function S1(e, t) {
    var r = t.getRootNode && t.getRootNode()
    if (e.contains(t)) return !0
    if (r && Yd(r)) {
        var n = t
        do {
            if (n && e.isSameNode(n)) return !0
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}
function pi(e) {
    return en(e).getComputedStyle(e)
}
function dT(e) {
    return ["table", "td", "th"].indexOf(qn(e)) >= 0
}
function Zi(e) {
    return ((Ls(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function of(e) {
    return qn(e) === "html" ? e : e.assignedSlot || e.parentNode || (Yd(e) ? e.host : null) || Zi(e)
}
function pp(e) {
    return !Yr(e) || pi(e).position === "fixed" ? null : e.offsetParent
}
function hT(e) {
    var t = /firefox/i.test(zc()),
        r = /Trident/i.test(zc())
    if (r && Yr(e)) {
        var n = pi(e)
        if (n.position === "fixed") return null
    }
    var i = of(e)
    for (Yd(i) && (i = i.host); Yr(i) && ["html", "body"].indexOf(qn(i)) < 0; ) {
        var s = pi(i)
        if (
            s.transform !== "none" ||
            s.perspective !== "none" ||
            s.contain === "paint" ||
            ["transform", "perspective"].indexOf(s.willChange) !== -1 ||
            (t && s.willChange === "filter") ||
            (t && s.filter && s.filter !== "none")
        )
            return i
        i = i.parentNode
    }
    return null
}
function ll(e) {
    for (var t = en(e), r = pp(e); r && dT(r) && pi(r).position === "static"; ) r = pp(r)
    return r && (qn(r) === "html" || (qn(r) === "body" && pi(r).position === "static")) ? t : r || hT(e) || t
}
function Xd(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function Sa(e, t, r) {
    return Ss(e, _u(t, r))
}
function pT(e, t, r) {
    var n = Sa(e, t, r)
    return n > r ? r : n
}
function k1() {
    return { top: 0, right: 0, bottom: 0, left: 0 }
}
function N1(e) {
    return Object.assign({}, k1(), e)
}
function O1(e, t) {
    return t.reduce(function (r, n) {
        return (r[n] = e), r
    }, {})
}
var gT = function (t, r) {
    return (t = typeof t == "function" ? t(Object.assign({}, r.rects, { placement: r.placement })) : t), N1(typeof t != "number" ? t : O1(t, Yo))
}
function mT(e) {
    var t,
        r = e.state,
        n = e.name,
        i = e.options,
        s = r.elements.arrow,
        o = r.modifiersData.popperOffsets,
        l = $n(r.placement),
        f = Xd(l),
        d = [mr, Dr].indexOf(l) >= 0,
        h = d ? "height" : "width"
    if (!(!s || !o)) {
        var y = gT(i.padding, r),
            E = Qd(s),
            T = f === "y" ? gr : mr,
            S = f === "y" ? Lr : Dr,
            N = r.rects.reference[h] + r.rects.reference[f] - o[f] - r.rects.popper[h],
            P = o[f] - r.rects.reference[f],
            M = ll(s),
            k = M ? (f === "y" ? M.clientHeight || 0 : M.clientWidth || 0) : 0,
            F = N / 2 - P / 2,
            $ = y[T],
            R = k - E[h] - y[S],
            W = k / 2 - E[h] / 2 + F,
            nt = Sa($, W, R),
            J = f
        r.modifiersData[n] = ((t = {}), (t[J] = nt), (t.centerOffset = nt - W), t)
    }
}
function vT(e) {
    var t = e.state,
        r = e.options,
        n = r.element,
        i = n === void 0 ? "[data-popper-arrow]" : n
    i != null &&
        ((typeof i == "string" && ((i = t.elements.popper.querySelector(i)), !i)) || !S1(t.elements.popper, i) || (t.elements.arrow = i))
}
var I1 = { name: "arrow", enabled: !0, phase: "main", fn: mT, effect: vT, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }
function Ro(e) {
    return e.split("-")[1]
}
var bT = { top: "auto", right: "auto", bottom: "auto", left: "auto" }
function yT(e) {
    var t = e.x,
        r = e.y,
        n = window,
        i = n.devicePixelRatio || 1
    return { x: Bo(t * i) / i || 0, y: Bo(r * i) / i || 0 }
}
function gp(e) {
    var t,
        r = e.popper,
        n = e.popperRect,
        i = e.placement,
        s = e.variation,
        o = e.offsets,
        l = e.position,
        f = e.gpuAcceleration,
        d = e.adaptive,
        h = e.roundOffsets,
        y = e.isFixed,
        E = o.x,
        T = E === void 0 ? 0 : E,
        S = o.y,
        N = S === void 0 ? 0 : S,
        P = typeof h == "function" ? h({ x: T, y: N }) : { x: T, y: N }
    ;(T = P.x), (N = P.y)
    var M = o.hasOwnProperty("x"),
        k = o.hasOwnProperty("y"),
        F = mr,
        $ = gr,
        R = window
    if (d) {
        var W = ll(r),
            nt = "clientHeight",
            J = "clientWidth"
        if (
            (W === en(r) && ((W = Zi(r)), pi(W).position !== "static" && l === "absolute" && ((nt = "scrollHeight"), (J = "scrollWidth"))),
            (W = W),
            i === gr || ((i === mr || i === Dr) && s === Io))
        ) {
            $ = Lr
            var Q = y && W === R && R.visualViewport ? R.visualViewport.height : W[nt]
            ;(N -= Q - n.height), (N *= f ? 1 : -1)
        }
        if (i === mr || ((i === gr || i === Lr) && s === Io)) {
            F = Dr
            var ot = y && W === R && R.visualViewport ? R.visualViewport.width : W[J]
            ;(T -= ot - n.width), (T *= f ? 1 : -1)
        }
    }
    var it = Object.assign({ position: l }, d && bT),
        at = h === !0 ? yT({ x: T, y: N }) : { x: T, y: N }
    if (((T = at.x), (N = at.y), f)) {
        var x
        return Object.assign(
            {},
            it,
            ((x = {}),
            (x[$] = k ? "0" : ""),
            (x[F] = M ? "0" : ""),
            (x.transform = (R.devicePixelRatio || 1) <= 1 ? "translate(" + T + "px, " + N + "px)" : "translate3d(" + T + "px, " + N + "px, 0)"),
            x)
        )
    }
    return Object.assign({}, it, ((t = {}), (t[$] = k ? N + "px" : ""), (t[F] = M ? T + "px" : ""), (t.transform = ""), t))
}
function _T(e) {
    var t = e.state,
        r = e.options,
        n = r.gpuAcceleration,
        i = n === void 0 ? !0 : n,
        s = r.adaptive,
        o = s === void 0 ? !0 : s,
        l = r.roundOffsets,
        f = l === void 0 ? !0 : l,
        d = {
            placement: $n(t.placement),
            variation: Ro(t.placement),
            popper: t.elements.popper,
            popperRect: t.rects.popper,
            gpuAcceleration: i,
            isFixed: t.options.strategy === "fixed",
        }
    t.modifiersData.popperOffsets != null &&
        (t.styles.popper = Object.assign(
            {},
            t.styles.popper,
            gp(Object.assign({}, d, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: f }))
        )),
        t.modifiersData.arrow != null &&
            (t.styles.arrow = Object.assign(
                {},
                t.styles.arrow,
                gp(Object.assign({}, d, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: f }))
            )),
        (t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }))
}
var Zd = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: _T, data: {} },
    kl = { passive: !0 }
function wT(e) {
    var t = e.state,
        r = e.instance,
        n = e.options,
        i = n.scroll,
        s = i === void 0 ? !0 : i,
        o = n.resize,
        l = o === void 0 ? !0 : o,
        f = en(t.elements.popper),
        d = [].concat(t.scrollParents.reference, t.scrollParents.popper)
    return (
        s &&
            d.forEach(function (h) {
                h.addEventListener("scroll", r.update, kl)
            }),
        l && f.addEventListener("resize", r.update, kl),
        function () {
            s &&
                d.forEach(function (h) {
                    h.removeEventListener("scroll", r.update, kl)
                }),
                l && f.removeEventListener("resize", r.update, kl)
        }
    )
}
var th = { name: "eventListeners", enabled: !0, phase: "write", fn: function () {}, effect: wT, data: {} },
    AT = { left: "right", right: "left", bottom: "top", top: "bottom" }
function Kl(e) {
    return e.replace(/left|right|bottom|top/g, function (t) {
        return AT[t]
    })
}
var ET = { start: "end", end: "start" }
function mp(e) {
    return e.replace(/start|end/g, function (t) {
        return ET[t]
    })
}
function eh(e) {
    var t = en(e),
        r = t.pageXOffset,
        n = t.pageYOffset
    return { scrollLeft: r, scrollTop: n }
}
function rh(e) {
    return Po(Zi(e)).left + eh(e).scrollLeft
}
function xT(e, t) {
    var r = en(e),
        n = Zi(e),
        i = r.visualViewport,
        s = n.clientWidth,
        o = n.clientHeight,
        l = 0,
        f = 0
    if (i) {
        ;(s = i.width), (o = i.height)
        var d = M1()
        ;(d || (!d && t === "fixed")) && ((l = i.offsetLeft), (f = i.offsetTop))
    }
    return { width: s, height: o, x: l + rh(e), y: f }
}
function TT(e) {
    var t,
        r = Zi(e),
        n = eh(e),
        i = (t = e.ownerDocument) == null ? void 0 : t.body,
        s = Ss(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = Ss(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        l = -n.scrollLeft + rh(e),
        f = -n.scrollTop
    return pi(i || r).direction === "rtl" && (l += Ss(r.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: l, y: f }
}
function nh(e) {
    var t = pi(e),
        r = t.overflow,
        n = t.overflowX,
        i = t.overflowY
    return /auto|scroll|overlay|hidden/.test(r + i + n)
}
function B1(e) {
    return ["html", "body", "#document"].indexOf(qn(e)) >= 0 ? e.ownerDocument.body : Yr(e) && nh(e) ? e : B1(of(e))
}
function ka(e, t) {
    var r
    t === void 0 && (t = [])
    var n = B1(e),
        i = n === ((r = e.ownerDocument) == null ? void 0 : r.body),
        s = en(n),
        o = i ? [s].concat(s.visualViewport || [], nh(n) ? n : []) : n,
        l = t.concat(o)
    return i ? l : l.concat(ka(of(o)))
}
function jc(e) {
    return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height })
}
function CT(e, t) {
    var r = Po(e, !1, t === "fixed")
    return (
        (r.top = r.top + e.clientTop),
        (r.left = r.left + e.clientLeft),
        (r.bottom = r.top + e.clientHeight),
        (r.right = r.left + e.clientWidth),
        (r.width = e.clientWidth),
        (r.height = e.clientHeight),
        (r.x = r.left),
        (r.y = r.top),
        r
    )
}
function vp(e, t, r) {
    return t === Gd ? jc(xT(e, r)) : Ls(t) ? CT(t, r) : jc(TT(Zi(e)))
}
function MT(e) {
    var t = ka(of(e)),
        r = ["absolute", "fixed"].indexOf(pi(e).position) >= 0,
        n = r && Yr(e) ? ll(e) : e
    return Ls(n)
        ? t.filter(function (i) {
              return Ls(i) && S1(i, n) && qn(i) !== "body"
          })
        : []
}
function ST(e, t, r, n) {
    var i = t === "clippingParents" ? MT(e) : [].concat(t),
        s = [].concat(i, [r]),
        o = s[0],
        l = s.reduce(function (f, d) {
            var h = vp(e, d, n)
            return (
                (f.top = Ss(h.top, f.top)),
                (f.right = _u(h.right, f.right)),
                (f.bottom = _u(h.bottom, f.bottom)),
                (f.left = Ss(h.left, f.left)),
                f
            )
        }, vp(e, o, n))
    return (l.width = l.right - l.left), (l.height = l.bottom - l.top), (l.x = l.left), (l.y = l.top), l
}
function P1(e) {
    var t = e.reference,
        r = e.element,
        n = e.placement,
        i = n ? $n(n) : null,
        s = n ? Ro(n) : null,
        o = t.x + t.width / 2 - r.width / 2,
        l = t.y + t.height / 2 - r.height / 2,
        f
    switch (i) {
        case gr:
            f = { x: o, y: t.y - r.height }
            break
        case Lr:
            f = { x: o, y: t.y + t.height }
            break
        case Dr:
            f = { x: t.x + t.width, y: l }
            break
        case mr:
            f = { x: t.x - r.width, y: l }
            break
        default:
            f = { x: t.x, y: t.y }
    }
    var d = i ? Xd(i) : null
    if (d != null) {
        var h = d === "y" ? "height" : "width"
        switch (s) {
            case Rs:
                f[d] = f[d] - (t[h] / 2 - r[h] / 2)
                break
            case Io:
                f[d] = f[d] + (t[h] / 2 - r[h] / 2)
                break
        }
    }
    return f
}
function Lo(e, t) {
    t === void 0 && (t = {})
    var r = t,
        n = r.placement,
        i = n === void 0 ? e.placement : n,
        s = r.strategy,
        o = s === void 0 ? e.strategy : s,
        l = r.boundary,
        f = l === void 0 ? g1 : l,
        d = r.rootBoundary,
        h = d === void 0 ? Gd : d,
        y = r.elementContext,
        E = y === void 0 ? so : y,
        T = r.altBoundary,
        S = T === void 0 ? !1 : T,
        N = r.padding,
        P = N === void 0 ? 0 : N,
        M = N1(typeof P != "number" ? P : O1(P, Yo)),
        k = E === so ? m1 : so,
        F = e.rects.popper,
        $ = e.elements[S ? k : E],
        R = ST(Ls($) ? $ : $.contextElement || Zi(e.elements.popper), f, h, o),
        W = Po(e.elements.reference),
        nt = P1({ reference: W, element: F, strategy: "absolute", placement: i }),
        J = jc(Object.assign({}, F, nt)),
        Q = E === so ? J : W,
        ot = {
            top: R.top - Q.top + M.top,
            bottom: Q.bottom - R.bottom + M.bottom,
            left: R.left - Q.left + M.left,
            right: Q.right - R.right + M.right,
        },
        it = e.modifiersData.offset
    if (E === so && it) {
        var at = it[i]
        Object.keys(ot).forEach(function (x) {
            var a = [Dr, Lr].indexOf(x) >= 0 ? 1 : -1,
                c = [gr, Lr].indexOf(x) >= 0 ? "y" : "x"
            ot[x] += at[c] * a
        })
    }
    return ot
}
function kT(e, t) {
    t === void 0 && (t = {})
    var r = t,
        n = r.placement,
        i = r.boundary,
        s = r.rootBoundary,
        o = r.padding,
        l = r.flipVariations,
        f = r.allowedAutoPlacements,
        d = f === void 0 ? Wd : f,
        h = Ro(n),
        y = h
            ? l
                ? qc
                : qc.filter(function (S) {
                      return Ro(S) === h
                  })
            : Yo,
        E = y.filter(function (S) {
            return d.indexOf(S) >= 0
        })
    E.length === 0 && (E = y)
    var T = E.reduce(function (S, N) {
        return (S[N] = Lo(e, { placement: N, boundary: i, rootBoundary: s, padding: o })[$n(N)]), S
    }, {})
    return Object.keys(T).sort(function (S, N) {
        return T[S] - T[N]
    })
}
function NT(e) {
    if ($n(e) === sf) return []
    var t = Kl(e)
    return [mp(e), t, mp(t)]
}
function OT(e) {
    var t = e.state,
        r = e.options,
        n = e.name
    if (!t.modifiersData[n]._skip) {
        for (
            var i = r.mainAxis,
                s = i === void 0 ? !0 : i,
                o = r.altAxis,
                l = o === void 0 ? !0 : o,
                f = r.fallbackPlacements,
                d = r.padding,
                h = r.boundary,
                y = r.rootBoundary,
                E = r.altBoundary,
                T = r.flipVariations,
                S = T === void 0 ? !0 : T,
                N = r.allowedAutoPlacements,
                P = t.options.placement,
                M = $n(P),
                k = M === P,
                F = f || (k || !S ? [Kl(P)] : NT(P)),
                $ = [P].concat(F).reduce(function (H, b) {
                    return H.concat(
                        $n(b) === sf
                            ? kT(t, { placement: b, boundary: h, rootBoundary: y, padding: d, flipVariations: S, allowedAutoPlacements: N })
                            : b
                    )
                }, []),
                R = t.rects.reference,
                W = t.rects.popper,
                nt = new Map(),
                J = !0,
                Q = $[0],
                ot = 0;
            ot < $.length;
            ot++
        ) {
            var it = $[ot],
                at = $n(it),
                x = Ro(it) === Rs,
                a = [gr, Lr].indexOf(at) >= 0,
                c = a ? "width" : "height",
                m = Lo(t, { placement: it, boundary: h, rootBoundary: y, altBoundary: E, padding: d }),
                _ = a ? (x ? Dr : mr) : x ? Lr : gr
            R[c] > W[c] && (_ = Kl(_))
            var A = Kl(_),
                w = []
            if (
                (s && w.push(m[at] <= 0),
                l && w.push(m[_] <= 0, m[A] <= 0),
                w.every(function (H) {
                    return H
                }))
            ) {
                ;(Q = it), (J = !1)
                break
            }
            nt.set(it, w)
        }
        if (J)
            for (
                var v = S ? 3 : 1,
                    g = function (b) {
                        var B = $.find(function (D) {
                            var U = nt.get(D)
                            if (U)
                                return U.slice(0, b).every(function (j) {
                                    return j
                                })
                        })
                        if (B) return (Q = B), "break"
                    },
                    u = v;
                u > 0;
                u--
            ) {
                var p = g(u)
                if (p === "break") break
            }
        t.placement !== Q && ((t.modifiersData[n]._skip = !0), (t.placement = Q), (t.reset = !0))
    }
}
var R1 = { name: "flip", enabled: !0, phase: "main", fn: OT, requiresIfExists: ["offset"], data: { _skip: !1 } }
function bp(e, t, r) {
    return (
        r === void 0 && (r = { x: 0, y: 0 }),
        { top: e.top - t.height - r.y, right: e.right - t.width + r.x, bottom: e.bottom - t.height + r.y, left: e.left - t.width - r.x }
    )
}
function yp(e) {
    return [gr, Dr, Lr, mr].some(function (t) {
        return e[t] >= 0
    })
}
function IT(e) {
    var t = e.state,
        r = e.name,
        n = t.rects.reference,
        i = t.rects.popper,
        s = t.modifiersData.preventOverflow,
        o = Lo(t, { elementContext: "reference" }),
        l = Lo(t, { altBoundary: !0 }),
        f = bp(o, n),
        d = bp(l, i, s),
        h = yp(f),
        y = yp(d)
    ;(t.modifiersData[r] = { referenceClippingOffsets: f, popperEscapeOffsets: d, isReferenceHidden: h, hasPopperEscaped: y }),
        (t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": h, "data-popper-escaped": y }))
}
var L1 = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: IT }
function BT(e, t, r) {
    var n = $n(e),
        i = [mr, gr].indexOf(n) >= 0 ? -1 : 1,
        s = typeof r == "function" ? r(Object.assign({}, t, { placement: e })) : r,
        o = s[0],
        l = s[1]
    return (o = o || 0), (l = (l || 0) * i), [mr, Dr].indexOf(n) >= 0 ? { x: l, y: o } : { x: o, y: l }
}
function PT(e) {
    var t = e.state,
        r = e.options,
        n = e.name,
        i = r.offset,
        s = i === void 0 ? [0, 0] : i,
        o = Wd.reduce(function (h, y) {
            return (h[y] = BT(y, t.rects, s)), h
        }, {}),
        l = o[t.placement],
        f = l.x,
        d = l.y
    t.modifiersData.popperOffsets != null && ((t.modifiersData.popperOffsets.x += f), (t.modifiersData.popperOffsets.y += d)),
        (t.modifiersData[n] = o)
}
var D1 = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: PT }
function RT(e) {
    var t = e.state,
        r = e.name
    t.modifiersData[r] = P1({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement })
}
var ih = { name: "popperOffsets", enabled: !0, phase: "read", fn: RT, data: {} }
function LT(e) {
    return e === "x" ? "y" : "x"
}
function DT(e) {
    var t = e.state,
        r = e.options,
        n = e.name,
        i = r.mainAxis,
        s = i === void 0 ? !0 : i,
        o = r.altAxis,
        l = o === void 0 ? !1 : o,
        f = r.boundary,
        d = r.rootBoundary,
        h = r.altBoundary,
        y = r.padding,
        E = r.tether,
        T = E === void 0 ? !0 : E,
        S = r.tetherOffset,
        N = S === void 0 ? 0 : S,
        P = Lo(t, { boundary: f, rootBoundary: d, padding: y, altBoundary: h }),
        M = $n(t.placement),
        k = Ro(t.placement),
        F = !k,
        $ = Xd(M),
        R = LT($),
        W = t.modifiersData.popperOffsets,
        nt = t.rects.reference,
        J = t.rects.popper,
        Q = typeof N == "function" ? N(Object.assign({}, t.rects, { placement: t.placement })) : N,
        ot = typeof Q == "number" ? { mainAxis: Q, altAxis: Q } : Object.assign({ mainAxis: 0, altAxis: 0 }, Q),
        it = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
        at = { x: 0, y: 0 }
    if (!!W) {
        if (s) {
            var x,
                a = $ === "y" ? gr : mr,
                c = $ === "y" ? Lr : Dr,
                m = $ === "y" ? "height" : "width",
                _ = W[$],
                A = _ + P[a],
                w = _ - P[c],
                v = T ? -J[m] / 2 : 0,
                g = k === Rs ? nt[m] : J[m],
                u = k === Rs ? -J[m] : -nt[m],
                p = t.elements.arrow,
                H = T && p ? Qd(p) : { width: 0, height: 0 },
                b = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : k1(),
                B = b[a],
                D = b[c],
                U = Sa(0, nt[m], H[m]),
                j = F ? nt[m] / 2 - v - U - B - ot.mainAxis : g - U - B - ot.mainAxis,
                dt = F ? -nt[m] / 2 + v + U + D + ot.mainAxis : u + U + D + ot.mainAxis,
                Z = t.elements.arrow && ll(t.elements.arrow),
                et = Z ? ($ === "y" ? Z.clientTop || 0 : Z.clientLeft || 0) : 0,
                C = (x = it == null ? void 0 : it[$]) != null ? x : 0,
                O = _ + j - C - et,
                I = _ + dt - C,
                G = Sa(T ? _u(A, O) : A, _, T ? Ss(w, I) : w)
            ;(W[$] = G), (at[$] = G - _)
        }
        if (l) {
            var q,
                X = $ === "x" ? gr : mr,
                lt = $ === "x" ? Lr : Dr,
                tt = W[R],
                rt = R === "y" ? "height" : "width",
                st = tt + P[X],
                ct = tt - P[lt],
                ht = [gr, mr].indexOf(M) !== -1,
                gt = (q = it == null ? void 0 : it[R]) != null ? q : 0,
                pt = ht ? st : tt - nt[rt] - J[rt] - gt + ot.altAxis,
                vt = ht ? tt + nt[rt] + J[rt] - gt - ot.altAxis : ct,
                Tt = T && ht ? pT(pt, tt, vt) : Sa(T ? pt : st, tt, T ? vt : ct)
            ;(W[R] = Tt), (at[R] = Tt - tt)
        }
        t.modifiersData[n] = at
    }
}
var $1 = { name: "preventOverflow", enabled: !0, phase: "main", fn: DT, requiresIfExists: ["offset"] }
function $T(e) {
    return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
}
function FT(e) {
    return e === en(e) || !Yr(e) ? eh(e) : $T(e)
}
function VT(e) {
    var t = e.getBoundingClientRect(),
        r = Bo(t.width) / e.offsetWidth || 1,
        n = Bo(t.height) / e.offsetHeight || 1
    return r !== 1 || n !== 1
}
function UT(e, t, r) {
    r === void 0 && (r = !1)
    var n = Yr(t),
        i = Yr(t) && VT(t),
        s = Zi(t),
        o = Po(e, i, r),
        l = { scrollLeft: 0, scrollTop: 0 },
        f = { x: 0, y: 0 }
    return (
        (n || (!n && !r)) &&
            ((qn(t) !== "body" || nh(s)) && (l = FT(t)),
            Yr(t) ? ((f = Po(t, !0)), (f.x += t.clientLeft), (f.y += t.clientTop)) : s && (f.x = rh(s))),
        { x: o.left + l.scrollLeft - f.x, y: o.top + l.scrollTop - f.y, width: o.width, height: o.height }
    )
}
function HT(e) {
    var t = new Map(),
        r = new Set(),
        n = []
    e.forEach(function (s) {
        t.set(s.name, s)
    })
    function i(s) {
        r.add(s.name)
        var o = [].concat(s.requires || [], s.requiresIfExists || [])
        o.forEach(function (l) {
            if (!r.has(l)) {
                var f = t.get(l)
                f && i(f)
            }
        }),
            n.push(s)
    }
    return (
        e.forEach(function (s) {
            r.has(s.name) || i(s)
        }),
        n
    )
}
function qT(e) {
    var t = HT(e)
    return C1.reduce(function (r, n) {
        return r.concat(
            t.filter(function (i) {
                return i.phase === n
            })
        )
    }, [])
}
function zT(e) {
    var t
    return function () {
        return (
            t ||
                (t = new Promise(function (r) {
                    Promise.resolve().then(function () {
                        ;(t = void 0), r(e())
                    })
                })),
            t
        )
    }
}
function jT(e) {
    var t = e.reduce(function (r, n) {
        var i = r[n.name]
        return (
            (r[n.name] = i
                ? Object.assign({}, i, n, { options: Object.assign({}, i.options, n.options), data: Object.assign({}, i.data, n.data) })
                : n),
            r
        )
    }, {})
    return Object.keys(t).map(function (r) {
        return t[r]
    })
}
var _p = { placement: "bottom", modifiers: [], strategy: "absolute" }
function wp() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r]
    return !t.some(function (n) {
        return !(n && typeof n.getBoundingClientRect == "function")
    })
}
function af(e) {
    e === void 0 && (e = {})
    var t = e,
        r = t.defaultModifiers,
        n = r === void 0 ? [] : r,
        i = t.defaultOptions,
        s = i === void 0 ? _p : i
    return function (l, f, d) {
        d === void 0 && (d = s)
        var h = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, _p, s),
                modifiersData: {},
                elements: { reference: l, popper: f },
                attributes: {},
                styles: {},
            },
            y = [],
            E = !1,
            T = {
                state: h,
                setOptions: function (M) {
                    var k = typeof M == "function" ? M(h.options) : M
                    N(),
                        (h.options = Object.assign({}, s, h.options, k)),
                        (h.scrollParents = { reference: Ls(l) ? ka(l) : l.contextElement ? ka(l.contextElement) : [], popper: ka(f) })
                    var F = qT(jT([].concat(n, h.options.modifiers)))
                    return (
                        (h.orderedModifiers = F.filter(function ($) {
                            return $.enabled
                        })),
                        S(),
                        T.update()
                    )
                },
                forceUpdate: function () {
                    if (!E) {
                        var M = h.elements,
                            k = M.reference,
                            F = M.popper
                        if (!!wp(k, F)) {
                            ;(h.rects = { reference: UT(k, ll(F), h.options.strategy === "fixed"), popper: Qd(F) }),
                                (h.reset = !1),
                                (h.placement = h.options.placement),
                                h.orderedModifiers.forEach(function (ot) {
                                    return (h.modifiersData[ot.name] = Object.assign({}, ot.data))
                                })
                            for (var $ = 0; $ < h.orderedModifiers.length; $++) {
                                if (h.reset === !0) {
                                    ;(h.reset = !1), ($ = -1)
                                    continue
                                }
                                var R = h.orderedModifiers[$],
                                    W = R.fn,
                                    nt = R.options,
                                    J = nt === void 0 ? {} : nt,
                                    Q = R.name
                                typeof W == "function" && (h = W({ state: h, options: J, name: Q, instance: T }) || h)
                            }
                        }
                    }
                },
                update: zT(function () {
                    return new Promise(function (P) {
                        T.forceUpdate(), P(h)
                    })
                }),
                destroy: function () {
                    N(), (E = !0)
                },
            }
        if (!wp(l, f)) return T
        T.setOptions(d).then(function (P) {
            !E && d.onFirstUpdate && d.onFirstUpdate(P)
        })
        function S() {
            h.orderedModifiers.forEach(function (P) {
                var M = P.name,
                    k = P.options,
                    F = k === void 0 ? {} : k,
                    $ = P.effect
                if (typeof $ == "function") {
                    var R = $({ state: h, name: M, instance: T, options: F }),
                        W = function () {}
                    y.push(R || W)
                }
            })
        }
        function N() {
            y.forEach(function (P) {
                return P()
            }),
                (y = [])
        }
        return T
    }
}
var KT = af(),
    GT = [th, ih, Zd, Jd],
    WT = af({ defaultModifiers: GT }),
    YT = [th, ih, Zd, Jd, D1, R1, $1, I1, L1],
    sh = af({ defaultModifiers: YT }),
    F1 = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                popperGenerator: af,
                detectOverflow: Lo,
                createPopperBase: KT,
                createPopper: sh,
                createPopperLite: WT,
                top: gr,
                bottom: Lr,
                right: Dr,
                left: mr,
                auto: sf,
                basePlacements: Yo,
                start: Rs,
                end: Io,
                clippingParents: g1,
                viewport: Gd,
                popper: so,
                reference: m1,
                variationPlacements: qc,
                placements: Wd,
                beforeRead: v1,
                read: b1,
                afterRead: y1,
                beforeMain: _1,
                main: w1,
                afterMain: A1,
                beforeWrite: E1,
                write: x1,
                afterWrite: T1,
                modifierPhases: C1,
                applyStyles: Jd,
                arrow: I1,
                computeStyles: Zd,
                eventListeners: th,
                flip: R1,
                hide: L1,
                offset: D1,
                popperOffsets: ih,
                preventOverflow: $1,
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    )
/*!
 * Bootstrap v5.2.0 (https://getbootstrap.com/)
 * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */ const JT = 1e6,
    QT = 1e3,
    Kc = "transitionend",
    XT = (e) =>
        e == null
            ? `${e}`
            : Object.prototype.toString
                  .call(e)
                  .match(/\s([a-z]+)/i)[1]
                  .toLowerCase(),
    ZT = (e) => {
        do e += Math.floor(Math.random() * JT)
        while (document.getElementById(e))
        return e
    },
    V1 = (e) => {
        let t = e.getAttribute("data-bs-target")
        if (!t || t === "#") {
            let r = e.getAttribute("href")
            if (!r || (!r.includes("#") && !r.startsWith("."))) return null
            r.includes("#") && !r.startsWith("#") && (r = `#${r.split("#")[1]}`), (t = r && r !== "#" ? r.trim() : null)
        }
        return t
    },
    U1 = (e) => {
        const t = V1(e)
        return t && document.querySelector(t) ? t : null
    },
    ni = (e) => {
        const t = V1(e)
        return t ? document.querySelector(t) : null
    },
    tC = (e) => {
        if (!e) return 0
        let { transitionDuration: t, transitionDelay: r } = window.getComputedStyle(e)
        const n = Number.parseFloat(t),
            i = Number.parseFloat(r)
        return !n && !i ? 0 : ((t = t.split(",")[0]), (r = r.split(",")[0]), (Number.parseFloat(t) + Number.parseFloat(r)) * QT)
    },
    H1 = (e) => {
        e.dispatchEvent(new Event(Kc))
    },
    ii = (e) => (!e || typeof e != "object" ? !1 : (typeof e.jquery != "undefined" && (e = e[0]), typeof e.nodeType != "undefined")),
    Yi = (e) => (ii(e) ? (e.jquery ? e[0] : e) : typeof e == "string" && e.length > 0 ? document.querySelector(e) : null),
    Jo = (e) => {
        if (!ii(e) || e.getClientRects().length === 0) return !1
        const t = getComputedStyle(e).getPropertyValue("visibility") === "visible",
            r = e.closest("details:not([open])")
        if (!r) return t
        if (r !== e) {
            const n = e.closest("summary")
            if ((n && n.parentNode !== r) || n === null) return !1
        }
        return t
    },
    Ji = (e) =>
        !e || e.nodeType !== Node.ELEMENT_NODE || e.classList.contains("disabled")
            ? !0
            : typeof e.disabled != "undefined"
            ? e.disabled
            : e.hasAttribute("disabled") && e.getAttribute("disabled") !== "false",
    q1 = (e) => {
        if (!document.documentElement.attachShadow) return null
        if (typeof e.getRootNode == "function") {
            const t = e.getRootNode()
            return t instanceof ShadowRoot ? t : null
        }
        return e instanceof ShadowRoot ? e : e.parentNode ? q1(e.parentNode) : null
    },
    wu = () => {},
    ul = (e) => {
        e.offsetHeight
    },
    z1 = () => (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null),
    Hf = [],
    eC = (e) => {
        document.readyState === "loading"
            ? (Hf.length ||
                  document.addEventListener("DOMContentLoaded", () => {
                      for (const t of Hf) t()
                  }),
              Hf.push(e))
            : e()
    },
    Qr = () => document.documentElement.dir === "rtl",
    rn = (e) => {
        eC(() => {
            const t = z1()
            if (t) {
                const r = e.NAME,
                    n = t.fn[r]
                ;(t.fn[r] = e.jQueryInterface), (t.fn[r].Constructor = e), (t.fn[r].noConflict = () => ((t.fn[r] = n), e.jQueryInterface))
            }
        })
    },
    ti = (e) => {
        typeof e == "function" && e()
    },
    j1 = (e, t, r = !0) => {
        if (!r) {
            ti(e)
            return
        }
        const n = 5,
            i = tC(t) + n
        let s = !1
        const o = ({ target: l }) => {
            l === t && ((s = !0), t.removeEventListener(Kc, o), ti(e))
        }
        t.addEventListener(Kc, o),
            setTimeout(() => {
                s || H1(t)
            }, i)
    },
    oh = (e, t, r, n) => {
        const i = e.length
        let s = e.indexOf(t)
        return s === -1 ? (!r && n ? e[i - 1] : e[0]) : ((s += r ? 1 : -1), n && (s = (s + i) % i), e[Math.max(0, Math.min(s, i - 1))])
    },
    rC = /[^.]*(?=\..*)\.|.*/,
    nC = /\..*/,
    iC = /::\d+$/,
    qf = {}
let Ap = 1
const K1 = { mouseenter: "mouseover", mouseleave: "mouseout" },
    sC = new Set([
        "click",
        "dblclick",
        "mouseup",
        "mousedown",
        "contextmenu",
        "mousewheel",
        "DOMMouseScroll",
        "mouseover",
        "mouseout",
        "mousemove",
        "selectstart",
        "selectend",
        "keydown",
        "keypress",
        "keyup",
        "orientationchange",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "pointerdown",
        "pointermove",
        "pointerup",
        "pointerleave",
        "pointercancel",
        "gesturestart",
        "gesturechange",
        "gestureend",
        "focus",
        "blur",
        "change",
        "reset",
        "select",
        "submit",
        "focusin",
        "focusout",
        "load",
        "unload",
        "beforeunload",
        "resize",
        "move",
        "DOMContentLoaded",
        "readystatechange",
        "error",
        "abort",
        "scroll",
    ])
function G1(e, t) {
    return (t && `${t}::${Ap++}`) || e.uidEvent || Ap++
}
function W1(e) {
    const t = G1(e)
    return (e.uidEvent = t), (qf[t] = qf[t] || {}), qf[t]
}
function oC(e, t) {
    return function r(n) {
        return ah(n, { delegateTarget: e }), r.oneOff && yt.off(e, n.type, t), t.apply(e, [n])
    }
}
function aC(e, t, r) {
    return function n(i) {
        const s = e.querySelectorAll(t)
        for (let { target: o } = i; o && o !== this; o = o.parentNode)
            for (const l of s) if (l === o) return ah(i, { delegateTarget: o }), n.oneOff && yt.off(e, i.type, t, r), r.apply(o, [i])
    }
}
function Y1(e, t, r = null) {
    return Object.values(e).find((n) => n.callable === t && n.delegationSelector === r)
}
function J1(e, t, r) {
    const n = typeof t == "string",
        i = n ? r : t || r
    let s = Q1(e)
    return sC.has(s) || (s = e), [n, i, s]
}
function Ep(e, t, r, n, i) {
    if (typeof t != "string" || !e) return
    let [s, o, l] = J1(t, r, n)
    t in K1 &&
        (o = ((S) =>
            function (N) {
                if (!N.relatedTarget || (N.relatedTarget !== N.delegateTarget && !N.delegateTarget.contains(N.relatedTarget)))
                    return S.call(this, N)
            })(o))
    const f = W1(e),
        d = f[l] || (f[l] = {}),
        h = Y1(d, o, s ? r : null)
    if (h) {
        h.oneOff = h.oneOff && i
        return
    }
    const y = G1(o, t.replace(rC, "")),
        E = s ? aC(e, r, o) : oC(e, o)
    ;(E.delegationSelector = s ? r : null), (E.callable = o), (E.oneOff = i), (E.uidEvent = y), (d[y] = E), e.addEventListener(l, E, s)
}
function Gc(e, t, r, n, i) {
    const s = Y1(t[r], n, i)
    !s || (e.removeEventListener(r, s, Boolean(i)), delete t[r][s.uidEvent])
}
function lC(e, t, r, n) {
    const i = t[r] || {}
    for (const s of Object.keys(i))
        if (s.includes(n)) {
            const o = i[s]
            Gc(e, t, r, o.callable, o.delegationSelector)
        }
}
function Q1(e) {
    return (e = e.replace(nC, "")), K1[e] || e
}
const yt = {
    on(e, t, r, n) {
        Ep(e, t, r, n, !1)
    },
    one(e, t, r, n) {
        Ep(e, t, r, n, !0)
    },
    off(e, t, r, n) {
        if (typeof t != "string" || !e) return
        const [i, s, o] = J1(t, r, n),
            l = o !== t,
            f = W1(e),
            d = f[o] || {},
            h = t.startsWith(".")
        if (typeof s != "undefined") {
            if (!Object.keys(d).length) return
            Gc(e, f, o, s, i ? r : null)
            return
        }
        if (h) for (const y of Object.keys(f)) lC(e, f, y, t.slice(1))
        for (const y of Object.keys(d)) {
            const E = y.replace(iC, "")
            if (!l || t.includes(E)) {
                const T = d[y]
                Gc(e, f, o, T.callable, T.delegationSelector)
            }
        }
    },
    trigger(e, t, r) {
        if (typeof t != "string" || !e) return null
        const n = z1(),
            i = Q1(t),
            s = t !== i
        let o = null,
            l = !0,
            f = !0,
            d = !1
        s &&
            n &&
            ((o = n.Event(t, r)),
            n(e).trigger(o),
            (l = !o.isPropagationStopped()),
            (f = !o.isImmediatePropagationStopped()),
            (d = o.isDefaultPrevented()))
        let h = new Event(t, { bubbles: l, cancelable: !0 })
        return (h = ah(h, r)), d && h.preventDefault(), f && e.dispatchEvent(h), h.defaultPrevented && o && o.preventDefault(), h
    },
}
function ah(e, t) {
    for (const [r, n] of Object.entries(t || {}))
        try {
            e[r] = n
        } catch {
            Object.defineProperty(e, r, {
                configurable: !0,
                get() {
                    return n
                },
            })
        }
    return e
}
const Mi = new Map(),
    zf = {
        set(e, t, r) {
            Mi.has(e) || Mi.set(e, new Map())
            const n = Mi.get(e)
            if (!n.has(t) && n.size !== 0) {
                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
                return
            }
            n.set(t, r)
        },
        get(e, t) {
            return (Mi.has(e) && Mi.get(e).get(t)) || null
        },
        remove(e, t) {
            if (!Mi.has(e)) return
            const r = Mi.get(e)
            r.delete(t), r.size === 0 && Mi.delete(e)
        },
    }
function xp(e) {
    if (e === "true") return !0
    if (e === "false") return !1
    if (e === Number(e).toString()) return Number(e)
    if (e === "" || e === "null") return null
    if (typeof e != "string") return e
    try {
        return JSON.parse(decodeURIComponent(e))
    } catch {
        return e
    }
}
function jf(e) {
    return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`)
}
const si = {
    setDataAttribute(e, t, r) {
        e.setAttribute(`data-bs-${jf(t)}`, r)
    },
    removeDataAttribute(e, t) {
        e.removeAttribute(`data-bs-${jf(t)}`)
    },
    getDataAttributes(e) {
        if (!e) return {}
        const t = {},
            r = Object.keys(e.dataset).filter((n) => n.startsWith("bs") && !n.startsWith("bsConfig"))
        for (const n of r) {
            let i = n.replace(/^bs/, "")
            ;(i = i.charAt(0).toLowerCase() + i.slice(1, i.length)), (t[i] = xp(e.dataset[n]))
        }
        return t
    },
    getDataAttribute(e, t) {
        return xp(e.getAttribute(`data-bs-${jf(t)}`))
    },
}
class fl {
    static get Default() {
        return {}
    }
    static get DefaultType() {
        return {}
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!')
    }
    _getConfig(t) {
        return (t = this._mergeConfigObj(t)), (t = this._configAfterMerge(t)), this._typeCheckConfig(t), t
    }
    _configAfterMerge(t) {
        return t
    }
    _mergeConfigObj(t, r) {
        const n = ii(r) ? si.getDataAttribute(r, "config") : {}
        return {
            ...this.constructor.Default,
            ...(typeof n == "object" ? n : {}),
            ...(ii(r) ? si.getDataAttributes(r) : {}),
            ...(typeof t == "object" ? t : {}),
        }
    }
    _typeCheckConfig(t, r = this.constructor.DefaultType) {
        for (const n of Object.keys(r)) {
            const i = r[n],
                s = t[n],
                o = ii(s) ? "element" : XT(s)
            if (!new RegExp(i).test(o))
                throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${o}" but expected type "${i}".`)
        }
    }
}
const uC = "5.2.0"
class mn extends fl {
    constructor(t, r) {
        super(),
            (t = Yi(t)),
            t && ((this._element = t), (this._config = this._getConfig(r)), zf.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
        zf.remove(this._element, this.constructor.DATA_KEY), yt.off(this._element, this.constructor.EVENT_KEY)
        for (const t of Object.getOwnPropertyNames(this)) this[t] = null
    }
    _queueCallback(t, r, n = !0) {
        j1(t, r, n)
    }
    _getConfig(t) {
        return (t = this._mergeConfigObj(t, this._element)), (t = this._configAfterMerge(t)), this._typeCheckConfig(t), t
    }
    static getInstance(t) {
        return zf.get(Yi(t), this.DATA_KEY)
    }
    static getOrCreateInstance(t, r = {}) {
        return this.getInstance(t) || new this(t, typeof r == "object" ? r : null)
    }
    static get VERSION() {
        return uC
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`
    }
    static eventName(t) {
        return `${t}${this.EVENT_KEY}`
    }
}
const lf = (e, t = "hide") => {
        const r = `click.dismiss${e.EVENT_KEY}`,
            n = e.NAME
        yt.on(document, r, `[data-bs-dismiss="${n}"]`, function (i) {
            if ((["A", "AREA"].includes(this.tagName) && i.preventDefault(), Ji(this))) return
            const s = ni(this) || this.closest(`.${n}`)
            e.getOrCreateInstance(s)[t]()
        })
    },
    fC = "alert",
    cC = "bs.alert",
    X1 = `.${cC}`,
    dC = `close${X1}`,
    hC = `closed${X1}`,
    pC = "fade",
    gC = "show"
class cl extends mn {
    static get NAME() {
        return fC
    }
    close() {
        if (yt.trigger(this._element, dC).defaultPrevented) return
        this._element.classList.remove(gC)
        const r = this._element.classList.contains(pC)
        this._queueCallback(() => this._destroyElement(), this._element, r)
    }
    _destroyElement() {
        this._element.remove(), yt.trigger(this._element, hC), this.dispose()
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = cl.getOrCreateInstance(this)
            if (typeof t == "string") {
                if (r[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`)
                r[t](this)
            }
        })
    }
}
lf(cl, "close")
rn(cl)
const mC = "button",
    vC = "bs.button",
    bC = `.${vC}`,
    yC = ".data-api",
    _C = "active",
    Tp = '[data-bs-toggle="button"]',
    wC = `click${bC}${yC}`
class uf extends mn {
    static get NAME() {
        return mC
    }
    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(_C))
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = uf.getOrCreateInstance(this)
            t === "toggle" && r[t]()
        })
    }
}
yt.on(document, wC, Tp, (e) => {
    e.preventDefault()
    const t = e.target.closest(Tp)
    uf.getOrCreateInstance(t).toggle()
})
rn(uf)
const ye = {
        find(e, t = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(t, e))
        },
        findOne(e, t = document.documentElement) {
            return Element.prototype.querySelector.call(t, e)
        },
        children(e, t) {
            return [].concat(...e.children).filter((r) => r.matches(t))
        },
        parents(e, t) {
            const r = []
            let n = e.parentNode.closest(t)
            for (; n; ) r.push(n), (n = n.parentNode.closest(t))
            return r
        },
        prev(e, t) {
            let r = e.previousElementSibling
            for (; r; ) {
                if (r.matches(t)) return [r]
                r = r.previousElementSibling
            }
            return []
        },
        next(e, t) {
            let r = e.nextElementSibling
            for (; r; ) {
                if (r.matches(t)) return [r]
                r = r.nextElementSibling
            }
            return []
        },
        focusableChildren(e) {
            const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]']
                .map((r) => `${r}:not([tabindex^="-"])`)
                .join(",")
            return this.find(t, e).filter((r) => !Ji(r) && Jo(r))
        },
    },
    AC = "swipe",
    Qo = ".bs.swipe",
    EC = `touchstart${Qo}`,
    xC = `touchmove${Qo}`,
    TC = `touchend${Qo}`,
    CC = `pointerdown${Qo}`,
    MC = `pointerup${Qo}`,
    SC = "touch",
    kC = "pen",
    NC = "pointer-event",
    OC = 40,
    IC = { endCallback: null, leftCallback: null, rightCallback: null },
    BC = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }
class Au extends fl {
    constructor(t, r) {
        super(),
            (this._element = t),
            !(!t || !Au.isSupported()) &&
                ((this._config = this._getConfig(r)),
                (this._deltaX = 0),
                (this._supportPointerEvents = Boolean(window.PointerEvent)),
                this._initEvents())
    }
    static get Default() {
        return IC
    }
    static get DefaultType() {
        return BC
    }
    static get NAME() {
        return AC
    }
    dispose() {
        yt.off(this._element, Qo)
    }
    _start(t) {
        if (!this._supportPointerEvents) {
            this._deltaX = t.touches[0].clientX
            return
        }
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
    }
    _end(t) {
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), ti(this._config.endCallback)
    }
    _move(t) {
        this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
    }
    _handleSwipe() {
        const t = Math.abs(this._deltaX)
        if (t <= OC) return
        const r = t / this._deltaX
        ;(this._deltaX = 0), r && ti(r > 0 ? this._config.rightCallback : this._config.leftCallback)
    }
    _initEvents() {
        this._supportPointerEvents
            ? (yt.on(this._element, CC, (t) => this._start(t)), yt.on(this._element, MC, (t) => this._end(t)), this._element.classList.add(NC))
            : (yt.on(this._element, EC, (t) => this._start(t)),
              yt.on(this._element, xC, (t) => this._move(t)),
              yt.on(this._element, TC, (t) => this._end(t)))
    }
    _eventIsPointerPenTouch(t) {
        return this._supportPointerEvents && (t.pointerType === kC || t.pointerType === SC)
    }
    static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
    }
}
const PC = "carousel",
    RC = "bs.carousel",
    ts = `.${RC}`,
    Z1 = ".data-api",
    LC = "ArrowLeft",
    DC = "ArrowRight",
    $C = 500,
    ua = "next",
    Qs = "prev",
    oo = "left",
    Gl = "right",
    FC = `slide${ts}`,
    Kf = `slid${ts}`,
    VC = `keydown${ts}`,
    UC = `mouseenter${ts}`,
    HC = `mouseleave${ts}`,
    qC = `dragstart${ts}`,
    zC = `load${ts}${Z1}`,
    jC = `click${ts}${Z1}`,
    tb = "carousel",
    Nl = "active",
    KC = "slide",
    GC = "carousel-item-end",
    WC = "carousel-item-start",
    YC = "carousel-item-next",
    JC = "carousel-item-prev",
    eb = ".active",
    rb = ".carousel-item",
    QC = eb + rb,
    XC = ".carousel-item img",
    ZC = ".carousel-indicators",
    t3 = "[data-bs-slide], [data-bs-slide-to]",
    e3 = '[data-bs-ride="carousel"]',
    r3 = { [LC]: Gl, [DC]: oo },
    n3 = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 },
    i3 = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean",
    }
class Xo extends mn {
    constructor(t, r) {
        super(t, r),
            (this._interval = null),
            (this._activeElement = null),
            (this._isSliding = !1),
            (this.touchTimeout = null),
            (this._swipeHelper = null),
            (this._indicatorsElement = ye.findOne(ZC, this._element)),
            this._addEventListeners(),
            this._config.ride === tb && this.cycle()
    }
    static get Default() {
        return n3
    }
    static get DefaultType() {
        return i3
    }
    static get NAME() {
        return PC
    }
    next() {
        this._slide(ua)
    }
    nextWhenVisible() {
        !document.hidden && Jo(this._element) && this.next()
    }
    prev() {
        this._slide(Qs)
    }
    pause() {
        this._isSliding && H1(this._element), this._clearInterval()
    }
    cycle() {
        this._clearInterval(), this._updateInterval(), (this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval))
    }
    _maybeEnableCycle() {
        if (!!this._config.ride) {
            if (this._isSliding) {
                yt.one(this._element, Kf, () => this.cycle())
                return
            }
            this.cycle()
        }
    }
    to(t) {
        const r = this._getItems()
        if (t > r.length - 1 || t < 0) return
        if (this._isSliding) {
            yt.one(this._element, Kf, () => this.to(t))
            return
        }
        const n = this._getItemIndex(this._getActive())
        if (n === t) return
        const i = t > n ? ua : Qs
        this._slide(i, r[t])
    }
    dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
    }
    _configAfterMerge(t) {
        return (t.defaultInterval = t.interval), t
    }
    _addEventListeners() {
        this._config.keyboard && yt.on(this._element, VC, (t) => this._keydown(t)),
            this._config.pause === "hover" &&
                (yt.on(this._element, UC, () => this.pause()), yt.on(this._element, HC, () => this._maybeEnableCycle())),
            this._config.touch && Au.isSupported() && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
        for (const n of ye.find(XC, this._element)) yt.on(n, qC, (i) => i.preventDefault())
        const r = {
            leftCallback: () => this._slide(this._directionToOrder(oo)),
            rightCallback: () => this._slide(this._directionToOrder(Gl)),
            endCallback: () => {
                this._config.pause === "hover" &&
                    (this.pause(),
                    this.touchTimeout && clearTimeout(this.touchTimeout),
                    (this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), $C + this._config.interval)))
            },
        }
        this._swipeHelper = new Au(this._element, r)
    }
    _keydown(t) {
        if (/input|textarea/i.test(t.target.tagName)) return
        const r = r3[t.key]
        r && (t.preventDefault(), this._slide(this._directionToOrder(r)))
    }
    _getItemIndex(t) {
        return this._getItems().indexOf(t)
    }
    _setActiveIndicatorElement(t) {
        if (!this._indicatorsElement) return
        const r = ye.findOne(eb, this._indicatorsElement)
        r.classList.remove(Nl), r.removeAttribute("aria-current")
        const n = ye.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement)
        n && (n.classList.add(Nl), n.setAttribute("aria-current", "true"))
    }
    _updateInterval() {
        const t = this._activeElement || this._getActive()
        if (!t) return
        const r = Number.parseInt(t.getAttribute("data-bs-interval"), 10)
        this._config.interval = r || this._config.defaultInterval
    }
    _slide(t, r = null) {
        if (this._isSliding) return
        const n = this._getActive(),
            i = t === ua,
            s = r || oh(this._getItems(), n, i, this._config.wrap)
        if (s === n) return
        const o = this._getItemIndex(s),
            l = (T) =>
                yt.trigger(this._element, T, { relatedTarget: s, direction: this._orderToDirection(t), from: this._getItemIndex(n), to: o })
        if (l(FC).defaultPrevented || !n || !s) return
        const d = Boolean(this._interval)
        this.pause(), (this._isSliding = !0), this._setActiveIndicatorElement(o), (this._activeElement = s)
        const h = i ? WC : GC,
            y = i ? YC : JC
        s.classList.add(y), ul(s), n.classList.add(h), s.classList.add(h)
        const E = () => {
            s.classList.remove(h, y), s.classList.add(Nl), n.classList.remove(Nl, y, h), (this._isSliding = !1), l(Kf)
        }
        this._queueCallback(E, n, this._isAnimated()), d && this.cycle()
    }
    _isAnimated() {
        return this._element.classList.contains(KC)
    }
    _getActive() {
        return ye.findOne(QC, this._element)
    }
    _getItems() {
        return ye.find(rb, this._element)
    }
    _clearInterval() {
        this._interval && (clearInterval(this._interval), (this._interval = null))
    }
    _directionToOrder(t) {
        return Qr() ? (t === oo ? Qs : ua) : t === oo ? ua : Qs
    }
    _orderToDirection(t) {
        return Qr() ? (t === Qs ? oo : Gl) : t === Qs ? Gl : oo
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = Xo.getOrCreateInstance(this, t)
            if (typeof t == "number") {
                r.to(t)
                return
            }
            if (typeof t == "string") {
                if (r[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
}
yt.on(document, jC, t3, function (e) {
    const t = ni(this)
    if (!t || !t.classList.contains(tb)) return
    e.preventDefault()
    const r = Xo.getOrCreateInstance(t),
        n = this.getAttribute("data-bs-slide-to")
    if (n) {
        r.to(n), r._maybeEnableCycle()
        return
    }
    if (si.getDataAttribute(this, "slide") === "next") {
        r.next(), r._maybeEnableCycle()
        return
    }
    r.prev(), r._maybeEnableCycle()
})
yt.on(window, zC, () => {
    const e = ye.find(e3)
    for (const t of e) Xo.getOrCreateInstance(t)
})
rn(Xo)
const s3 = "collapse",
    o3 = "bs.collapse",
    dl = `.${o3}`,
    a3 = ".data-api",
    l3 = `show${dl}`,
    u3 = `shown${dl}`,
    f3 = `hide${dl}`,
    c3 = `hidden${dl}`,
    d3 = `click${dl}${a3}`,
    Gf = "show",
    ho = "collapse",
    Ol = "collapsing",
    h3 = "collapsed",
    p3 = `:scope .${ho} .${ho}`,
    g3 = "collapse-horizontal",
    m3 = "width",
    v3 = "height",
    b3 = ".collapse.show, .collapse.collapsing",
    Wc = '[data-bs-toggle="collapse"]',
    y3 = { parent: null, toggle: !0 },
    _3 = { parent: "(null|element)", toggle: "boolean" }
class Do extends mn {
    constructor(t, r) {
        super(t, r), (this._isTransitioning = !1), (this._triggerArray = [])
        const n = ye.find(Wc)
        for (const i of n) {
            const s = U1(i),
                o = ye.find(s).filter((l) => l === this._element)
            s !== null && o.length && this._triggerArray.push(i)
        }
        this._initializeChildren(),
            this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
            this._config.toggle && this.toggle()
    }
    static get Default() {
        return y3
    }
    static get DefaultType() {
        return _3
    }
    static get NAME() {
        return s3
    }
    toggle() {
        this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (this._isTransitioning || this._isShown()) return
        let t = []
        if (
            (this._config.parent &&
                (t = this._getFirstLevelChildren(b3)
                    .filter((l) => l !== this._element)
                    .map((l) => Do.getOrCreateInstance(l, { toggle: !1 }))),
            (t.length && t[0]._isTransitioning) || yt.trigger(this._element, l3).defaultPrevented)
        )
            return
        for (const l of t) l.hide()
        const n = this._getDimension()
        this._element.classList.remove(ho),
            this._element.classList.add(Ol),
            (this._element.style[n] = 0),
            this._addAriaAndCollapsedClass(this._triggerArray, !0),
            (this._isTransitioning = !0)
        const i = () => {
                ;(this._isTransitioning = !1),
                    this._element.classList.remove(Ol),
                    this._element.classList.add(ho, Gf),
                    (this._element.style[n] = ""),
                    yt.trigger(this._element, u3)
            },
            o = `scroll${n[0].toUpperCase() + n.slice(1)}`
        this._queueCallback(i, this._element, !0), (this._element.style[n] = `${this._element[o]}px`)
    }
    hide() {
        if (this._isTransitioning || !this._isShown() || yt.trigger(this._element, f3).defaultPrevented) return
        const r = this._getDimension()
        ;(this._element.style[r] = `${this._element.getBoundingClientRect()[r]}px`),
            ul(this._element),
            this._element.classList.add(Ol),
            this._element.classList.remove(ho, Gf)
        for (const i of this._triggerArray) {
            const s = ni(i)
            s && !this._isShown(s) && this._addAriaAndCollapsedClass([i], !1)
        }
        this._isTransitioning = !0
        const n = () => {
            ;(this._isTransitioning = !1), this._element.classList.remove(Ol), this._element.classList.add(ho), yt.trigger(this._element, c3)
        }
        ;(this._element.style[r] = ""), this._queueCallback(n, this._element, !0)
    }
    _isShown(t = this._element) {
        return t.classList.contains(Gf)
    }
    _configAfterMerge(t) {
        return (t.toggle = Boolean(t.toggle)), (t.parent = Yi(t.parent)), t
    }
    _getDimension() {
        return this._element.classList.contains(g3) ? m3 : v3
    }
    _initializeChildren() {
        if (!this._config.parent) return
        const t = this._getFirstLevelChildren(Wc)
        for (const r of t) {
            const n = ni(r)
            n && this._addAriaAndCollapsedClass([r], this._isShown(n))
        }
    }
    _getFirstLevelChildren(t) {
        const r = ye.find(p3, this._config.parent)
        return ye.find(t, this._config.parent).filter((n) => !r.includes(n))
    }
    _addAriaAndCollapsedClass(t, r) {
        if (!!t.length) for (const n of t) n.classList.toggle(h3, !r), n.setAttribute("aria-expanded", r)
    }
    static jQueryInterface(t) {
        const r = {}
        return (
            typeof t == "string" && /show|hide/.test(t) && (r.toggle = !1),
            this.each(function () {
                const n = Do.getOrCreateInstance(this, r)
                if (typeof t == "string") {
                    if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                    n[t]()
                }
            })
        )
    }
}
yt.on(document, d3, Wc, function (e) {
    ;(e.target.tagName === "A" || (e.delegateTarget && e.delegateTarget.tagName === "A")) && e.preventDefault()
    const t = U1(this),
        r = ye.find(t)
    for (const n of r) Do.getOrCreateInstance(n, { toggle: !1 }).toggle()
})
rn(Do)
const Cp = "dropdown",
    w3 = "bs.dropdown",
    js = `.${w3}`,
    lh = ".data-api",
    A3 = "Escape",
    Mp = "Tab",
    E3 = "ArrowUp",
    Sp = "ArrowDown",
    x3 = 2,
    T3 = `hide${js}`,
    C3 = `hidden${js}`,
    M3 = `show${js}`,
    S3 = `shown${js}`,
    nb = `click${js}${lh}`,
    ib = `keydown${js}${lh}`,
    k3 = `keyup${js}${lh}`,
    ao = "show",
    N3 = "dropup",
    O3 = "dropend",
    I3 = "dropstart",
    B3 = "dropup-center",
    P3 = "dropdown-center",
    ff = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    R3 = `${ff}.${ao}`,
    sb = ".dropdown-menu",
    L3 = ".navbar",
    D3 = ".navbar-nav",
    $3 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
    F3 = Qr() ? "top-end" : "top-start",
    V3 = Qr() ? "top-start" : "top-end",
    U3 = Qr() ? "bottom-end" : "bottom-start",
    H3 = Qr() ? "bottom-start" : "bottom-end",
    q3 = Qr() ? "left-start" : "right-start",
    z3 = Qr() ? "right-start" : "left-start",
    j3 = "top",
    K3 = "bottom",
    G3 = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" },
    W3 = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)",
    }
class dn extends mn {
    constructor(t, r) {
        super(t, r),
            (this._popper = null),
            (this._parent = this._element.parentNode),
            (this._menu = ye.findOne(sb, this._parent)),
            (this._inNavbar = this._detectNavbar())
    }
    static get Default() {
        return G3
    }
    static get DefaultType() {
        return W3
    }
    static get NAME() {
        return Cp
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (Ji(this._element) || this._isShown()) return
        const t = { relatedTarget: this._element }
        if (!yt.trigger(this._element, M3, t).defaultPrevented) {
            if ((this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(D3)))
                for (const n of [].concat(...document.body.children)) yt.on(n, "mouseover", wu)
            this._element.focus(),
                this._element.setAttribute("aria-expanded", !0),
                this._menu.classList.add(ao),
                this._element.classList.add(ao),
                yt.trigger(this._element, S3, t)
        }
    }
    hide() {
        if (Ji(this._element) || !this._isShown()) return
        const t = { relatedTarget: this._element }
        this._completeHide(t)
    }
    dispose() {
        this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
        ;(this._inNavbar = this._detectNavbar()), this._popper && this._popper.update()
    }
    _completeHide(t) {
        if (!yt.trigger(this._element, T3, t).defaultPrevented) {
            if ("ontouchstart" in document.documentElement) for (const n of [].concat(...document.body.children)) yt.off(n, "mouseover", wu)
            this._popper && this._popper.destroy(),
                this._menu.classList.remove(ao),
                this._element.classList.remove(ao),
                this._element.setAttribute("aria-expanded", "false"),
                si.removeDataAttribute(this._menu, "popper"),
                yt.trigger(this._element, C3, t)
        }
    }
    _getConfig(t) {
        if (
            ((t = super._getConfig(t)),
            typeof t.reference == "object" && !ii(t.reference) && typeof t.reference.getBoundingClientRect != "function")
        )
            throw new TypeError(
                `${Cp.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
            )
        return t
    }
    _createPopper() {
        if (typeof F1 == "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)")
        let t = this._element
        this._config.reference === "parent"
            ? (t = this._parent)
            : ii(this._config.reference)
            ? (t = Yi(this._config.reference))
            : typeof this._config.reference == "object" && (t = this._config.reference)
        const r = this._getPopperConfig()
        this._popper = sh(t, this._menu, r)
    }
    _isShown() {
        return this._menu.classList.contains(ao)
    }
    _getPlacement() {
        const t = this._parent
        if (t.classList.contains(O3)) return q3
        if (t.classList.contains(I3)) return z3
        if (t.classList.contains(B3)) return j3
        if (t.classList.contains(P3)) return K3
        const r = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"
        return t.classList.contains(N3) ? (r ? V3 : F3) : r ? H3 : U3
    }
    _detectNavbar() {
        return this._element.closest(L3) !== null
    }
    _getOffset() {
        const { offset: t } = this._config
        return typeof t == "string" ? t.split(",").map((r) => Number.parseInt(r, 10)) : typeof t == "function" ? (r) => t(r, this._element) : t
    }
    _getPopperConfig() {
        const t = {
            placement: this._getPlacement(),
            modifiers: [
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "offset", options: { offset: this._getOffset() } },
            ],
        }
        return (
            (this._inNavbar || this._config.display === "static") &&
                (si.setDataAttribute(this._menu, "popper", "static"), (t.modifiers = [{ name: "applyStyles", enabled: !1 }])),
            { ...t, ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig) }
        )
    }
    _selectMenuItem({ key: t, target: r }) {
        const n = ye.find($3, this._menu).filter((i) => Jo(i))
        !n.length || oh(n, r, t === Sp, !n.includes(r)).focus()
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = dn.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
    static clearMenus(t) {
        if (t.button === x3 || (t.type === "keyup" && t.key !== Mp)) return
        const r = ye.find(R3)
        for (const n of r) {
            const i = dn.getInstance(n)
            if (!i || i._config.autoClose === !1) continue
            const s = t.composedPath(),
                o = s.includes(i._menu)
            if (
                s.includes(i._element) ||
                (i._config.autoClose === "inside" && !o) ||
                (i._config.autoClose === "outside" && o) ||
                (i._menu.contains(t.target) &&
                    ((t.type === "keyup" && t.key === Mp) || /input|select|option|textarea|form/i.test(t.target.tagName)))
            )
                continue
            const l = { relatedTarget: i._element }
            t.type === "click" && (l.clickEvent = t), i._completeHide(l)
        }
    }
    static dataApiKeydownHandler(t) {
        const r = /input|textarea/i.test(t.target.tagName),
            n = t.key === A3,
            i = [E3, Sp].includes(t.key)
        if ((!i && !n) || (r && !n)) return
        t.preventDefault()
        const s = ye.findOne(ff, t.delegateTarget.parentNode),
            o = dn.getOrCreateInstance(s)
        if (i) {
            t.stopPropagation(), o.show(), o._selectMenuItem(t)
            return
        }
        o._isShown() && (t.stopPropagation(), o.hide(), s.focus())
    }
}
yt.on(document, ib, ff, dn.dataApiKeydownHandler)
yt.on(document, ib, sb, dn.dataApiKeydownHandler)
yt.on(document, nb, dn.clearMenus)
yt.on(document, k3, dn.clearMenus)
yt.on(document, nb, ff, function (e) {
    e.preventDefault(), dn.getOrCreateInstance(this).toggle()
})
rn(dn)
const kp = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    Np = ".sticky-top",
    Il = "padding-right",
    Op = "margin-right"
class Yc {
    constructor() {
        this._element = document.body
    }
    getWidth() {
        const t = document.documentElement.clientWidth
        return Math.abs(window.innerWidth - t)
    }
    hide() {
        const t = this.getWidth()
        this._disableOverFlow(),
            this._setElementAttributes(this._element, Il, (r) => r + t),
            this._setElementAttributes(kp, Il, (r) => r + t),
            this._setElementAttributes(Np, Op, (r) => r - t)
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow"),
            this._resetElementAttributes(this._element, Il),
            this._resetElementAttributes(kp, Il),
            this._resetElementAttributes(Np, Op)
    }
    isOverflowing() {
        return this.getWidth() > 0
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), (this._element.style.overflow = "hidden")
    }
    _setElementAttributes(t, r, n) {
        const i = this.getWidth(),
            s = (o) => {
                if (o !== this._element && window.innerWidth > o.clientWidth + i) return
                this._saveInitialAttribute(o, r)
                const l = window.getComputedStyle(o).getPropertyValue(r)
                o.style.setProperty(r, `${n(Number.parseFloat(l))}px`)
            }
        this._applyManipulationCallback(t, s)
    }
    _saveInitialAttribute(t, r) {
        const n = t.style.getPropertyValue(r)
        n && si.setDataAttribute(t, r, n)
    }
    _resetElementAttributes(t, r) {
        const n = (i) => {
            const s = si.getDataAttribute(i, r)
            if (s === null) {
                i.style.removeProperty(r)
                return
            }
            si.removeDataAttribute(i, r), i.style.setProperty(r, s)
        }
        this._applyManipulationCallback(t, n)
    }
    _applyManipulationCallback(t, r) {
        if (ii(t)) {
            r(t)
            return
        }
        for (const n of ye.find(t, this._element)) r(n)
    }
}
const ob = "backdrop",
    Y3 = "fade",
    Ip = "show",
    Bp = `mousedown.bs.${ob}`,
    J3 = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" },
    Q3 = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }
class ab extends fl {
    constructor(t) {
        super(), (this._config = this._getConfig(t)), (this._isAppended = !1), (this._element = null)
    }
    static get Default() {
        return J3
    }
    static get DefaultType() {
        return Q3
    }
    static get NAME() {
        return ob
    }
    show(t) {
        if (!this._config.isVisible) {
            ti(t)
            return
        }
        this._append()
        const r = this._getElement()
        this._config.isAnimated && ul(r),
            r.classList.add(Ip),
            this._emulateAnimation(() => {
                ti(t)
            })
    }
    hide(t) {
        if (!this._config.isVisible) {
            ti(t)
            return
        }
        this._getElement().classList.remove(Ip),
            this._emulateAnimation(() => {
                this.dispose(), ti(t)
            })
    }
    dispose() {
        !this._isAppended || (yt.off(this._element, Bp), this._element.remove(), (this._isAppended = !1))
    }
    _getElement() {
        if (!this._element) {
            const t = document.createElement("div")
            ;(t.className = this._config.className), this._config.isAnimated && t.classList.add(Y3), (this._element = t)
        }
        return this._element
    }
    _configAfterMerge(t) {
        return (t.rootElement = Yi(t.rootElement)), t
    }
    _append() {
        if (this._isAppended) return
        const t = this._getElement()
        this._config.rootElement.append(t),
            yt.on(t, Bp, () => {
                ti(this._config.clickCallback)
            }),
            (this._isAppended = !0)
    }
    _emulateAnimation(t) {
        j1(t, this._getElement(), this._config.isAnimated)
    }
}
const X3 = "focustrap",
    Z3 = "bs.focustrap",
    Eu = `.${Z3}`,
    tM = `focusin${Eu}`,
    eM = `keydown.tab${Eu}`,
    rM = "Tab",
    nM = "forward",
    Pp = "backward",
    iM = { autofocus: !0, trapElement: null },
    sM = { autofocus: "boolean", trapElement: "element" }
class lb extends fl {
    constructor(t) {
        super(), (this._config = this._getConfig(t)), (this._isActive = !1), (this._lastTabNavDirection = null)
    }
    static get Default() {
        return iM
    }
    static get DefaultType() {
        return sM
    }
    static get NAME() {
        return X3
    }
    activate() {
        this._isActive ||
            (this._config.autofocus && this._config.trapElement.focus(),
            yt.off(document, Eu),
            yt.on(document, tM, (t) => this._handleFocusin(t)),
            yt.on(document, eM, (t) => this._handleKeydown(t)),
            (this._isActive = !0))
    }
    deactivate() {
        !this._isActive || ((this._isActive = !1), yt.off(document, Eu))
    }
    _handleFocusin(t) {
        const { trapElement: r } = this._config
        if (t.target === document || t.target === r || r.contains(t.target)) return
        const n = ye.focusableChildren(r)
        n.length === 0 ? r.focus() : this._lastTabNavDirection === Pp ? n[n.length - 1].focus() : n[0].focus()
    }
    _handleKeydown(t) {
        t.key === rM && (this._lastTabNavDirection = t.shiftKey ? Pp : nM)
    }
}
const oM = "modal",
    aM = "bs.modal",
    Kn = `.${aM}`,
    lM = ".data-api",
    uM = "Escape",
    fM = `hide${Kn}`,
    cM = `hidePrevented${Kn}`,
    ub = `hidden${Kn}`,
    fb = `show${Kn}`,
    dM = `shown${Kn}`,
    hM = `resize${Kn}`,
    pM = `mousedown.dismiss${Kn}`,
    gM = `keydown.dismiss${Kn}`,
    mM = `click${Kn}${lM}`,
    Rp = "modal-open",
    vM = "fade",
    Lp = "show",
    Wf = "modal-static",
    bM = ".modal.show",
    yM = ".modal-dialog",
    _M = ".modal-body",
    wM = '[data-bs-toggle="modal"]',
    AM = { backdrop: !0, focus: !0, keyboard: !0 },
    EM = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }
class Ds extends mn {
    constructor(t, r) {
        super(t, r),
            (this._dialog = ye.findOne(yM, this._element)),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            (this._isShown = !1),
            (this._isTransitioning = !1),
            (this._scrollBar = new Yc()),
            this._addEventListeners()
    }
    static get Default() {
        return AM
    }
    static get DefaultType() {
        return EM
    }
    static get NAME() {
        return oM
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        this._isShown ||
            this._isTransitioning ||
            yt.trigger(this._element, fb, { relatedTarget: t }).defaultPrevented ||
            ((this._isShown = !0),
            (this._isTransitioning = !0),
            this._scrollBar.hide(),
            document.body.classList.add(Rp),
            this._adjustDialog(),
            this._backdrop.show(() => this._showElement(t)))
    }
    hide() {
        !this._isShown ||
            this._isTransitioning ||
            yt.trigger(this._element, fM).defaultPrevented ||
            ((this._isShown = !1),
            (this._isTransitioning = !0),
            this._focustrap.deactivate(),
            this._element.classList.remove(Lp),
            this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()))
    }
    dispose() {
        for (const t of [window, this._dialog]) yt.off(t, Kn)
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    handleUpdate() {
        this._adjustDialog()
    }
    _initializeBackDrop() {
        return new ab({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() })
    }
    _initializeFocusTrap() {
        return new lb({ trapElement: this._element })
    }
    _showElement(t) {
        document.body.contains(this._element) || document.body.append(this._element),
            (this._element.style.display = "block"),
            this._element.removeAttribute("aria-hidden"),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            (this._element.scrollTop = 0)
        const r = ye.findOne(_M, this._dialog)
        r && (r.scrollTop = 0), ul(this._element), this._element.classList.add(Lp)
        const n = () => {
            this._config.focus && this._focustrap.activate(), (this._isTransitioning = !1), yt.trigger(this._element, dM, { relatedTarget: t })
        }
        this._queueCallback(n, this._dialog, this._isAnimated())
    }
    _addEventListeners() {
        yt.on(this._element, gM, (t) => {
            if (t.key === uM) {
                if (this._config.keyboard) {
                    t.preventDefault(), this.hide()
                    return
                }
                this._triggerBackdropTransition()
            }
        }),
            yt.on(window, hM, () => {
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }),
            yt.on(this._element, pM, (t) => {
                if (t.target === t.currentTarget) {
                    if (this._config.backdrop === "static") {
                        this._triggerBackdropTransition()
                        return
                    }
                    this._config.backdrop && this.hide()
                }
            })
    }
    _hideModal() {
        ;(this._element.style.display = "none"),
            this._element.setAttribute("aria-hidden", !0),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            (this._isTransitioning = !1),
            this._backdrop.hide(() => {
                document.body.classList.remove(Rp), this._resetAdjustments(), this._scrollBar.reset(), yt.trigger(this._element, ub)
            })
    }
    _isAnimated() {
        return this._element.classList.contains(vM)
    }
    _triggerBackdropTransition() {
        if (yt.trigger(this._element, cM).defaultPrevented) return
        const r = this._element.scrollHeight > document.documentElement.clientHeight,
            n = this._element.style.overflowY
        n === "hidden" ||
            this._element.classList.contains(Wf) ||
            (r || (this._element.style.overflowY = "hidden"),
            this._element.classList.add(Wf),
            this._queueCallback(() => {
                this._element.classList.remove(Wf),
                    this._queueCallback(() => {
                        this._element.style.overflowY = n
                    }, this._dialog)
            }, this._dialog),
            this._element.focus())
    }
    _adjustDialog() {
        const t = this._element.scrollHeight > document.documentElement.clientHeight,
            r = this._scrollBar.getWidth(),
            n = r > 0
        if (n && !t) {
            const i = Qr() ? "paddingLeft" : "paddingRight"
            this._element.style[i] = `${r}px`
        }
        if (!n && t) {
            const i = Qr() ? "paddingRight" : "paddingLeft"
            this._element.style[i] = `${r}px`
        }
    }
    _resetAdjustments() {
        ;(this._element.style.paddingLeft = ""), (this._element.style.paddingRight = "")
    }
    static jQueryInterface(t, r) {
        return this.each(function () {
            const n = Ds.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                n[t](r)
            }
        })
    }
}
yt.on(document, mM, wM, function (e) {
    const t = ni(this)
    ;["A", "AREA"].includes(this.tagName) && e.preventDefault(),
        yt.one(t, fb, (i) => {
            i.defaultPrevented ||
                yt.one(t, ub, () => {
                    Jo(this) && this.focus()
                })
        })
    const r = ye.findOne(bM)
    r && Ds.getInstance(r).hide(), Ds.getOrCreateInstance(t).toggle(this)
})
lf(Ds)
rn(Ds)
const xM = "offcanvas",
    TM = "bs.offcanvas",
    _i = `.${TM}`,
    cb = ".data-api",
    CM = `load${_i}${cb}`,
    MM = "Escape",
    Dp = "show",
    $p = "showing",
    Fp = "hiding",
    SM = "offcanvas-backdrop",
    db = ".offcanvas.show",
    kM = `show${_i}`,
    NM = `shown${_i}`,
    OM = `hide${_i}`,
    Vp = `hidePrevented${_i}`,
    hb = `hidden${_i}`,
    IM = `resize${_i}`,
    BM = `click${_i}${cb}`,
    PM = `keydown.dismiss${_i}`,
    RM = '[data-bs-toggle="offcanvas"]',
    LM = { backdrop: !0, keyboard: !0, scroll: !1 },
    DM = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }
class gi extends mn {
    constructor(t, r) {
        super(t, r),
            (this._isShown = !1),
            (this._backdrop = this._initializeBackDrop()),
            (this._focustrap = this._initializeFocusTrap()),
            this._addEventListeners()
    }
    static get Default() {
        return LM
    }
    static get DefaultType() {
        return DM
    }
    static get NAME() {
        return xM
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        if (this._isShown || yt.trigger(this._element, kM, { relatedTarget: t }).defaultPrevented) return
        ;(this._isShown = !0),
            this._backdrop.show(),
            this._config.scroll || new Yc().hide(),
            this._element.setAttribute("aria-modal", !0),
            this._element.setAttribute("role", "dialog"),
            this._element.classList.add($p)
        const n = () => {
            ;(!this._config.scroll || this._config.backdrop) && this._focustrap.activate(),
                this._element.classList.add(Dp),
                this._element.classList.remove($p),
                yt.trigger(this._element, NM, { relatedTarget: t })
        }
        this._queueCallback(n, this._element, !0)
    }
    hide() {
        if (!this._isShown || yt.trigger(this._element, OM).defaultPrevented) return
        this._focustrap.deactivate(), this._element.blur(), (this._isShown = !1), this._element.classList.add(Fp), this._backdrop.hide()
        const r = () => {
            this._element.classList.remove(Dp, Fp),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || new Yc().reset(),
                yt.trigger(this._element, hb)
        }
        this._queueCallback(r, this._element, !0)
    }
    dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    _initializeBackDrop() {
        const t = () => {
                if (this._config.backdrop === "static") {
                    yt.trigger(this._element, Vp)
                    return
                }
                this.hide()
            },
            r = Boolean(this._config.backdrop)
        return new ab({ className: SM, isVisible: r, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: r ? t : null })
    }
    _initializeFocusTrap() {
        return new lb({ trapElement: this._element })
    }
    _addEventListeners() {
        yt.on(this._element, PM, (t) => {
            if (t.key === MM) {
                if (!this._config.keyboard) {
                    yt.trigger(this._element, Vp)
                    return
                }
                this.hide()
            }
        })
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = gi.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (r[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`)
                r[t](this)
            }
        })
    }
}
yt.on(document, BM, RM, function (e) {
    const t = ni(this)
    if ((["A", "AREA"].includes(this.tagName) && e.preventDefault(), Ji(this))) return
    yt.one(t, hb, () => {
        Jo(this) && this.focus()
    })
    const r = ye.findOne(db)
    r && r !== t && gi.getInstance(r).hide(), gi.getOrCreateInstance(t).toggle(this)
})
yt.on(window, CM, () => {
    for (const e of ye.find(db)) gi.getOrCreateInstance(e).show()
})
yt.on(window, IM, () => {
    for (const e of ye.find("[aria-modal][class*=show][class*=offcanvas-]"))
        getComputedStyle(e).position !== "fixed" && gi.getOrCreateInstance(e).hide()
})
lf(gi)
rn(gi)
const $M = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    FM = /^aria-[\w-]*$/i,
    VM = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    UM = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    HM = (e, t) => {
        const r = e.nodeName.toLowerCase()
        return t.includes(r)
            ? $M.has(r)
                ? Boolean(VM.test(e.nodeValue) || UM.test(e.nodeValue))
                : !0
            : t.filter((n) => n instanceof RegExp).some((n) => n.test(r))
    },
    pb = {
        "*": ["class", "dir", "id", "lang", "role", FM],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
    }
function qM(e, t, r) {
    if (!e.length) return e
    if (r && typeof r == "function") return r(e)
    const i = new window.DOMParser().parseFromString(e, "text/html"),
        s = [].concat(...i.body.querySelectorAll("*"))
    for (const o of s) {
        const l = o.nodeName.toLowerCase()
        if (!Object.keys(t).includes(l)) {
            o.remove()
            continue
        }
        const f = [].concat(...o.attributes),
            d = [].concat(t["*"] || [], t[l] || [])
        for (const h of f) HM(h, d) || o.removeAttribute(h.nodeName)
    }
    return i.body.innerHTML
}
const zM = "TemplateFactory",
    jM = { allowList: pb, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" },
    KM = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string",
    },
    GM = { entry: "(string|element|function|null)", selector: "(string|element)" }
class WM extends fl {
    constructor(t) {
        super(), (this._config = this._getConfig(t))
    }
    static get Default() {
        return jM
    }
    static get DefaultType() {
        return KM
    }
    static get NAME() {
        return zM
    }
    getContent() {
        return Object.values(this._config.content)
            .map((t) => this._resolvePossibleFunction(t))
            .filter(Boolean)
    }
    hasContent() {
        return this.getContent().length > 0
    }
    changeContent(t) {
        return this._checkContent(t), (this._config.content = { ...this._config.content, ...t }), this
    }
    toHtml() {
        const t = document.createElement("div")
        t.innerHTML = this._maybeSanitize(this._config.template)
        for (const [i, s] of Object.entries(this._config.content)) this._setContent(t, s, i)
        const r = t.children[0],
            n = this._resolvePossibleFunction(this._config.extraClass)
        return n && r.classList.add(...n.split(" ")), r
    }
    _typeCheckConfig(t) {
        super._typeCheckConfig(t), this._checkContent(t.content)
    }
    _checkContent(t) {
        for (const [r, n] of Object.entries(t)) super._typeCheckConfig({ selector: r, entry: n }, GM)
    }
    _setContent(t, r, n) {
        const i = ye.findOne(n, t)
        if (!!i) {
            if (((r = this._resolvePossibleFunction(r)), !r)) {
                i.remove()
                return
            }
            if (ii(r)) {
                this._putElementInTemplate(Yi(r), i)
                return
            }
            if (this._config.html) {
                i.innerHTML = this._maybeSanitize(r)
                return
            }
            i.textContent = r
        }
    }
    _maybeSanitize(t) {
        return this._config.sanitize ? qM(t, this._config.allowList, this._config.sanitizeFn) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t(this) : t
    }
    _putElementInTemplate(t, r) {
        if (this._config.html) {
            ;(r.innerHTML = ""), r.append(t)
            return
        }
        r.textContent = t.textContent
    }
}
const YM = "tooltip",
    JM = new Set(["sanitize", "allowList", "sanitizeFn"]),
    Yf = "fade",
    QM = "modal",
    Bl = "show",
    XM = ".tooltip-inner",
    Up = `.${QM}`,
    Hp = "hide.bs.modal",
    fa = "hover",
    Jf = "focus",
    ZM = "click",
    tS = "manual",
    eS = "hide",
    rS = "hidden",
    nS = "show",
    iS = "shown",
    sS = "inserted",
    oS = "click",
    aS = "focusin",
    lS = "focusout",
    uS = "mouseenter",
    fS = "mouseleave",
    cS = { AUTO: "auto", TOP: "top", RIGHT: Qr() ? "left" : "right", BOTTOM: "bottom", LEFT: Qr() ? "right" : "left" },
    dS = {
        allowList: pb,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 0],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus",
    },
    hS = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string",
    }
class oi extends mn {
    constructor(t, r) {
        if (typeof F1 == "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)")
        super(t, r),
            (this._isEnabled = !0),
            (this._timeout = 0),
            (this._isHovered = !1),
            (this._activeTrigger = {}),
            (this._popper = null),
            (this._templateFactory = null),
            (this._newContent = null),
            (this.tip = null),
            this._setListeners()
    }
    static get Default() {
        return dS
    }
    static get DefaultType() {
        return hS
    }
    static get NAME() {
        return YM
    }
    enable() {
        this._isEnabled = !0
    }
    disable() {
        this._isEnabled = !1
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }
    toggle(t) {
        if (!!this._isEnabled) {
            if (t) {
                const r = this._initializeOnDelegatedTarget(t)
                ;(r._activeTrigger.click = !r._activeTrigger.click), r._isWithActiveTrigger() ? r._enter() : r._leave()
                return
            }
            if (this._isShown()) {
                this._leave()
                return
            }
            this._enter()
        }
    }
    dispose() {
        clearTimeout(this._timeout),
            yt.off(this._element.closest(Up), Hp, this._hideModalHandler),
            this.tip && this.tip.remove(),
            this._disposePopper(),
            super.dispose()
    }
    show() {
        if (this._element.style.display === "none") throw new Error("Please use show on visible elements")
        if (!(this._isWithContent() && this._isEnabled)) return
        const t = yt.trigger(this._element, this.constructor.eventName(nS)),
            n = (q1(this._element) || this._element.ownerDocument.documentElement).contains(this._element)
        if (t.defaultPrevented || !n) return
        this.tip && (this.tip.remove(), (this.tip = null))
        const i = this._getTipElement()
        this._element.setAttribute("aria-describedby", i.getAttribute("id"))
        const { container: s } = this._config
        if (
            (this._element.ownerDocument.documentElement.contains(this.tip) ||
                (s.append(i), yt.trigger(this._element, this.constructor.eventName(sS))),
            this._popper ? this._popper.update() : (this._popper = this._createPopper(i)),
            i.classList.add(Bl),
            "ontouchstart" in document.documentElement)
        )
            for (const l of [].concat(...document.body.children)) yt.on(l, "mouseover", wu)
        const o = () => {
            const l = this._isHovered
            ;(this._isHovered = !1), yt.trigger(this._element, this.constructor.eventName(iS)), l && this._leave()
        }
        this._queueCallback(o, this.tip, this._isAnimated())
    }
    hide() {
        if (!this._isShown() || yt.trigger(this._element, this.constructor.eventName(eS)).defaultPrevented) return
        const r = this._getTipElement()
        if ((r.classList.remove(Bl), "ontouchstart" in document.documentElement))
            for (const i of [].concat(...document.body.children)) yt.off(i, "mouseover", wu)
        ;(this._activeTrigger[ZM] = !1), (this._activeTrigger[Jf] = !1), (this._activeTrigger[fa] = !1), (this._isHovered = !1)
        const n = () => {
            this._isWithActiveTrigger() ||
                (this._isHovered || r.remove(),
                this._element.removeAttribute("aria-describedby"),
                yt.trigger(this._element, this.constructor.eventName(rS)),
                this._disposePopper())
        }
        this._queueCallback(n, this.tip, this._isAnimated())
    }
    update() {
        this._popper && this._popper.update()
    }
    _isWithContent() {
        return Boolean(this._getTitle())
    }
    _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
    }
    _createTipElement(t) {
        const r = this._getTemplateFactory(t).toHtml()
        if (!r) return null
        r.classList.remove(Yf, Bl), r.classList.add(`bs-${this.constructor.NAME}-auto`)
        const n = ZT(this.constructor.NAME).toString()
        return r.setAttribute("id", n), this._isAnimated() && r.classList.add(Yf), r
    }
    setContent(t) {
        ;(this._newContent = t), this._isShown() && (this._disposePopper(), this.show())
    }
    _getTemplateFactory(t) {
        return (
            this._templateFactory
                ? this._templateFactory.changeContent(t)
                : (this._templateFactory = new WM({
                      ...this._config,
                      content: t,
                      extraClass: this._resolvePossibleFunction(this._config.customClass),
                  })),
            this._templateFactory
        )
    }
    _getContentForTemplate() {
        return { [XM]: this._getTitle() }
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle
    }
    _initializeOnDelegatedTarget(t) {
        return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
    }
    _isAnimated() {
        return this._config.animation || (this.tip && this.tip.classList.contains(Yf))
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(Bl)
    }
    _createPopper(t) {
        const r = typeof this._config.placement == "function" ? this._config.placement.call(this, t, this._element) : this._config.placement,
            n = cS[r.toUpperCase()]
        return sh(this._element, t, this._getPopperConfig(n))
    }
    _getOffset() {
        const { offset: t } = this._config
        return typeof t == "string" ? t.split(",").map((r) => Number.parseInt(r, 10)) : typeof t == "function" ? (r) => t(r, this._element) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t.call(this._element) : t
    }
    _getPopperConfig(t) {
        const r = {
            placement: t,
            modifiers: [
                { name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } },
                { name: "offset", options: { offset: this._getOffset() } },
                { name: "preventOverflow", options: { boundary: this._config.boundary } },
                { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } },
                {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: (n) => {
                        this._getTipElement().setAttribute("data-popper-placement", n.state.placement)
                    },
                },
            ],
        }
        return { ...r, ...(typeof this._config.popperConfig == "function" ? this._config.popperConfig(r) : this._config.popperConfig) }
    }
    _setListeners() {
        const t = this._config.trigger.split(" ")
        for (const r of t)
            if (r === "click") yt.on(this._element, this.constructor.eventName(oS), this._config.selector, (n) => this.toggle(n))
            else if (r !== tS) {
                const n = r === fa ? this.constructor.eventName(uS) : this.constructor.eventName(aS),
                    i = r === fa ? this.constructor.eventName(fS) : this.constructor.eventName(lS)
                yt.on(this._element, n, this._config.selector, (s) => {
                    const o = this._initializeOnDelegatedTarget(s)
                    ;(o._activeTrigger[s.type === "focusin" ? Jf : fa] = !0), o._enter()
                }),
                    yt.on(this._element, i, this._config.selector, (s) => {
                        const o = this._initializeOnDelegatedTarget(s)
                        ;(o._activeTrigger[s.type === "focusout" ? Jf : fa] = o._element.contains(s.relatedTarget)), o._leave()
                    })
            }
        ;(this._hideModalHandler = () => {
            this._element && this.hide()
        }),
            yt.on(this._element.closest(Up), Hp, this._hideModalHandler),
            this._config.selector ? (this._config = { ...this._config, trigger: "manual", selector: "" }) : this._fixTitle()
    }
    _fixTitle() {
        const t = this._config.originalTitle
        !t ||
            (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t),
            this._element.removeAttribute("title"))
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = !0
            return
        }
        ;(this._isHovered = !0),
            this._setTimeout(() => {
                this._isHovered && this.show()
            }, this._config.delay.show)
    }
    _leave() {
        this._isWithActiveTrigger() ||
            ((this._isHovered = !1),
            this._setTimeout(() => {
                this._isHovered || this.hide()
            }, this._config.delay.hide))
    }
    _setTimeout(t, r) {
        clearTimeout(this._timeout), (this._timeout = setTimeout(t, r))
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0)
    }
    _getConfig(t) {
        const r = si.getDataAttributes(this._element)
        for (const n of Object.keys(r)) JM.has(n) && delete r[n]
        return (
            (t = { ...r, ...(typeof t == "object" && t ? t : {}) }),
            (t = this._mergeConfigObj(t)),
            (t = this._configAfterMerge(t)),
            this._typeCheckConfig(t),
            t
        )
    }
    _configAfterMerge(t) {
        return (
            (t.container = t.container === !1 ? document.body : Yi(t.container)),
            typeof t.delay == "number" && (t.delay = { show: t.delay, hide: t.delay }),
            (t.originalTitle = this._element.getAttribute("title") || ""),
            typeof t.title == "number" && (t.title = t.title.toString()),
            typeof t.content == "number" && (t.content = t.content.toString()),
            t
        )
    }
    _getDelegateConfig() {
        const t = {}
        for (const r in this._config) this.constructor.Default[r] !== this._config[r] && (t[r] = this._config[r])
        return t
    }
    _disposePopper() {
        this._popper && (this._popper.destroy(), (this._popper = null))
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = oi.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
}
rn(oi)
const pS = "popover",
    gS = ".popover-header",
    mS = ".popover-body",
    vS = {
        ...oi.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template:
            '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click",
    },
    bS = { ...oi.DefaultType, content: "(null|string|element|function)" }
class $o extends oi {
    static get Default() {
        return vS
    }
    static get DefaultType() {
        return bS
    }
    static get NAME() {
        return pS
    }
    _isWithContent() {
        return this._getTitle() || this._getContent()
    }
    _getContentForTemplate() {
        return { [gS]: this._getTitle(), [mS]: this._getContent() }
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = $o.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
}
rn($o)
const yS = "scrollspy",
    _S = "bs.scrollspy",
    uh = `.${_S}`,
    wS = ".data-api",
    AS = `activate${uh}`,
    qp = `click${uh}`,
    ES = `load${uh}${wS}`,
    xS = "dropdown-item",
    Xs = "active",
    TS = '[data-bs-spy="scroll"]',
    Qf = "[href]",
    CS = ".nav, .list-group",
    zp = ".nav-link",
    MS = ".nav-item",
    SS = ".list-group-item",
    kS = `${zp}, ${MS} > ${zp}, ${SS}`,
    NS = ".dropdown",
    OS = ".dropdown-toggle",
    IS = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null },
    BS = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element" }
class cf extends mn {
    constructor(t, r) {
        super(t, r),
            (this._targetLinks = new Map()),
            (this._observableSections = new Map()),
            (this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element),
            (this._activeTarget = null),
            (this._observer = null),
            (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }),
            this.refresh()
    }
    static get Default() {
        return IS
    }
    static get DefaultType() {
        return BS
    }
    static get NAME() {
        return yS
    }
    refresh() {
        this._initializeTargetsAndObservables(),
            this._maybeEnableSmoothScroll(),
            this._observer ? this._observer.disconnect() : (this._observer = this._getNewObserver())
        for (const t of this._observableSections.values()) this._observer.observe(t)
    }
    dispose() {
        this._observer.disconnect(), super.dispose()
    }
    _configAfterMerge(t) {
        return (t.target = Yi(t.target) || document.body), t
    }
    _maybeEnableSmoothScroll() {
        !this._config.smoothScroll ||
            (yt.off(this._config.target, qp),
            yt.on(this._config.target, qp, Qf, (t) => {
                const r = this._observableSections.get(t.target.hash)
                if (r) {
                    t.preventDefault()
                    const n = this._rootElement || window,
                        i = r.offsetTop - this._element.offsetTop
                    if (n.scrollTo) {
                        n.scrollTo({ top: i, behavior: "smooth" })
                        return
                    }
                    n.scrollTop = i
                }
            }))
    }
    _getNewObserver() {
        const t = { root: this._rootElement, threshold: [0.1, 0.5, 1], rootMargin: this._getRootMargin() }
        return new IntersectionObserver((r) => this._observerCallback(r), t)
    }
    _observerCallback(t) {
        const r = (o) => this._targetLinks.get(`#${o.target.id}`),
            n = (o) => {
                ;(this._previousScrollData.visibleEntryTop = o.target.offsetTop), this._process(r(o))
            },
            i = (this._rootElement || document.documentElement).scrollTop,
            s = i >= this._previousScrollData.parentScrollTop
        this._previousScrollData.parentScrollTop = i
        for (const o of t) {
            if (!o.isIntersecting) {
                ;(this._activeTarget = null), this._clearActiveClass(r(o))
                continue
            }
            const l = o.target.offsetTop >= this._previousScrollData.visibleEntryTop
            if (s && l) {
                if ((n(o), !i)) return
                continue
            }
            !s && !l && n(o)
        }
    }
    _getRootMargin() {
        return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin
    }
    _initializeTargetsAndObservables() {
        ;(this._targetLinks = new Map()), (this._observableSections = new Map())
        const t = ye.find(Qf, this._config.target)
        for (const r of t) {
            if (!r.hash || Ji(r)) continue
            const n = ye.findOne(r.hash, this._element)
            Jo(n) && (this._targetLinks.set(r.hash, r), this._observableSections.set(r.hash, n))
        }
    }
    _process(t) {
        this._activeTarget !== t &&
            (this._clearActiveClass(this._config.target),
            (this._activeTarget = t),
            t.classList.add(Xs),
            this._activateParents(t),
            yt.trigger(this._element, AS, { relatedTarget: t }))
    }
    _activateParents(t) {
        if (t.classList.contains(xS)) {
            ye.findOne(OS, t.closest(NS)).classList.add(Xs)
            return
        }
        for (const r of ye.parents(t, CS)) for (const n of ye.prev(r, kS)) n.classList.add(Xs)
    }
    _clearActiveClass(t) {
        t.classList.remove(Xs)
        const r = ye.find(`${Qf}.${Xs}`, t)
        for (const n of r) n.classList.remove(Xs)
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = cf.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (r[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
}
yt.on(window, ES, () => {
    for (const e of ye.find(TS)) cf.getOrCreateInstance(e)
})
rn(cf)
const PS = "tab",
    RS = "bs.tab",
    Ks = `.${RS}`,
    LS = `hide${Ks}`,
    DS = `hidden${Ks}`,
    $S = `show${Ks}`,
    FS = `shown${Ks}`,
    VS = `click${Ks}`,
    US = `keydown${Ks}`,
    HS = `load${Ks}`,
    qS = "ArrowLeft",
    jp = "ArrowRight",
    zS = "ArrowUp",
    Kp = "ArrowDown",
    Ri = "active",
    Gp = "fade",
    Xf = "show",
    jS = "dropdown",
    KS = ".dropdown-toggle",
    GS = ".dropdown-menu",
    WS = ".dropdown-item",
    Zf = ":not(.dropdown-toggle)",
    YS = '.list-group, .nav, [role="tablist"]',
    JS = ".nav-item, .list-group-item",
    QS = `.nav-link${Zf}, .list-group-item${Zf}, [role="tab"]${Zf}`,
    gb = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    tc = `${QS}, ${gb}`,
    XS = `.${Ri}[data-bs-toggle="tab"], .${Ri}[data-bs-toggle="pill"], .${Ri}[data-bs-toggle="list"]`
class Fo extends mn {
    constructor(t) {
        super(t),
            (this._parent = this._element.closest(YS)),
            this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), yt.on(this._element, US, (r) => this._keydown(r)))
    }
    static get NAME() {
        return PS
    }
    show() {
        const t = this._element
        if (this._elemIsActive(t)) return
        const r = this._getActiveElem(),
            n = r ? yt.trigger(r, LS, { relatedTarget: t }) : null
        yt.trigger(t, $S, { relatedTarget: r }).defaultPrevented || (n && n.defaultPrevented) || (this._deactivate(r, t), this._activate(t, r))
    }
    _activate(t, r) {
        if (!t) return
        t.classList.add(Ri), this._activate(ni(t))
        const n = () => {
            if (t.getAttribute("role") !== "tab") {
                t.classList.add(Xf)
                return
            }
            t.focus(),
                t.removeAttribute("tabindex"),
                t.setAttribute("aria-selected", !0),
                this._toggleDropDown(t, !0),
                yt.trigger(t, FS, { relatedTarget: r })
        }
        this._queueCallback(n, t, t.classList.contains(Gp))
    }
    _deactivate(t, r) {
        if (!t) return
        t.classList.remove(Ri), t.blur(), this._deactivate(ni(t))
        const n = () => {
            if (t.getAttribute("role") !== "tab") {
                t.classList.remove(Xf)
                return
            }
            t.setAttribute("aria-selected", !1),
                t.setAttribute("tabindex", "-1"),
                this._toggleDropDown(t, !1),
                yt.trigger(t, DS, { relatedTarget: r })
        }
        this._queueCallback(n, t, t.classList.contains(Gp))
    }
    _keydown(t) {
        if (![qS, jp, zS, Kp].includes(t.key)) return
        t.stopPropagation(), t.preventDefault()
        const r = [jp, Kp].includes(t.key),
            n = oh(
                this._getChildren().filter((i) => !Ji(i)),
                t.target,
                r,
                !0
            )
        n && Fo.getOrCreateInstance(n).show()
    }
    _getChildren() {
        return ye.find(tc, this._parent)
    }
    _getActiveElem() {
        return this._getChildren().find((t) => this._elemIsActive(t)) || null
    }
    _setInitialAttributes(t, r) {
        this._setAttributeIfNotExists(t, "role", "tablist")
        for (const n of r) this._setInitialAttributesOnChild(n)
    }
    _setInitialAttributesOnChild(t) {
        t = this._getInnerElement(t)
        const r = this._elemIsActive(t),
            n = this._getOuterElement(t)
        t.setAttribute("aria-selected", r),
            n !== t && this._setAttributeIfNotExists(n, "role", "presentation"),
            r || t.setAttribute("tabindex", "-1"),
            this._setAttributeIfNotExists(t, "role", "tab"),
            this._setInitialAttributesOnTargetPanel(t)
    }
    _setInitialAttributesOnTargetPanel(t) {
        const r = ni(t)
        !r || (this._setAttributeIfNotExists(r, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(r, "aria-labelledby", `#${t.id}`))
    }
    _toggleDropDown(t, r) {
        const n = this._getOuterElement(t)
        if (!n.classList.contains(jS)) return
        const i = (s, o) => {
            const l = ye.findOne(s, n)
            l && l.classList.toggle(o, r)
        }
        i(KS, Ri), i(GS, Xf), i(WS, Ri), n.setAttribute("aria-expanded", r)
    }
    _setAttributeIfNotExists(t, r, n) {
        t.hasAttribute(r) || t.setAttribute(r, n)
    }
    _elemIsActive(t) {
        return t.classList.contains(Ri)
    }
    _getInnerElement(t) {
        return t.matches(tc) ? t : ye.findOne(tc, t)
    }
    _getOuterElement(t) {
        return t.closest(JS) || t
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = Fo.getOrCreateInstance(this)
            if (typeof t == "string") {
                if (r[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`)
                r[t]()
            }
        })
    }
}
yt.on(document, VS, gb, function (e) {
    ;["A", "AREA"].includes(this.tagName) && e.preventDefault(), !Ji(this) && Fo.getOrCreateInstance(this).show()
})
yt.on(window, HS, () => {
    for (const e of ye.find(XS)) Fo.getOrCreateInstance(e)
})
rn(Fo)
const ZS = "toast",
    tk = "bs.toast",
    es = `.${tk}`,
    ek = `mouseover${es}`,
    rk = `mouseout${es}`,
    nk = `focusin${es}`,
    ik = `focusout${es}`,
    sk = `hide${es}`,
    ok = `hidden${es}`,
    ak = `show${es}`,
    lk = `shown${es}`,
    uk = "fade",
    Wp = "hide",
    Pl = "show",
    Rl = "showing",
    fk = { animation: "boolean", autohide: "boolean", delay: "number" },
    ck = { animation: !0, autohide: !0, delay: 5e3 }
class df extends mn {
    constructor(t, r) {
        super(t, r), (this._timeout = null), (this._hasMouseInteraction = !1), (this._hasKeyboardInteraction = !1), this._setListeners()
    }
    static get Default() {
        return ck
    }
    static get DefaultType() {
        return fk
    }
    static get NAME() {
        return ZS
    }
    show() {
        if (yt.trigger(this._element, ak).defaultPrevented) return
        this._clearTimeout(), this._config.animation && this._element.classList.add(uk)
        const r = () => {
            this._element.classList.remove(Rl), yt.trigger(this._element, lk), this._maybeScheduleHide()
        }
        this._element.classList.remove(Wp),
            ul(this._element),
            this._element.classList.add(Pl, Rl),
            this._queueCallback(r, this._element, this._config.animation)
    }
    hide() {
        if (!this.isShown() || yt.trigger(this._element, sk).defaultPrevented) return
        const r = () => {
            this._element.classList.add(Wp), this._element.classList.remove(Rl, Pl), yt.trigger(this._element, ok)
        }
        this._element.classList.add(Rl), this._queueCallback(r, this._element, this._config.animation)
    }
    dispose() {
        this._clearTimeout(), this.isShown() && this._element.classList.remove(Pl), super.dispose()
    }
    isShown() {
        return this._element.classList.contains(Pl)
    }
    _maybeScheduleHide() {
        !this._config.autohide ||
            this._hasMouseInteraction ||
            this._hasKeyboardInteraction ||
            (this._timeout = setTimeout(() => {
                this.hide()
            }, this._config.delay))
    }
    _onInteraction(t, r) {
        switch (t.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = r
                break
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = r
                break
        }
        if (r) {
            this._clearTimeout()
            return
        }
        const n = t.relatedTarget
        this._element === n || this._element.contains(n) || this._maybeScheduleHide()
    }
    _setListeners() {
        yt.on(this._element, ek, (t) => this._onInteraction(t, !0)),
            yt.on(this._element, rk, (t) => this._onInteraction(t, !1)),
            yt.on(this._element, nk, (t) => this._onInteraction(t, !0)),
            yt.on(this._element, ik, (t) => this._onInteraction(t, !1))
    }
    _clearTimeout() {
        clearTimeout(this._timeout), (this._timeout = null)
    }
    static jQueryInterface(t) {
        return this.each(function () {
            const r = df.getOrCreateInstance(this, t)
            if (typeof t == "string") {
                if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`)
                r[t](this)
            }
        })
    }
}
lf(df)
rn(df)
var dk = Object.defineProperty,
    hk = (e, t, r) => (t in e ? dk(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)),
    Ue = (e, t, r) => (hk(e, typeof t != "symbol" ? t + "" : t, r), r)
const pk = (e) =>
        K(() => (e.value === "center" ? "justify-content-center" : e.value === "end" ? "justify-content-end" : "justify-content-start")),
    mb = Symbol(),
    vb = {
        items: Ze([]),
        reset() {
            this.items = Ze([])
        },
    },
    gk = (e) => {
        e.provide(mb, vb)
    },
    mk = () => Ie(mb) || vb,
    Ke = (e, t, r) => {
        je(() => {
            var n
            ;(n = e == null ? void 0 : e.value) == null || n.addEventListener(t, r)
        }),
            qs(() => {
                var n
                ;(n = e == null ? void 0 : e.value) == null || n.removeEventListener(t, r)
            })
    },
    vk = (e, t) => e.indexOf(t) !== -1,
    bk = (...e) => Array.from([...e]),
    yk = (...e) => Array.prototype.concat.apply([], e)
class hf {
    constructor(t, r = {}) {
        if (
            (Ue(this, "cancelable", !0),
            Ue(this, "componentId", null),
            Ue(this, "defaultPrevented", !1),
            Ue(this, "nativeEvent", null),
            Ue(this, "preventDefault"),
            Ue(this, "relatedTarget", null),
            Ue(this, "target", null),
            Ue(this, "eventType", ""),
            Ue(this, "vueTarget", null),
            !t)
        )
            throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`)
        Vk(this, hf.Defaults, this.constructor.Defaults, r, { eventType: t }),
            Uk(this, { type: ys(), cancelable: ys(), nativeEvent: ys(), target: ys(), relatedTarget: ys(), vueTarget: ys(), componentId: ys() })
        let n = !1
        ;(this.preventDefault = function () {
            this.cancelable && (n = !0)
        }),
            Hk(this, "defaultPrevented", {
                enumerable: !0,
                get() {
                    return n
                },
            })
    }
    static get Defaults() {
        return { eventType: "", cancelable: !0, nativeEvent: null, target: null, relatedTarget: null, vueTarget: null, componentId: null }
    }
}
const ec = (e) => `\\${e}`,
    _k = (e) => {
        e = Qc(e)
        const { length: t } = e,
            r = e.charCodeAt(0)
        return e.split("").reduce((n, i, s) => {
            const o = e.charCodeAt(s)
            return o === 0
                ? `${n}\uFFFD`
                : o === 127 || (o >= 1 && o <= 31) || (s === 0 && o >= 48 && o <= 57) || (s === 1 && o >= 48 && o <= 57 && r === 45)
                ? n + ec(`${o.toString(16)} `)
                : s === 0 && o === 45 && t === 1
                ? n + ec(i)
                : o >= 128 || o === 45 || o === 95 || (o >= 48 && o <= 57) || (o >= 65 && o <= 90) || (o >= 97 && o <= 122)
                ? n + i
                : n + ec(i)
        }, "")
    },
    bb = typeof window < "u",
    yb = typeof document < "u",
    wk = typeof navigator < "u",
    Ak = bb && yb && wk,
    _b = yb ? document : {},
    rs = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE),
    Ek = (e) => (rs(e) ? e.getBoundingClientRect() : null),
    xk = (e = []) => {
        const { activeElement: t } = document
        return t && !e.some((r) => r === t) ? t : null
    },
    Tk = (e) => rs(e) && e === xk(),
    Ck = (e, t = {}) => {
        try {
            e.focus(t)
        } catch (r) {
            console.error(r)
        }
        return Tk(e)
    },
    Mk = (e, t) => (t && rs(e) && e.getAttribute(t)) || null,
    Sk = (e) => {
        if (Mk(e, "display") === "none") return !1
        const t = Ek(e)
        return !!(t && t.height > 0 && t.width > 0)
    },
    Yp = (e, t) => !e || e(t).filter((r) => r.type !== or).length < 1,
    kk = (e, t) => (rs(t) ? t : _b).querySelector(e) || null,
    Nk = (e, t) => bk((rs(t) ? t : _b).querySelectorAll(e)),
    wb = (e, t) => (t && rs(e) ? e.getAttribute(t) : null),
    Ok = (e, t, r) => {
        t && rs(e) && e.setAttribute(t, r)
    },
    Ik = (e, t) => {
        t && rs(e) && e.removeAttribute(t)
    },
    Bk = (e, t) => Qc(e).toLowerCase() === Qc(t).toLowerCase(),
    Ll = bb
        ? window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          ((e) => setTimeout(e, 16))
        : (e) => setTimeout(e, 0),
    pf = (e, t, r) =>
        t
            .concat(["sm", "md", "lg", "xl", "xxl"])
            .reduce((n, i) => ((n[e ? `${e}${i.charAt(0).toUpperCase() + i.slice(1)}` : i] = r), n), Object.create(null)),
    Ab = (e, t, r, n = r) =>
        Object.keys(t).reduce(
            (i, s) => (
                e[s] &&
                    i.push(
                        [n, s.replace(r, ""), e[s]]
                            .filter((o) => o && typeof o != "boolean")
                            .join("-")
                            .toLowerCase()
                    ),
                i
            ),
            []
        ),
    ri = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`,
    gf = (e, t) =>
        e === !0 || e === "true" || e === ""
            ? "true"
            : e === "grammar" || e === "spelling"
            ? e
            : t === !1
            ? "true"
            : e === !1 || e === "false"
            ? "false"
            : e,
    Pk = /^[0-9]*\.?[0-9]+$/,
    rc = (e) => Tb(e) === "boolean",
    Rk = (e) => e !== null && typeof e == "object",
    Vo = (e) => typeof e == "string",
    Lk = (e) => e === void 0,
    Dk = (e) => e === null,
    Eb = (e) => Lk(e) || Dk(e),
    xb = (e) => Pk.test(String(e)),
    $k = (e) => typeof e == "number",
    Tb = (e) => typeof e,
    Cb = (e) => Tb(e) === "function",
    Mb = (e) => Object.prototype.toString.call(e) === "[object Object]",
    Sb = (e) => Array.isArray(e),
    nc = (e) => e && typeof e == "object" && e.constructor === Object,
    Jc = (e, t, r = !0) => {
        const n = e instanceof Date && typeof e.getMonth == "function" ? new Date(e) : Object.assign({}, e)
        return (
            nc(e) &&
                nc(t) &&
                Object.keys(t).forEach((i) => {
                    nc(t[i])
                        ? i in e
                            ? (n[i] = Jc(e[i], t[i], r))
                            : Object.assign(n, { [i]: t[i] })
                        : Array.isArray(t[i]) && Array.isArray(e[i])
                        ? Object.assign(n, { [i]: r ? e[i].concat(t[i].filter((s) => !e[i].includes(s))) : t[i] })
                        : Object.assign(n, { [i]: t[i] })
                }),
            n
        )
    },
    Nr = (e, t = {}, r = {}) => {
        const n = [e]
        let i
        for (let s = 0; s < n.length && !i; s++) {
            const o = n[s]
            i = r[o]
        }
        return i && Cb(i) ? i(t) : i
    },
    Uo = (e, t = NaN) => (Number.isInteger(e) ? e : t),
    Fk = (e, t = NaN) => {
        const r = parseInt(e, 10)
        return isNaN(r) ? t : r
    },
    fh = (e, t = NaN) => {
        const r = parseFloat(e.toString())
        return isNaN(r) ? t : r
    },
    Vk = (e, ...t) => Object.assign(e, ...t),
    Uk = (e, t) => Object.defineProperties(e, t),
    Hk = (e, t, r) => Object.defineProperty(e, t, r),
    mf = (e, t) =>
        Object.keys(e)
            .filter((r) => t.indexOf(r) === -1)
            .reduce((r, n) => ({ ...r, [n]: e[n] }), {}),
    ys = () => ({ enumerable: !0, configurable: !1, writable: !1 }),
    Jp = (e, t) => t + (e ? Yk(e) : ""),
    kb = (e, t, r = (n) => n) => (Sb(e) ? e.slice() : Object.keys(e)).reduce((n, i) => ((n[r(i)] = t[i]), n), {}),
    qk = (e) => (typeof e == "boolean" ? e : e === "" ? !0 : e === "true"),
    za = (e) => !!(e.href || e.to),
    zk = /_/g,
    jk = /([a-z])([A-Z])/g,
    Kk = /(\s|^)(\w)/,
    Wl = /\s+/,
    Gk = /^#/,
    Wk = /^#[A-Za-z]+[\w\-:.]*$/,
    Qc = (e, t = 2) => (Eb(e) ? "" : Sb(e) || (Mb(e) && e.toString === Object.prototype.toString) ? JSON.stringify(e, null, t) : String(e)),
    Qp = (e) =>
        e
            .replace(zk, " ")
            .replace(jk, (t, r, n) => `${r} ${n}`)
            .replace(Kk, (t, r, n) => r + n.toUpperCase()),
    Yk = (e) => ((e = Vo(e) ? e.trim() : String(e)), e.charAt(0).toUpperCase() + e.slice(1)),
    Nb = (e) =>
        K(() => ({
            "form-check": !e.plain && !e.button,
            "form-check-inline": e.inline,
            "form-switch": e.switch,
            [`form-control-${e.size}`]: e.size && e.size !== "md",
        })),
    Ob = (e) =>
        K(() => ({
            "form-check-input": !e.plain && !e.button,
            "is-valid": e.state === !0,
            "is-invalid": e.state === !1,
            "btn-check": e.button,
        })),
    Ib = (e) =>
        K(() => ({
            "form-check-label": !e.plain && !e.button,
            btn: e.button,
            [`btn-${e.buttonVariant}`]: e.button,
            [`btn-${e.size}`]: e.button && e.size && e.size !== "md",
        })),
    Bb = (e) =>
        K(() => {
            var t
            return {
                "aria-invalid": gf(e.ariaInvalid, e.state),
                "aria-required": ((t = e.required) == null ? void 0 : t.toString()) === "true" ? "true" : null,
            }
        }),
    Pb = (e) =>
        K(() => ({
            "was-validated": e.validated,
            "btn-group": e.buttons && !e.stacked,
            "btn-group-vertical": e.stacked,
            [`btn-group-${e.size}`]: e.size,
        })),
    xu = (e, t, r) =>
        e
            .filter((n) => n.type.name === t)
            .map((n) => {
                const i = (n.children.default ? n.children.default() : []).find((s) => s.type.toString() === "Symbol(Text)")
                return { props: { disabled: r, ...n.props }, text: i ? i.children : "" }
            }),
    Rb = (e, t) =>
        typeof e == "string"
            ? { props: { value: e, disabled: t.disabled }, text: e }
            : {
                  props: { value: e[t.valueField], disabled: t.disabled || e[t.disabledField], ...e.props },
                  text: e[t.textField],
                  html: e[t.htmlField],
              },
    Lb = (e, t, r, n, i) => ({
        ...e,
        props: {
            "button-variant": r.buttonVariant,
            form: r.form,
            name: n.value,
            id: `${i.value}_option_${t}`,
            button: r.buttons,
            state: r.state,
            plain: r.plain,
            size: r.size,
            inline: !r.stacked,
            required: r.required,
            ...e.props,
        },
    }),
    ar = (e, t) => K(() => (e == null ? void 0 : e.value) || ri(t)),
    Db = {
        ariaInvalid: { type: [Boolean, String], default: void 0 },
        autocomplete: { type: String, required: !1 },
        autofocus: { type: Boolean, default: !1 },
        disabled: { type: Boolean, default: !1 },
        form: { type: String, required: !1 },
        formatter: { type: Function, required: !1 },
        id: { type: String, required: !1 },
        lazy: { type: Boolean, default: !1 },
        lazyFormatter: { type: Boolean, default: !1 },
        list: { type: String, required: !1 },
        modelValue: { type: [String, Number], default: "" },
        name: { type: String, required: !1 },
        number: { type: Boolean, default: !1 },
        placeholder: { type: String, required: !1 },
        plaintext: { type: Boolean, default: !1 },
        readonly: { type: Boolean, default: !1 },
        required: { type: Boolean, default: !1 },
        size: { type: String, required: !1 },
        state: { type: Boolean, default: null },
        trim: { type: Boolean, default: !1 },
    },
    $b = (e, t) => {
        const r = Ht()
        let n = null,
            i = !0
        const s = ar(L(e, "id"), "input"),
            o = (N, P, M = !1) => (
                (N = String(N)), typeof e.formatter == "function" && (!e.lazyFormatter || M) ? ((i = !1), e.formatter(N, P)) : N
            ),
            l = (N) => (e.trim ? N.trim() : e.number ? parseFloat(N) : N),
            f = () => {
                Wr(() => {
                    var N
                    e.autofocus && ((N = r.value) == null || N.focus())
                })
            }
        je(f),
            je(() => {
                r.value && (r.value.value = e.modelValue)
            }),
            tl(f)
        const d = K(() => {
                var N
                return gf(e.ariaInvalid, (N = e.state) != null ? N : void 0)
            }),
            h = (N) => {
                const { value: P } = N.target,
                    M = o(P, N)
                if (M === !1 || N.defaultPrevented) {
                    N.preventDefault()
                    return
                }
                if (e.lazy) return
                const k = l(M)
                e.modelValue !== k && ((n = P), t("update:modelValue", k)), t("input", M)
            },
            y = (N) => {
                const { value: P } = N.target,
                    M = o(P, N)
                if (M === !1 || N.defaultPrevented) {
                    N.preventDefault()
                    return
                }
                if (!e.lazy) return
                ;(n = P), t("update:modelValue", M)
                const k = l(M)
                e.modelValue !== k && t("change", M)
            },
            E = (N) => {
                if ((t("blur", N), !e.lazy && !e.lazyFormatter)) return
                const { value: P } = N.target,
                    M = o(P, N, !0)
                ;(n = P), t("update:modelValue", M)
            },
            T = () => {
                var N
                e.disabled || (N = r.value) == null || N.focus()
            },
            S = () => {
                var N
                e.disabled || (N = r.value) == null || N.blur()
            }
        return (
            Oe(
                () => e.modelValue,
                (N) => {
                    !r.value || ((r.value.value = n && i ? n : N), (n = null), (i = !0))
                }
            ),
            { input: r, computedId: s, computedAriaInvalid: d, onInput: h, onChange: y, onBlur: E, focus: T, blur: S }
        )
    },
    lo = (e, t) => {
        if (!e) return e
        if (t in e) return e[t]
        const r = t.split(".")
        return lo(e[r[0]], r.splice(1).join("."))
    },
    ic = (e, t = null, r, n) => {
        if (Object.prototype.toString.call(e) === "[object Object]") {
            const i = lo(e, n.valueField),
                s = lo(e, n.textField),
                o = lo(e, n.htmlField),
                l = lo(e, n.disabledField),
                f = e[n.optionsField] || null
            return f !== null
                ? { label: String(lo(e, n.labelField) || s), options: ch(f, r, n) }
                : { value: typeof i > "u" ? t || s : i, text: String(typeof s > "u" ? t : s), html: o, disabled: Boolean(l) }
        }
        return { value: t || e, text: String(e), disabled: !1 }
    },
    ch = (e, t, r) =>
        Array.isArray(e)
            ? e.map((n) => ic(n, null, t, r))
            : Object.prototype.toString.call(e) === "[object Object]"
            ? (console.warn(`[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`),
              Object.keys(e).map((n) => {
                  const i = e[n]
                  switch (typeof i) {
                      case "object":
                          return ic(i.text, String(i.value), t, r)
                      default:
                          return ic(i, String(n), t, r)
                  }
              }))
            : [],
    z = (e) => K(() => qk(e.value)),
    Jk = ["id"],
    Fb = Symbol(),
    Qk = bt({
        __name: "BAccordion",
        props: { flush: { default: !1 }, free: { default: !1 }, id: { default: void 0 } },
        setup(e) {
            const t = e,
                r = ar(L(t, "id"), "accordion"),
                n = z(L(t, "flush")),
                i = z(L(t, "free")),
                s = K(() => ({ "accordion-flush": n.value }))
            return (
                i.value || cn(Fb, r.value.toString()),
                (o, l) => (Y(), ft("div", { id: V(r), class: wt(["accordion", V(s)]) }, [mt(o.$slots, "default")], 10, Jk))
            )
        },
    }),
    Vb = bt({
        __name: "BCollapse",
        props: {
            accordion: null,
            id: { default: ri() },
            modelValue: { default: !1 },
            tag: { default: "div" },
            toggle: { default: !1 },
            visible: { default: !1 },
            isNav: { default: !1 },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "modelValue")),
                i = z(L(r, "toggle")),
                s = z(L(r, "visible")),
                o = z(L(r, "isNav")),
                l = Ht(),
                f = Ht(),
                d = K(() => ({ show: n.value, "navbar-collapse": o.value })),
                h = () => t("update:modelValue", !1)
            return (
                Ke(l, "show.bs.collapse", () => {
                    t("show"), t("update:modelValue", !0)
                }),
                Ke(l, "hide.bs.collapse", () => {
                    t("hide"), t("update:modelValue", !1)
                }),
                Ke(l, "shown.bs.collapse", () => t("shown")),
                Ke(l, "hidden.bs.collapse", () => t("hidden")),
                je(() => {
                    var y
                    ;(f.value = new Do(l.value, { parent: r.accordion ? `#${r.accordion}` : void 0, toggle: i.value })),
                        (s.value || n.value) && (t("update:modelValue", !0), (y = f.value) == null || y.show())
                }),
                Oe(
                    () => n.value,
                    (y) => {
                        var E, T
                        y ? (E = f.value) == null || E.show() : (T = f.value) == null || T.hide()
                    }
                ),
                Oe(
                    () => s.value,
                    (y) => {
                        var E, T
                        y
                            ? (t("update:modelValue", !!y), (E = f.value) == null || E.show())
                            : (t("update:modelValue", !!y), (T = f.value) == null || T.hide())
                    }
                ),
                (y, E) => (
                    Y(),
                    kt(
                        Kt(e.tag),
                        {
                            id: e.id,
                            ref_key: "element",
                            ref: l,
                            class: wt(["collapse", V(d)]),
                            "data-bs-parent": e.accordion || null,
                            "is-nav": V(o),
                        },
                        { default: Ct(() => [mt(y.$slots, "default", { visible: V(n), close: h })]), _: 3 },
                        8,
                        ["id", "class", "data-bs-parent", "is-nav"]
                    )
                )
            )
        },
    }),
    Xk = (e) => {
        if (e.classList.contains("offcanvas")) return "offcanvas"
        if (e.classList.contains("collapse")) return "collapse"
        throw Error("Couldn't resolve toggle type")
    },
    Zk = (e, t) => {
        const { modifiers: r, arg: n, value: i } = e,
            s = Object.keys(r || {}),
            o = Vo(i) ? i.split(Wl) : i
        if (Bk(t.tagName, "a")) {
            const l = wb(t, "href") || ""
            Wk.test(l) && s.push(l.replace(Gk, ""))
        }
        return yk(n, o).forEach((l) => Vo(l) && s.push(l)), s.filter((l, f, d) => l && d.indexOf(l) === f)
    },
    dh = {
        mounted(e, t) {
            const r = Zk(t, e),
                n = []
            let i = "data-bs-target"
            e.tagName === "a" && (i = "href")
            for (let s = 0; s < r.length; s++) {
                const o = r[s],
                    l = document.getElementById(o)
                l && (e.setAttribute("data-bs-toggle", Xk(l)), n.push(`#${o}`))
            }
            n.length > 0 && e.setAttribute(i, n.join(","))
        },
    },
    t4 = { class: "accordion-item" },
    e4 = ["id"],
    r4 = ["aria-expanded", "aria-controls"],
    n4 = { class: "accordion-body" },
    i4 = bt({
        __name: "BAccordionItem",
        props: { id: null, title: null, visible: { default: !1 } },
        setup(e) {
            const t = e,
                r = z(L(t, "visible")),
                n = ar(L(t, "id"), "accordion_item"),
                i = Ie(Fb, "")
            return (s, o) => (
                Y(),
                ft("div", t4, [
                    xt(
                        "h2",
                        { id: `${V(n)}heading`, class: "accordion-header" },
                        [
                            qi(
                                (Y(),
                                ft(
                                    "button",
                                    {
                                        class: wt(["accordion-button", { collapsed: !V(r) }]),
                                        type: "button",
                                        "aria-expanded": V(r) ? "true" : "false",
                                        "aria-controls": V(n),
                                    },
                                    [mt(s.$slots, "title", {}, () => [ve(jt(e.title), 1)])],
                                    10,
                                    r4
                                )),
                                [[V(dh), void 0, V(n)]]
                            ),
                        ],
                        8,
                        e4
                    ),
                    Ut(
                        Vb,
                        { id: V(n), class: "accordion-collapse", visible: V(r), accordion: V(i), "aria-labelledby": `heading${V(n)}` },
                        { default: Ct(() => [xt("div", n4, [mt(s.$slots, "default")])]), _: 3 },
                        8,
                        ["id", "visible", "accordion", "aria-labelledby"]
                    ),
                ])
            )
        },
    }),
    s4 = ["aria-label"],
    o4 = bt({
        __name: "BAlert",
        props: {
            dismissLabel: { default: "Close" },
            dismissible: { default: !1 },
            fade: { default: !1 },
            modelValue: { type: [Boolean, Number], default: !1 },
            show: { default: !1 },
            variant: { default: "info" },
        },
        emits: ["dismissed", "dismiss-count-down", "update:modelValue"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "dismissible"))
            z(L(r, "fade"))
            const i = z(L(r, "show")),
                s = Ht(),
                o = Ht(),
                l = K(() => ({ [`alert-${r.variant}`]: !!r.variant, show: !!r.modelValue, "alert-dismissible": n.value, fade: !!r.modelValue }))
            let f
            const d = (P) => {
                    if (typeof P == "boolean") return 0
                    const M = Uo(P, 0)
                    return M > 0 ? M : 0
                },
                h = () => {
                    f !== void 0 && (clearTimeout(f), (f = void 0))
                },
                y = Ht(d(r.modelValue)),
                E = K(() => !!r.modelValue || i.value)
            qs(() => {
                var P
                h(), (P = o.value) == null || P.dispose(), (o.value = void 0)
            })
            const T = K(() => (r.modelValue === !0 ? !0 : r.modelValue === !1 || Uo(r.modelValue, 0) < 1 ? !1 : !!r.modelValue)),
                S = () => {
                    ;(y.value = d(r.modelValue)), (T.value || i.value) && !o.value && (o.value = new cl(s.value))
                },
                N = () => {
                    typeof r.modelValue == "boolean" ? t("update:modelValue", !1) : t("update:modelValue", 0), t("dismissed")
                }
            return (
                Oe(() => r.modelValue, S),
                Oe(() => i.value, S),
                Oe(y, (P) => {
                    h(),
                        typeof r.modelValue != "boolean" &&
                            (t("dismiss-count-down", P),
                            P === 0 && r.modelValue > 0 && t("dismissed"),
                            r.modelValue !== P && t("update:modelValue", P),
                            P > 0 &&
                                (f = setTimeout(() => {
                                    y.value--
                                }, 1e3)))
                }),
                (P, M) =>
                    V(E)
                        ? (Y(),
                          ft(
                              "div",
                              { key: 0, ref_key: "element", ref: s, class: wt(["alert", V(l)]), role: "alert" },
                              [
                                  mt(P.$slots, "default"),
                                  V(n)
                                      ? (Y(),
                                        ft(
                                            "button",
                                            {
                                                key: 0,
                                                type: "button",
                                                class: "btn-close",
                                                "data-bs-dismiss": "alert",
                                                "aria-label": e.dismissLabel,
                                                onClick: N,
                                            },
                                            null,
                                            8,
                                            s4
                                        ))
                                      : Dt("", !0),
                              ],
                              2
                          ))
                        : Dt("", !0)
            )
        },
    }),
    Ub = Symbol(),
    a4 = bt({
        __name: "BAvatarGroup",
        props: {
            overlap: { default: 0.3 },
            rounded: { type: [Boolean, String], default: !1 },
            size: null,
            square: { default: !1 },
            tag: { default: "div" },
            variant: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "square")),
                n = K(() => Xc(t.size)),
                i = (l) => (Vo(l) && xb(l) ? fh(l, 0) : l || 0),
                s = K(() => Math.min(Math.max(i(t.overlap), 0), 1) / 2),
                o = K(() => {
                    let { value: l } = n
                    return (l = l ? `calc(${l} * ${s.value})` : null), l ? { paddingLeft: l, paddingRight: l } : {}
                })
            return (
                cn(Ub, { overlapScale: s, size: t.size, square: r.value, rounded: t.rounded, variant: t.variant }),
                (l, f) => (
                    Y(),
                    kt(
                        Kt(e.tag),
                        { class: "b-avatar-group", role: "group" },
                        {
                            default: Ct(() => [xt("div", { class: "b-avatar-group-inner", style: hn(V(o)) }, [mt(l.$slots, "default")], 4)]),
                            _: 3,
                        }
                    )
                )
            )
        },
    }),
    l4 = { key: 0, class: "b-avatar-custom" },
    u4 = { key: 1, class: "b-avatar-img" },
    f4 = ["src", "alt"],
    Xc = (e) => {
        const t = Vo(e) && xb(e) ? fh(e, 0) : e
        return $k(t) ? `${t}px` : t || null
    },
    c4 = bt({
        __name: "BAvatar",
        props: {
            alt: { default: "avatar" },
            ariaLabel: null,
            badge: { type: [Boolean, String], default: !1 },
            badgeLeft: { default: !1 },
            badgeOffset: null,
            badgeTop: { default: !1 },
            badgeVariant: { default: "primary" },
            button: { default: !1 },
            buttonType: { default: "button" },
            disabled: { default: !1 },
            icon: null,
            rounded: { type: [Boolean, String], default: "circle" },
            size: null,
            square: { default: !1 },
            src: null,
            text: null,
            textVariant: { default: void 0 },
            variant: { default: "secondary" },
        },
        emits: ["click", "img-error"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "badgeLeft")),
                i = z(L(r, "badgeTop")),
                s = z(L(r, "button")),
                o = z(L(r, "disabled")),
                l = z(L(r, "square")),
                f = Qi(),
                d = ["sm", null, "lg"],
                h = 0.4,
                y = h * 0.7,
                E = Ie(Ub, null),
                T = (_) => {
                    const A = _
                    return A === "light" || A === "warning" ? "dark" : "light"
                },
                S = K(() => !Yp(f.default)),
                N = K(() => !Yp(f.badge)),
                P = K(() => r.badge || r.badge === "" || N.value),
                M = K(() => (E != null && E.size ? E.size : Xc(r.size))),
                k = K(() => (E != null && E.variant ? E.variant : r.variant)),
                F = K(() => (E != null && E.rounded ? E.rounded : r.rounded)),
                $ = K(() => ({ "aria-label": r.ariaLabel || null, disabled: o.value || null })),
                R = K(() => ({ [`bg-${r.badgeVariant}`]: !!r.badgeVariant })),
                W = K(() => (r.badge === !0 ? "" : r.badge)),
                nt = K(() => `text-${T(r.badgeVariant)}`),
                J = K(() => ({
                    [`b-avatar-${r.size}`]: !!r.size && d.indexOf(Xc(r.size)) !== -1,
                    [`bg-${k.value}`]: !!k.value,
                    badge: !s.value && k.value && S.value,
                    rounded: F.value === "" || F.value === !0,
                    ["rounded-circle"]: !l.value && F.value === "circle",
                    ["rounded-0"]: l.value || F.value === "0",
                    ["rounded-1"]: !l.value && F.value === "sm",
                    ["rounded-3"]: !l.value && F.value === "lg",
                    ["rounded-top"]: !l.value && F.value === "top",
                    ["rounded-bottom"]: !l.value && F.value === "bottom",
                    ["rounded-start"]: !l.value && F.value === "left",
                    ["rounded-end"]: !l.value && F.value === "right",
                    btn: s.value,
                    [`btn-${k.value}`]: s.value ? !!k.value : !1,
                })),
                Q = K(() => `text-${r.textVariant || T(k.value)}`),
                ot = K(() => {
                    const _ = r.badgeOffset || "0px"
                    return {
                        fontSize: (d.indexOf(M.value || null) === -1 ? `calc(${M.value} * ${y})` : "") || "",
                        top: i.value ? _ : "",
                        bottom: i.value ? "" : _,
                        left: n.value ? _ : "",
                        right: n.value ? "" : _,
                    }
                }),
                it = K(() => {
                    const _ = d.indexOf(M.value || null) === -1 ? `calc(${M.value} * ${h})` : null
                    return _ ? { fontSize: _ } : {}
                }),
                at = K(() => {
                    var _
                    const A = ((_ = E == null ? void 0 : E.overlapScale) == null ? void 0 : _.value) || 0,
                        w = M.value && A ? `calc(${M.value} * -${A})` : null
                    return w ? { marginLeft: w, marginRight: w } : {}
                }),
                x = K(() => (s.value ? r.buttonType : "span")),
                a = K(() => ({ ...at.value, width: M.value, height: M.value })),
                c = (_) => {
                    !o.value && s.value && t("click", _)
                },
                m = (_) => t("img-error", _)
            return (_, A) => (
                Y(),
                kt(
                    Kt(V(x)),
                    ce({ class: ["b-avatar", V(J)], style: V(a) }, V($), { onClick: c }),
                    {
                        default: Ct(() => [
                            V(S)
                                ? (Y(), ft("span", l4, [mt(_.$slots, "default")]))
                                : e.src
                                ? (Y(), ft("span", u4, [xt("img", { src: e.src, alt: e.alt, onError: m }, null, 40, f4)]))
                                : e.text
                                ? (Y(), ft("span", { key: 2, class: wt(["b-avatar-text", V(Q)]), style: hn(V(it)) }, jt(e.text), 7))
                                : Dt("", !0),
                            V(P)
                                ? (Y(),
                                  ft(
                                      "span",
                                      { key: 3, class: wt(["b-avatar-badge", V(R)]), style: hn(V(ot)) },
                                      [V(N) ? mt(_.$slots, "badge", { key: 0 }) : (Y(), ft("span", { key: 1, class: wt(V(nt)) }, jt(V(W)), 3))],
                                      6
                                  ))
                                : Dt("", !0),
                        ]),
                        _: 3,
                    },
                    16,
                    ["class", "style"]
                )
            )
        },
    }),
    Gs = {
        active: { type: [Boolean, String], default: !1 },
        activeClass: { type: String, default: "router-link-active" },
        append: { type: [Boolean, String], default: !1 },
        disabled: { type: [Boolean, String], default: !1 },
        event: { type: [String, Array], default: "click" },
        exact: { type: [Boolean, String], default: !1 },
        exactActiveClass: { type: String, default: "router-link-exact-active" },
        href: { type: String },
        rel: { type: String, default: null },
        replace: { type: [Boolean, String], default: !1 },
        routerComponentName: { type: String, default: "router-link" },
        routerTag: { type: String, default: "a" },
        target: { type: String, default: "_self" },
        to: { type: [String, Object], default: null },
    },
    d4 = bt({
        props: Gs,
        emits: ["click"],
        setup(e, { emit: t, attrs: r }) {
            const n = z(L(e, "active")),
                i = z(L(e, "append")),
                s = z(L(e, "disabled")),
                o = z(L(e, "exact")),
                l = z(L(e, "replace")),
                f = vi(),
                d = Ht(null),
                h = K(() => {
                    const T = e.routerComponentName
                        .split("-")
                        .map((S) => S.charAt(0).toUpperCase() + S.slice(1))
                        .join("")
                    return (f == null ? void 0 : f.appContext.app.component(T)) === void 0 || s.value || !e.to ? "a" : e.routerComponentName
                }),
                y = K(() => {
                    const T = "#"
                    if (e.href) return e.href
                    if (typeof e.to == "string") return e.to || T
                    const S = e.to
                    if (Object.prototype.toString.call(S) === "[object Object]" && (S.path || S.query || S.hash)) {
                        const N = S.path || "",
                            P = S.query
                                ? `?${Object.keys(S.query)
                                      .map((k) => `${k}=${S.query[k]}`)
                                      .join("=")}`
                                : "",
                            M = !S.hash || S.hash.charAt(0) === "#" ? S.hash || "" : `#${S.hash}`
                        return `${N}${P}${M}` || T
                    }
                    return T
                }),
                E = K(() => ({
                    to: e.to,
                    href: y.value,
                    target: e.target,
                    rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
                    tabindex: s.value ? "-1" : typeof r.tabindex > "u" ? null : r.tabindex,
                    "aria-disabled": s.value ? "true" : null,
                }))
            return {
                tag: h,
                routerAttr: E,
                link: d,
                clicked: (T) => {
                    if (s.value) {
                        T.preventDefault(), T.stopImmediatePropagation()
                        return
                    }
                    t("click", T)
                },
                activeBoolean: n,
                appendBoolean: i,
                disabledBoolean: s,
                replaceBoolean: l,
                exactBoolean: o,
            }
        },
    }),
    ur = (e, t) => {
        const r = e.__vccOpts || e
        for (const [n, i] of t) r[n] = i
        return r
    }
function h4(e, t, r, n, i, s) {
    return e.tag === "router-link"
        ? (Y(),
          kt(
              Kt(e.tag),
              ce({ key: 0 }, e.routerAttr, { custom: "" }),
              {
                  default: Ct(({ href: o, navigate: l, isActive: f, isExactActive: d }) => [
                      (Y(),
                      kt(
                          Kt(e.routerTag),
                          ce({ ref: "link", href: o, class: [f && e.activeClass, d && e.exactActiveClass] }, e.$attrs, { onClick: l }),
                          { default: Ct(() => [mt(e.$slots, "default")]), _: 2 },
                          1040,
                          ["href", "class", "onClick"]
                      )),
                  ]),
                  _: 3,
              },
              16
          ))
        : (Y(),
          kt(
              Kt(e.tag),
              ce({ key: 1, ref: "link", class: { active: e.activeBoolean, disabled: e.disabledBoolean } }, e.routerAttr, { onClick: e.clicked }),
              { default: Ct(() => [mt(e.$slots, "default")]), _: 3 },
              16,
              ["class", "onClick"]
          ))
}
const $r = ur(d4, [["render", h4]]),
    Xp = mf(Gs, ["event", "routerTag"]),
    p4 = bt({
        components: { BLink: $r },
        props: {
            pill: { type: [Boolean, String], default: !1 },
            tag: { type: String, default: "span" },
            variant: { type: String, default: "secondary" },
            textIndicator: { type: [Boolean, String], default: !1 },
            dotIndicator: { type: [Boolean, String], default: !1 },
            ...Xp,
        },
        setup(e) {
            const t = K(() => za(e)),
                r = K(() => (t.value ? $r : e.tag)),
                n = z(L(e, "pill")),
                i = z(L(e, "textIndicator")),
                s = z(L(e, "dotIndicator"))
            return {
                classes: K(() => ({
                    [`bg-${e.variant}`]: e.variant,
                    active: e.active,
                    disabled: e.disabled,
                    "text-dark": ["warning", "info", "light"].includes(e.variant),
                    "rounded-pill": n.value,
                    "position-absolute top-0 start-100 translate-middle": i.value || s.value,
                    "p-2 border border-light rounded-circle": s.value,
                    "text-decoration-none": t.value,
                })),
                props: t.value ? kb(Xp, e) : {},
                computedTag: r,
            }
        },
    })
function g4(e, t, r, n, i, s) {
    return (
        Y(),
        kt(Kt(e.computedTag), ce({ class: ["badge", e.classes] }, e.props), { default: Ct(() => [mt(e.$slots, "default")]), _: 3 }, 16, [
            "class",
        ])
    )
}
const m4 = ur(p4, [["render", g4]]),
    v4 = bt({
        components: { BLink: $r },
        props: {
            ...mf(Gs, ["event", "routerTag"]),
            active: { type: [Boolean, String], default: !1 },
            ariaCurrent: { type: String, default: "location" },
            disabled: { type: [Boolean, String], default: !1 },
            text: { type: String, required: !1 },
        },
        emits: ["click"],
        setup(e, { emit: t }) {
            const r = z(L(e, "active")),
                n = z(L(e, "disabled")),
                i = K(() => ({ active: r.value })),
                s = K(() => (r.value ? "span" : $r)),
                o = K(() => (r.value ? e.ariaCurrent : void 0))
            return {
                liClasses: i,
                computedTag: s,
                computedAriaCurrent: o,
                clicked: (l) => {
                    if (n.value || r.value) {
                        l.preventDefault(), l.stopImmediatePropagation()
                        return
                    }
                    n.value || t("click", l)
                },
            }
        },
    })
function b4(e, t, r, n, i, s) {
    return (
        Y(),
        ft(
            "li",
            { class: wt(["breadcrumb-item", e.liClasses]) },
            [
                (Y(),
                kt(
                    Kt(e.computedTag),
                    ce({ "aria-current": e.computedAriaCurrent }, e.$props, { onClick: e.clicked }),
                    { default: Ct(() => [mt(e.$slots, "default")]), _: 3 },
                    16,
                    ["aria-current", "onClick"]
                )),
            ],
            2
        )
    )
}
const Hb = ur(v4, [["render", b4]]),
    y4 = { "aria-label": "breadcrumb" },
    _4 = { class: "breadcrumb" },
    w4 = bt({
        __name: "BBreadcrumb",
        props: { items: null },
        setup(e) {
            const t = e,
                r = mk(),
                n = K(() => {
                    const i = t.items || (r == null ? void 0 : r.items) || []
                    let s = !1
                    return i.map(
                        (o, l) => (
                            typeof o == "string" && ((o = { text: o }), l < i.length - 1 && (o.href = "#")),
                            o.active && (s = !0),
                            !o.active && !s && (o.active = l + 1 === i.length),
                            o
                        )
                    )
                })
            return (i, s) => (
                Y(),
                ft("nav", y4, [
                    xt("ol", _4, [
                        mt(i.$slots, "prepend"),
                        (Y(!0),
                        ft(
                            Yt,
                            null,
                            Pe(V(n), (o, l) => (Y(), kt(Hb, ce({ key: l }, o), { default: Ct(() => [ve(jt(o.text), 1)]), _: 2 }, 1040))),
                            128
                        )),
                        mt(i.$slots, "default"),
                        mt(i.$slots, "append"),
                    ]),
                ])
            )
        },
    }),
    A4 = bt({
        components: { BLink: $r },
        props: {
            ...Gs,
            active: { type: [Boolean, String], default: !1 },
            disabled: { type: [Boolean, String], default: !1 },
            href: { type: String, required: !1 },
            pill: { type: [Boolean, String], default: !1 },
            pressed: { type: [Boolean, String], default: !1 },
            rel: { type: String, default: void 0 },
            size: { type: String, default: "md" },
            squared: { type: [Boolean, String], default: !1 },
            tag: { type: String, default: "button" },
            target: { type: String, default: "_self" },
            type: { type: String, default: "button" },
            variant: { type: String, default: "secondary" },
            loading: { type: [Boolean, String], default: !1 },
            loadingMode: { type: String, default: "inline" },
        },
        emits: ["click", "update:pressed"],
        setup(e, { emit: t }) {
            const r = z(L(e, "active")),
                n = z(L(e, "disabled")),
                i = z(L(e, "pill")),
                s = z(L(e, "pressed")),
                o = z(L(e, "squared")),
                l = K(() => s.value === !0),
                f = K(() => e.tag === "button" && e.href === void 0 && e.to === null),
                d = K(() => za(e)),
                h = K(() => e.to !== null),
                y = K(() => (e.href !== void 0 ? !1 : !f.value)),
                E = K(() => ({
                    [`btn-${e.variant}`]: !!e.variant,
                    [`btn-${e.size}`]: !!e.size,
                    active: r.value || s.value,
                    "rounded-pill": i.value,
                    "rounded-0": o.value,
                    disabled: n.value,
                })),
                T = K(() => ({
                    "aria-disabled": y.value ? n.value : null,
                    "aria-pressed": l.value ? s.value : null,
                    autocomplete: l.value ? "off" : null,
                    disabled: f.value ? n.value : null,
                    href: e.href,
                    rel: d.value ? e.rel : null,
                    role: y.value || d.value ? "button" : null,
                    target: d.value ? e.target : null,
                    type: f.value ? e.type : null,
                    to: f.value ? null : e.to,
                    append: d.value ? e.append : null,
                    activeClass: h.value ? e.activeClass : null,
                    event: h.value ? e.event : null,
                    exact: h.value ? e.exact : null,
                    exactActiveClass: h.value ? e.exactActiveClass : null,
                    replace: h.value ? e.replace : null,
                    routerComponentName: h.value ? e.routerComponentName : null,
                    routerTag: h.value ? e.routerTag : null,
                })),
                S = K(() => (h.value ? $r : e.href ? "a" : e.tag))
            return {
                classes: E,
                attrs: T,
                computedTag: S,
                clicked: (N) => {
                    if (n.value) {
                        N.preventDefault(), N.stopPropagation()
                        return
                    }
                    t("click", N), l.value && t("update:pressed", !s.value)
                },
            }
        },
    })
function E4(e, t, r, n, i, s) {
    const o = ui("BSpinner")
    return (
        Y(),
        kt(
            Kt(e.computedTag),
            ce({ class: ["btn", e.classes] }, e.attrs, { onClick: e.clicked }),
            {
                default: Ct(() => [
                    e.loading
                        ? (Y(),
                          ft(
                              "div",
                              {
                                  key: 0,
                                  class: wt([
                                      "btn-loading",
                                      { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" },
                                  ]),
                              },
                              [mt(e.$slots, "loading", {}, () => [Ut(o, { class: "btn-spinner", small: e.size !== "lg" }, null, 8, ["small"])])],
                              2
                          ))
                        : Dt("", !0),
                    xt(
                        "div",
                        { class: wt(["btn-content", { "btn-loading-fill": e.loading && e.loadingMode == "fill" }]) },
                        [mt(e.$slots, "default")],
                        2
                    ),
                ]),
                _: 3,
            },
            16,
            ["class", "onClick"]
        )
    )
}
const ja = ur(A4, [["render", E4]]),
    x4 = bt({
        __name: "BButtonGroup",
        props: { ariaLabel: { default: "Group" }, size: null, tag: { default: "div" }, vertical: { default: !1 } },
        setup(e) {
            const t = e,
                r = z(L(t, "vertical")),
                n = K(() => ({ "btn-group": !r.value, "btn-group-vertical": r.value, [`btn-group-${t.size}`]: t.size !== void 0 }))
            return (i, s) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { class: wt(V(n)), role: "group", "aria-label": e.ariaLabel },
                    { default: Ct(() => [mt(i.$slots, "default")]), _: 3 },
                    8,
                    ["class", "aria-label"]
                )
            )
        },
    }),
    T4 = ["aria-label"],
    C4 = bt({
        __name: "BButtonToolbar",
        props: { ariaLabel: { default: "Group" }, justify: { default: !1 } },
        setup(e) {
            const t = z(L(e, "justify")),
                r = K(() => ({ "justify-content-between": t.value }))
            return (n, i) => (
                Y(),
                ft("div", { class: wt([V(r), "btn-toolbar"]), role: "toolbar", "aria-label": e.ariaLabel }, [mt(n.$slots, "default")], 10, T4)
            )
        },
    }),
    M4 = ["disabled", "aria-label"],
    qb = bt({
        __name: "BCloseButton",
        props: { disabled: { default: !1 }, white: { default: !1 }, ariaLabel: { default: "Close" } },
        setup(e) {
            const t = e,
                r = z(L(t, "disabled")),
                n = z(L(t, "white")),
                i = K(() => ({ "btn-close-white": n.value }))
            return (s, o) => (
                Y(), ft("button", { type: "button", class: wt(["btn-close", V(i)]), disabled: V(r), "aria-label": e.ariaLabel }, null, 10, M4)
            )
        },
    }),
    S4 = ["innerHTML"],
    k4 = ["innerHTML"],
    N4 = bt({
        __name: "BCard",
        props: {
            align: null,
            bgVariant: null,
            bodyBgVariant: null,
            bodyClass: null,
            bodyTag: { default: "div" },
            bodyTextVariant: null,
            borderVariant: null,
            footer: null,
            footerBgVariant: null,
            footerBorderVariant: null,
            footerClass: null,
            footerHtml: { default: "" },
            footerTag: { default: "div" },
            footerTextVariant: null,
            header: null,
            headerBgVariant: null,
            headerBorderVariant: null,
            headerClass: null,
            headerHtml: { default: "" },
            headerTag: { default: "div" },
            headerTextVariant: null,
            imgAlt: null,
            imgBottom: { default: !1 },
            imgEnd: { default: !1 },
            imgHeight: null,
            imgLeft: { default: !1 },
            imgRight: { default: !1 },
            imgSrc: null,
            imgStart: { default: !1 },
            imgTop: { default: !1 },
            imgWidth: null,
            noBody: { default: !1 },
            overlay: { default: !1 },
            subTitle: null,
            subTitleTag: { default: "h6" },
            subTitleTextVariant: { default: "muted" },
            tag: { default: "div" },
            textVariant: null,
            title: null,
            titleTag: { default: "h4" },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "imgBottom")),
                n = z(L(t, "imgEnd")),
                i = z(L(t, "imgLeft")),
                s = z(L(t, "imgRight")),
                o = z(L(t, "imgStart")),
                l = z(L(t, "imgTop")),
                f = z(L(t, "noBody")),
                d = z(L(t, "overlay")),
                h = K(() => ({
                    [`text-${t.align}`]: t.align !== void 0,
                    [`text-${t.textVariant}`]: t.textVariant !== void 0,
                    [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
                    [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
                    "flex-row": i.value || o.value,
                    "flex-row-reverse": n.value || s.value,
                })),
                y = K(() => ({
                    "card-body": !f.value,
                    "card-img-overlay": d.value,
                    [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0,
                    [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
                })),
                E = K(() => ({
                    [`bg-${t.footerBgVariant}`]: t.footerBgVariant !== void 0,
                    [`border-${t.footerBorderVariant}`]: t.footerBorderVariant !== void 0,
                    [`text-${t.footerTextVariant}`]: t.footerTextVariant !== void 0,
                })),
                T = K(() => ({
                    [`bg-${t.headerBgVariant}`]: t.headerBgVariant !== void 0,
                    [`border-${t.headerBorderVariant}`]: t.headerBorderVariant !== void 0,
                    [`text-${t.headerTextVariant}`]: t.headerTextVariant !== void 0,
                })),
                S = K(() => ({
                    "card-img": !n.value && !s.value && !o.value && !i.value && !l.value && !l.value,
                    "card-img-right": n.value || s.value,
                    "card-img-left": o.value || i.value,
                    "card-img-top": l.value,
                    "card-img-bottom": r.value,
                })),
                N = K(() => ({ src: t.imgSrc, alt: t.imgAlt, height: t.imgHeight, width: t.imgWidth })),
                P = K(() => ({ [`text-${t.subTitleTextVariant}`]: !!t.subTitleTextVariant }))
            return (M, k) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { class: wt(["card", V(h)]) },
                    {
                        default: Ct(() => [
                            e.imgSrc && !V(r) ? (Y(), ft("img", ce({ key: 0 }, V(N), { class: V(S) }), null, 16)) : Dt("", !0),
                            e.header || M.$slots.header || e.headerHtml
                                ? (Y(),
                                  kt(
                                      Kt(e.headerTag),
                                      { key: 1, class: wt(["card-header", [e.headerClass, V(T)]]) },
                                      {
                                          default: Ct(() => [
                                              e.headerHtml
                                                  ? (Y(), ft("div", { key: 0, innerHTML: e.headerHtml }, null, 8, S4))
                                                  : mt(M.$slots, "header", { key: 1 }, () => [ve(jt(e.header), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      8,
                                      ["class"]
                                  ))
                                : Dt("", !0),
                            V(f)
                                ? Dt("", !0)
                                : (Y(),
                                  kt(
                                      Kt(e.bodyTag),
                                      { key: 2, class: wt([e.bodyClass, V(y)]) },
                                      {
                                          default: Ct(() => [
                                              e.title && !V(f)
                                                  ? (Y(),
                                                    kt(
                                                        Kt(e.titleTag),
                                                        { key: 0, class: "card-title" },
                                                        { default: Ct(() => [ve(jt(e.title), 1)]), _: 1 }
                                                    ))
                                                  : Dt("", !0),
                                              e.subTitle && !V(f)
                                                  ? (Y(),
                                                    kt(
                                                        Kt(e.subTitleTag),
                                                        { key: 1, class: wt(["card-subtitle mb-2", V(P)]) },
                                                        { default: Ct(() => [ve(jt(e.subTitle), 1)]), _: 1 },
                                                        8,
                                                        ["class"]
                                                    ))
                                                  : Dt("", !0),
                                              mt(M.$slots, "default"),
                                          ]),
                                          _: 3,
                                      },
                                      8,
                                      ["class"]
                                  )),
                            V(f) ? mt(M.$slots, "default", { key: 3 }) : Dt("", !0),
                            e.footer || M.$slots.footer || e.footerHtml
                                ? (Y(),
                                  kt(
                                      Kt(e.footerTag),
                                      { key: 4, class: wt(["card-footer", [e.footerClass, V(E)]]) },
                                      {
                                          default: Ct(() => [
                                              e.footerHtml
                                                  ? (Y(), ft("div", { key: 0, innerHTML: e.footerHtml }, null, 8, k4))
                                                  : mt(M.$slots, "footer", { key: 1 }, () => [ve(jt(e.footer), 1)]),
                                          ]),
                                          _: 3,
                                      },
                                      8,
                                      ["class"]
                                  ))
                                : Dt("", !0),
                            e.imgSrc && V(r) ? (Y(), ft("img", ce({ key: 5 }, V(N), { class: V(S) }), null, 16)) : Dt("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    zb = bt({
        __name: "BCardTitle",
        props: { title: null, titleTag: { default: "h4" } },
        setup(e) {
            return (t, r) => (
                Y(),
                kt(
                    Kt(e.titleTag),
                    { class: "card-title" },
                    { default: Ct(() => [mt(t.$slots, "default", {}, () => [ve(jt(e.title), 1)])]), _: 3 }
                )
            )
        },
    }),
    jb = bt({
        __name: "BCardSubTitle",
        props: { subTitle: null, subTitleTag: { default: "h6" }, subTitleTextVariant: { default: "muted" } },
        setup(e) {
            const t = e,
                r = K(() => ({ [`text-${t.subTitleTextVariant}`]: !!t.subTitleTextVariant }))
            return (n, i) => (
                Y(),
                kt(
                    Kt(e.subTitleTag),
                    { class: wt(["card-subtitle mb-2", V(r)]) },
                    { default: Ct(() => [mt(n.$slots, "default", {}, () => [ve(jt(e.subTitle), 1)])]), _: 3 },
                    8,
                    ["class"]
                )
            )
        },
    }),
    O4 = bt({
        __name: "BCardBody",
        props: {
            bodyBgVariant: null,
            bodyClass: null,
            bodyTag: { default: "div" },
            bodyTextVariant: null,
            overlay: { default: !1 },
            subTitle: null,
            subTitleTag: { default: "h4" },
            subTitleTextVariant: null,
            title: null,
            titleTag: { default: "h4" },
        },
        setup(e) {
            const t = e
            z(L(t, "overlay"))
            const r = K(() => ({
                [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
                [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0,
            }))
            return (n, i) => (
                Y(),
                kt(
                    Kt(e.bodyTag),
                    { class: wt(["card-body", V(r)]) },
                    {
                        default: Ct(() => [
                            e.title
                                ? (Y(), kt(zb, { key: 0, "title-tag": e.titleTag, title: e.title }, null, 8, ["title-tag", "title"]))
                                : Dt("", !0),
                            e.subTitle
                                ? (Y(),
                                  kt(
                                      jb,
                                      {
                                          key: 1,
                                          "sub-title-tag": e.subTitleTag,
                                          "sub-title": e.subTitle,
                                          "sub-title-text-variant": e.subTitleTextVariant,
                                      },
                                      null,
                                      8,
                                      ["sub-title-tag", "sub-title", "sub-title-text-variant"]
                                  ))
                                : Dt("", !0),
                            mt(n.$slots, "default"),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    I4 = ["innerHTML"],
    B4 = bt({
        __name: "BCardFooter",
        props: {
            footer: null,
            footerBgVariant: null,
            footerBorderVariant: null,
            footerClass: null,
            footerHtml: null,
            footerTag: { default: "div" },
            footerTextVariant: null,
        },
        setup(e) {
            const t = e,
                r = K(() => ({
                    [`text-${t.footerTextVariant}`]: t.footerTextVariant !== void 0,
                    [`bg-${t.footerBgVariant}`]: t.footerBgVariant !== void 0,
                    [`border-${t.footerBorderVariant}`]: t.footerBorderVariant !== void 0,
                }))
            return (n, i) => (
                Y(),
                kt(
                    Kt(e.footerTag),
                    { class: wt(["card-footer", [e.footerClass, V(r)]]) },
                    {
                        default: Ct(() => [
                            e.footerHtml
                                ? (Y(), ft("div", { key: 0, innerHTML: e.footerHtml }, null, 8, I4))
                                : mt(n.$slots, "default", { key: 1 }, () => [ve(jt(e.footer), 1)]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    P4 = bt({
        __name: "BCardGroup",
        props: { columns: { default: !1 }, deck: { default: !1 }, tag: { default: "div" } },
        setup(e) {
            const t = e,
                r = z(L(t, "columns")),
                n = z(L(t, "deck")),
                i = K(() => (n.value ? "card-deck" : r.value ? "card-columns" : "card-group"))
            return (s, o) => (Y(), kt(Kt(e.tag), { class: wt(V(i)) }, { default: Ct(() => [mt(s.$slots, "default")]), _: 3 }, 8, ["class"]))
        },
    }),
    R4 = ["innerHTML"],
    L4 = bt({
        __name: "BCardHeader",
        props: {
            header: null,
            headerBgVariant: null,
            headerBorderVariant: null,
            headerClass: null,
            headerHtml: null,
            headerTag: { default: "div" },
            headerTextVariant: null,
        },
        setup(e) {
            const t = e,
                r = K(() => ({
                    [`text-${t.headerTextVariant}`]: t.headerTextVariant !== void 0,
                    [`bg-${t.headerBgVariant}`]: t.headerBgVariant !== void 0,
                    [`border-${t.headerBorderVariant}`]: t.headerBorderVariant !== void 0,
                }))
            return (n, i) => (
                Y(),
                kt(
                    Kt(e.headerTag),
                    { class: wt(["card-header", [e.headerClass, V(r)]]) },
                    {
                        default: Ct(() => [
                            e.headerHtml
                                ? (Y(), ft("div", { key: 0, innerHTML: e.headerHtml }, null, 8, R4))
                                : mt(n.$slots, "default", { key: 1 }, () => [ve(jt(e.header), 1)]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class"]
                )
            )
        },
    }),
    D4 = bt({
        __name: "BCardImg",
        props: {
            alt: { default: void 0 },
            bottom: { default: !1 },
            end: { default: !1 },
            height: null,
            left: { default: !1 },
            right: { default: !1 },
            src: null,
            start: { default: !1 },
            top: { default: !1 },
            width: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "bottom")),
                n = z(L(t, "end")),
                i = z(L(t, "left")),
                s = z(L(t, "right")),
                o = z(L(t, "start")),
                l = z(L(t, "top")),
                f = K(() => ({
                    src: t.src,
                    alt: t.alt,
                    width: (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || void 0,
                    height: (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || void 0,
                })),
                d = K(() => {
                    const h = i.value ? "float-left" : s.value ? "float-right" : ""
                    let y = "card-img"
                    return (
                        l.value
                            ? (y += "-top")
                            : s.value || n.value
                            ? (y += "-right")
                            : r.value
                            ? (y += "-bottom")
                            : (i.value || o.value) && (y += "-left"),
                        { [h]: !!h, [y]: !0 }
                    )
                })
            return (h, y) => (Y(), ft("img", ce({ class: V(d) }, V(f)), null, 16))
        },
    }),
    $4 = {},
    F4 = { class: "card-text" }
function V4(e, t) {
    return Y(), ft("p", F4, [mt(e.$slots, "default")])
}
const U4 = ur($4, [["render", V4]]),
    H4 = ["id"],
    q4 = { key: 0, class: "carousel-indicators" },
    z4 = ["data-bs-target", "data-bs-slide-to", "aria-label"],
    j4 = { class: "carousel-inner" },
    K4 = ["data-bs-target"],
    G4 = xt("span", { class: "carousel-control-prev-icon", "aria-hidden": "true" }, null, -1),
    W4 = xt("span", { class: "visually-hidden" }, "Previous", -1),
    Y4 = [G4, W4],
    J4 = ["data-bs-target"],
    Q4 = xt("span", { class: "carousel-control-next-icon", "aria-hidden": "true" }, null, -1),
    X4 = xt("span", { class: "visually-hidden" }, "Next", -1),
    Z4 = [Q4, X4],
    Kb = Symbol(),
    t8 = bt({
        __name: "BCarousel",
        props: {
            id: null,
            imgHeight: null,
            imgWidth: null,
            background: null,
            modelValue: { default: 0 },
            controls: { default: !1 },
            indicators: { default: !1 },
            interval: { default: 5e3 },
            noTouch: { default: !1 },
            noWrap: { default: !1 },
        },
        emits: ["sliding-start", "sliding-end"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "controls")),
                i = z(L(r, "indicators")),
                s = z(L(r, "noTouch"))
            z(L(r, "noWrap"))
            const o = Qi(),
                l = Ht(),
                f = Ht(),
                d = ar(L(r, "id"), "accordion"),
                h = Ht([])
            return (
                Ke(l, "slide.bs.carousel", (y) => t("sliding-start", y)),
                Ke(l, "slid.bs.carousel", (y) => t("sliding-end", y)),
                je(() => {
                    ;(f.value = new Xo(l.value, { wrap: !s.value, interval: r.interval, touch: !s.value })),
                        o.default &&
                            (h.value = o.default().filter((y) => {
                                var E
                                return ((E = y.type) == null ? void 0 : E.name) === "BCarouselSlide"
                            }))
                }),
                cn(Kb, { background: r.background, width: r.imgWidth, height: r.imgHeight }),
                (y, E) => (
                    Y(),
                    ft(
                        "div",
                        { id: V(d), ref_key: "element", ref: l, class: "carousel slide", "data-bs-ride": "carousel" },
                        [
                            V(i)
                                ? (Y(),
                                  ft("div", q4, [
                                      (Y(!0),
                                      ft(
                                          Yt,
                                          null,
                                          Pe(
                                              h.value,
                                              (T, S) => (
                                                  Y(),
                                                  ft(
                                                      "button",
                                                      {
                                                          key: S,
                                                          type: "button",
                                                          "data-bs-target": `#${V(d)}`,
                                                          "data-bs-slide-to": S,
                                                          class: wt(S === 0 ? "active" : ""),
                                                          "aria-current": "true",
                                                          "aria-label": `Slide ${S}`,
                                                      },
                                                      null,
                                                      10,
                                                      z4
                                                  )
                                              )
                                          ),
                                          128
                                      )),
                                  ]))
                                : Dt("", !0),
                            xt("div", j4, [mt(y.$slots, "default")]),
                            V(n)
                                ? (Y(),
                                  ft(
                                      Yt,
                                      { key: 1 },
                                      [
                                          xt(
                                              "button",
                                              {
                                                  class: "carousel-control-prev",
                                                  type: "button",
                                                  "data-bs-target": `#${V(d)}`,
                                                  "data-bs-slide": "prev",
                                              },
                                              Y4,
                                              8,
                                              K4
                                          ),
                                          xt(
                                              "button",
                                              {
                                                  class: "carousel-control-next",
                                                  type: "button",
                                                  "data-bs-target": `#${V(d)}`,
                                                  "data-bs-slide": "next",
                                              },
                                              Z4,
                                              8,
                                              J4
                                          ),
                                      ],
                                      64
                                  ))
                                : Dt("", !0),
                        ],
                        8,
                        H4
                    )
                )
            )
        },
    }),
    Gb = bt({
        __name: "BImg",
        props: {
            alt: { default: void 0 },
            blank: { default: !1 },
            blankColor: { default: "transparent" },
            block: { default: !1 },
            center: { default: !1 },
            fluid: { default: !1 },
            lazy: { default: !1 },
            fluidGrow: { default: !1 },
            height: null,
            left: { default: !1 },
            right: { default: !1 },
            rounded: { type: [Boolean, String], default: !1 },
            sizes: null,
            src: null,
            srcset: null,
            thumbnail: { default: !1 },
            width: null,
        },
        emits: ["load"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "lazy")),
                i = z(L(r, "blank")),
                s = z(L(r, "block")),
                o = z(L(r, "center")),
                l = z(L(r, "fluid")),
                f = z(L(r, "fluidGrow")),
                d = z(L(r, "left")),
                h = z(L(r, "right")),
                y = z(L(r, "thumbnail")),
                E =
                    '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>',
                T = (M, k, F) =>
                    `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
                        E.replace("%{w}", String(M)).replace("%{h}", String(k)).replace("%{f}", F)
                    )}`,
                S = K(() => {
                    let { src: M } = r,
                        k = (typeof r.width == "number" ? r.width : parseInt(r.width, 10)) || void 0,
                        F = (typeof r.height == "number" ? r.height : parseInt(r.height, 10)) || void 0,
                        $ = ""
                    typeof r.srcset == "string"
                        ? ($ = r.srcset
                              .split(",")
                              .filter((W) => W)
                              .join(","))
                        : Array.isArray(r.srcset) && ($ = r.srcset.filter((W) => W).join(","))
                    let R = ""
                    return (
                        typeof r.sizes == "string"
                            ? (R = r.sizes
                                  .split(",")
                                  .filter((W) => W)
                                  .join(","))
                            : Array.isArray(r.sizes) && (R = r.sizes.filter((W) => W).join(",")),
                        i.value &&
                            (!F && k ? (F = k) : !k && F && (k = F),
                            !k && !F && ((k = 1), (F = 1)),
                            (M = T(k, F, r.blankColor || "transparent")),
                            ($ = ""),
                            (R = "")),
                        {
                            src: M,
                            alt: r.alt,
                            width: k || void 0,
                            height: F || void 0,
                            srcset: $ || void 0,
                            sizes: R || void 0,
                            loading: n.value ? "lazy" : "eager",
                        }
                    )
                }),
                N = K(() => (d.value ? "float-start" : h.value ? "float-end" : o.value ? "mx-auto" : void 0)),
                P = K(() => ({
                    "img-thumbnail": y.value,
                    "img-fluid": l.value || f.value,
                    "w-100": f.value,
                    rounded: r.rounded === "" || r.rounded === !0,
                    [`rounded-${r.rounded}`]: typeof r.rounded == "string" && r.rounded !== "",
                    [`${N.value}`]: N.value !== void 0,
                    "d-block": s.value || o.value,
                }))
            return (M, k) => (Y(), ft("img", ce({ class: V(P) }, V(S), { onLoad: k[0] || (k[0] = (F) => t("load", F)) }), null, 16))
        },
    }),
    e8 = ["id", "data-bs-interval"],
    r8 = { key: 0 },
    n8 = ["innerHTML"],
    i8 = { key: 0 },
    s8 = ["innerHTML"],
    o8 = bt({
        __name: "BCarouselSlide",
        props: {
            imgSrc: null,
            imgHeight: null,
            imgWidth: null,
            interval: null,
            active: { default: !1 },
            background: null,
            caption: null,
            captionHtml: null,
            captionTag: { default: "h3" },
            contentTag: { default: "div" },
            contentVisibleUp: null,
            id: null,
            imgAlt: null,
            imgBlank: { default: !1 },
            imgBlankColor: { default: "transparent" },
            text: null,
            textHtml: null,
            textTag: { default: "p" },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "active")),
                n = z(L(t, "imgBlank")),
                i = Ie(Kb, {}),
                s = ar(L(t, "id"), "accordion")
            K(() => (n.value ? n.value : t.imgSrc))
            const o = K(() => ({ background: `${t.background || i.background || "rgb(171, 171, 171)"} none repeat scroll 0% 0%` })),
                l = K(() => ({ "d-none": t.contentVisibleUp !== void 0, [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0 })),
                f = K(() => t.text && !t.textHtml),
                d = K(() => t.textHtml),
                h = K(() => t.caption && !t.captionHtml),
                y = K(() => t.captionHtml),
                E = K(() => i.width),
                T = K(() => i.height)
            return (S, N) => (
                Y(),
                ft(
                    "div",
                    { id: V(s), class: wt(["carousel-item", { active: V(r) }]), "data-bs-interval": e.interval, style: hn(V(o)) },
                    [
                        mt(S.$slots, "img", {}, () => [
                            Ut(
                                Gb,
                                {
                                    class: "d-block w-100",
                                    alt: e.imgAlt,
                                    src: e.imgSrc,
                                    width: e.imgWidth || V(E),
                                    height: e.imgHeight || V(T),
                                    blank: V(n),
                                    "blank-color": e.imgBlankColor,
                                },
                                null,
                                8,
                                ["alt", "src", "width", "height", "blank", "blank-color"]
                            ),
                        ]),
                        e.caption || e.captionHtml || e.text || e.textHtml || S.$slots.default
                            ? (Y(),
                              kt(
                                  Kt(e.contentTag),
                                  { key: 0, class: wt(["carousel-caption", V(l)]) },
                                  {
                                      default: Ct(() => [
                                          e.caption || e.captionHtml
                                              ? (Y(),
                                                kt(
                                                    Kt(e.captionTag),
                                                    { key: 0 },
                                                    {
                                                        default: Ct(() => [
                                                            V(h) ? (Y(), ft("span", r8, jt(e.caption), 1)) : Dt("", !0),
                                                            V(y)
                                                                ? (Y(), ft("span", { key: 1, innerHTML: e.captionHtml }, null, 8, n8))
                                                                : Dt("", !0),
                                                        ]),
                                                        _: 1,
                                                    }
                                                ))
                                              : Dt("", !0),
                                          e.text || e.textHtml
                                              ? (Y(),
                                                kt(
                                                    Kt(e.textTag),
                                                    { key: 1 },
                                                    {
                                                        default: Ct(() => [
                                                            V(f) ? (Y(), ft("span", i8, jt(e.text), 1)) : Dt("", !0),
                                                            V(d)
                                                                ? (Y(), ft("span", { key: 1, innerHTML: e.textHtml }, null, 8, s8))
                                                                : Dt("", !0),
                                                        ]),
                                                        _: 1,
                                                    }
                                                ))
                                              : Dt("", !0),
                                          mt(S.$slots, "default"),
                                      ]),
                                      _: 3,
                                  },
                                  8,
                                  ["class"]
                              ))
                            : Dt("", !0),
                    ],
                    14,
                    e8
                )
            )
        },
    }),
    Zp = pf("", [], { type: [Boolean, String, Number], default: !1 }),
    tg = pf("offset", [""], { type: [String, Number], default: null }),
    eg = pf("order", [""], { type: [String, Number], default: null }),
    a8 = bt({
        name: "BCol",
        props: {
            col: { type: [Boolean, String], default: !1 },
            cols: { type: [String, Number], default: null },
            ...Zp,
            offset: { type: [String, Number], default: null },
            ...tg,
            order: { type: [String, Number], default: null },
            ...eg,
            alignSelf: { type: String, default: null },
            tag: { type: String, default: "div" },
        },
        setup(e) {
            const t = z(L(e, "col")),
                r = [
                    { content: Zp, propPrefix: "cols", classPrefix: "col" },
                    { content: tg, propPrefix: "offset" },
                    { content: eg, propPrefix: "order" },
                ],
                n = K(() => r.flatMap((i) => Ab(e, i.content, i.propPrefix, i.classPrefix)))
            return {
                classes: K(() => ({
                    col: t.value || !n.value.some((i) => /^col-/.test(i) && !e.cols),
                    [`col-${e.cols}`]: !!e.cols,
                    [`offset-${e.offset}`]: !!e.offset,
                    [`order-${e.order}`]: !!e.order,
                    [`align-self-${e.alignSelf}`]: !!e.alignSelf,
                })),
                classList: n,
            }
        },
    })
function l8(e, t, r, n, i, s) {
    return Y(), kt(Kt(e.tag), { class: wt([e.classes, e.classList]) }, { default: Ct(() => [mt(e.$slots, "default")]), _: 3 }, 8, ["class"])
}
const ga = ur(a8, [["render", l8]]),
    Zs = { delay: 5e3, value: !0, pos: "top-right" }
class rg {
    constructor(t) {
        Ue(this, "vm"),
            Ue(this, "containerPositions"),
            Di(t) ? (this.vm = t) : (this.vm = Ze(t)),
            (this.containerPositions = K(() => {
                const r = new Set([])
                return (
                    this.vm.toasts.map((n) => {
                        n.options.pos && r.add(n.options.pos)
                    }),
                    r
                )
            }))
    }
    toasts(t) {
        return K(
            t
                ? () =>
                      this.vm.toasts.filter((r) => {
                          if (r.options.pos === t && r.options.value) return r
                      })
                : () => this.vm.toasts
        )
    }
    remove(...t) {
        this.vm.toasts = this.vm.toasts.filter((r) => {
            if (r.options.id && !t.includes(r.options.id)) return r
        })
    }
    isRoot() {
        var t
        return (t = this.vm.root) != null ? t : !1
    }
    show(t, r = Zs) {
        const n = { id: ri(), ...Zs, ...r },
            i = { options: Ze(n), content: t }
        return this.vm.toasts.push(i), i
    }
    info(t, r = Zs) {
        return this.show(t, { variant: "info", ...r })
    }
    danger(t, r = Zs) {
        return this.show(t, { variant: "danger", ...r })
    }
    warning(t, r = Zs) {
        return this.show(t, { variant: "warning", ...r })
    }
    success(t, r = Zs) {
        return this.show(t, { variant: "success", ...r })
    }
    hide() {}
}
class u8 {
    constructor() {
        Ue(this, "vms"), Ue(this, "rootInstance"), Ue(this, "useToast", Yb), (this.vms = {})
    }
    getOrCreateViewModel(t) {
        if (!t) {
            if (this.rootInstance) return this.vms[this.rootInstance]
            const r = { root: !0, toasts: [], container: void 0, id: Symbol("toast") }
            return (this.rootInstance = r.id), (this.vms[r.id] = r), r
        }
        if (t.root) {
            if (this.rootInstance) return this.vms[this.rootInstance]
            this.rootInstance = t.id
        }
        return (this.vms[t.id] = t), t
    }
    getVM(t) {
        if (!t && this.rootInstance) return this.vms[this.rootInstance]
        if (t) return this.vms[t]
    }
}
const Zc = Symbol(),
    Wb = Symbol(),
    f8 = { container: void 0, toasts: [], root: !1 }
function c8() {
    return Ie(Wb)
}
function Yb(e, t = Zc) {
    const r = Ie(c8())
    if (!e) return new rg(r.getOrCreateViewModel())
    const n = { id: Symbol("toastInstance") },
        i = { ...f8, ...n, ...e },
        s = r.getOrCreateViewModel(i)
    return new rg(s)
}
const d8 = {
        install: (e, t = {}) => {
            var r, n, i, s
            e.provide(Wb, (n = (r = t == null ? void 0 : t.BToast) == null ? void 0 : r.injectkey) != null ? n : Zc),
                e.provide((s = (i = t == null ? void 0 : t.BToast) == null ? void 0 : i.injectkey) != null ? s : Zc, new u8())
        },
    },
    Jb = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: "",
    },
    h8 = { ...Jb, enterActiveClass: "fade showing", leaveActiveClass: "fade showing" },
    Tu = bt({
        props: {
            appear: { type: [Boolean, String], default: !1 },
            mode: { type: String, required: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            transProps: { type: Object, required: !1 },
        },
        setup(e, { slots: t }) {
            const r = z(L(e, "appear")),
                n = z(L(e, "noFade")),
                i = Ht(e.transProps)
            return (
                Mb(i.value) ||
                    ((i.value = n.value ? Jb : h8),
                    r.value &&
                        (i.value = {
                            ...i.value,
                            appear: !0,
                            appearClass: i.value.enterClass,
                            appearActiveClass: i.value.enterActiveClass,
                            appearToClass: i.value.enterToClass,
                        })),
                (i.value = { mode: e.mode, ...i.value, css: !0 }),
                () => he(zu, { ...i.value }, { default: () => (t.default ? t.default() : []) })
            )
        },
    }),
    p8 = "toast-title",
    ng = 1e3,
    Qb = bt({
        components: { BLink: $r },
        props: {
            ...Gs,
            delay: { type: Number, default: 5e3 },
            bodyClass: { type: String },
            body: { type: [Object, String] },
            headerClass: { type: String },
            headerTag: { type: String, default: "div" },
            animation: { type: [Boolean, String], default: !0 },
            id: { type: String },
            isStatus: { type: [Boolean, String], default: !1 },
            autoHide: { type: [Boolean, String], default: !0 },
            noCloseButton: { type: [Boolean, String], default: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            noHoverPause: { type: [Boolean, String], default: !1 },
            solid: { type: [Boolean, String], default: !1 },
            static: { type: [Boolean, String], default: !1 },
            title: { type: String },
            modelValue: { type: [Boolean, String], default: !1 },
            toastClass: { type: Array },
            variant: { type: String },
        },
        emits: ["destroyed", "update:modelValue"],
        setup(e, { emit: t, slots: r }) {
            z(L(e, "animation"))
            const n = z(L(e, "isStatus")),
                i = z(L(e, "autoHide")),
                s = z(L(e, "noCloseButton")),
                o = z(L(e, "noFade")),
                l = z(L(e, "noHoverPause"))
            z(L(e, "solid")), z(L(e, "static"))
            const f = z(L(e, "modelValue")),
                d = Ht(!1),
                h = Ht(!1),
                y = Ht(!1),
                E = K(() => ({ [`b-toast-${e.variant}`]: e.variant !== void 0, show: y.value || d.value }))
            let T, S, N
            const P = () => {
                    typeof T > "u" || (clearTimeout(T), (T = void 0))
                },
                M = K(() => Math.max(Uo(e.delay, 0), ng)),
                k = () => {
                    f.value &&
                        ((S = N = 0),
                        P(),
                        (h.value = !0),
                        Ll(() => {
                            y.value = !1
                        }))
                },
                F = () => {
                    P(),
                        t("update:modelValue", !0),
                        (S = N = 0),
                        (h.value = !1),
                        Wr(() => {
                            Ll(() => {
                                y.value = !0
                            })
                        })
                },
                $ = () => {
                    if (!i.value || l.value || !T || N) return
                    const at = Date.now() - S
                    at > 0 && (P(), (N = Math.max(M.value - at, ng)))
                },
                R = () => {
                    ;(!i.value || l.value || !N) && (N = S = 0), W()
                }
            Oe(
                () => f.value,
                (at) => {
                    at ? F() : k()
                }
            )
            const W = () => {
                    P(), i.value && ((T = setTimeout(k, N || M.value)), (S = Date.now()), (N = 0))
                },
                nt = () => {
                    ;(d.value = !0), t("update:modelValue", !0)
                },
                J = () => {
                    ;(d.value = !1), W()
                },
                Q = () => {
                    d.value = !0
                },
                ot = () => {
                    ;(d.value = !1), (N = S = 0), t("update:modelValue", !1)
                }
            el(() => {
                P(), i.value && t("destroyed", e.id)
            }),
                je(() => {
                    Wr(() => {
                        f.value &&
                            Ll(() => {
                                F()
                            })
                    })
                })
            const it = () => {
                Wr(() => {
                    Ll(() => {
                        k()
                    })
                })
            }
            return () => {
                const at = () => {
                    const x = [],
                        a = Nr(p8, { hide: k }, r)
                    a ? x.push(he(a)) : e.title && x.push(he("strong", { class: "me-auto" }, e.title)),
                        !s.value &&
                            x.length !== 0 &&
                            x.push(
                                he(qb, {
                                    class: ["btn-close"],
                                    onClick: () => {
                                        k()
                                    },
                                })
                            )
                    const c = []
                    if (
                        (x.length > 0 && c.push(he(e.headerTag, { class: "toast-header" }, { default: () => x })),
                        Nr("default", { hide: k }, r) || e.body)
                    ) {
                        const m = he(
                            za(e) ? "b-link" : "div",
                            { class: ["toast-body", e.bodyClass], onClick: za(e) ? { click: it } : {} },
                            Nr("default", { hide: k }, r) || e.body
                        )
                        c.push(m)
                    }
                    return he("div", { class: ["toast", e.toastClass, E.value], tabindex: "0" }, c)
                }
                return he(
                    "div",
                    {
                        class: ["b-toast"],
                        id: e.id,
                        role: h.value ? null : n.value ? "status" : "alert",
                        "aria-live": h.value ? null : n.value ? "polite" : "assertive",
                        "aria-atomic": h.value ? null : "true",
                        onmouseenter: $,
                        onmouseleave: R,
                    },
                    [
                        he(Tu, { noFade: o.value, onAfterEnter: J, onBeforeEnter: nt, onAfterLeave: ot, onBeforeLeave: Q }, () => [
                            y.value ? at() : "",
                        ]),
                    ]
                )
            }
        },
    }),
    td = bt({
        __name: "BToaster",
        props: { position: { default: "top-right" }, instance: null },
        setup(e) {
            const t = e,
                r = {
                    "top-left": "top-0 start-0",
                    "top-center": "top-0 start-50 translate-middle-x",
                    "top-right": "top-0 end-0",
                    "middle-left": "top-50 start-0 translate-middle-y",
                    "middle-center": "top-50 start-50 translate-middle",
                    "middle-right": "top-50 end-0 translate-middle-y",
                    "bottom-left": "bottom-0 start-0",
                    "bottom-center": "bottom-0 start-50 translate-middle-x",
                    "bottom-right": "bottom-0 end-0",
                },
                n = K(() => r[t.position]),
                i = (s) => {
                    var o
                    ;(o = t.instance) == null || o.remove(s)
                }
            return (s, o) => {
                var l
                return (
                    Y(),
                    ft(
                        "div",
                        { class: wt([[V(n)], "b-toaster position-fixed p-3"]), style: { "z-index": "11" } },
                        [
                            (Y(!0),
                            ft(
                                Yt,
                                null,
                                Pe(
                                    (l = e.instance) == null ? void 0 : l.toasts(e.position).value,
                                    (f) => (
                                        Y(),
                                        kt(
                                            Qb,
                                            {
                                                id: f.options.id,
                                                key: f.options.id,
                                                modelValue: f.options.value,
                                                "onUpdate:modelValue": (d) => (f.options.value = d),
                                                delay: f.options.delay,
                                                title: f.content.title,
                                                body: f.content.body,
                                                component: f.content.body,
                                                variant: f.options.variant,
                                                onDestroyed: i,
                                            },
                                            null,
                                            8,
                                            ["id", "modelValue", "onUpdate:modelValue", "delay", "title", "body", "component", "variant"]
                                        )
                                    )
                                ),
                                128
                            )),
                        ],
                        2
                    )
                )
            }
        },
    }),
    g8 = bt({
        name: "BContainer",
        props: {
            gutterX: { type: String, default: null },
            gutterY: { type: String, default: null },
            fluid: { type: [Boolean, String], default: !1 },
            toast: { type: Object },
            position: { type: String, required: !1 },
        },
        setup(e, { slots: t, expose: r }) {
            const n = Ht()
            let i
            const s = K(() => ({
                container: !e.fluid,
                ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
                [`container-${e.fluid}`]: typeof e.fluid == "string",
                [`gx-${e.gutterX}`]: e.gutterX !== null,
                [`gy-${e.gutterY}`]: e.gutterY !== null,
            }))
            return (
                je(() => {
                    e.toast
                }),
                e.toast && ((i = Yb({ container: n, root: e.toast.root })), r({})),
                () => {
                    var o
                    const l = []
                    return (
                        i == null ||
                            i.containerPositions.value.forEach((f) => {
                                l.push(he(td, { key: f, instance: i, position: f }))
                            }),
                        he("div", { class: [s.value, e.position], ref: n }, [...l, (o = t.default) == null ? void 0 : o.call(t)])
                    )
                }
            )
        },
        methods: {},
    }),
    m8 = { class: "visually-hidden" },
    v8 = ["aria-labelledby", "role"],
    Xb = bt({
        __name: "BDropdown",
        props: {
            id: null,
            menuClass: null,
            size: null,
            splitClass: null,
            splitVariant: null,
            text: null,
            toggleClass: null,
            autoClose: { type: [Boolean, String], default: !0 },
            block: { default: !1 },
            boundary: { default: "clippingParents" },
            dark: { default: !1 },
            disabled: { default: !1 },
            isNav: { default: !1 },
            dropup: { default: !1 },
            dropright: { default: !1 },
            dropleft: { default: !1 },
            noFlip: { default: !1 },
            offset: { default: 0 },
            popperOpts: { default: () => ({}) },
            right: { default: !1 },
            role: { default: "menu" },
            split: { default: !1 },
            splitButtonType: { default: "button" },
            splitHref: { default: void 0 },
            noCaret: { default: !1 },
            toggleText: { default: "Toggle dropdown" },
            variant: { default: "secondary" },
        },
        emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
        setup(e, { expose: t, emit: r }) {
            const n = e,
                i = z(L(n, "block")),
                s = z(L(n, "dark")),
                o = z(L(n, "disabled")),
                l = z(L(n, "dropup")),
                f = z(L(n, "dropright")),
                d = z(L(n, "isNav")),
                h = z(L(n, "dropleft")),
                y = z(L(n, "right")),
                E = z(L(n, "split")),
                T = z(L(n, "noCaret")),
                S = Ht(),
                N = Ht(),
                P = Ht(),
                M = ar(L(n, "id"), "dropdown")
            Ke(S, "show.bs.dropdown", () => r("show")),
                Ke(S, "shown.bs.dropdown", () => r("shown")),
                Ke(S, "hide.bs.dropdown", () => r("hide")),
                Ke(S, "hidden.bs.dropdown", () => r("hidden"))
            const k = (Q) => {
                    E.value && r("click", Q)
                },
                F = K(() => ({ "d-grid": i.value, "d-flex": i.value && E.value })),
                $ = K(() => ({
                    "nav-link": d.value,
                    "dropdown-toggle": !E.value,
                    "dropdown-toggle-no-caret": T.value && !E.value,
                    "w-100": E.value && i.value,
                })),
                R = K(() => ({ "dropdown-menu-dark": s.value, "dropdown-menu-right": y.value })),
                W = K(() => ({
                    "data-bs-toggle": E.value ? void 0 : "dropdown",
                    "aria-expanded": E.value ? void 0 : !1,
                    ref: E.value ? void 0 : N,
                    href: E.value ? n.splitHref : void 0,
                })),
                nt = K(() => ({ ref: E.value ? N : void 0 })),
                J = () => {
                    var Q
                    ;(Q = P.value) == null || Q.hide()
                }
            return (
                je(() => {
                    var Q
                    P.value = new dn((Q = N.value) == null ? void 0 : Q.$el, {
                        autoClose: n.autoClose,
                        boundary: n.boundary,
                        offset: n.offset ? n.offset.toString() : "",
                        reference: n.offset || E.value ? "parent" : "toggle",
                        popperConfig: (ot) => {
                            const it = {
                                placement: "bottom-start",
                                modifiers: n.noFlip ? [{ name: "flip", options: { fallbackPlacements: [] } }] : [],
                            }
                            return (
                                l.value
                                    ? (it.placement = y.value ? "top-end" : "top-start")
                                    : f.value
                                    ? (it.placement = "right-start")
                                    : h.value
                                    ? (it.placement = "left-start")
                                    : y.value && (it.placement = "bottom-end"),
                                Jc(ot, Jc(it, n.popperOpts))
                            )
                        },
                    })
                }),
                t({ hide: J }),
                (Q, ot) => (
                    Y(),
                    ft(
                        "div",
                        { ref_key: "parent", ref: S, class: wt([V(F), "btn-group"]) },
                        [
                            Ut(
                                ja,
                                ce(
                                    {
                                        id: V(M),
                                        variant: e.splitVariant || e.variant,
                                        size: e.size,
                                        class: [V($), V(E) ? e.splitClass : e.toggleClass],
                                        disabled: V(o),
                                        type: e.splitButtonType,
                                    },
                                    V(W),
                                    { onClick: k }
                                ),
                                { default: Ct(() => [ve(jt(e.text) + " ", 1), mt(Q.$slots, "button-content")]), _: 3 },
                                16,
                                ["id", "variant", "size", "class", "disabled", "type"]
                            ),
                            V(E)
                                ? (Y(),
                                  kt(
                                      ja,
                                      ce({ key: 0, variant: e.variant, size: e.size, disabled: V(o) }, V(nt), {
                                          class: [e.toggleClass, "dropdown-toggle-split dropdown-toggle"],
                                          "data-bs-toggle": "dropdown",
                                          "aria-expanded": "false",
                                          onClick: ot[0] || (ot[0] = (it) => r("toggle")),
                                      }),
                                      { default: Ct(() => [xt("span", m8, jt(e.toggleText), 1)]), _: 1 },
                                      16,
                                      ["variant", "size", "disabled", "class"]
                                  ))
                                : Dt("", !0),
                            xt(
                                "ul",
                                { class: wt(["dropdown-menu", [e.menuClass, V(R)]]), "aria-labelledby": V(M), role: e.role },
                                [mt(Q.$slots, "default")],
                                10,
                                v8
                            ),
                        ],
                        2
                    )
                )
            )
        },
    }),
    b8 = { role: "presentation" },
    y8 = bt({
        __name: "BDropdownDivider",
        props: { tag: { default: "hr" } },
        setup(e) {
            return (t, r) => (
                Y(), ft("li", b8, [(Y(), kt(Kt(e.tag), { class: "dropdown-divider", role: "separator", "aria-orientation": "horizontal" }))])
            )
        },
    }),
    _8 = {},
    w8 = { role: "presentation" },
    A8 = { class: "px-4 py-3" }
function E8(e, t) {
    return Y(), ft("li", w8, [xt("form", A8, [mt(e.$slots, "default")])])
}
const x8 = ur(_8, [["render", E8]]),
    T8 = { role: "presentation" },
    C8 = ["id", "aria-describedby"],
    M8 = { inheritAttrs: !1 },
    S8 = bt({
        ...M8,
        __name: "BDropdownGroup",
        props: {
            id: null,
            ariaDescribedby: null,
            header: null,
            headerClasses: { default: void 0 },
            headerTag: { default: "header" },
            headerVariant: { default: void 0 },
        },
        setup(e) {
            const t = e,
                r = K(() => (t.id ? [t.id, "group_dd_header"].join("_") : void 0)),
                n = K(() => (t.headerTag === "header" ? void 0 : "heading")),
                i = K(() => ({ [`text-${t.headerVariant}`]: !!t.headerVariant }))
            return (s, o) => (
                Y(),
                ft("li", T8, [
                    (Y(),
                    kt(
                        Kt(e.headerTag),
                        { id: V(r), class: wt(["dropdown-header", [V(i), e.headerClasses]]), role: V(n) },
                        { default: Ct(() => [mt(s.$slots, "header", {}, () => [ve(jt(e.header), 1)])]), _: 3 },
                        8,
                        ["id", "class", "role"]
                    )),
                    xt(
                        "ul",
                        ce({ id: e.id, role: "group", class: "list-unstyled" }, s.$attrs, { "aria-describedby": e.ariaDescribedby || V(r) }),
                        [mt(s.$slots, "default")],
                        16,
                        C8
                    ),
                ])
            )
        },
    }),
    k8 = {},
    N8 = { class: "dropdown-header" }
function O8(e, t) {
    return Y(), ft("li", null, [xt("h6", N8, [mt(e.$slots, "default")])])
}
const I8 = ur(k8, [["render", O8]]),
    B8 = { role: "presentation" },
    P8 = { inheritAttrs: !1 },
    R8 = bt({
        ...P8,
        __name: "BDropdownItem",
        props: {
            href: null,
            linkClass: null,
            active: { default: !1 },
            disabled: { default: !1 },
            rel: { default: void 0 },
            target: { default: "_self" },
            variant: { default: void 0 },
        },
        emits: ["click"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "active")),
                i = z(L(r, "disabled")),
                s = Sd(),
                o = K(() => ({ active: n.value, disabled: i.value, [`text-${r.variant}`]: !!r.variant })),
                l = K(() => (r.href ? "a" : s.to ? $r : "button")),
                f = K(() => ({
                    "aria-current": n.value ? "true" : null,
                    href: l.value === "a" ? r.href : null,
                    rel: r.rel,
                    type: l.value === "button" ? "button" : null,
                    target: r.target,
                    ...(s.to ? { activeClass: "active", ...s } : {}),
                })),
                d = (h) => t("click", h)
            return (h, y) => (
                Y(),
                ft("li", B8, [
                    (Y(),
                    kt(
                        Kt(V(l)),
                        ce({ class: ["dropdown-item", [V(o), e.linkClass]] }, V(f), { onClick: d }),
                        { default: Ct(() => [mt(h.$slots, "default")]), _: 3 },
                        16,
                        ["class"]
                    )),
                ])
            )
        },
    }),
    L8 = { role: "presentation" },
    D8 = { inheritAttrs: !1 },
    $8 = bt({
        ...D8,
        __name: "BDropdownItemButton",
        props: {
            buttonClass: null,
            active: { default: !1 },
            activeClass: { default: "active" },
            disabled: { default: !1 },
            variant: { default: void 0 },
        },
        emits: ["click"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "active")),
                i = z(L(r, "disabled")),
                s = K(() => ({ [r.activeClass]: n.value, disabled: i.value, [`text-${r.variant}`]: !!r.variant })),
                o = K(() => ({ role: "menuitem", type: "button", disabled: i.value })),
                l = (f) => t("click", f)
            return (f, d) => (
                Y(),
                ft("li", L8, [
                    xt("button", ce({ class: ["dropdown-item", [V(s), e.buttonClass]] }, V(o), { onClick: l }), [mt(f.$slots, "default")], 16),
                ])
            )
        },
    }),
    F8 = {},
    V8 = { role: "presentation" },
    U8 = { class: "px-4 py-1 mb-0 text-muted" }
function H8(e, t) {
    return Y(), ft("li", V8, [xt("p", U8, [mt(e.$slots, "default")])])
}
const q8 = ur(F8, [["render", H8]]),
    z8 = ["id", "novalidate", "onSubmit"],
    Zb = bt({
        __name: "BForm",
        props: { id: null, floating: { default: !1 }, novalidate: { default: !1 }, validated: { default: !1 } },
        emits: ["submit"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "floating")),
                i = z(L(r, "novalidate")),
                s = z(L(r, "validated")),
                o = K(() => ({ "form-floating": n.value, "was-validated": s.value })),
                l = (f) => t("submit", f)
            return (f, d) => (
                Y(), ft("form", { id: e.id, novalidate: V(i), class: wt(V(o)), onSubmit: Gu(l, ["prevent"]) }, [mt(f.$slots, "default")], 42, z8)
            )
        },
    }),
    j8 = { class: "form-floating" },
    K8 = ["for"],
    G8 = bt({
        __name: "BFormFloatingLabel",
        props: { labelFor: null, label: null },
        setup(e) {
            return (t, r) => (Y(), ft("div", j8, [mt(t.$slots, "default"), xt("label", { for: e.labelFor }, jt(e.label), 9, K8)]))
        },
    }),
    ed = bt({
        __name: "BFormInvalidFeedback",
        props: {
            ariaLive: null,
            forceShow: { default: !1 },
            id: null,
            role: null,
            state: { default: void 0 },
            tag: { default: "div" },
            tooltip: { default: !1 },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "forceShow")),
                n = t.state !== void 0 ? z(L(t, "state")) : K(() => {}),
                i = z(L(t, "tooltip")),
                s = K(() => r.value === !0 || n.value === !1),
                o = K(() => ({ "d-block": s.value, "invalid-feedback": !i.value, "invalid-tooltip": i.value })),
                l = K(() => ({
                    id: t.id || null,
                    role: t.role || null,
                    "aria-live": t.ariaLive || null,
                    "aria-atomic": t.ariaLive ? "true" : null,
                }))
            return (f, d) => (
                Y(), kt(Kt(e.tag), ce({ class: V(o) }, V(l)), { default: Ct(() => [mt(f.$slots, "default")]), _: 3 }, 16, ["class"])
            )
        },
    }),
    Yl = bt({
        __name: "BFormRow",
        props: { tag: { default: "div" } },
        setup(e) {
            return (t, r) => (Y(), kt(Kt(e.tag), { class: "row d-flex flex-wrap" }, { default: Ct(() => [mt(t.$slots, "default")]), _: 3 }))
        },
    }),
    rd = bt({
        __name: "BFormText",
        props: { id: null, inline: { default: !1 }, tag: { default: "small" }, textVariant: { default: "muted" } },
        setup(e) {
            const t = e,
                r = z(L(t, "inline")),
                n = K(() => ({ "form-text": !r.value, [`text-${t.textVariant}`]: !!t.textVariant })),
                i = K(() => ({ id: t.id || null }))
            return (s, o) => (
                Y(), kt(Kt(e.tag), ce({ class: V(n) }, V(i)), { default: Ct(() => [mt(s.$slots, "default")]), _: 3 }, 16, ["class"])
            )
        },
    }),
    nd = bt({
        __name: "BFormValidFeedback",
        props: {
            ariaLive: null,
            forceShow: { default: !1 },
            id: null,
            role: null,
            state: { default: void 0 },
            tag: { default: "div" },
            tooltip: { default: !1 },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "forceShow")),
                n = t.state !== void 0 ? z(L(t, "state")) : K(() => {}),
                i = z(L(t, "tooltip")),
                s = K(() => r.value === !0 || n.value === !0),
                o = K(() => ({ "d-block": s.value, "valid-feedback": !i.value, "valid-tooltip": i.value })),
                l = K(() => ({
                    id: t.id || null,
                    role: t.role || null,
                    "aria-live": t.ariaLive || null,
                    "aria-atomic": t.ariaLive ? "true" : null,
                }))
            return (f, d) => (
                Y(), kt(Kt(e.tag), ce({ class: V(o) }, V(l)), { default: Ct(() => [mt(f.$slots, "default")]), _: 3 }, 16, ["class"])
            )
        },
    }),
    W8 = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"],
    Y8 = ["for"],
    J8 = { inheritAttrs: !1 },
    ty = bt({
        ...J8,
        __name: "BFormCheckbox",
        props: {
            ariaLabel: null,
            ariaLabelledBy: null,
            form: null,
            indeterminate: null,
            name: null,
            id: { default: void 0 },
            autofocus: { default: !1 },
            plain: { default: !1 },
            button: { default: !1 },
            switch: { default: !1 },
            disabled: { default: !1 },
            buttonVariant: { default: "secondary" },
            inline: { default: !1 },
            required: { default: void 0 },
            size: { default: "md" },
            state: { default: void 0 },
            uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
            value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
            modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 },
        },
        emits: ["update:modelValue", "input", "change"],
        setup(e, { emit: t }) {
            const r = e,
                n = r.indeterminate !== void 0 ? z(L(r, "indeterminate")) : K(() => {}),
                i = z(L(r, "autofocus")),
                s = z(L(r, "plain")),
                o = z(L(r, "button")),
                l = z(L(r, "switch")),
                f = z(L(r, "disabled")),
                d = z(L(r, "inline")),
                h = r.required !== void 0 ? z(L(r, "required")) : K(() => {}),
                y = r.state !== void 0 ? z(L(r, "state")) : K(() => {}),
                E = ar(L(r, "id"), "form-check"),
                T = Ht(null),
                S = Ht(!1),
                N = K({
                    get: () =>
                        r.uncheckedValue
                            ? Array.isArray(r.modelValue)
                                ? r.modelValue.indexOf(r.value) > -1
                                : r.modelValue === r.value
                            : r.modelValue,
                    set: (R) => {
                        let W = R
                        Array.isArray(r.modelValue)
                            ? r.uncheckedValue &&
                              ((W = r.modelValue),
                              R
                                  ? (W.indexOf(r.uncheckedValue) > -1 && W.splice(W.indexOf(r.uncheckedValue), 1), W.push(r.value))
                                  : (W.indexOf(r.value) > -1 && W.splice(W.indexOf(r.value), 1), W.push(r.uncheckedValue)))
                            : (W = R ? r.value : r.uncheckedValue),
                            t("input", W),
                            t("update:modelValue", W),
                            t("change", W)
                    },
                }),
                P = K(() =>
                    Array.isArray(r.modelValue) ? r.modelValue.indexOf(r.value) > -1 : JSON.stringify(r.modelValue) === JSON.stringify(r.value)
                ),
                M = Ze({
                    plain: L(s, "value"),
                    button: L(o, "value"),
                    inline: L(d, "value"),
                    switch: L(l, "value"),
                    size: L(r, "size"),
                    state: L(y, "value"),
                    buttonVariant: L(r, "buttonVariant"),
                }),
                k = Nb(M),
                F = Ob(M),
                $ = Ib(M)
            return (
                je(() => {
                    i.value && T.value.focus()
                }),
                (R, W) => (
                    Y(),
                    ft(
                        "div",
                        { class: wt(V(k)) },
                        [
                            qi(
                                xt(
                                    "input",
                                    ce({ id: V(E) }, R.$attrs, {
                                        ref_key: "input",
                                        ref: T,
                                        "onUpdate:modelValue": W[0] || (W[0] = (nt) => (Re(N) ? (N.value = nt) : null)),
                                        class: V(F),
                                        type: "checkbox",
                                        disabled: V(f),
                                        required: !!e.name && !!V(h),
                                        name: e.name,
                                        form: e.form,
                                        "aria-label": e.ariaLabel,
                                        "aria-labelledby": e.ariaLabelledBy,
                                        "aria-required": e.name && V(h) ? "true" : void 0,
                                        value: e.value,
                                        indeterminate: V(n),
                                        onFocus: W[1] || (W[1] = (nt) => (S.value = !0)),
                                        onBlur: W[2] || (W[2] = (nt) => (S.value = !1)),
                                    }),
                                    null,
                                    16,
                                    W8
                                ),
                                [[ju, V(N)]]
                            ),
                            R.$slots.default || !V(s)
                                ? (Y(),
                                  ft(
                                      "label",
                                      { key: 0, for: V(E), class: wt([V($), { active: V(P), focus: S.value }]) },
                                      [mt(R.$slots, "default")],
                                      10,
                                      Y8
                                  ))
                                : Dt("", !0),
                        ],
                        2
                    )
                )
            )
        },
    }),
    Q8 = ["id"],
    X8 = ["innerHTML"],
    Z8 = ["textContent"],
    tN = bt({
        __name: "BFormCheckboxGroup",
        props: {
            id: null,
            form: null,
            modelValue: { default: () => [] },
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            buttonVariant: { default: "secondary" },
            buttons: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            name: null,
            options: { default: () => [] },
            plain: { default: !1 },
            required: { default: !1 },
            size: null,
            stacked: { default: !1 },
            state: { default: void 0 },
            switches: { default: !1 },
            textField: { default: "text" },
            validated: { default: !1 },
            valueField: { default: "value" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(e, { emit: t }) {
            const r = e
            z(L(r, "autofocus"))
            const n = z(L(r, "buttons")),
                i = z(L(r, "disabled"))
            z(L(r, "plain"))
            const s = z(L(r, "required")),
                o = z(L(r, "stacked")),
                l = r.state !== void 0 ? z(L(r, "state")) : K(() => {}),
                f = z(L(r, "switches")),
                d = z(L(r, "validated")),
                h = Qi(),
                y = "BFormCheckbox",
                E = ar(L(r, "id"), "checkbox"),
                T = ar(L(r, "name"), "checkbox"),
                S = K({
                    get: () => r.modelValue,
                    set: (F) => {
                        if (JSON.stringify(F) === JSON.stringify(r.modelValue)) return
                        const $ = r.options
                            .filter((R) => F.map((W) => JSON.stringify(W)).includes(JSON.stringify(typeof R == "string" ? R : R[r.valueField])))
                            .map((R) => (typeof R == "string" ? R : R[r.valueField]))
                        t("input", $), t("update:modelValue", $), t("change", $)
                    },
                }),
                N = K(() =>
                    (h.first ? xu(h.first(), y, i.value) : [])
                        .concat(r.options.map((F) => Rb(F, r)))
                        .concat(h.default ? xu(h.default(), y, i.value) : [])
                        .map((F, $) => Lb(F, $, r, T, E))
                        .map((F) => ({ ...F, props: { switch: f.value, ...F.props } }))
                ),
                P = Ze({
                    required: L(s, "value"),
                    ariaInvalid: L(r, "ariaInvalid"),
                    state: L(l, "value"),
                    validated: L(d, "value"),
                    buttons: L(n, "value"),
                    stacked: L(o, "value"),
                    size: L(r, "size"),
                }),
                M = Bb(P),
                k = Pb(P)
            return (F, $) => (
                Y(),
                ft(
                    "div",
                    ce(V(M), { id: V(E), role: "group", class: [V(k), "bv-no-focus-ring"], tabindex: "-1" }),
                    [
                        (Y(!0),
                        ft(
                            Yt,
                            null,
                            Pe(
                                V(N),
                                (R, W) => (
                                    Y(),
                                    kt(
                                        ty,
                                        ce(
                                            {
                                                key: W,
                                                modelValue: V(S),
                                                "onUpdate:modelValue": $[0] || ($[0] = (nt) => (Re(S) ? (S.value = nt) : null)),
                                            },
                                            R.props
                                        ),
                                        {
                                            default: Ct(() => [
                                                R.html
                                                    ? (Y(), ft("span", { key: 0, innerHTML: R.html }, null, 8, X8))
                                                    : (Y(), ft("span", { key: 1, textContent: jt(R.text) }, null, 8, Z8)),
                                            ]),
                                            _: 2,
                                        },
                                        1040,
                                        ["modelValue"]
                                    )
                                )
                            ),
                            128
                        )),
                    ],
                    16,
                    Q8
                )
            )
        },
    }),
    ey = ["input", "select", "textarea"],
    eN = ey.map((e) => `${e}:not([disabled])`).join(),
    rN = [...ey, "a", "button", "label"],
    nN = "label",
    iN = "invalid-feedback",
    sN = "valid-feedback",
    oN = "description",
    aN = "default",
    lN = bt({
        components: { BCol: ga, BFormInvalidFeedback: ed, BFormRow: Yl, BFormText: rd, BFormValidFeedback: nd },
        props: {
            contentCols: { type: [Boolean, String, Number], required: !1 },
            contentColsLg: { type: [Boolean, String, Number], required: !1 },
            contentColsMd: { type: [Boolean, String, Number], required: !1 },
            contentColsSm: { type: [Boolean, String, Number], required: !1 },
            contentColsXl: { type: [Boolean, String, Number], required: !1 },
            description: { type: [String], required: !1 },
            disabled: { type: [Boolean, String], default: !1 },
            feedbackAriaLive: { type: String, default: "assertive" },
            id: { type: String, required: !1 },
            invalidFeedback: { type: String, required: !1 },
            label: { type: String, required: !1 },
            labelAlign: { type: [Boolean, String, Number], required: !1 },
            labelAlignLg: { type: [Boolean, String, Number], required: !1 },
            labelAlignMd: { type: [Boolean, String, Number], required: !1 },
            labelAlignSm: { type: [Boolean, String, Number], required: !1 },
            labelAlignXl: { type: [Boolean, String, Number], required: !1 },
            labelClass: { type: [Array, Object, String], required: !1 },
            labelCols: { type: [Boolean, String, Number], required: !1 },
            labelColsLg: { type: [Boolean, String, Number], required: !1 },
            labelColsMd: { type: [Boolean, String, Number], required: !1 },
            labelColsSm: { type: [Boolean, String, Number], required: !1 },
            labelColsXl: { type: [Boolean, String, Number], required: !1 },
            labelFor: { type: String, required: !1 },
            labelSize: { type: String, required: !1 },
            labelSrOnly: { type: [Boolean, String], default: !1 },
            state: { type: [Boolean, String], default: null },
            tooltip: { type: [Boolean, String], default: !1 },
            validFeedback: { type: String, required: !1 },
            validated: { type: [Boolean, String], default: !1 },
            floating: { type: [Boolean, String], default: !1 },
        },
        setup(e, { attrs: t }) {
            const r = z(L(e, "disabled")),
                n = z(L(e, "labelSrOnly")),
                i = z(L(e, "state")),
                s = z(L(e, "tooltip")),
                o = z(L(e, "validated")),
                l = z(L(e, "floating")),
                f = null,
                d = ["xs", "sm", "md", "lg", "xl"],
                h = (R, W) =>
                    d.reduce((nt, J) => {
                        const Q = R[Jp(J, `${W}Align`)] || null
                        return Q && nt.push(["text", J, Q].filter((ot) => ot).join("-")), nt
                    }, []),
                y = (R, W) =>
                    d.reduce((nt, J) => {
                        let Q = R[Jp(J, `${W}Cols`)]
                        return (
                            (Q = Q === "" ? !0 : Q || !1),
                            !rc(Q) && Q !== "auto" && ((Q = Fk(Q, 0)), (Q = Q > 0 ? Q : !1)),
                            Q && (nt[J || (rc(Q) ? "col" : "cols")] = Q),
                            nt
                        )
                    }, {}),
                E = Ht(),
                T = (R, W = null) => {
                    if (Ak && e.labelFor) {
                        const nt = kk(`#${_k(e.labelFor)}`, E)
                        if (nt) {
                            const J = "aria-describedby",
                                Q = (R || "").split(Wl),
                                ot = (W || "").split(Wl),
                                it = (wb(nt, J) || "")
                                    .split(Wl)
                                    .filter((at) => !vk(ot, at))
                                    .concat(Q)
                                    .filter((at, x, a) => a.indexOf(at) === x)
                                    .filter((at) => at)
                                    .join(" ")
                                    .trim()
                            it ? Ok(nt, J, it) : Ik(nt, J)
                        }
                    }
                },
                S = K(() => y(e, "content")),
                N = K(() => h(e, "label")),
                P = K(() => y(e, "label")),
                M = K(() => Object.keys(S.value).length > 0 || Object.keys(P.value).length > 0),
                k = K(() => (rc(i.value) ? i.value : null)),
                F = K(() => {
                    const R = k.value
                    return R === !0 ? "is-valid" : R === !1 ? "is-invalid" : null
                }),
                $ = K(() => gf(t.ariaInvalid, i.value))
            return (
                Oe(
                    () => f,
                    (R, W) => {
                        R !== W && T(R, W)
                    }
                ),
                je(() => {
                    Wr(() => {
                        T(f)
                    })
                }),
                {
                    disabledBoolean: r,
                    labelSrOnlyBoolean: n,
                    stateBoolean: i,
                    tooltipBoolean: s,
                    validatedBoolean: o,
                    floatingBoolean: l,
                    ariaDescribedby: f,
                    computedAriaInvalid: $,
                    contentColProps: S,
                    isHorizontal: M,
                    labelAlignClasses: N,
                    labelColProps: P,
                    onLegendClick: (R) => {
                        if (e.labelFor) return
                        const { target: W } = R,
                            nt = W ? W.tagName : ""
                        if (rN.indexOf(nt) !== -1) return
                        const J = Nk(eN, E).filter(Sk)
                        J.length === 1 && Ck(J[0])
                    },
                    stateClass: F,
                }
            )
        },
        render() {
            const e = this.$props,
                t = this.$slots,
                r = ar(),
                n = !e.labelFor
            let i = null
            const s = Nr(nN, {}, t) || e.label,
                o = s ? ri("_BV_label_") : null
            if (s || this.isHorizontal) {
                const $ = n ? "legend" : "label"
                if (this.labelSrOnlyBoolean)
                    s && (i = he($, { class: "visually-hidden", id: o, for: e.labelFor || null }, s)),
                        this.isHorizontal ? (i = he(ga, this.labelColProps, { default: () => i })) : (i = he("div", {}, [i]))
                else {
                    const R = {
                        onClick: n ? this.onLegendClick : null,
                        ...(this.isHorizontal ? this.labelColProps : {}),
                        tag: this.isHorizontal ? $ : null,
                        id: o,
                        for: e.labelFor || null,
                        tabIndex: n ? "-1" : null,
                        class: [
                            this.isHorizontal ? "col-form-label" : "form-label",
                            {
                                "bv-no-focus-ring": n,
                                "col-form-label": this.isHorizontal || n,
                                "pt-0": !this.isHorizontal && n,
                                "d-block": !this.isHorizontal && !n,
                                [`col-form-label-${e.labelSize}`]: !!e.labelSize,
                            },
                            this.labelAlignClasses,
                            e.labelClass,
                        ],
                    }
                    this.isHorizontal ? (i = he(ga, R, { default: () => s })) : (i = he($, R, s))
                }
            }
            let l = null
            const f = Nr(iN, {}, t) || this.invalidFeedback,
                d = f ? ri("_BV_feedback_invalid_") : void 0
            f &&
                (l = he(
                    ed,
                    { ariaLive: e.feedbackAriaLive, id: d, state: this.stateBoolean, tooltip: this.tooltipBoolean },
                    { default: () => f }
                ))
            let h = null
            const y = Nr(sN, {}, t) || this.validFeedback,
                E = y ? ri("_BV_feedback_valid_") : void 0
            y &&
                (h = he(
                    nd,
                    { ariaLive: e.feedbackAriaLive, id: E, state: this.stateBoolean, tooltip: this.tooltipBoolean },
                    { default: () => y }
                ))
            let T = null
            const S = Nr(oN, {}, t) || this.description,
                N = S ? ri("_BV_description_") : void 0
            S && (T = he(rd, { id: N }, { default: () => S }))
            const P = (this.ariaDescribedby =
                    [N, this.stateBoolean === !1 ? d : null, this.stateBoolean === !0 ? E : null].filter(($) => $).join(" ") || null),
                M = [Nr(aN, { ariaDescribedby: P, descriptionId: N, id: r, labelId: o }, t) || "", l, h, T]
            !this.isHorizontal && this.floatingBoolean && M.push(i)
            let k = he("div", { ref: "content", class: [{ "form-floating": !this.isHorizontal && this.floatingBoolean }] }, M)
            this.isHorizontal && (k = he(ga, { ref: "content", ...this.contentColProps }, { default: () => M }))
            const F = {
                class: ["mb-3", this.stateClass, { "was-validated": this.validatedBoolean }],
                id: ar(L(e, "id")).value,
                disabled: n ? this.disabledBoolean : null,
                role: n ? null : "group",
                "aria-invalid": this.computedAriaInvalid,
                "aria-labelledby": n && this.isHorizontal ? o : null,
            }
            return this.isHorizontal && !n
                ? he(Yl, F, { default: () => [i, k] })
                : he(
                      n ? "fieldset" : "div",
                      F,
                      this.isHorizontal && n
                          ? [he(Yl, {}, { default: () => [i, k] })]
                          : this.isHorizontal || !this.floatingBoolean
                          ? [i, k]
                          : [k]
                  )
        },
    }),
    ig = ["text", "number", "email", "password", "search", "url", "tel", "date", "time", "range", "color"],
    uN = bt({
        props: {
            ...Db,
            max: { type: [String, Number], required: !1 },
            min: { type: [String, Number], required: !1 },
            step: { type: [String, Number], required: !1 },
            type: { type: String, default: "text", validator: (e) => ig.includes(e) },
        },
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(e, { emit: t }) {
            const r = K(() => {
                    const E = e.type === "range",
                        T = e.type === "color"
                    return {
                        "form-range": E,
                        "form-control": T || (!e.plaintext && !E),
                        "form-control-color": T,
                        "form-control-plaintext": e.plaintext && !E && !T,
                        [`form-control-${e.size}`]: !!e.size,
                        "is-valid": e.state === !0,
                        "is-invalid": e.state === !1,
                    }
                }),
                n = K(() => (ig.includes(e.type) ? e.type : "text")),
                { input: i, computedId: s, computedAriaInvalid: o, onInput: l, onChange: f, onBlur: d, focus: h, blur: y } = $b(e, t)
            return {
                classes: r,
                localType: n,
                input: i,
                computedId: s,
                computedAriaInvalid: o,
                onInput: l,
                onChange: f,
                onBlur: d,
                focus: h,
                blur: y,
            }
        },
    }),
    fN = [
        "id",
        "name",
        "form",
        "type",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "min",
        "max",
        "step",
        "list",
        "aria-required",
        "aria-invalid",
    ]
function cN(e, t, r, n, i, s) {
    return (
        Y(),
        ft(
            "input",
            ce(
                {
                    id: e.computedId,
                    ref: "input",
                    class: e.classes,
                    name: e.name || void 0,
                    form: e.form || void 0,
                    type: e.localType,
                    disabled: e.disabled,
                    placeholder: e.placeholder,
                    required: e.required,
                    autocomplete: e.autocomplete || void 0,
                    readonly: e.readonly || e.plaintext,
                    min: e.min,
                    max: e.max,
                    step: e.step,
                    list: e.type !== "password" ? e.list : void 0,
                    "aria-required": e.required ? "true" : void 0,
                    "aria-invalid": e.computedAriaInvalid,
                },
                e.$attrs,
                {
                    onInput: t[0] || (t[0] = (o) => e.onInput(o)),
                    onChange: t[1] || (t[1] = (o) => e.onChange(o)),
                    onBlur: t[2] || (t[2] = (o) => e.onBlur(o)),
                }
            ),
            null,
            16,
            fN
        )
    )
}
const dN = ur(uN, [["render", cN]]),
    hN = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"],
    pN = ["for"],
    ry = bt({
        __name: "BFormRadio",
        props: {
            ariaLabel: null,
            ariaLabelledBy: null,
            form: null,
            id: null,
            name: null,
            size: null,
            autofocus: { default: !1 },
            modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
            plain: { default: !1 },
            button: { default: !1 },
            switch: { default: !1 },
            disabled: { default: !1 },
            buttonVariant: { default: "secondary" },
            inline: { default: !1 },
            required: { default: !1 },
            state: { default: void 0 },
            value: { type: [String, Boolean, Object, Number], default: !0 },
        },
        emits: ["input", "change", "update:modelValue"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "autofocus")),
                i = z(L(r, "plain")),
                s = z(L(r, "button")),
                o = z(L(r, "switch")),
                l = z(L(r, "disabled")),
                f = z(L(r, "inline")),
                d = z(L(r, "required")),
                h = r.state !== void 0 ? z(L(r, "state")) : K(() => {}),
                y = ar(L(r, "id"), "form-check"),
                E = Ht(null),
                T = Ht(!1),
                S = K({
                    get: () => (Array.isArray(r.modelValue) ? r.modelValue[0] : r.modelValue),
                    set: ($) => {
                        const R = $ ? r.value : !1,
                            W = Array.isArray(r.modelValue) ? [R] : R
                        t("input", W), t("change", W), t("update:modelValue", W)
                    },
                }),
                N = K(() =>
                    Array.isArray(r.modelValue)
                        ? (r.modelValue || []).find(($) => $ === r.value)
                        : JSON.stringify(r.modelValue) === JSON.stringify(r.value)
                ),
                P = Ze({
                    plain: L(i, "value"),
                    button: L(s, "value"),
                    inline: L(f, "value"),
                    switch: L(o, "value"),
                    size: L(r, "size"),
                    state: L(h, "value"),
                    buttonVariant: L(r, "buttonVariant"),
                }),
                M = Nb(P),
                k = Ob(P),
                F = Ib(P)
            return (
                je(() => {
                    n.value && E.value.focus()
                }),
                ($, R) => (
                    Y(),
                    ft(
                        "div",
                        { class: wt(V(M)) },
                        [
                            qi(
                                xt(
                                    "input",
                                    ce({ id: V(y) }, $.$attrs, {
                                        ref_key: "input",
                                        ref: E,
                                        "onUpdate:modelValue": R[0] || (R[0] = (W) => (Re(S) ? (S.value = W) : null)),
                                        class: V(k),
                                        type: "radio",
                                        disabled: V(l),
                                        required: !!e.name && !!V(d),
                                        name: e.name,
                                        form: e.form,
                                        "aria-label": e.ariaLabel,
                                        "aria-labelledby": e.ariaLabelledBy,
                                        value: e.value,
                                        "aria-required": e.name && V(d) ? !0 : void 0,
                                        onFocus: R[1] || (R[1] = (W) => (T.value = !0)),
                                        onBlur: R[2] || (R[2] = (W) => (T.value = !1)),
                                    }),
                                    null,
                                    16,
                                    hN
                                ),
                                [[Ku, V(S)]]
                            ),
                            $.$slots.default || !V(i)
                                ? (Y(),
                                  ft(
                                      "label",
                                      { key: 0, for: V(y), class: wt([V(F), { active: V(N), focus: T.value }]) },
                                      [mt($.$slots, "default")],
                                      10,
                                      pN
                                  ))
                                : Dt("", !0),
                        ],
                        2
                    )
                )
            )
        },
    }),
    gN = ["id"],
    mN = ["innerHTML"],
    vN = ["textContent"],
    bN = bt({
        __name: "BFormRadioGroup",
        props: {
            size: null,
            form: null,
            id: null,
            name: null,
            modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            buttonVariant: { default: "secondary" },
            buttons: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            options: { default: () => [] },
            plain: { default: !1 },
            required: { default: !1 },
            stacked: { default: !1 },
            state: { default: void 0 },
            textField: { default: "text" },
            validated: { default: !1 },
            valueField: { default: "value" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(e, { emit: t }) {
            const r = e
            z(L(r, "autofocus"))
            const n = z(L(r, "buttons")),
                i = z(L(r, "disabled"))
            z(L(r, "plain"))
            const s = z(L(r, "required")),
                o = z(L(r, "stacked")),
                l = r.state !== void 0 ? z(L(r, "state")) : K(() => {}),
                f = z(L(r, "validated")),
                d = Qi(),
                h = "BFormRadio",
                y = ar(L(r, "id"), "radio"),
                E = ar(L(r, "name"), "checkbox"),
                T = K({
                    get: () => r.modelValue,
                    set: (k) => {
                        t("input", k), t("update:modelValue", k), t("change", k)
                    },
                }),
                S = K(() =>
                    (d.first ? xu(d.first(), h, i.value) : [])
                        .concat(r.options.map((k) => Rb(k, r)))
                        .concat(d.default ? xu(d.default(), h, i.value) : [])
                        .map((k, F) => Lb(k, F, r, E, y))
                        .map((k) => ({ ...k }))
                ),
                N = Ze({
                    required: L(s, "value"),
                    ariaInvalid: L(r, "ariaInvalid"),
                    state: L(l, "value"),
                    validated: L(f, "value"),
                    buttons: L(n, "value"),
                    stacked: L(o, "value"),
                    size: L(r, "size"),
                }),
                P = Bb(N),
                M = Pb(N)
            return (k, F) => (
                Y(),
                ft(
                    "div",
                    ce(V(P), { id: V(y), role: "radiogroup", class: [V(M), "bv-no-focus-ring"], tabindex: "-1" }),
                    [
                        (Y(!0),
                        ft(
                            Yt,
                            null,
                            Pe(
                                V(S),
                                ($, R) => (
                                    Y(),
                                    kt(
                                        ry,
                                        ce(
                                            {
                                                key: R,
                                                modelValue: V(T),
                                                "onUpdate:modelValue": F[0] || (F[0] = (W) => (Re(T) ? (T.value = W) : null)),
                                            },
                                            $.props
                                        ),
                                        {
                                            default: Ct(() => [
                                                $.html
                                                    ? (Y(), ft("span", { key: 0, innerHTML: $.html }, null, 8, mN))
                                                    : (Y(), ft("span", { key: 1, textContent: jt($.text) }, null, 8, vN)),
                                            ]),
                                            _: 2,
                                        },
                                        1040,
                                        ["modelValue"]
                                    )
                                )
                            ),
                            128
                        )),
                    ],
                    16,
                    gN
                )
            )
        },
    }),
    yN = ["value", "disabled"],
    hh = bt({
        __name: "BFormSelectOption",
        props: { value: null, disabled: { default: !1 } },
        setup(e) {
            const t = z(L(e, "disabled"))
            return (r, n) => {
                var i
                return Y(), ft("option", { value: (i = e.value) != null ? i : "", disabled: V(t) }, [mt(r.$slots, "default")], 8, yN)
            }
        },
    }),
    _N = ["label"],
    ny = bt({
        __name: "BFormSelectOptionGroup",
        props: {
            label: null,
            disabledField: { default: "disabled" },
            htmlField: { default: "html" },
            options: { default: () => [] },
            textField: { default: "text" },
            valueField: { default: "value" },
        },
        setup(e) {
            const t = e,
                r = K(() => ch(t.options, "BFormSelectOptionGroup", t))
            return (n, i) => (
                Y(),
                ft(
                    "optgroup",
                    { label: e.label },
                    [
                        mt(n.$slots, "first"),
                        (Y(!0),
                        ft(
                            Yt,
                            null,
                            Pe(
                                V(r),
                                (s, o) => (
                                    Y(),
                                    kt(
                                        hh,
                                        ce({ key: `option_${o}`, value: s.value, disabled: s.disabled }, n.$attrs, {
                                            innerHTML: s.html || s.text,
                                        }),
                                        null,
                                        16,
                                        ["value", "disabled", "innerHTML"]
                                    )
                                )
                            ),
                            128
                        )),
                        mt(n.$slots, "default"),
                    ],
                    8,
                    _N
                )
            )
        },
    }),
    wN = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"],
    AN = bt({
        __name: "BFormSelect",
        props: {
            ariaInvalid: { default: void 0 },
            autofocus: { default: !1 },
            disabled: { default: !1 },
            disabledField: { default: "disabled" },
            form: null,
            htmlField: { default: "html" },
            id: null,
            labelField: { default: "label" },
            multiple: { default: !1 },
            name: null,
            options: { default: () => [] },
            optionsField: { default: "options" },
            plain: { default: !1 },
            required: { default: !1 },
            selectSize: { default: 0 },
            size: null,
            state: { default: void 0 },
            textField: { default: "text" },
            valueField: { default: "value" },
            modelValue: { default: "" },
        },
        emits: ["input", "update:modelValue", "change"],
        setup(e, { expose: t, emit: r }) {
            const n = e,
                i = z(L(n, "autofocus")),
                s = z(L(n, "disabled")),
                o = z(L(n, "multiple")),
                l = z(L(n, "plain")),
                f = z(L(n, "required")),
                d = n.state !== void 0 ? z(L(n, "state")) : K(() => {}),
                h = Ht(),
                y = ar(L(n, "id"), "input"),
                E = () => {
                    Wr(() => {
                        var k
                        i.value && ((k = h.value) == null || k.focus())
                    })
                }
            je(E), tl(E)
            const T = K(() => ({
                    "form-control": l.value,
                    [`form-control-${n.size}`]: n.size && l.value,
                    "form-select": !l.value,
                    [`form-select-${n.size}`]: n.size && !l.value,
                    "is-valid": d.value === !0,
                    "is-invalid": d.value === !1,
                })),
                S = K(() => {
                    if (n.selectSize || l.value) return n.selectSize
                }),
                N = K(() => gf(n.ariaInvalid, d.value)),
                P = K(() => ch(n.options, "BFormSelect", n)),
                M = K({
                    get() {
                        return n.modelValue
                    },
                    set(k) {
                        r("change", k), r("update:modelValue", k), r("input", k)
                    },
                })
            return (
                t({
                    blur: () => {
                        var k
                        s.value || (k = h.value) == null || k.blur()
                    },
                    focus: () => {
                        var k
                        s.value || (k = h.value) == null || k.focus()
                    },
                }),
                (k, F) =>
                    qi(
                        (Y(),
                        ft(
                            "select",
                            ce({ id: V(y), ref_key: "input", ref: h }, k.$attrs, {
                                "onUpdate:modelValue": F[0] || (F[0] = ($) => (Re(M) ? (M.value = $) : null)),
                                class: V(T),
                                name: e.name,
                                form: e.form || void 0,
                                multiple: V(o) || void 0,
                                size: V(S),
                                disabled: V(s),
                                required: V(f),
                                "aria-required": V(f) ? !0 : void 0,
                                "aria-invalid": V(N),
                            }),
                            [
                                mt(k.$slots, "first"),
                                (Y(!0),
                                ft(
                                    Yt,
                                    null,
                                    Pe(
                                        V(P),
                                        ($, R) => (
                                            Y(),
                                            ft(
                                                Yt,
                                                null,
                                                [
                                                    Array.isArray($.options)
                                                        ? (Y(),
                                                          kt(ny, { key: `option_${R}`, label: $.label, options: $.options }, null, 8, [
                                                              "label",
                                                              "options",
                                                          ]))
                                                        : (Y(),
                                                          kt(
                                                              hh,
                                                              {
                                                                  key: `option2_${R}`,
                                                                  value: $.value,
                                                                  disabled: $.disabled,
                                                                  innerHTML: $.html || $.text,
                                                              },
                                                              null,
                                                              8,
                                                              ["value", "disabled", "innerHTML"]
                                                          )),
                                                ],
                                                64
                                            )
                                        )
                                    ),
                                    256
                                )),
                                mt(k.$slots, "default"),
                            ],
                            16,
                            wN
                        )),
                        [[kd, V(M)]]
                    )
            )
        },
    }),
    EN = ["id"],
    xN = ["aria-label", "aria-controls", "aria-describedby"],
    iy = bt({
        __name: "BFormTag",
        props: {
            id: null,
            title: null,
            disabled: { default: !1 },
            noRemove: { default: !1 },
            pill: { default: !1 },
            removeLabel: { default: "Remove tag" },
            tag: { default: "span" },
            variant: { default: "secondary" },
        },
        emits: ["remove"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "disabled")),
                i = z(L(r, "noRemove")),
                s = z(L(r, "pill")),
                o = Qi(),
                l = K(() => {
                    var y, E, T
                    return (T = ((E = (y = o.default) == null ? void 0 : y.call(o)[0].children) == null ? void 0 : E.toString()) || r.title) !=
                        null
                        ? T
                        : ""
                }),
                f = ar(L(r, "id")),
                d = K(() => `${f.value}taglabel__`),
                h = K(() => [
                    `bg-${r.variant}`,
                    { "text-dark": ["warning", "info", "light"].includes(r.variant), "rounded-pill": s.value, disabled: n.value },
                ])
            return (y, E) => (
                Y(),
                kt(
                    Kt(e.tag),
                    {
                        id: V(f),
                        title: V(l),
                        class: wt(["badge b-form-tag d-inline-flex align-items-center mw-100", V(h)]),
                        "aria-labelledby": V(d),
                    },
                    {
                        default: Ct(() => [
                            xt(
                                "span",
                                { id: V(d), class: "b-form-tag-content flex-grow-1 text-truncate" },
                                [mt(y.$slots, "default", {}, () => [ve(jt(V(l)), 1)])],
                                8,
                                EN
                            ),
                            !V(n) && !V(i)
                                ? (Y(),
                                  ft(
                                      "button",
                                      {
                                          key: 0,
                                          "aria-keyshortcuts": "Delete",
                                          type: "button",
                                          "aria-label": e.removeLabel,
                                          class: wt([
                                              "btn-close b-form-tag-remove",
                                              { "btn-close-white": !["warning", "info", "light"].includes(e.variant) },
                                          ]),
                                          "aria-controls": e.id,
                                          "aria-describedby": V(d),
                                          onClick: E[0] || (E[0] = (T) => t("remove", V(l))),
                                      },
                                      null,
                                      10,
                                      xN
                                  ))
                                : Dt("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "title", "class", "aria-labelledby"]
                )
            )
        },
    }),
    TN = ["id"],
    CN = ["id", "for", "aria-live"],
    MN = ["id", "aria-live"],
    SN = ["id"],
    kN = ["aria-controls"],
    NN = { role: "group", class: "d-flex" },
    ON = ["id", "disabled", "value", "type", "placeholder", "form", "required"],
    IN = ["disabled"],
    BN = { "aria-live": "polite", "aria-atomic": "true" },
    PN = { key: 0, class: "d-block invalid-feedback" },
    RN = { key: 1, class: "form-text text-muted" },
    LN = { key: 2, class: "form-text text-muted" },
    DN = ["name", "value"],
    $N = bt({
        __name: "BFormTags",
        props: {
            addButtonText: { default: "Add" },
            addButtonVariant: { default: "outline-secondary" },
            addOnChange: { default: !1 },
            autofocus: { default: !1 },
            disabled: { default: !1 },
            duplicateTagText: { default: "Duplicate tag(s)" },
            inputAttrs: null,
            inputClass: null,
            inputId: null,
            inputType: { default: "text" },
            invalidTagText: { default: "Invalid tag(s)" },
            form: null,
            limit: null,
            limitTagsText: { default: "Tag limit reached" },
            modelValue: { default: () => [] },
            name: null,
            noAddOnEnter: { default: !1 },
            noOuterFocus: { default: !1 },
            noTagRemove: { default: !1 },
            placeholder: { default: "Add tag..." },
            removeOnDelete: { default: !1 },
            required: { default: !1 },
            separator: null,
            state: { default: void 0 },
            size: null,
            tagClass: null,
            tagPills: { default: !1 },
            tagRemoveLabel: null,
            tagRemovedLabel: { default: "Tag removed" },
            tagValidator: { type: Function, default: () => !0 },
            tagVariant: { default: "secondary" },
        },
        emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "addOnChange")),
                i = z(L(r, "autofocus")),
                s = z(L(r, "disabled")),
                o = z(L(r, "noAddOnEnter")),
                l = z(L(r, "noOuterFocus")),
                f = z(L(r, "noTagRemove")),
                d = z(L(r, "removeOnDelete")),
                h = z(L(r, "required")),
                y = r.state !== void 0 ? z(L(r, "state")) : K(() => {}),
                E = z(L(r, "tagPills")),
                T = Ht(null),
                S = ar(),
                N = K(() => r.inputId || `${S.value}input__`)
            je(() => {
                x(), r.modelValue.length > 0 && (k.value = !0)
            }),
                tl(() => x()),
                Oe(
                    () => r.modelValue,
                    (p) => {
                        P.value = p
                    }
                )
            const P = Ht(r.modelValue),
                M = Ht(""),
                k = Ht(!1),
                F = Ht(!1),
                $ = Ht(""),
                R = Ht([]),
                W = Ht([]),
                nt = Ht([]),
                J = K(() => ({
                    [`form-control-${r.size}`]: r.size !== void 0,
                    disabled: s.value,
                    focus: F.value,
                    "is-invalid": y.value === !1,
                    "is-valid": y.value === !0,
                })),
                Q = K(() => P.value.includes(M.value)),
                ot = K(() => (M.value === "" ? !1 : !r.tagValidator(M.value))),
                it = K(() => P.value.length === r.limit),
                at = K(() => !ot.value && !Q.value),
                x = () => {
                    var p
                    i.value && ((p = T.value) == null || p.focus())
                },
                a = (p) => {
                    if (s.value) {
                        p.target.blur()
                        return
                    }
                    t("focusin", p)
                },
                c = (p) => {
                    s.value || l.value || ((F.value = !0), t("focus", p))
                },
                m = (p) => {
                    ;(F.value = !1), t("blur", p)
                },
                _ = (p) => {
                    var H, b
                    const B = typeof p == "string" ? p : p.target.value
                    if (((k.value = !1), ((H = r.separator) == null ? void 0 : H.includes(B.charAt(0))) && B.length > 0)) {
                        T.value && (T.value.value = "")
                        return
                    }
                    if (((M.value = B), (b = r.separator) != null && b.includes(B.charAt(B.length - 1)))) {
                        v(B.slice(0, B.length - 1))
                        return
                    }
                    ;(R.value = r.tagValidator(B) && !Q.value ? [B] : []),
                        (W.value = r.tagValidator(B) ? [] : [B]),
                        (nt.value = Q.value ? [B] : []),
                        t("tag-state", R.value, W.value, nt.value)
                },
                A = (p) => {
                    n.value && (_(p), Q.value || v(M.value))
                },
                w = (p) => {
                    if (p.key === "Enter" && !o.value) {
                        v(M.value)
                        return
                    }
                    ;(p.key === "Backspace" || p.key === "Delete") && d.value && M.value === "" && k.value && P.value.length > 0
                        ? g(P.value[P.value.length - 1])
                        : (k.value = !0)
                },
                v = (p) => {
                    var H
                    if (((p = (p || M.value).trim()), p === "" || Q.value || !r.tagValidator(p) || (r.limit && it.value))) return
                    const b = [...r.modelValue, p]
                    ;(M.value = ""), (k.value = !0), t("update:modelValue", b), t("input", b), (H = T.value) == null || H.focus()
                },
                g = (p) => {
                    var H
                    const b = P.value.indexOf((H = p == null ? void 0 : p.toString()) != null ? H : "")
                    ;($.value = P.value.splice(b, 1).toString()), t("update:modelValue", P.value)
                },
                u = K(() => {
                    const {
                        addButtonText: p,
                        addButtonVariant: H,
                        duplicateTagText: b,
                        inputAttrs: B,
                        form: D,
                        inputType: U,
                        invalidTagText: j,
                        limitTagsText: dt,
                        limit: Z,
                        placeholder: et,
                        separator: C,
                        size: O,
                        tagClass: I,
                        tagRemoveLabel: G,
                        tagVariant: q,
                    } = r
                    return {
                        addButtonText: p,
                        addButtonVariant: H,
                        addTag: v,
                        disableAddButton: at,
                        disabled: s.value,
                        duplicateTagText: b,
                        duplicateTags: nt,
                        form: D,
                        inputAttrs: { ...B, disabled: s.value, form: D, id: N, value: M },
                        inputHandlers: { input: _, keydown: w, change: A },
                        inputId: N,
                        inputType: U,
                        invalidTagText: j,
                        invalidTags: W,
                        isDuplicate: Q,
                        isInvalid: ot,
                        isLimitReached: it,
                        limitTagsText: dt,
                        limit: Z,
                        noTagRemove: f.value,
                        placeholder: et,
                        removeTag: g,
                        required: h.value,
                        separator: C,
                        size: O,
                        state: y.value,
                        tagClass: I,
                        tagPills: E.value,
                        tagRemoveLabel: G,
                        tagVariant: q,
                        tags: P,
                    }
                })
            return (p, H) => (
                Y(),
                ft(
                    "div",
                    {
                        id: V(S),
                        class: wt(["b-form-tags form-control h-auto", V(J)]),
                        role: "group",
                        tabindex: "-1",
                        onFocusin: a,
                        onFocusout: H[1] || (H[1] = (b) => p.$emit("focusout", b)),
                    },
                    [
                        xt(
                            "output",
                            {
                                id: `${V(S)}selected_tags__`,
                                class: "visually-hidden",
                                role: "status",
                                for: V(N),
                                "aria-live": F.value ? "polite" : "off",
                                "aria-atomic": "true",
                                "aria-relevant": "additions text",
                            },
                            jt(P.value.join(", ")),
                            9,
                            CN
                        ),
                        xt(
                            "div",
                            {
                                id: `${V(S)}removed_tags__`,
                                role: "status",
                                "aria-live": F.value ? "assertive" : "off",
                                "aria-atomic": "true",
                                class: "visually-hidden",
                            },
                            " (" + jt(e.tagRemovedLabel) + ") " + jt($.value),
                            9,
                            MN
                        ),
                        mt(p.$slots, "default", Ga(Ho(V(u))), () => [
                            xt(
                                "ul",
                                { id: `${V(S)}tag_list__`, class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center" },
                                [
                                    (Y(!0),
                                    ft(
                                        Yt,
                                        null,
                                        Pe(
                                            P.value,
                                            (b) => (
                                                Y(),
                                                kt(
                                                    iy,
                                                    { key: b, class: wt(e.tagClass), tag: "li", variant: e.tagVariant, pill: V(E), onRemove: g },
                                                    { default: Ct(() => [ve(jt(b), 1)]), _: 2 },
                                                    1032,
                                                    ["class", "variant", "pill"]
                                                )
                                            )
                                        ),
                                        128
                                    )),
                                    xt(
                                        "li",
                                        {
                                            role: "none",
                                            "aria-live": "off",
                                            class: "b-from-tags-field flex-grow-1",
                                            "aria-controls": `${V(S)}tag_list__`,
                                        },
                                        [
                                            xt("div", NN, [
                                                xt(
                                                    "input",
                                                    ce(
                                                        {
                                                            id: V(N),
                                                            ref_key: "input",
                                                            ref: T,
                                                            disabled: V(s),
                                                            value: M.value,
                                                            type: e.inputType,
                                                            placeholder: e.placeholder,
                                                            class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                                                            style: { outline: "currentcolor none 0px", "min-width": "5rem" },
                                                        },
                                                        e.inputAttrs,
                                                        {
                                                            form: e.form,
                                                            required: V(h),
                                                            onInput: _,
                                                            onChange: A,
                                                            onKeydown: w,
                                                            onFocus: c,
                                                            onBlur: m,
                                                        }
                                                    ),
                                                    null,
                                                    16,
                                                    ON
                                                ),
                                                V(at)
                                                    ? (Y(),
                                                      ft(
                                                          "button",
                                                          {
                                                              key: 0,
                                                              type: "button",
                                                              class: wt([
                                                                  "btn b-form-tags-button py-0",
                                                                  [
                                                                      `btn-${e.addButtonVariant}`,
                                                                      { "disabled invisible": M.value.length === 0 },
                                                                      e.inputClass,
                                                                  ],
                                                              ]),
                                                              style: { "font-size": "90%" },
                                                              disabled: V(s) || M.value.length === 0 || V(it),
                                                              onClick: H[0] || (H[0] = (b) => v(M.value)),
                                                          },
                                                          [mt(p.$slots, "add-button-text", {}, () => [ve(jt(e.addButtonText), 1)])],
                                                          10,
                                                          IN
                                                      ))
                                                    : Dt("", !0),
                                            ]),
                                        ],
                                        8,
                                        kN
                                    ),
                                ],
                                8,
                                SN
                            ),
                            xt("div", BN, [
                                V(ot) ? (Y(), ft("div", PN, jt(e.invalidTagText) + ": " + jt(M.value), 1)) : Dt("", !0),
                                V(Q) ? (Y(), ft("small", RN, jt(e.duplicateTagText) + ": " + jt(M.value), 1)) : Dt("", !0),
                                P.value.length === e.limit ? (Y(), ft("small", LN, "Tag limit reached")) : Dt("", !0),
                            ]),
                        ]),
                        e.name
                            ? (Y(!0),
                              ft(
                                  Yt,
                                  { key: 0 },
                                  Pe(P.value, (b) => (Y(), ft("input", { key: b, type: "hidden", name: e.name, value: b }, null, 8, DN))),
                                  128
                              ))
                            : Dt("", !0),
                    ],
                    42,
                    TN
                )
            )
        },
    }),
    FN = bt({
        props: {
            ...Db,
            noResize: { type: [Boolean, String], default: !1 },
            rows: { type: [String, Number], required: !1, default: 2 },
            wrap: { type: String, default: "soft" },
        },
        emits: ["update:modelValue", "change", "blur", "input"],
        setup(e, { emit: t }) {
            const r = z(L(e, "noResize")),
                n = K(() => ({
                    "form-control": !e.plaintext,
                    "form-control-plaintext": e.plaintext,
                    [`form-control-${e.size}`]: !!e.size,
                    "is-valid": e.state === !0,
                    "is-invalid": e.state === !1,
                })),
                i = K(() => (r.value ? { resize: "none" } : void 0)),
                { input: s, computedId: o, computedAriaInvalid: l, onInput: f, onChange: d, onBlur: h, focus: y, blur: E } = $b(e, t)
            return {
                input: s,
                computedId: o,
                computedAriaInvalid: l,
                onInput: f,
                onChange: d,
                onBlur: h,
                focus: y,
                blur: E,
                classes: n,
                computedStyles: i,
            }
        },
    }),
    VN = [
        "id",
        "name",
        "form",
        "disabled",
        "placeholder",
        "required",
        "autocomplete",
        "readonly",
        "aria-required",
        "aria-invalid",
        "rows",
        "wrap",
    ]
function UN(e, t, r, n, i, s) {
    return (
        Y(),
        ft(
            "textarea",
            ce(
                {
                    id: e.computedId,
                    ref: "input",
                    class: e.classes,
                    name: e.name || void 0,
                    form: e.form || void 0,
                    disabled: e.disabled,
                    placeholder: e.placeholder,
                    required: e.required,
                    autocomplete: e.autocomplete || void 0,
                    readonly: e.readonly || e.plaintext,
                    "aria-required": e.required ? "true" : void 0,
                    "aria-invalid": e.computedAriaInvalid,
                    rows: e.rows,
                    style: e.computedStyles,
                    wrap: e.wrap || void 0,
                },
                e.$attrs,
                {
                    onInput: t[0] || (t[0] = (o) => e.onInput(o)),
                    onChange: t[1] || (t[1] = (o) => e.onChange(o)),
                    onBlur: t[2] || (t[2] = (o) => e.onBlur(o)),
                }
            ),
            null,
            16,
            VN
        )
    )
}
const HN = ur(FN, [["render", UN]]),
    qN = { key: 0, class: "input-group-text" },
    zN = { key: 0 },
    jN = ["innerHTML"],
    KN = { key: 0, class: "input-group-text" },
    GN = { key: 0 },
    WN = ["innerHTML"],
    YN = bt({
        __name: "BInputGroup",
        props: { append: null, appendHtml: null, id: null, prepend: null, prependHtml: null, size: null, tag: { default: "div" } },
        setup(e) {
            const t = e,
                r = K(() => ({ "input-group-sm": t.size === "sm", "input-group-lg": t.size === "lg" })),
                n = K(() => !!t.append || !!t.appendHtml),
                i = K(() => !!t.prepend || !!t.prependHtml),
                s = K(() => !!t.appendHtml),
                o = K(() => !!t.prependHtml)
            return (l, f) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { id: e.id, class: wt(["input-group", V(r)]), role: "group" },
                    {
                        default: Ct(() => [
                            mt(l.$slots, "prepend", {}, () => [
                                V(i)
                                    ? (Y(),
                                      ft("span", qN, [
                                          V(o) ? Dt("", !0) : (Y(), ft("span", zN, jt(e.prepend), 1)),
                                          V(o) ? (Y(), ft("span", { key: 1, innerHTML: e.prependHtml }, null, 8, jN)) : Dt("", !0),
                                      ]))
                                    : Dt("", !0),
                            ]),
                            mt(l.$slots, "default"),
                            mt(l.$slots, "append", {}, () => [
                                V(n)
                                    ? (Y(),
                                      ft("span", KN, [
                                          V(s) ? Dt("", !0) : (Y(), ft("span", GN, jt(e.append), 1)),
                                          V(s) ? (Y(), ft("span", { key: 1, innerHTML: e.appendHtml }, null, 8, WN)) : Dt("", !0),
                                      ]))
                                    : Dt("", !0),
                            ]),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    sy = bt({
        __name: "BInputGroupText",
        props: { tag: { default: "div" } },
        setup(e) {
            return (t, r) => (Y(), kt(Kt(e.tag), { class: "input-group-text" }, { default: Ct(() => [mt(t.$slots, "default")]), _: 3 }))
        },
    }),
    ph = bt({
        __name: "BInputGroupAddon",
        props: { append: { default: !1 }, id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(e) {
            const t = e,
                r = z(L(t, "append")),
                n = z(L(t, "isText")),
                i = K(() => ({ "input-group-append": r.value, "input-group-prepend": !r.value }))
            return (s, o) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { id: e.id, class: wt(["d-flex", V(i)]) },
                    {
                        default: Ct(() => [
                            V(n)
                                ? (Y(), kt(sy, { key: 0 }, { default: Ct(() => [mt(s.$slots, "default")]), _: 3 }))
                                : mt(s.$slots, "default", { key: 1 }),
                        ]),
                        _: 3,
                    },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    JN = bt({
        __name: "BInputGroupAppend",
        props: { id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(e) {
            const t = z(L(e, "isText"))
            return (r, n) => (
                Y(),
                kt(ph, { id: e.id, "is-text": V(t), tag: e.tag, append: "" }, { default: Ct(() => [mt(r.$slots, "default")]), _: 3 }, 8, [
                    "id",
                    "is-text",
                    "tag",
                ])
            )
        },
    }),
    QN = bt({
        __name: "BInputGroupPrepend",
        props: { id: null, isText: { default: !1 }, tag: { default: "div" } },
        setup(e) {
            const t = z(L(e, "isText"))
            return (r, n) => (
                Y(),
                kt(ph, { id: e.id, "is-text": V(t), tag: e.tag, append: !1 }, { default: Ct(() => [mt(r.$slots, "default")]), _: 3 }, 8, [
                    "id",
                    "is-text",
                    "tag",
                ])
            )
        },
    }),
    oy = Symbol(),
    XN = bt({
        __name: "BListGroup",
        props: {
            flush: { default: !1 },
            horizontal: { type: [Boolean, String], default: !1 },
            numbered: { default: !1 },
            tag: { default: "div" },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "flush")),
                n = z(L(t, "numbered")),
                i = K(() => {
                    const o = r.value ? !1 : t.horizontal
                    return {
                        "list-group-flush": r.value,
                        "list-group-horizontal": o === !0,
                        [`list-group-horizontal-${o}`]: typeof o == "string",
                        "list-group-numbered": n.value,
                    }
                }),
                s = K(() => (n.value === !0 ? "ol" : t.tag))
            return (
                cn(oy, { numbered: n.value }),
                (o, l) => (
                    Y(), kt(Kt(V(s)), { class: wt(["list-group", V(i)]) }, { default: Ct(() => [mt(o.$slots, "default")]), _: 3 }, 8, ["class"])
                )
            )
        },
    }),
    ZN = bt({
        __name: "BListGroupItem",
        props: {
            action: { default: !1 },
            active: { default: !1 },
            button: { default: !1 },
            disabled: { default: !1 },
            href: null,
            tag: { default: "div" },
            target: { default: "_self" },
            to: null,
            variant: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "action")),
                n = z(L(t, "active")),
                i = z(L(t, "button")),
                s = z(L(t, "disabled")),
                o = Sd(),
                l = Ie(oy, null),
                f = K(() => !i.value && (!!t.href || !!t.to)),
                d = K(() => (l != null && l.numbered ? "li" : i.value ? "button" : f.value ? $r : t.tag)),
                h = K(() => {
                    const E = r.value || f.value || i.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
                    return {
                        [`list-group-item-${t.variant}`]: t.variant !== void 0,
                        "list-group-item-action": E,
                        active: n.value,
                        disabled: s.value,
                    }
                }),
                y = K(() => {
                    const E = {}
                    return i.value && ((!o || !o.type) && (E.type = "button"), s.value && (E.disabled = !0)), E
                })
            return (E, T) => (
                Y(),
                kt(
                    Kt(V(d)),
                    ce(
                        {
                            class: ["list-group-item", V(h)],
                            "aria-current": V(n) ? !0 : null,
                            "aria-disabled": V(s) ? !0 : null,
                            target: V(f) ? e.target : null,
                            href: V(i) ? null : e.href,
                            to: V(i) ? null : e.to,
                        },
                        V(y)
                    ),
                    { default: Ct(() => [mt(E.$slots, "default")]), _: 3 },
                    16,
                    ["class", "aria-current", "aria-disabled", "target", "href", "to"]
                )
            )
        },
    }),
    tO = ["id"],
    eO = ["aria-label"],
    rO = { inheritAttrs: !1 },
    nO = bt({
        ...rO,
        __name: "BModal",
        props: {
            bodyBgVariant: null,
            bodyClass: null,
            bodyTextVariant: null,
            busy: { default: !1 },
            lazy: { default: !1 },
            buttonSize: { default: "md" },
            cancelDisabled: { default: !1 },
            cancelTitle: { default: "Cancel" },
            cancelVariant: { default: "secondary" },
            centered: { default: !1 },
            contentClass: null,
            dialogClass: null,
            footerBgVariant: null,
            footerBorderVariant: null,
            footerClass: null,
            footerTextVariant: null,
            fullscreen: { type: [Boolean, String], default: !1 },
            headerBgVariant: null,
            headerBorderVariant: null,
            headerClass: null,
            headerCloseLabel: { default: "Close" },
            headerCloseWhite: { default: !1 },
            headerTextVariant: null,
            hideBackdrop: { default: !1 },
            hideFooter: { default: !1 },
            hideHeader: { default: !1 },
            hideHeaderClose: { default: !1 },
            id: null,
            modalClass: null,
            modelValue: { default: !1 },
            noCloseOnBackdrop: { default: !1 },
            noCloseOnEsc: { default: !1 },
            noFade: { default: !1 },
            noFocus: { default: !1 },
            okDisabled: { default: !1 },
            okOnly: { default: !1 },
            okTitle: { default: "Ok" },
            okVariant: { default: "primary" },
            scrollable: { default: !1 },
            show: { default: !1 },
            size: null,
            title: null,
            titleClass: null,
            titleSrOnly: { default: !1 },
            titleTag: { default: "h5" },
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "busy")),
                i = z(L(r, "lazy")),
                s = z(L(r, "cancelDisabled")),
                o = z(L(r, "centered")),
                l = z(L(r, "headerCloseWhite")),
                f = z(L(r, "hideBackdrop")),
                d = z(L(r, "hideFooter")),
                h = z(L(r, "hideHeader")),
                y = z(L(r, "hideHeaderClose")),
                E = z(L(r, "modelValue")),
                T = z(L(r, "noCloseOnBackdrop")),
                S = z(L(r, "noCloseOnEsc")),
                N = z(L(r, "noFade")),
                P = z(L(r, "noFocus")),
                M = z(L(r, "okDisabled")),
                k = z(L(r, "okOnly")),
                F = z(L(r, "scrollable")),
                $ = z(L(r, "show")),
                R = z(L(r, "titleSrOnly")),
                W = Ht(!1),
                nt = Qi(),
                J = Ht(),
                Q = Ht(),
                ot = K(() => [{ fade: !N.value, show: $.value }, r.modalClass]),
                it = K(() => [
                    {
                        "modal-fullscreen": typeof r.fullscreen == "boolean" ? r.fullscreen : !1,
                        [`modal-fullscreen-${r.fullscreen}-down`]: typeof r.fullscreen == "string" ? r.fullscreen : !1,
                        [`modal-${r.size}`]: r.size,
                        "modal-dialog-centered": o.value,
                        "modal-dialog-scrollable": F.value,
                    },
                    r.dialogClass,
                ]),
                at = K(() => [{ [`bg-${r.bodyBgVariant}`]: r.bodyBgVariant, [`text-${r.bodyTextVariant}`]: r.bodyTextVariant }, r.bodyClass]),
                x = K(() => [
                    {
                        [`bg-${r.headerBgVariant}`]: r.headerBgVariant,
                        [`border-${r.headerBorderVariant}`]: r.headerBorderVariant,
                        [`text-${r.headerTextVariant}`]: r.headerTextVariant,
                    },
                    r.headerClass,
                ]),
                a = K(() => [
                    {
                        [`bg-${r.footerBgVariant}`]: r.footerBgVariant,
                        [`border-${r.footerBorderVariant}`]: r.footerBorderVariant,
                        [`text-${r.footerTextVariant}`]: r.footerTextVariant,
                    },
                    r.footerClass,
                ]),
                c = K(() => [{ ["visually-hidden"]: R.value }, r.titleClass]),
                m = K(() => !!nt["header-close"]),
                _ = K(() => [{ ["btn-close-content"]: m.value, ["d-flex"]: m.value, ["btn-close-white"]: !m.value && l.value }]),
                A = K(() => s.value || n.value),
                w = K(() => M.value || n.value)
            Ke(J, "shown.bs.modal", (b) => v(b)), Ke(J, "hidden.bs.modal", (b) => g(b))
            const v = (b) => {
                    t("shown", b), i.value === !0 && (W.value = !0)
                },
                g = (b) => {
                    t("hidden", b), i.value === !0 && (W.value = !1)
                },
                u = () => {
                    t("update:modelValue", !0), H().show()
                },
                p = () => {
                    t("update:modelValue", !1), H().hide()
                },
                H = () => (Q.value !== void 0 || (Q.value = new Ds(J.value, { backdrop: !1, keyboard: !S.value, focus: !P.value })), Q.value)
            return (
                je(() => {
                    E.value && H().show()
                }),
                Oe(
                    () => r.noCloseOnBackdrop,
                    (b) => {
                        H()._config.backdrop = r.hideBackdrop ? !1 : b ? "static" : !r.hideBackdrop
                    }
                ),
                Oe(
                    () => r.noCloseOnEsc,
                    (b) => {
                        H()._config.keyboard = !b
                    }
                ),
                Oe(
                    () => E.value,
                    (b) => {
                        Wr(() => {
                            b ? u() : p()
                        })
                    }
                ),
                (b, B) => (
                    Y(),
                    kt(gm, { to: "body" }, [
                        xt(
                            "div",
                            ce({ id: e.id, ref_key: "element", ref: J, class: ["modal", V(ot)], tabindex: "-1" }, b.$attrs),
                            [
                                xt(
                                    "div",
                                    { class: wt(["modal-dialog", V(it)]) },
                                    [
                                        !V(i) || (V(i) && W.value) || (V(i) && V(E) === !0)
                                            ? (Y(),
                                              ft(
                                                  "div",
                                                  { key: 0, class: wt(["modal-content", e.contentClass]) },
                                                  [
                                                      V(h)
                                                          ? Dt("", !0)
                                                          : (Y(),
                                                            ft(
                                                                "div",
                                                                { key: 0, class: wt(["modal-header", V(x)]) },
                                                                [
                                                                    (Y(),
                                                                    kt(
                                                                        Kt(e.titleTag),
                                                                        { class: wt(["modal-title", V(c)]) },
                                                                        {
                                                                            default: Ct(() => [
                                                                                mt(b.$slots, "title", {}, () => [ve(jt(e.title), 1)], !0),
                                                                            ]),
                                                                            _: 3,
                                                                        },
                                                                        8,
                                                                        ["class"]
                                                                    )),
                                                                    V(y)
                                                                        ? Dt("", !0)
                                                                        : (Y(),
                                                                          ft(
                                                                              "button",
                                                                              {
                                                                                  key: 0,
                                                                                  type: "button",
                                                                                  class: wt(["btn-close", V(_)]),
                                                                                  "data-bs-dismiss": "modal",
                                                                                  "aria-label": e.headerCloseLabel,
                                                                              },
                                                                              [mt(b.$slots, "header-close", {}, void 0, !0)],
                                                                              10,
                                                                              eO
                                                                          )),
                                                                ],
                                                                2
                                                            )),
                                                      xt(
                                                          "div",
                                                          { class: wt(["modal-body", V(at)]) },
                                                          [mt(b.$slots, "default", {}, void 0, !0)],
                                                          2
                                                      ),
                                                      V(d)
                                                          ? Dt("", !0)
                                                          : (Y(),
                                                            ft(
                                                                "div",
                                                                { key: 1, class: wt(["modal-footer", V(a)]) },
                                                                [
                                                                    mt(
                                                                        b.$slots,
                                                                        "footer",
                                                                        {},
                                                                        () => [
                                                                            V(k)
                                                                                ? Dt("", !0)
                                                                                : (Y(),
                                                                                  kt(
                                                                                      ja,
                                                                                      {
                                                                                          key: 0,
                                                                                          type: "button",
                                                                                          class: "btn",
                                                                                          disabled: V(A),
                                                                                          size: e.buttonSize,
                                                                                          variant: e.cancelVariant,
                                                                                          onClick:
                                                                                              B[0] || (B[0] = (D) => (p(), b.$emit("cancel"))),
                                                                                      },
                                                                                      { default: Ct(() => [ve(jt(e.cancelTitle), 1)]), _: 1 },
                                                                                      8,
                                                                                      ["disabled", "size", "variant"]
                                                                                  )),
                                                                            Ut(
                                                                                ja,
                                                                                {
                                                                                    type: "button",
                                                                                    class: "btn",
                                                                                    disabled: V(w),
                                                                                    size: e.buttonSize,
                                                                                    variant: e.okVariant,
                                                                                    onClick: B[1] || (B[1] = (D) => (p(), b.$emit("ok"))),
                                                                                },
                                                                                { default: Ct(() => [ve(jt(e.okTitle), 1)]), _: 1 },
                                                                                8,
                                                                                ["disabled", "size", "variant"]
                                                                            ),
                                                                        ],
                                                                        !0
                                                                    ),
                                                                ],
                                                                2
                                                            )),
                                                  ],
                                                  2
                                              ))
                                            : Dt("", !0),
                                    ],
                                    2
                                ),
                                V(f) === !1
                                    ? (Y(),
                                      ft("div", {
                                          key: 0,
                                          class: "modal-backdrop fade show",
                                          onClick: B[2] || (B[2] = Gu((D) => V(T) === !1 && p(), ["prevent"])),
                                      }))
                                    : Dt("", !0),
                            ],
                            16,
                            tO
                        ),
                    ])
                )
            )
        },
    }),
    iO = ur(nO, [["__scopeId", "data-v-0368138c"]]),
    sO = bt({
        __name: "BNav",
        props: {
            align: null,
            cardHeader: { default: !1 },
            fill: { default: !1 },
            justified: { default: !1 },
            pills: { default: !1 },
            small: { default: !1 },
            tabs: { default: !1 },
            tag: { default: "ul" },
            vertical: { default: !1 },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "cardHeader")),
                n = z(L(t, "fill")),
                i = z(L(t, "justified")),
                s = z(L(t, "pills")),
                o = z(L(t, "small")),
                l = z(L(t, "tabs")),
                f = z(L(t, "vertical")),
                d = K(() => ({
                    "nav-tabs": l.value,
                    "nav-pills": s.value && !l.value,
                    "card-header-tabs": !f.value && r.value && l.value,
                    "card-header-pills": !f.value && r.value && s.value && !l.value,
                    "flex-column": f.value,
                    "nav-fill": !f.value && n.value,
                    "nav-justified": !f.value && i.value,
                    [`justify-content-${t.align}`]: !f.value && t.align !== void 0,
                    small: o.value,
                }))
            return (h, y) => (
                Y(), kt(Kt(e.tag), { class: wt(["nav", V(d)]) }, { default: Ct(() => [mt(h.$slots, "default")]), _: 3 }, 8, ["class"])
            )
        },
    }),
    oO = bt({
        __name: "BNavForm",
        props: { role: null, id: null, floating: { default: !1 }, novalidate: { default: !1 }, validated: { default: !1 } },
        setup(e) {
            const t = e,
                r = K(() => ({ floating: t.floating, role: t.role, id: t.id, novalidate: t.novalidate, validated: t.validated }))
            return (n, i) => (Y(), kt(Zb, ce(V(r), { class: "d-flex" }), { default: Ct(() => [mt(n.$slots, "default")]), _: 3 }, 16))
        },
    }),
    aO = mf(Gs, ["event", "routerTag"]),
    lO = bt({
        components: { BLink: $r },
        props: { ...aO },
        setup(e) {
            return { disabledBoolean: z(L(e, "disabled")) }
        },
    }),
    uO = { class: "nav-item" }
function fO(e, t, r, n, i, s) {
    const o = ui("b-link")
    return (
        Y(),
        ft("li", uO, [
            Ut(
                o,
                ce({ class: "nav-link" }, e.$props, {
                    tabindex: e.disabledBoolean ? -1 : void 0,
                    "aria-disabled": e.disabledBoolean ? !0 : void 0,
                }),
                { default: Ct(() => [mt(e.$slots, "default")]), _: 3 },
                16,
                ["tabindex", "aria-disabled"]
            ),
        ])
    )
}
const cO = ur(lO, [["render", fO]]),
    dO = { class: "nav-item dropdown" },
    hO = bt({
        __name: "BNavItemDropdown",
        props: {
            id: null,
            text: null,
            size: null,
            offset: null,
            autoClose: { type: [Boolean, String], default: !0 },
            dark: { type: Boolean, default: !1 },
            dropleft: { type: Boolean, default: !1 },
            dropright: { type: Boolean, default: !1 },
            dropup: { type: Boolean, default: !1 },
            right: { type: Boolean, default: !1 },
            left: { type: [Boolean, String], default: !1 },
            split: { type: Boolean, default: !1 },
            splitVariant: null,
            noCaret: { type: Boolean, default: !1 },
            variant: { default: "link" },
        },
        setup(e) {
            return (t, r) => (
                Y(),
                ft("li", dO, [
                    Ut(
                        Xb,
                        ce(t.$props, { "is-nav": "" }),
                        rm({ _: 2 }, [Pe(t.$slots, (n, i) => ({ name: i, fn: Ct((s) => [mt(t.$slots, i, Ga(Ho(s || {})))]) }))]),
                        1040
                    ),
                ])
            )
        },
    }),
    pO = {},
    gO = { class: "navbar-text" }
function mO(e, t) {
    return Y(), ft("li", gO, [mt(e.$slots, "default")])
}
const vO = ur(pO, [["render", mO]]),
    bO = bt({
        __name: "BNavbar",
        props: {
            fixed: null,
            print: { default: !1 },
            sticky: null,
            tag: { default: "nav" },
            toggleable: { type: [Boolean, String], default: !1 },
            dark: { default: !1 },
            variant: null,
            container: { type: [String, Boolean], default: "fluid" },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "print")),
                n = z(L(t, "dark")),
                i = K(() => (t.tag === "nav" ? void 0 : "navigation")),
                s = K(() =>
                    typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
                ),
                o = K(() => (t.container === !1 ? void 0 : t.container === !0 ? "container" : `container-${t.container}`)),
                l = K(() => ({
                    "d-print": r.value,
                    [`sticky-${t.sticky}`]: t.sticky !== void 0,
                    "navbar-dark": n.value,
                    [`bg-${t.variant}`]: t.variant !== void 0,
                    [`fixed-${t.fixed}`]: t.fixed !== void 0,
                    [`${s.value}`]: s.value !== void 0,
                }))
            return (f, d) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { class: wt(["navbar", V(l)]), role: V(i) },
                    {
                        default: Ct(() => [
                            e.container !== !1
                                ? (Y(), ft("div", { key: 0, class: wt(V(o)) }, [mt(f.$slots, "default")], 2))
                                : mt(f.$slots, "default", { key: 1 }),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class", "role"]
                )
            )
        },
    }),
    sg = mf(Gs, ["event", "routerTag"]),
    yO = bt({
        components: { BLink: $r },
        props: { tag: { type: String, default: "div" }, ...sg },
        setup(e) {
            const t = K(() => za(e)),
                r = K(() => (t.value ? $r : e.tag))
            return { props: t.value ? kb(sg, e) : {}, computedTag: r }
        },
    })
function _O(e, t, r, n, i, s) {
    return Y(), kt(Kt(e.computedTag), ce({ class: "navbar-brand" }, e.props), { default: Ct(() => [mt(e.$slots, "default")]), _: 3 }, 16)
}
const wO = ur(yO, [["render", _O]]),
    AO = bt({
        __name: "BNavbarNav",
        props: { align: null, fill: { default: !1 }, justified: { default: !1 }, small: { default: !1 }, tag: { default: "ul" } },
        setup(e) {
            const t = e,
                r = z(L(t, "fill")),
                n = z(L(t, "justified")),
                i = z(L(t, "small")),
                s = K(() => ({
                    "nav-fill": r.value,
                    "nav-justified": n.value,
                    [`justify-content-${t.align}`]: t.align !== void 0,
                    small: i.value,
                }))
            return (o, l) => (Y(), ft("ul", { class: wt(["navbar-nav", V(s)]) }, [mt(o.$slots, "default")], 2))
        },
    }),
    EO = {
        mounted(e, t) {
            let r = t.value
            Object.keys(t.modifiers).length > 0 && ([r] = Object.keys(t.modifiers)),
                e.setAttribute("data-bs-toggle", "modal"),
                e.setAttribute("data-bs-target", `#${r}`)
        },
    },
    xO = {
        mounted(e, t) {
            let r = "right"
            const n = []
            t.modifiers.left
                ? (r = "left")
                : t.modifiers.right
                ? (r = "right")
                : t.modifiers.bottom
                ? (r = "bottom")
                : t.modifiers.top && (r = "top"),
                t.modifiers.manual
                    ? n.push("manual")
                    : (t.modifiers.click && n.push("click"), t.modifiers.hover && n.push("hover"), t.modifiers.focus && n.push("focus")),
                e.setAttribute("data-bs-toggle", "popover"),
                new $o(e, { trigger: n.length === 0 ? "click" : n.join(" "), placement: r, content: t.value })
        },
        unmounted(e) {
            const t = $o.getInstance(e)
            t == null || t.dispose()
        },
    },
    TO = (e) => {
        if (e.manual) return "manual"
        const t = []
        return e.click && t.push("click"), e.hover && t.push("hover"), e.focus && t.push("focus"), t.length > 0 ? t.join(" ") : "hover focus"
    },
    CO = (e) => (e.left ? "left" : e.right ? "right" : e.bottom ? "bottom" : "top"),
    MO = (e) => (e != null && e.delay ? e.delay : 0),
    SO = {
        beforeMount(e, t) {
            e.setAttribute("data-bs-toggle", "tooltip")
            const r = /<("[^"]*"|'[^']*'|[^'">])*>/.test(e.title),
                n = TO(t.modifiers),
                i = CO(t.modifiers),
                s = MO(t.value),
                o = e.getAttribute("title")
            new oi(e, { trigger: n, placement: i, delay: s, html: r }), o && e.setAttribute("data-bs-original-title", o)
        },
        updated(e) {
            const t = e.getAttribute("title"),
                r = e.getAttribute("data-bs-original-title"),
                n = oi.getInstance(e)
            e.removeAttribute("title"),
                t && t !== r && (n == null || n.setContent({ ".tooltip-inner": t }), e.setAttribute("data-bs-original-title", t))
        },
        unmounted(e) {
            const t = oi.getInstance(e)
            t == null || t.dispose()
        },
    },
    Jl = new Map(),
    ay = (e) => {
        if (Jl.has(e)) {
            const t = Jl.get(e)
            t && t.stop && t.stop(), Jl.delete(e)
        }
    },
    og = (e, t) => {
        const r = { margin: "0px", once: !1, callback: t.value }
        Object.keys(t.modifiers).forEach((i) => {
            Number.isInteger(i) ? (r.margin = `${i}px`) : i.toLowerCase() === "once" && (r.once = !0)
        }),
            ay(e)
        const n = new NO(e, r.margin, r.once, r.callback, t.instance)
        Jl.set(e, n)
    },
    kO = {
        beforeMount(e, t) {
            og(e, t)
        },
        updated(e, t) {
            og(e, t)
        },
        unmounted(e) {
            ay(e)
        },
    }
class NO {
    constructor(t, r, n, i, s) {
        Ue(this, "element"),
            Ue(this, "margin"),
            Ue(this, "once"),
            Ue(this, "callback"),
            Ue(this, "instance"),
            Ue(this, "observer"),
            Ue(this, "doneOnce"),
            Ue(this, "visible"),
            (this.element = t),
            (this.margin = r),
            (this.once = n),
            (this.callback = i),
            (this.instance = s),
            this.createObserver()
    }
    createObserver() {
        if ((this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function"))) {
            try {
                this.observer = new IntersectionObserver(this.handler.bind(this), { root: null, rootMargin: this.margin, threshold: 0 })
            } catch {
                console.error("Intersection Observer not supported"), (this.doneOnce = !0), (this.observer = void 0), this.callback(null)
                return
            }
            this.instance.$nextTick(() => {
                this.observer && this.observer.observe(this.element)
            })
        }
    }
    handler(t) {
        const [r] = t,
            n = Boolean(r.isIntersecting || r.intersectionRatio > 0)
        n !== this.visible && ((this.visible = n), this.callback(n), this.once && this.visible && ((this.doneOnce = !0), this.stop()))
    }
    stop() {
        this.observer && this.observer.disconnect(), (this.observer = null)
    }
}
const OO = {
        mounted(e, t) {
            t.value !== !1 && e.focus()
        },
    },
    IO = { BModal: EO, BPopover: xO, BToggle: dh, BTooltip: SO, BVisible: kO, focus: OO },
    BO = xt("span", { class: "navbar-toggler-icon" }, null, -1),
    PO = bt({
        __name: "BNavbarToggle",
        props: { disabled: { default: !1 }, label: { default: "Toggle navigation" }, target: null },
        emits: ["click"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "disabled")),
                i = K(() => ({ disabled: n.value, "aria-label": r.label })),
                s = K(() => ({ disabled: n.value })),
                o = () => {
                    n.value || t("click")
                }
            return (l, f) =>
                qi(
                    (Y(),
                    ft(
                        "button",
                        ce({ class: ["navbar-toggler", V(s)], type: "button" }, V(i), { onClick: o }),
                        [mt(l.$slots, "default", {}, () => [BO])],
                        16
                    )),
                    [[V(dh), V(n) ? void 0 : e.target]]
                )
        },
    }),
    RO = ["data-bs-backdrop", "data-bs-scroll"],
    LO = { class: "offcanvas-header" },
    DO = { id: "offcanvasLabel", class: "offcanvas-title" },
    $O = ["aria-label"],
    FO = { class: "offcanvas-body" },
    VO = bt({
        __name: "BOffcanvas",
        props: {
            dismissLabel: { default: "Close" },
            modelValue: { default: !1 },
            bodyScrolling: { default: !1 },
            backdrop: { default: !0 },
            placement: { default: "start" },
            title: null,
        },
        emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "modelValue")),
                i = z(L(r, "bodyScrolling")),
                s = z(L(r, "backdrop")),
                o = Ht(),
                l = Ht()
            Ke(o, "shown.bs.offcanvas", () => t("shown")),
                Ke(o, "hidden.bs.offcanvas", () => t("hidden")),
                Ke(o, "show.bs.offcanvas", () => {
                    t("show"), t("update:modelValue", !0)
                }),
                Ke(o, "hide.bs.offcanvas", () => {
                    t("hide"), t("update:modelValue", !1)
                }),
                je(() => {
                    var d
                    ;(l.value = new gi(o.value)), n.value && ((d = l.value) == null || d.show(o.value))
                })
            const f = K(() => ({ [`offcanvas-${r.placement}`]: !!r.placement }))
            return (
                Oe(
                    () => n.value,
                    (d) => {
                        var h, y
                        d ? (h = l.value) == null || h.show(o.value) : (y = l.value) == null || y.hide()
                    }
                ),
                (d, h) => (
                    Y(),
                    ft(
                        "div",
                        {
                            ref_key: "element",
                            ref: o,
                            class: wt(["offcanvas", V(f)]),
                            tabindex: "-1",
                            "aria-labelledby": "offcanvasLabel",
                            "data-bs-backdrop": V(s),
                            "data-bs-scroll": V(i),
                        },
                        [
                            xt("div", LO, [
                                xt("h5", DO, [mt(d.$slots, "title", {}, () => [ve(jt(e.title), 1)])]),
                                xt(
                                    "button",
                                    {
                                        type: "button",
                                        class: "btn-close text-reset",
                                        "data-bs-dismiss": "offcanvas",
                                        "aria-label": e.dismissLabel,
                                    },
                                    null,
                                    8,
                                    $O
                                ),
                            ]),
                            xt("div", FO, [mt(d.$slots, "default")]),
                        ],
                        10,
                        RO
                    )
                )
            )
        },
    }),
    sc = { top: 0, left: 0, bottom: 0, right: 0 },
    UO = "default",
    HO = "overlay",
    qO = bt({
        components: { BTransition: Tu },
        props: {
            bgColor: { type: String, required: !1 },
            blur: { type: String, default: "2px" },
            fixed: { type: [Boolean, String], default: !1 },
            noCenter: { type: [Boolean, String], default: !1 },
            noFade: { type: [Boolean, String], default: !1 },
            noWrap: { type: [Boolean, String], default: !1 },
            opacity: {
                type: [Number, String],
                default: 0.85,
                validator: (e) => {
                    const t = fh(e, 0)
                    return t >= 0 && t <= 1
                },
            },
            overlayTag: { type: String, default: "div" },
            rounded: { type: [Boolean, String], default: !1 },
            show: { type: [Boolean, String], default: !1 },
            spinnerSmall: { type: [Boolean, String], default: !1 },
            spinnerType: { type: String, default: "border" },
            spinnerVariant: { type: String, required: !1 },
            variant: { type: String, default: "light" },
            wrapTag: { type: String, default: "div" },
            zIndex: { type: [Number, String], default: 10 },
        },
        emits: ["click", "hidden", "shown"],
        setup(e, { slots: t, emit: r }) {
            const n = z(L(e, "fixed")),
                i = z(L(e, "noCenter")),
                s = z(L(e, "noFade")),
                o = z(L(e, "noWrap")),
                l = z(L(e, "show")),
                f = z(L(e, "spinnerSmall")),
                d = K(() => (e.rounded === !0 || e.rounded === "" ? "rounded" : e.rounded ? `rounded-${e.rounded}` : "")),
                h = K(() => (e.variant && !e.bgColor ? `bg-${e.variant}` : "")),
                y = K(() => ({ spinnerType: e.spinnerType || null, spinnerVariant: e.spinnerVariant || null, spinnerSmall: f.value }))
            return () => {
                const E = (N) => he(ui("BSpinner"), { type: N.spinnerType, variant: N.spinnerVariant, small: f.value })
                let T = ""
                if (l.value) {
                    const N = he("div", {
                            class: ["position-absolute", h.value, d.value],
                            style: {
                                ...sc,
                                opacity: e.opacity,
                                backgroundColor: e.bgColor || null,
                                backdropFilter: e.blur ? `blur(${e.blur})` : null,
                            },
                        }),
                        P = he(
                            "div",
                            {
                                class: "position-absolute",
                                style: i.value ? { ...sc } : { top: "50%", left: "50%", transform: "translateX(-50%) translateY(-50%)" },
                            },
                            Nr(HO, y.value, t) || E(y.value) || ""
                        )
                    T = he(
                        e.overlayTag,
                        {
                            class: [
                                "b-overlay",
                                { "position-absolute": !o.value || (o.value && !n.value), "position-fixed": o.value && n.value },
                            ],
                            style: { ...sc, zIndex: e.zIndex || 10 },
                            onClick: (M) => r("click", M),
                            key: "overlay",
                        },
                        [N, P]
                    )
                }
                const S = () =>
                    he(
                        Tu,
                        {
                            noFade: s.value,
                            transProps: { enterToClass: "show" },
                            name: "fade",
                            onAfterEnter: () => r("shown"),
                            onAfterLeave: () => r("hidden"),
                        },
                        { default: () => T }
                    )
                return o.value
                    ? S()
                    : he(e.wrapTag, { class: ["b-overlay-wrap position-relative"], "aria-busy": l.value ? "true" : null }, [
                          he("span", Nr(UO, {}, t)),
                          S(),
                      ])
            }
        },
    }),
    zO = 5,
    ly = 20,
    uy = 0,
    xn = 3,
    jO = "ellipsis-text",
    KO = "first-text",
    GO = "last-text",
    WO = "next-text",
    YO = "page",
    JO = "prev-text",
    ag = (e) => Math.max(Uo(e) || ly, 1),
    lg = (e) => Math.max(Uo(e) || uy, 0),
    QO = (e, t) => {
        const r = Uo(e) || 1
        return r > t ? t : r < 1 ? 1 : r
    },
    XO = bt({
        name: "BPagination",
        props: {
            align: { type: String, default: "start" },
            ariaControls: { type: String, required: !1 },
            ariaLabel: { type: String, default: "Pagination" },
            disabled: { type: [Boolean, String], default: !1 },
            ellipsisClass: { type: [Array, String], default: () => [] },
            ellipsisText: { type: String, default: "\u2026" },
            firstClass: { type: [Array, String], default: () => [] },
            firstNumber: { type: [Boolean, String], default: !1 },
            firstText: { type: String, default: "\xAB" },
            hideEllipsis: { type: [Boolean, String], default: !1 },
            hideGotoEndButtons: { type: [Boolean, String], default: !1 },
            labelFirstPage: { type: String, default: "Go to first page" },
            labelLastPage: { type: String, default: "Go to last page" },
            labelNextPage: { type: String, default: "Go to next page" },
            labelPage: { type: String, default: "Go to page" },
            labelPrevPage: { type: String, default: "Go to previous page" },
            lastClass: { type: [Array, String], default: () => [] },
            lastNumber: { type: [Boolean, String], default: !1 },
            lastText: { type: String, default: "\xBB" },
            limit: { type: Number, default: zO },
            modelValue: { type: Number, default: 1 },
            nextClass: { type: [Array, String], default: () => [] },
            nextText: { type: String, default: "\u203A" },
            pageClass: { type: [Array, String], default: () => [] },
            perPage: { type: Number, default: ly },
            pills: { type: [Boolean, String], default: !1 },
            prevClass: { type: [Array, String], default: () => [] },
            prevText: { type: String, default: "\u2039" },
            size: { type: String, required: !1 },
            totalRows: { type: Number, default: uy },
        },
        emits: ["update:modelValue", "page-click"],
        setup(e, { emit: t, slots: r }) {
            const n = z(L(e, "disabled")),
                i = z(L(e, "firstNumber")),
                s = z(L(e, "hideEllipsis")),
                o = z(L(e, "hideGotoEndButtons")),
                l = z(L(e, "lastNumber")),
                f = z(L(e, "pills")),
                d = pk(L(e, "align")),
                h = K(() => Math.ceil(lg(e.totalRows) / ag(e.perPage))),
                y = K(() => {
                    let $
                    return (
                        h.value - e.modelValue + 2 < e.limit && e.limit > xn
                            ? ($ = h.value - T.value + 1)
                            : ($ = e.modelValue - Math.floor(T.value / 2)),
                        $ < 1 ? ($ = 1) : $ > h.value - T.value && ($ = h.value - T.value + 1),
                        e.limit <= xn && l.value && h.value === $ + T.value - 1 && ($ = Math.max($ - 1, 1)),
                        $
                    )
                }),
                E = K(() => {
                    const $ = h.value - e.modelValue
                    let R = !1
                    return (
                        $ + 2 < e.limit && e.limit > xn ? e.limit > xn && (R = !0) : e.limit > xn && (R = !!(!s.value || i.value)),
                        y.value <= 1 && (R = !1),
                        R && i.value && y.value < 4 && (R = !1),
                        R
                    )
                }),
                T = K(() => {
                    let $ = e.limit
                    return (
                        h.value <= e.limit
                            ? ($ = h.value)
                            : e.modelValue < e.limit - 1 && e.limit > xn
                            ? ((!s.value || l.value) && ($ = e.limit - (i.value ? 0 : 1)), ($ = Math.min($, e.limit)))
                            : h.value - e.modelValue + 2 < e.limit && e.limit > xn
                            ? (!s.value || i.value) && ($ = e.limit - (l.value ? 0 : 1))
                            : e.limit > xn && ($ = e.limit - (s.value ? 0 : 2)),
                        $
                    )
                }),
                S = K(() => {
                    const $ = h.value - T.value
                    let R = !1
                    e.modelValue < e.limit - 1 && e.limit > xn
                        ? (!s.value || l.value) && (R = !0)
                        : e.limit > xn && (R = !!(!s.value || l.value)),
                        y.value > $ && (R = !1)
                    const W = y.value + T.value - 1
                    return R && l.value && W > h.value - 3 && (R = !1), R
                }),
                N = Ze({ pageSize: ag(e.perPage), totalRows: lg(e.totalRows), numberOfPages: h.value }),
                P = ($, R) => {
                    if (R === e.modelValue) return
                    const { target: W } = $,
                        nt = new hf("page-click", { cancelable: !0, vueTarget: this, target: W })
                    t("page-click", nt, R), !nt.defaultPrevented && t("update:modelValue", R)
                },
                M = K(() => (e.size ? `pagination-${e.size}` : "")),
                k = K(() => (f.value ? "b-pagination-pills" : ""))
            Oe(
                () => e.modelValue,
                ($) => {
                    const R = QO($, h.value)
                    R !== e.modelValue && t("update:modelValue", R)
                }
            ),
                Oe(N, ($, R) => {
                    Eb($) ||
                        (((R.pageSize !== $.pageSize && R.totalRows === $.totalRows) ||
                            (R.numberOfPages !== $.numberOfPages && e.modelValue > R.numberOfPages)) &&
                            t("update:modelValue", 1))
                })
            const F = K(() => {
                const $ = []
                for (let R = 0; R < T.value; R++) $.push({ number: y.value + R, classes: null })
                return $
            })
            return () => {
                const $ = [],
                    R = F.value.map((a) => a.number),
                    W = (a) => a === e.modelValue,
                    nt = e.modelValue < 1,
                    J = e.align === "fill",
                    Q = (a, c, m, _, A, w) => {
                        const v = n.value || W(w) || nt || a < 1 || a > h.value,
                            g = a < 1 ? 1 : a > h.value ? h.value : a,
                            u = { disabled: v, page: g, index: g - 1 },
                            p = Nr(m, u, r) || _ || ""
                        return he(
                            "li",
                            { class: ["page-item", { disabled: v, "flex-fill": J, "d-flex": J && !v }, A] },
                            he(
                                v ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !v && J }],
                                    "aria-label": c,
                                    "aria-controls": e.ariaControls || null,
                                    "aria-disabled": v ? "true" : null,
                                    role: "menuitem",
                                    type: v ? null : "button",
                                    tabindex: v ? null : "-1",
                                    onClick: (H) => {
                                        v || P(H, g)
                                    },
                                },
                                p
                            )
                        )
                    },
                    ot = (a) =>
                        he(
                            "li",
                            {
                                class: ["page-item", "disabled", "bv-d-xs-down-none", J ? "flex-fill" : "", e.ellipsisClass],
                                role: "separator",
                                key: `ellipsis-${a ? "last" : "first"}`,
                            },
                            [he("span", { class: ["page-link"] }, Nr(jO, {}, r) || e.ellipsisText || "...")]
                        ),
                    it = (a, c) => {
                        const m = W(a.number) && !nt,
                            _ = n.value ? null : m || (nt && c === 0) ? "0" : "-1",
                            A = { active: m, disabled: n.value, page: a.number, index: a.number - 1, content: a.number },
                            w = Nr(YO, A, r) || a.number,
                            v = he(
                                n.value ? "span" : "button",
                                {
                                    class: ["page-link", { "flex-grow-1": !n.value && J }],
                                    "aria-controls": e.ariaControls || null,
                                    "aria-disabled": n.value ? "true" : null,
                                    "aria-label": e.labelPage ? `${e.labelPage} ${a.number}` : null,
                                    role: "menuitemradio",
                                    type: n.value ? null : "button",
                                    tabindex: _,
                                    onClick: (g) => {
                                        n.value || P(g, a.number)
                                    },
                                },
                                w
                            )
                        return he(
                            "li",
                            {
                                class: ["page-item", { disabled: n.value, active: m, "flex-fill": J, "d-flex": J && !n.value }, e.pageClass],
                                role: "presentation",
                                key: `page-${a.number}`,
                            },
                            v
                        )
                    }
                if (!o.value && !i.value) {
                    const a = Q(1, e.labelFirstPage, KO, e.firstText, e.firstClass, 1)
                    $.push(a)
                }
                const at = Q(e.modelValue - 1, e.labelFirstPage, JO, e.prevText, e.prevClass, 1)
                $.push(at),
                    i.value && R[0] !== 1 && $.push(it({ number: 1 }, 0)),
                    E.value && $.push(ot(!1)),
                    F.value.forEach((a, c) => {
                        const m = E.value && i.value && R[0] !== 1 ? 1 : 0
                        $.push(it(a, c + m))
                    }),
                    S.value && $.push(ot(!0)),
                    l.value && R[R.length - 1] !== h.value && $.push(it({ number: h.value }, -1))
                const x = Q(e.modelValue + 1, e.labelNextPage, WO, e.nextText, e.nextClass, h.value)
                if (($.push(x), !l.value && !o.value)) {
                    const a = Q(h.value, e.labelLastPage, GO, e.lastText, e.lastClass, h.value)
                    $.push(a)
                }
                return he(
                    "ul",
                    {
                        class: ["pagination", M.value, d.value, k.value],
                        role: "menubar",
                        "aria-disabled": n.value,
                        "aria-label": e.ariaLabel || null,
                    },
                    $
                )
            }
        },
    }),
    ZO = bt({
        props: {
            container: { type: [String, Object], default: "body" },
            content: { type: String },
            id: { type: String },
            customClass: { type: String, default: "" },
            noninteractive: { type: [Boolean, String], default: !1 },
            placement: { type: String, default: "right" },
            target: { type: [String, Object], default: void 0 },
            title: { type: String },
            delay: { type: [Number, Object], default: 0 },
            triggers: { type: String, default: "click" },
            show: { type: [Boolean, String], default: !1 },
            variant: { type: String, default: void 0 },
            html: { type: [Boolean, String], default: !0 },
            sanitize: { type: [Boolean, String], default: !1 },
            offset: { type: String, default: "0" },
        },
        emits: ["show", "shown", "hide", "hidden", "inserted"],
        setup(e, { emit: t, slots: r }) {
            z(L(e, "noninteractive"))
            const n = z(L(e, "show")),
                i = z(L(e, "html")),
                s = z(L(e, "sanitize")),
                o = Ht(),
                l = Ht(),
                f = Ht(),
                d = Ht(),
                h = Ht(),
                y = K(() => ({ [`b-popover-${e.variant}`]: e.variant !== void 0 })),
                E = (N) => {
                    if (typeof N == "string" || N instanceof HTMLElement) return N
                    if (typeof N < "u") return N.$el
                },
                T = (N) => {
                    if (N) return typeof N == "string" ? document.getElementById(N) || void 0 : N
                },
                S = (N) => {
                    ;(l.value = T(E(N))),
                        l.value &&
                            (f.value = new $o(l.value, {
                                customClass: e.customClass,
                                container: E(e.container),
                                trigger: e.triggers,
                                placement: e.placement,
                                title: e.title || r.title ? d.value : "",
                                content: h.value,
                                html: i.value,
                                delay: e.delay,
                                sanitize: s.value,
                                offset: e.offset,
                            }))
                }
            return (
                je(() => {
                    var N, P, M
                    Wr(() => {
                        S(e.target)
                    }),
                        (P = (N = o.value) == null ? void 0 : N.parentNode) == null || P.removeChild(o.value),
                        n.value && ((M = f.value) == null || M.show())
                }),
                qs(() => {
                    var N
                    ;(N = f.value) == null || N.dispose()
                }),
                Oe(
                    () => e.target,
                    (N) => {
                        var P
                        ;(P = f.value) == null || P.dispose(), S(N)
                    }
                ),
                Oe(
                    () => n.value,
                    (N, P) => {
                        var M, k
                        N !== P && (N ? (M = f.value) == null || M.show() : (k = f.value) == null || k.hide())
                    }
                ),
                Ke(l, "show.bs.popover", () => t("show")),
                Ke(l, "shown.bs.popover", () => t("shown")),
                Ke(l, "hide.bs.popover", () => t("hide")),
                Ke(l, "hidden.bs.popover", () => t("hidden")),
                Ke(l, "inserted.bs.popover", () => t("inserted")),
                { element: o, titleRef: d, contentRef: h, classes: y }
            )
        },
    }),
    tI = ["id"],
    eI = { ref: "titleRef" },
    rI = { ref: "contentRef" }
function nI(e, t, r, n, i, s) {
    return (
        Y(),
        ft(
            "div",
            { id: e.id, ref: "element", class: wt(["popover b-popover", e.classes]), role: "tooltip", tabindex: "-1" },
            [
                xt("div", eI, [mt(e.$slots, "title", {}, () => [ve(jt(e.title), 1)])], 512),
                xt("div", rI, [mt(e.$slots, "default", {}, () => [ve(jt(e.content), 1)])], 512),
            ],
            10,
            tI
        )
    )
}
const iI = ur(ZO, [["render", nI]]),
    fy = bt({
        props: {
            animated: { type: [Boolean, String], default: !1 },
            label: { type: String },
            labelHtml: { type: String },
            max: { type: [Number, String] },
            precision: { type: [Number, String], default: 0 },
            showProgress: { type: [Boolean, String], default: !1 },
            showValue: { type: [Boolean, String], default: !1 },
            striped: { type: [Boolean, String], default: !1 },
            value: { type: [Number, String], default: 0 },
            variant: { type: String },
        },
        setup(e, { slots: t }) {
            const r = z(L(e, "animated")),
                n = z(L(e, "showProgress")),
                i = z(L(e, "showValue")),
                s = z(L(e, "striped")),
                o = Ie(cy),
                l = K(() => ({
                    "progress-bar-animated": r.value || (o == null ? void 0 : o.animated),
                    "progress-bar-striped": s.value || (o == null ? void 0 : o.striped) || r.value || (o == null ? void 0 : o.animated),
                    [`bg-${e.variant}`]: e.variant !== void 0,
                })),
                f = K(() => {
                    if (i.value || (o == null ? void 0 : o.showValue)) return parseFloat(e.value).toFixed(e.precision)
                    if (n.value || (o == null ? void 0 : o.showProgress)) {
                        const y = ((e.value * 100) / parseInt(e.max || 100)).toString()
                        return parseFloat(y).toFixed(e.precision)
                    }
                    return e.label || ""
                }),
                d = K(() =>
                    e.max || (o == null ? void 0 : o.max)
                        ? `${(e.value * 100) / parseInt(e.max || (o == null ? void 0 : o.max))}%`
                        : typeof e.value == "string"
                        ? e.value
                        : `${e.value}%`
                ),
                h = K(() => {
                    const y = {
                        class: ["progress-bar", l.value],
                        role: "progressbar",
                        "aria-valuenow": e.value,
                        "aria-valuemin": 0,
                        "aria-valuemax": e.max,
                        style: { width: d.value },
                    }
                    return e.labelHtml ? { ...y, innerHTML: e.labelHtml } : y
                })
            return () => {
                var y
                return he("div", h.value, ((y = t.default) == null ? void 0 : y.call(t)) || f.value)
            }
        },
    }),
    cy = Symbol(),
    sI = bt({
        __name: "BProgress",
        props: {
            variant: null,
            max: null,
            height: null,
            animated: { default: !1 },
            precision: { default: 0 },
            showProgress: { default: !1 },
            showValue: { default: !1 },
            striped: { default: !1 },
            value: { default: 0 },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "animated")),
                n = z(L(t, "showProgress")),
                i = z(L(t, "showValue")),
                s = z(L(t, "striped"))
            return (
                cn(cy, { animated: r.value, max: t.max, showProgress: n.value, showValue: i.value, striped: s.value }),
                (o, l) => (
                    Y(),
                    ft(
                        "div",
                        { class: "progress", style: hn({ height: e.height }) },
                        [
                            mt(o.$slots, "default", {}, () => [
                                Ut(
                                    fy,
                                    Ga(
                                        Ho({
                                            animated: V(r),
                                            max: e.max,
                                            precision: e.precision,
                                            showProgress: V(n),
                                            showValue: V(i),
                                            striped: V(s),
                                            value: e.value,
                                            variant: e.variant,
                                        })
                                    ),
                                    null,
                                    16
                                ),
                            ]),
                        ],
                        4
                    )
                )
            )
        },
    }),
    ug = pf("cols", [""], { type: [String, Number], default: null }),
    oI = bt({
        name: "BRow",
        props: {
            tag: { type: String, default: "div" },
            gutterX: { type: String, default: null },
            gutterY: { type: String, default: null },
            noGutters: { type: [Boolean, String], default: !1 },
            alignV: { type: String, default: null },
            alignH: { type: String, default: null },
            alignContent: { type: String, default: null },
            ...ug,
        },
        setup(e) {
            const t = z(L(e, "noGutters")),
                r = Ab(e, ug, "cols", "row-cols")
            return {
                classes: K(() => ({
                    [`gx-${e.gutterX}`]: e.gutterX !== null,
                    [`gy-${e.gutterY}`]: e.gutterY !== null,
                    "g-0": t.value,
                    [`align-items-${e.alignV}`]: e.alignV !== null,
                    [`justify-content-${e.alignH}`]: e.alignH !== null,
                    [`align-content-${e.alignContent}`]: e.alignContent !== null,
                })),
                rowColsClasses: r,
            }
        },
    })
function aI(e, t, r, n, i, s) {
    return (
        Y(),
        kt(Kt(e.tag), { class: wt(["row", [e.classes, e.rowColsClasses]]) }, { default: Ct(() => [mt(e.$slots, "default")]), _: 3 }, 8, [
            "class",
        ])
    )
}
const lI = ur(oI, [["render", aI]]),
    Ql = bt({
        __name: "BSkeleton",
        props: { height: null, width: null, size: null, animation: { default: "wave" }, type: { default: "text" }, variant: null },
        setup(e) {
            const t = e,
                r = K(() => [
                    `b-skeleton-${t.type}`,
                    {
                        [`b-skeleton-animate-${t.animation}`]: typeof t.animation == "boolean" ? !1 : t.animation,
                        [`bg-${t.variant}`]: t.variant !== void 0,
                    },
                ]),
                n = K(() => ({ width: t.size || t.width, height: t.size || t.height }))
            return (i, s) => (Y(), ft("div", { class: wt(["b-skeleton", V(r)]), style: hn(V(n)) }, null, 6))
        },
    }),
    uI = bt({
        __name: "BSkeletonIcon",
        props: { animation: { default: "wave" } },
        setup(e) {
            const t = e,
                r = K(() => [`b-skeleton-animate-${t.animation}`])
            return (n, i) => (
                Y(),
                ft(
                    "div",
                    { class: wt(["b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden", V(r)]) },
                    [mt(n.$slots, "default")],
                    2
                )
            )
        },
    }),
    dy = bt({
        __name: "BTableSimple",
        props: {
            bordered: { default: !1 },
            borderless: { default: !1 },
            borderVariant: null,
            captionTop: { default: !1 },
            dark: { default: !1 },
            hover: { default: !1 },
            responsive: { type: [Boolean, String], default: !1 },
            stacked: { type: [Boolean, String], default: !1 },
            striped: { default: !1 },
            small: { default: !1 },
            tableClass: null,
            tableVariant: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "captionTop")),
                n = z(L(t, "borderless")),
                i = z(L(t, "bordered")),
                s = z(L(t, "dark")),
                o = z(L(t, "hover")),
                l = z(L(t, "small")),
                f = z(L(t, "striped")),
                d = K(() => [
                    "table",
                    "b-table",
                    {
                        "table-bordered": i.value,
                        "table-borderless": n.value,
                        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
                        "caption-top": r.value,
                        "table-dark": s.value,
                        "table-hover": o.value,
                        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
                        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
                        "table-striped": f.value,
                        "table-sm": l.value,
                        [`table-${t.tableVariant}`]: t.tableVariant !== void 0,
                    },
                    t.tableClass,
                ]),
                h = K(() => [
                    {
                        "table-responsive": typeof t.responsive == "boolean" && t.responsive,
                        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
                    },
                ])
            return (y, E) =>
                e.responsive
                    ? (Y(),
                      ft("div", { key: 1, class: wt(V(h)) }, [xt("table", { role: "table", class: wt(V(d)) }, [mt(y.$slots, "default")], 2)], 2))
                    : (Y(), ft("table", { key: 0, role: "table", class: wt(V(d)) }, [mt(y.$slots, "default")], 2))
        },
    }),
    fI = { key: 0 },
    cI = { key: 1 },
    dI = bt({
        __name: "BSkeletonTable",
        props: {
            animation: { default: "wave" },
            columns: { default: 5 },
            hideHeader: { default: !1 },
            rows: { default: 3 },
            showFooter: { default: !1 },
            tableProps: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "hideHeader")),
                n = z(L(t, "showFooter"))
            return (i, s) => (
                Y(),
                kt(
                    dy,
                    Ga(Ho(e.tableProps)),
                    {
                        default: Ct(() => [
                            V(r)
                                ? Dt("", !0)
                                : (Y(),
                                  ft("thead", fI, [
                                      xt("tr", null, [
                                          (Y(!0),
                                          ft(
                                              Yt,
                                              null,
                                              Pe(e.columns, (o, l) => (Y(), ft("th", { key: l }, [Ut(Ql)]))),
                                              128
                                          )),
                                      ]),
                                  ])),
                            xt("tbody", null, [
                                (Y(!0),
                                ft(
                                    Yt,
                                    null,
                                    Pe(
                                        e.rows,
                                        (o, l) => (
                                            Y(),
                                            ft("tr", { key: l }, [
                                                (Y(!0),
                                                ft(
                                                    Yt,
                                                    null,
                                                    Pe(e.columns, (f, d) => (Y(), ft("td", { key: d }, [Ut(Ql, { width: "75%" })]))),
                                                    128
                                                )),
                                            ])
                                        )
                                    ),
                                    128
                                )),
                            ]),
                            V(n)
                                ? (Y(),
                                  ft("tfoot", cI, [
                                      xt("tr", null, [
                                          (Y(!0),
                                          ft(
                                              Yt,
                                              null,
                                              Pe(e.columns, (o, l) => (Y(), ft("th", { key: l }, [Ut(Ql)]))),
                                              128
                                          )),
                                      ]),
                                  ]))
                                : Dt("", !0),
                        ]),
                        _: 1,
                    },
                    16
                )
            )
        },
    }),
    hI = bt({
        __name: "BSkeletonWrapper",
        props: { loading: { default: !1 } },
        setup(e) {
            const t = z(L(e, "loading"))
            return (r, n) => (V(t) ? mt(r.$slots, "loading", { key: 0 }) : mt(r.$slots, "default", { key: 1 }))
        },
    }),
    pI = { key: 0, class: "visually-hidden" },
    gI = bt({
        __name: "BSpinner",
        props: {
            label: null,
            role: { default: "status" },
            small: { default: !1 },
            tag: { default: "span" },
            type: { default: "border" },
            variant: null,
        },
        setup(e) {
            const t = e,
                r = z(L(t, "small")),
                n = K(() => ({
                    "spinner-border": t.type === "border",
                    "spinner-border-sm": t.type === "border" && r.value,
                    "spinner-grow": t.type === "grow",
                    "spinner-grow-sm": t.type === "grow" && r.value,
                    [`text-${t.variant}`]: t.variant !== void 0,
                }))
            return (i, s) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { class: wt(V(n)), role: e.label || i.$slots.label ? e.role : null, "aria-hidden": e.label || i.$slots.label ? null : !0 },
                    {
                        default: Ct(() => [
                            e.label || i.$slots.label
                                ? (Y(), ft("span", pI, [mt(i.$slots, "label", {}, () => [ve(jt(e.label), 1)])]))
                                : Dt("", !0),
                        ]),
                        _: 3,
                    },
                    8,
                    ["class", "role", "aria-hidden"]
                )
            )
        },
    }),
    mI = bt({
        __name: "BTableContainer",
        props: { responsive: { type: [Boolean, String], default: !1 }, responsiveClasses: null },
        setup(e) {
            return (t, r) =>
                e.responsive
                    ? (Y(), ft("div", { key: 0, class: wt(e.responsiveClasses) }, [mt(t.$slots, "default")], 2))
                    : mt(t.$slots, "default", { key: 1 })
        },
    }),
    vI = () => ({
        normaliseFields: (e, t) => {
            const r = []
            return !(e != null && e.length) && (t == null ? void 0 : t.length)
                ? (Object.keys(t[0]).forEach((n) => r.push({ key: n, label: Qp(n) })), r)
                : (Array.isArray(e) &&
                      e.forEach((n) => {
                          typeof n == "string" ? r.push({ key: n, label: Qp(n) }) : Rk(n) && n.key && Vo(n.key) && r.push({ ...n })
                      }),
                  r)
        },
        sortItems: (e, t, r) => {
            if (!r || !r.key) return t
            const n = r.key
            return t.sort((i, s) => (i[n] > s[n] ? (r.desc ? -1 : 1) : s[n] > i[n] ? (r.desc ? 1 : -1) : 0))
        },
    }),
    bI = ["title", "abbr", "onClick"],
    yI = { class: "d-flex flex-nowrap align-items-center gap-1" },
    _I = { key: 0, class: "text-muted small" },
    wI = { key: 1 },
    AI = { key: 0 },
    EI = ["title", "abbr"],
    xI = { key: 1 },
    TI = { key: 2 },
    CI = bt({
        __name: "BTable",
        props: {
            align: null,
            caption: null,
            captionTop: { default: !1 },
            borderless: { default: !1 },
            bordered: { default: !1 },
            borderVariant: null,
            dark: { default: !1 },
            fields: { default: () => [] },
            footClone: { default: !1 },
            hover: { default: !1 },
            items: { default: () => [] },
            responsive: { type: [Boolean, String], default: !1 },
            small: { default: !1 },
            striped: { default: !1 },
            variant: null,
            sortBy: null,
            sortDesc: { type: Boolean },
            sortInternal: { type: Boolean, default: !0 },
        },
        emits: ["update:sortBy", "update:sortDesc", "sorted"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "captionTop")),
                i = z(L(r, "borderless")),
                s = z(L(r, "bordered")),
                o = z(L(r, "dark")),
                l = z(L(r, "footClone")),
                f = z(L(r, "hover")),
                d = z(L(r, "small")),
                h = z(L(r, "striped")),
                y = K(() => [
                    "table",
                    {
                        [`align-${r.align}`]: r.align !== void 0,
                        [`table-${r.variant}`]: r.variant !== void 0,
                        "table-striped": h.value,
                        "table-hover": f.value,
                        "table-dark": o.value,
                        "table-bordered": s.value,
                        [`border-${r.borderVariant}`]: r.borderVariant !== void 0,
                        "table-borderless": i.value,
                        "table-sm": d.value,
                        "caption-top": n.value,
                    },
                ]),
                E = vI(),
                T = K(() => E.normaliseFields(r.fields, r.items)),
                S = K(() => (r.sortInternal ? E.sortItems(r.fields, r.items, { key: r.sortBy, desc: r.sortDesc }) : r.items)),
                N = K(() => ({
                    "table-responsive": typeof r.responsive == "boolean" && r.responsive,
                    [`table-responsive-${r.responsive}`]: typeof r.responsive == "string",
                })),
                P = K(() => r.fields.filter((F) => (typeof F == "string" ? !1 : F.sortable)).length > 0),
                M = (F) => {
                    //!! make sure to enable this flag after implementing the table.busy feature.
                    const $ = typeof F == "string" ? F : F.key,
                        R = typeof F == "string" ? !1 : F.sortable
                    P.value === !0 &&
                        R === !0 &&
                        ($ === r.sortBy
                            ? t("update:sortDesc", !r.sortDesc)
                            : (t("update:sortBy", typeof F == "string" ? F : F.key), t("update:sortDesc", !1)),
                        t("sorted", r.sortBy, r.sortDesc))
                },
                k = (F) => [F.class, F.thClass, F.variant ? `table-${F.variant}` : void 0, { "b-table-sortable-column": P.value && F.sortable }]
            return (F, $) => (
                Y(),
                kt(
                    mI,
                    { responsive: e.responsive, "responsive-classes": V(N) },
                    {
                        default: Ct(() => [
                            xt(
                                "table",
                                { class: wt(V(y)) },
                                [
                                    xt("thead", null, [
                                        F.$slots["thead-top"] ? mt(F.$slots, "thead-top", { key: 0 }) : Dt("", !0),
                                        xt("tr", null, [
                                            (Y(!0),
                                            ft(
                                                Yt,
                                                null,
                                                Pe(
                                                    V(T),
                                                    (R) => (
                                                        Y(),
                                                        ft(
                                                            "th",
                                                            ce(
                                                                {
                                                                    key: R.key,
                                                                    scope: "col",
                                                                    class: k(R),
                                                                    title: R.headerTitle,
                                                                    abbr: R.headerAbbr,
                                                                    style: R.thStyle,
                                                                },
                                                                R.thAttr,
                                                                { onClick: (W) => M(R) }
                                                            ),
                                                            [
                                                                xt("div", yI, [
                                                                    V(P) && R.sortable && R.key === e.sortBy
                                                                        ? (Y(),
                                                                          ft("span", _I, [
                                                                              qi(xt("span", null, "\u25BC", 512), [[uu, e.sortDesc === !0]]),
                                                                              qi(xt("span", null, "\u25B2", 512), [[uu, e.sortDesc === !1]]),
                                                                          ]))
                                                                        : Dt("", !0),
                                                                    xt("div", null, [
                                                                        F.$slots["head(" + R.key + ")"]
                                                                            ? mt(F.$slots, "head(" + R.key + ")", { key: 0, label: R.label })
                                                                            : (Y(), ft(Yt, { key: 1 }, [ve(jt(R.label), 1)], 64)),
                                                                    ]),
                                                                ]),
                                                            ],
                                                            16,
                                                            bI
                                                        )
                                                    )
                                                ),
                                                128
                                            )),
                                        ]),
                                        F.$slots["thead-sub"]
                                            ? (Y(),
                                              ft("tr", wI, [
                                                  (Y(!0),
                                                  ft(
                                                      Yt,
                                                      null,
                                                      Pe(
                                                          V(T),
                                                          (R) => (
                                                              Y(),
                                                              ft(
                                                                  "td",
                                                                  {
                                                                      key: R.key,
                                                                      scope: "col",
                                                                      class: wt([R.class, R.thClass, R.variant ? `table-${R.variant}` : ""]),
                                                                  },
                                                                  [
                                                                      F.$slots["thead-sub"]
                                                                          ? mt(F.$slots, "thead-sub", ce({ key: 0, items: V(T) }, R))
                                                                          : (Y(), ft(Yt, { key: 1 }, [ve(jt(R.label), 1)], 64)),
                                                                  ],
                                                                  2
                                                              )
                                                          )
                                                      ),
                                                      128
                                                  )),
                                              ]))
                                            : Dt("", !0),
                                    ]),
                                    xt("tbody", null, [
                                        (Y(!0),
                                        ft(
                                            Yt,
                                            null,
                                            Pe(
                                                V(S),
                                                (R, W) => (
                                                    Y(),
                                                    ft(
                                                        "tr",
                                                        { key: W, class: wt(R._rowVariant ? `table-${R._rowVariant}` : null) },
                                                        [
                                                            (Y(!0),
                                                            ft(
                                                                Yt,
                                                                null,
                                                                Pe(
                                                                    V(T),
                                                                    (nt, J) => (
                                                                        Y(),
                                                                        ft(
                                                                            "td",
                                                                            ce({ key: nt.key }, nt.tdAttr, {
                                                                                class: [
                                                                                    nt.class,
                                                                                    nt.tdClass,
                                                                                    nt.variant ? `table-${nt.variant}` : "",
                                                                                    (R == null ? void 0 : R._cellVariants) &&
                                                                                    (R == null ? void 0 : R._cellVariants[nt.key])
                                                                                        ? `table-${R == null ? void 0 : R._cellVariants[nt.key]}`
                                                                                        : "",
                                                                                ],
                                                                            }),
                                                                            [
                                                                                F.$slots["cell(" + nt.key + ")"]
                                                                                    ? mt(F.$slots, "cell(" + nt.key + ")", {
                                                                                          key: 0,
                                                                                          value: R[nt.key],
                                                                                          index: J,
                                                                                          item: R,
                                                                                          items: e.items,
                                                                                      })
                                                                                    : (Y(), ft(Yt, { key: 1 }, [ve(jt(R[nt.key]), 1)], 64)),
                                                                            ],
                                                                            16
                                                                        )
                                                                    )
                                                                ),
                                                                128
                                                            )),
                                                        ],
                                                        2
                                                    )
                                                )
                                            ),
                                            128
                                        )),
                                    ]),
                                    V(l)
                                        ? (Y(),
                                          ft("tfoot", AI, [
                                              xt("tr", null, [
                                                  (Y(!0),
                                                  ft(
                                                      Yt,
                                                      null,
                                                      Pe(
                                                          V(T),
                                                          (R) => (
                                                              Y(),
                                                              ft(
                                                                  "th",
                                                                  ce({ key: R.key }, R.thAttr, {
                                                                      scope: "col",
                                                                      class: [R.class, R.thClass, R.variant ? `table-${R.variant}` : ""],
                                                                      title: R.headerTitle,
                                                                      abbr: R.headerAbbr,
                                                                      style: R.thStyle,
                                                                  }),
                                                                  jt(R.label),
                                                                  17,
                                                                  EI
                                                              )
                                                          )
                                                      ),
                                                      128
                                                  )),
                                              ]),
                                          ]))
                                        : Dt("", !0),
                                    F.$slots["table-caption"]
                                        ? (Y(), ft("caption", xI, [mt(F.$slots, "table-caption")]))
                                        : e.caption
                                        ? (Y(), ft("caption", TI, jt(e.caption), 1))
                                        : Dt("", !0),
                                ],
                                2
                            ),
                        ]),
                        _: 3,
                    },
                    8,
                    ["responsive", "responsive-classes"]
                )
            )
        },
    }),
    MI = bt({
        __name: "BTbody",
        props: { variant: null },
        setup(e) {
            const t = e,
                r = K(() => ({ [`thead-${t.variant}`]: t.variant !== void 0 }))
            return (n, i) => (Y(), ft("tbody", { role: "rowgroup", class: wt(V(r)) }, [mt(n.$slots, "default")], 2))
        },
    }),
    SI = ["scope", "colspan", "rowspan", "data-label"],
    kI = { key: 0 },
    NI = bt({
        __name: "BTd",
        props: { colspan: null, rowspan: null, stackedHeading: null, stickyColumn: { default: !1 }, variant: null },
        setup(e) {
            const t = e,
                r = z(L(t, "stickyColumn")),
                n = K(() => ({
                    [`table-${t.variant}`]: t.variant !== void 0,
                    "b-table-sticky-column": r.value,
                    "table-b-table-default": r.value && !t.variant,
                })),
                i = K(() => (t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col"))
            return (s, o) => (
                Y(),
                ft(
                    "td",
                    { role: "cell", scope: V(i), class: wt(V(n)), colspan: e.colspan, rowspan: e.rowspan, "data-label": e.stackedHeading },
                    [e.stackedHeading ? (Y(), ft("div", kI, [mt(s.$slots, "default")])) : mt(s.$slots, "default", { key: 1 })],
                    10,
                    SI
                )
            )
        },
    }),
    OI = bt({
        __name: "BTfoot",
        props: { variant: null },
        setup(e) {
            const t = e,
                r = K(() => ({ [`table-${t.variant}`]: t.variant !== void 0 }))
            return (n, i) => (Y(), ft("tfoot", { role: "rowgroup", class: wt(V(r)) }, [mt(n.$slots, "default")], 2))
        },
    }),
    II = ["scope", "colspan", "rowspan", "data-label"],
    BI = { key: 0 },
    PI = bt({
        __name: "BTh",
        props: { colspan: null, rowspan: null, stackedHeading: null, stickyColumn: { default: !1 }, variant: null },
        setup(e) {
            const t = e,
                r = z(L(t, "stickyColumn")),
                n = K(() => ({
                    [`table-${t.variant}`]: t.variant !== void 0,
                    "b-table-sticky-column": r.value,
                    "table-b-table-default": r.value && t.variant === void 0,
                })),
                i = K(() => (t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col"))
            return (s, o) => (
                Y(),
                ft(
                    "th",
                    {
                        role: "columnheader",
                        scope: V(i),
                        class: wt(V(n)),
                        colspan: e.colspan,
                        rowspan: e.rowspan,
                        "data-label": e.stackedHeading,
                    },
                    [e.stackedHeading !== void 0 ? (Y(), ft("div", BI, [mt(s.$slots, "default")])) : mt(s.$slots, "default", { key: 1 })],
                    10,
                    II
                )
            )
        },
    }),
    RI = bt({
        __name: "BThead",
        props: { variant: null },
        setup(e) {
            const t = e,
                r = K(() => ({ [`table-${t.variant}`]: t.variant !== void 0 }))
            return (n, i) => (Y(), ft("thead", { role: "rowgroup", class: wt(V(r)) }, [mt(n.$slots, "default")], 2))
        },
    }),
    LI = bt({
        __name: "BTr",
        props: { variant: null },
        setup(e) {
            const t = e,
                r = K(() => ({ [`table-${t.variant}`]: t.variant !== void 0 }))
            return (n, i) => (Y(), ft("tr", { role: "row", class: wt(V(r)) }, [mt(n.$slots, "default")], 2))
        },
    }),
    DI = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"],
    hy = Symbol(),
    $I = bt({
        __name: "BTabs",
        props: {
            activeNavItemClass: { default: void 0 },
            activeTabClass: { default: void 0 },
            align: { default: void 0 },
            card: { default: !1 },
            contentClass: { default: void 0 },
            end: { default: !1 },
            fill: { default: !1 },
            id: { default: void 0 },
            justified: { default: !1 },
            lazy: { default: !1 },
            navClass: { default: void 0 },
            navWrapperClass: { default: void 0 },
            noFade: { default: !1 },
            noNavStyle: { default: !1 },
            pills: { default: !1 },
            small: { default: !1 },
            tag: { default: "div" },
            vertical: { default: !1 },
            modelValue: { default: -1 },
        },
        emits: ["update:modelValue", "activate-tab", "click"],
        setup(e, { emit: t }) {
            const r = e,
                n = z(L(r, "card")),
                i = z(L(r, "end")),
                s = z(L(r, "fill")),
                o = z(L(r, "justified")),
                l = z(L(r, "lazy")),
                f = z(L(r, "noFade")),
                d = z(L(r, "noNavStyle")),
                h = z(L(r, "pills")),
                y = z(L(r, "small")),
                E = z(L(r, "vertical")),
                T = Qi(),
                S = Ht(r.modelValue),
                N = Ht(""),
                P = K({
                    get: () => S.value,
                    set: (J) => {
                        ;(S.value = J),
                            M.value.length > 0 && J >= 0 && J < M.value.length ? (N.value = M.value[J].buttonId) : (N.value = ""),
                            t("update:modelValue", J)
                    },
                }),
                M = K(() => {
                    let J = []
                    return (
                        T.default &&
                            (J = nt(T).map((Q, ot) => {
                                Q.props || (Q.props = {})
                                const it = Q.props["button-id"] || ri("tab"),
                                    at = Q.props.id || ri(),
                                    x = P.value > -1 ? ot === P.value : Q.props.active === "",
                                    a = Q.props["title-item-class"],
                                    c = Q.props["title-link-attributes"]
                                return {
                                    buttonId: it,
                                    contentId: at,
                                    active: x,
                                    disabled: Q.props.disabled === "" || Q.props.disabled === !0,
                                    navItemClasses: [
                                        { active: x, disabled: Q.props.disabled === "" || Q.props.disabled === !0 },
                                        x && r.activeNavItemClass ? r.activeNavItemClass : null,
                                        Q.props["title-link-class"],
                                    ],
                                    tabClasses: [{ fade: !f.value }, x && r.activeTabClass ? r.activeTabClass : null],
                                    target: `#${at}`,
                                    title: Q.props.title,
                                    titleItemClass: a,
                                    titleLinkAttributes: c,
                                    onClick: Q.props.onClick,
                                    tab: Q,
                                }
                            })),
                        J
                    )
                }),
                k = K(() => !((M == null ? void 0 : M.value) && M.value.length > 0)),
                F = K(() => ({ "d-flex align-items-start": E.value })),
                $ = K(() => ({
                    "nav-pills": h.value,
                    "flex-column me-3": E.value,
                    [`justify-content-${r.align}`]: !!r.align,
                    "nav-fill": s.value,
                    "card-header-tabs": n.value,
                    "nav-justified": o.value,
                    "nav-tabs": !d.value && !h.value,
                    small: y.value,
                })),
                R = (J) => {
                    let Q = !1
                    if (
                        J !== void 0 &&
                        J > -1 &&
                        J < M.value.length &&
                        !M.value[J].disabled &&
                        (P.value < 0 || M.value[J].buttonId !== N.value)
                    ) {
                        const ot = new hf("activate-tab", { cancelable: !0, vueTarget: this })
                        t("activate-tab", J, P.value, ot), ot.defaultPrevented || ((P.value = J), (Q = !0))
                    }
                    return !Q && r.modelValue !== P.value && t("update:modelValue", P.value), Q
                },
                W = (J, Q) => {
                    var ot
                    R(Q),
                        Q >= 0 &&
                            !M.value[Q].disabled &&
                            ((ot = M.value[Q]) == null ? void 0 : ot.onClick) &&
                            Cb(M.value[Q].onClick) &&
                            M.value[Q].onClick(J)
                },
                nt = (J) =>
                    !J || !J.default
                        ? []
                        : J.default()
                              .reduce((Q, ot) => (typeof ot.type == "symbol" ? (Q = Q.concat(ot.children)) : Q.push(ot), Q), [])
                              .filter((Q) => {
                                  var ot
                                  return ((ot = Q.type) == null ? void 0 : ot.__name) === "BTab"
                              })
            return (
                R(S.value),
                Oe(
                    () => r.modelValue,
                    (J, Q) => {
                        if (J === Q) return
                        if (((J = Math.max(J, -1)), (Q = Math.max(Q, -1)), M.value.length <= 0)) {
                            P.value = -1
                            return
                        }
                        const ot = J > Q
                        let it = J
                        const at = M.value.length - 1
                        for (; it >= 0 && it <= at && M.value[it].disabled; ) it += ot ? 1 : -1
                        if (it < 0) {
                            R(0)
                            return
                        }
                        if (it >= M.value.length) {
                            R(M.value.length - 1)
                            return
                        }
                        R(it)
                    }
                ),
                Oe(
                    () => M.value,
                    () => {
                        let J = M.value.map((Q) => Q.active && !Q.disabled).lastIndexOf(!0)
                        J < 0 &&
                            (P.value >= M.value.length
                                ? (J = M.value.map((Q) => !Q.disabled).lastIndexOf(!0))
                                : M.value[P.value] && !M.value[P.value].disabled && (J = P.value)),
                            J < 0 && (J = M.value.map((Q) => !Q.disabled).indexOf(!0)),
                            M.value.forEach((Q, ot) => (Q.active = ot === J)),
                            R(J)
                    }
                ),
                je(() => {
                    if (P.value < 0 && M.value.length > 0 && !M.value.some((J) => J.active)) {
                        const J = M.value.map((Q) => !Q.disabled).indexOf(!0)
                        R(J >= 0 ? J : -1)
                    }
                }),
                cn(hy, { lazy: l.value, card: n.value }),
                (J, Q) => (
                    Y(),
                    kt(
                        Kt(e.tag),
                        { id: e.id, class: wt(["tabs", V(F)]) },
                        {
                            default: Ct(() => [
                                V(i)
                                    ? (Y(),
                                      ft(
                                          "div",
                                          { key: 0, class: wt(["tab-content", e.contentClass]) },
                                          [
                                              (Y(!0),
                                              ft(
                                                  Yt,
                                                  null,
                                                  Pe(
                                                      V(M),
                                                      ({ tab: ot, contentId: it, tabClasses: at, active: x }, a) => (
                                                          Y(),
                                                          kt(Kt(ot), { key: a, id: it, class: wt(at), active: x }, null, 8, [
                                                              "id",
                                                              "class",
                                                              "active",
                                                          ])
                                                      )
                                                  ),
                                                  128
                                              )),
                                              V(k)
                                                  ? (Y(),
                                                    ft(
                                                        "div",
                                                        { key: "bv-empty-tab", class: wt(["tab-pane active", { "card-body": V(n) }]) },
                                                        [mt(J.$slots, "empty")],
                                                        2
                                                    ))
                                                  : Dt("", !0),
                                          ],
                                          2
                                      ))
                                    : Dt("", !0),
                                xt(
                                    "div",
                                    { class: wt([e.navWrapperClass, { "card-header": V(n), "ms-auto": e.vertical && V(i) }]) },
                                    [
                                        xt(
                                            "ul",
                                            { class: wt(["nav", [V($), e.navClass]]), role: "tablist" },
                                            [
                                                mt(J.$slots, "tabs-start"),
                                                (Y(!0),
                                                ft(
                                                    Yt,
                                                    null,
                                                    Pe(
                                                        V(M),
                                                        (
                                                            { tab: ot, buttonId: it, contentId: at, navItemClasses: x, active: a, target: c },
                                                            m
                                                        ) => (
                                                            Y(),
                                                            ft(
                                                                "li",
                                                                { key: m, class: wt(["nav-item", ot.props["title-item-class"]]) },
                                                                [
                                                                    xt(
                                                                        "button",
                                                                        ce(
                                                                            {
                                                                                id: it,
                                                                                class: ["nav-link", x],
                                                                                "data-bs-toggle": "tab",
                                                                                "data-bs-target": c,
                                                                                role: "tab",
                                                                                "aria-controls": at,
                                                                                "aria-selected": a,
                                                                            },
                                                                            ot.props["title-link-attributes"],
                                                                            { onClick: Gu((_) => W(_, m), ["stop", "prevent"]) }
                                                                        ),
                                                                        [
                                                                            ot.children && ot.children.title
                                                                                ? (Y(), kt(Kt(ot.children.title), { key: 0 }))
                                                                                : (Y(), ft(Yt, { key: 1 }, [ve(jt(ot.props.title), 1)], 64)),
                                                                        ],
                                                                        16,
                                                                        DI
                                                                    ),
                                                                ],
                                                                2
                                                            )
                                                        )
                                                    ),
                                                    128
                                                )),
                                                mt(J.$slots, "tabs-end"),
                                            ],
                                            2
                                        ),
                                    ],
                                    2
                                ),
                                V(i)
                                    ? Dt("", !0)
                                    : (Y(),
                                      ft(
                                          "div",
                                          { key: 1, class: wt(["tab-content", e.contentClass]) },
                                          [
                                              (Y(!0),
                                              ft(
                                                  Yt,
                                                  null,
                                                  Pe(
                                                      V(M),
                                                      ({ tab: ot, contentId: it, tabClasses: at, active: x }, a) => (
                                                          Y(),
                                                          kt(Kt(ot), { key: a, id: it, class: wt(at), active: x }, null, 8, [
                                                              "id",
                                                              "class",
                                                              "active",
                                                          ])
                                                      )
                                                  ),
                                                  128
                                              )),
                                              V(k)
                                                  ? (Y(),
                                                    ft(
                                                        "div",
                                                        { key: "bv-empty-tab", class: wt(["tab-pane active", { "card-body": V(n) }]) },
                                                        [mt(J.$slots, "empty")],
                                                        2
                                                    ))
                                                  : Dt("", !0),
                                          ],
                                          2
                                      )),
                            ]),
                            _: 3,
                        },
                        8,
                        ["id", "class"]
                    )
                )
            )
        },
    }),
    FI = bt({
        __name: "BTab",
        props: {
            id: null,
            title: null,
            active: { default: !1 },
            buttonId: { default: void 0 },
            disabled: { default: !1 },
            lazy: { default: !1 },
            noBody: { type: [Boolean, String], default: !1 },
            tag: { default: "div" },
            titleItemClass: { default: void 0 },
            titleLinkAttributes: { default: void 0 },
            titleLinkClass: { default: void 0 },
        },
        setup(e) {
            const t = e,
                r = z(L(t, "active")),
                n = z(L(t, "disabled")),
                i = z(L(t, "lazy")),
                s = Ie(hy, null),
                o = K(() => (s == null ? void 0 : s.lazy) || i.value),
                l = K(() => r.value && !n.value),
                f = K(() => l.value || !o.value),
                d = K(() => ({ active: r.value, show: r.value, "card-body": (s == null ? void 0 : s.card) && t.noBody === !1 }))
            return (h, y) => (
                Y(),
                kt(
                    Kt(e.tag),
                    { id: e.id, class: wt(["tab-pane", V(d)]), role: "tabpanel", "aria-labelledby": "profile-tab" },
                    { default: Ct(() => [V(f) ? mt(h.$slots, "default", { key: 0 }) : Dt("", !0)]), _: 3 },
                    8,
                    ["id", "class"]
                )
            )
        },
    }),
    VI = {
        BAccordion: Qk,
        BAccordionItem: i4,
        BNavText: vO,
        BAlert: o4,
        BAvatar: c4,
        BAvatarGroup: a4,
        BNavForm: oO,
        BBadge: m4,
        BBreadcrumb: w4,
        BBreadcrumbItem: Hb,
        BButton: ja,
        BButtonGroup: x4,
        BButtonToolbar: C4,
        BCard: N4,
        BCardBody: O4,
        BCardFooter: B4,
        BCardGroup: P4,
        BCardHeader: L4,
        BCardImg: D4,
        BCardSubTitle: jb,
        BCardText: U4,
        BCardTitle: zb,
        BCarousel: t8,
        BCarouselSlide: o8,
        BCloseButton: qb,
        BCol: ga,
        BCollapse: Vb,
        BContainer: g8,
        BDropdown: Xb,
        BDropdownDivider: y8,
        BDropdownForm: x8,
        BDropdownGroup: S8,
        BDropdownHeader: I8,
        BDropdownItem: R8,
        BDropdownItemButton: $8,
        BDropdownText: q8,
        BForm: Zb,
        BFormCheckbox: ty,
        BFormCheckboxGroup: tN,
        BFormFloatingLabel: G8,
        BFormGroup: lN,
        BFormInput: dN,
        BFormInvalidFeedback: ed,
        BFormRadio: ry,
        BFormRadioGroup: bN,
        BFormRow: Yl,
        BFormSelect: AN,
        BFormSelectOption: hh,
        BFormSelectOptionGroup: ny,
        BFormText: rd,
        BFormTextarea: HN,
        BFormTag: iy,
        BFormTags: $N,
        BFormValidFeedback: nd,
        BImg: Gb,
        BInputGroup: YN,
        BInputGroupAddon: ph,
        BInputGroupAppend: JN,
        BInputGroupPrepend: QN,
        BInputGroupText: sy,
        BLink: $r,
        BListGroup: XN,
        BListGroupItem: ZN,
        BModal: iO,
        BNav: sO,
        BNavbar: bO,
        BNavbarBrand: wO,
        BNavbarNav: AO,
        BNavbarToggle: PO,
        BNavItem: cO,
        BNavItemDropdown: hO,
        BOffcanvas: VO,
        BOverlay: qO,
        BPagination: XO,
        BPopover: iI,
        BProgress: sI,
        BProgressBar: fy,
        BRow: lI,
        BSkeleton: Ql,
        BSkeletonIcon: uI,
        BSkeletonTable: dI,
        BSkeletonWrapper: hI,
        BSpinner: gI,
        BTab: FI,
        BTable: CI,
        BTableSimple: dy,
        BTbody: MI,
        BTd: NI,
        BTfoot: OI,
        BTh: PI,
        BThead: RI,
        BTr: LI,
        BToast: Qb,
        BToaster: td,
        BToastContainer: td,
        BTabs: $I,
        BTransition: Tu,
        BToastPlugin: d8,
    },
    UI = {
        install(e, t = {}) {
            Object.entries(VI).forEach(([r, n]) => {
                e.component(r, n)
            }),
                Object.entries(IO).forEach(([r, n]) => {
                    e.directive(r, n)
                }),
                gk(e)
        },
    }
const HI = ve(" Loading... "),
    qI = bt({
        __name: "App",
        setup(e) {
            const t = Ie("app"),
                r = Ht(!1)
            return (
                Oe(
                    () => t.web3.active.length,
                    (n) => {
                        r.value = n > 0
                    }
                ),
                (n, i) => {
                    const s = ui("router-view"),
                        o = ui("b-modal")
                    return (
                        Y(),
                        ft(
                            Yt,
                            null,
                            [
                                Ut(
                                    s,
                                    { style: { height: "100%" }, class: "mx-md-3" },
                                    {
                                        default: Ct(({ Component: l }) => [
                                            (Y(),
                                            kt(
                                                Hg,
                                                null,
                                                { fallback: Ct(() => [HI]), default: Ct(() => [xt("div", null, [(Y(), kt(Kt(l)))])]), _: 2 },
                                                1024
                                            )),
                                        ]),
                                        _: 1,
                                    }
                                ),
                                Ut(
                                    o,
                                    {
                                        modelValue: r.value,
                                        "onUpdate:modelValue": i[0] || (i[0] = (l) => (r.value = l)),
                                        title: "Transactions",
                                        hideFooter: "",
                                        centered: "",
                                    },
                                    {
                                        default: Ct(() => [
                                            (Y(!0),
                                            ft(
                                                Yt,
                                                null,
                                                Pe(V(t).web3.active, (l) => (Y(), ft("div", null, jt(l.description) + " - " + jt(l.status), 1))),
                                                256
                                            )),
                                        ]),
                                        _: 1,
                                    },
                                    8,
                                    ["modelValue"]
                                ),
                            ],
                            64
                        )
                    )
                }
            )
        },
    })
var zI = "/frame.jpg",
    py = { exports: {} },
    jI = K2(UA)
;(function (e, t) {
    ;(function (r, n) {
        e.exports = n(jI)
    })(self, function (r) {
        return (() => {
            var n = {
                    192: (l, f) => {
                        var d,
                            h,
                            y = (function () {
                                var E = function (c, m) {
                                    var _ = c,
                                        A = k[m],
                                        w = null,
                                        v = 0,
                                        g = null,
                                        u = [],
                                        p = {},
                                        H = function (C, O) {
                                            ;(w = (function (I) {
                                                for (var G = new Array(I), q = 0; q < I; q += 1) {
                                                    G[q] = new Array(I)
                                                    for (var X = 0; X < I; X += 1) G[q][X] = null
                                                }
                                                return G
                                            })((v = 4 * _ + 17))),
                                                b(0, 0),
                                                b(v - 7, 0),
                                                b(0, v - 7),
                                                D(),
                                                B(),
                                                j(C, O),
                                                _ >= 7 && U(C),
                                                g == null && (g = Z(_, A, u)),
                                                dt(g, O)
                                        },
                                        b = function (C, O) {
                                            for (var I = -1; I <= 7; I += 1)
                                                if (!(C + I <= -1 || v <= C + I))
                                                    for (var G = -1; G <= 7; G += 1)
                                                        O + G <= -1 ||
                                                            v <= O + G ||
                                                            (w[C + I][O + G] =
                                                                (0 <= I && I <= 6 && (G == 0 || G == 6)) ||
                                                                (0 <= G && G <= 6 && (I == 0 || I == 6)) ||
                                                                (2 <= I && I <= 4 && 2 <= G && G <= 4))
                                        },
                                        B = function () {
                                            for (var C = 8; C < v - 8; C += 1) w[C][6] == null && (w[C][6] = C % 2 == 0)
                                            for (var O = 8; O < v - 8; O += 1) w[6][O] == null && (w[6][O] = O % 2 == 0)
                                        },
                                        D = function () {
                                            for (var C = F.getPatternPosition(_), O = 0; O < C.length; O += 1)
                                                for (var I = 0; I < C.length; I += 1) {
                                                    var G = C[O],
                                                        q = C[I]
                                                    if (w[G][q] == null)
                                                        for (var X = -2; X <= 2; X += 1)
                                                            for (var lt = -2; lt <= 2; lt += 1)
                                                                w[G + X][q + lt] =
                                                                    X == -2 || X == 2 || lt == -2 || lt == 2 || (X == 0 && lt == 0)
                                                }
                                        },
                                        U = function (C) {
                                            for (var O = F.getBCHTypeNumber(_), I = 0; I < 18; I += 1) {
                                                var G = !C && ((O >> I) & 1) == 1
                                                w[Math.floor(I / 3)][(I % 3) + v - 8 - 3] = G
                                            }
                                            for (I = 0; I < 18; I += 1)
                                                (G = !C && ((O >> I) & 1) == 1), (w[(I % 3) + v - 8 - 3][Math.floor(I / 3)] = G)
                                        },
                                        j = function (C, O) {
                                            for (var I = (A << 3) | O, G = F.getBCHTypeInfo(I), q = 0; q < 15; q += 1) {
                                                var X = !C && ((G >> q) & 1) == 1
                                                q < 6 ? (w[q][8] = X) : q < 8 ? (w[q + 1][8] = X) : (w[v - 15 + q][8] = X)
                                            }
                                            for (q = 0; q < 15; q += 1)
                                                (X = !C && ((G >> q) & 1) == 1),
                                                    q < 8 ? (w[8][v - q - 1] = X) : q < 9 ? (w[8][15 - q - 1 + 1] = X) : (w[8][15 - q - 1] = X)
                                            w[v - 8][8] = !C
                                        },
                                        dt = function (C, O) {
                                            for (var I = -1, G = v - 1, q = 7, X = 0, lt = F.getMaskFunction(O), tt = v - 1; tt > 0; tt -= 2)
                                                for (tt == 6 && (tt -= 1); ; ) {
                                                    for (var rt = 0; rt < 2; rt += 1)
                                                        if (w[G][tt - rt] == null) {
                                                            var st = !1
                                                            X < C.length && (st = ((C[X] >>> q) & 1) == 1),
                                                                lt(G, tt - rt) && (st = !st),
                                                                (w[G][tt - rt] = st),
                                                                (q -= 1) == -1 && ((X += 1), (q = 7))
                                                        }
                                                    if ((G += I) < 0 || v <= G) {
                                                        ;(G -= I), (I = -I)
                                                        break
                                                    }
                                                }
                                        },
                                        Z = function (C, O, I) {
                                            for (var G = W.getRSBlocks(C, O), q = nt(), X = 0; X < I.length; X += 1) {
                                                var lt = I[X]
                                                q.put(lt.getMode(), 4), q.put(lt.getLength(), F.getLengthInBits(lt.getMode(), C)), lt.write(q)
                                            }
                                            var tt = 0
                                            for (X = 0; X < G.length; X += 1) tt += G[X].dataCount
                                            if (q.getLengthInBits() > 8 * tt)
                                                throw "code length overflow. (" + q.getLengthInBits() + ">" + 8 * tt + ")"
                                            for (q.getLengthInBits() + 4 <= 8 * tt && q.put(0, 4); q.getLengthInBits() % 8 != 0; ) q.putBit(!1)
                                            for (; !(q.getLengthInBits() >= 8 * tt || (q.put(236, 8), q.getLengthInBits() >= 8 * tt)); )
                                                q.put(17, 8)
                                            return (function (rt, st) {
                                                for (
                                                    var ct = 0, ht = 0, gt = 0, pt = new Array(st.length), vt = new Array(st.length), Tt = 0;
                                                    Tt < st.length;
                                                    Tt += 1
                                                ) {
                                                    var Et = st[Tt].dataCount,
                                                        At = st[Tt].totalCount - Et
                                                    ;(ht = Math.max(ht, Et)), (gt = Math.max(gt, At)), (pt[Tt] = new Array(Et))
                                                    for (var Ft = 0; Ft < pt[Tt].length; Ft += 1) pt[Tt][Ft] = 255 & rt.getBuffer()[Ft + ct]
                                                    ct += Et
                                                    var Ot = F.getErrorCorrectPolynomial(At),
                                                        Bt = R(pt[Tt], Ot.getLength() - 1).mod(Ot)
                                                    for (vt[Tt] = new Array(Ot.getLength() - 1), Ft = 0; Ft < vt[Tt].length; Ft += 1) {
                                                        var ke = Ft + Bt.getLength() - vt[Tt].length
                                                        vt[Tt][Ft] = ke >= 0 ? Bt.getAt(ke) : 0
                                                    }
                                                }
                                                var Vt = 0
                                                for (Ft = 0; Ft < st.length; Ft += 1) Vt += st[Ft].totalCount
                                                var Mt = new Array(Vt),
                                                    ge = 0
                                                for (Ft = 0; Ft < ht; Ft += 1)
                                                    for (Tt = 0; Tt < st.length; Tt += 1)
                                                        Ft < pt[Tt].length && ((Mt[ge] = pt[Tt][Ft]), (ge += 1))
                                                for (Ft = 0; Ft < gt; Ft += 1)
                                                    for (Tt = 0; Tt < st.length; Tt += 1)
                                                        Ft < vt[Tt].length && ((Mt[ge] = vt[Tt][Ft]), (ge += 1))
                                                return Mt
                                            })(q, G)
                                        }
                                    ;(p.addData = function (C, O) {
                                        var I = null
                                        switch ((O = O || "Byte")) {
                                            case "Numeric":
                                                I = J(C)
                                                break
                                            case "Alphanumeric":
                                                I = Q(C)
                                                break
                                            case "Byte":
                                                I = ot(C)
                                                break
                                            case "Kanji":
                                                I = it(C)
                                                break
                                            default:
                                                throw "mode:" + O
                                        }
                                        u.push(I), (g = null)
                                    }),
                                        (p.isDark = function (C, O) {
                                            if (C < 0 || v <= C || O < 0 || v <= O) throw C + "," + O
                                            return w[C][O]
                                        }),
                                        (p.getModuleCount = function () {
                                            return v
                                        }),
                                        (p.make = function () {
                                            if (_ < 1) {
                                                for (var C = 1; C < 40; C++) {
                                                    for (var O = W.getRSBlocks(C, A), I = nt(), G = 0; G < u.length; G++) {
                                                        var q = u[G]
                                                        I.put(q.getMode(), 4),
                                                            I.put(q.getLength(), F.getLengthInBits(q.getMode(), C)),
                                                            q.write(I)
                                                    }
                                                    var X = 0
                                                    for (G = 0; G < O.length; G++) X += O[G].dataCount
                                                    if (I.getLengthInBits() <= 8 * X) break
                                                }
                                                _ = C
                                            }
                                            H(
                                                !1,
                                                (function () {
                                                    for (var lt = 0, tt = 0, rt = 0; rt < 8; rt += 1) {
                                                        H(!0, rt)
                                                        var st = F.getLostPoint(p)
                                                        ;(rt == 0 || lt > st) && ((lt = st), (tt = rt))
                                                    }
                                                    return tt
                                                })()
                                            )
                                        }),
                                        (p.createTableTag = function (C, O) {
                                            C = C || 2
                                            var I = ""
                                            ;(I += '<table style="'),
                                                (I += " border-width: 0px; border-style: none;"),
                                                (I += " border-collapse: collapse;"),
                                                (I += " padding: 0px; margin: " + (O = O === void 0 ? 4 * C : O) + "px;"),
                                                (I += '">'),
                                                (I += "<tbody>")
                                            for (var G = 0; G < p.getModuleCount(); G += 1) {
                                                I += "<tr>"
                                                for (var q = 0; q < p.getModuleCount(); q += 1)
                                                    (I += '<td style="'),
                                                        (I += " border-width: 0px; border-style: none;"),
                                                        (I += " border-collapse: collapse;"),
                                                        (I += " padding: 0px; margin: 0px;"),
                                                        (I += " width: " + C + "px;"),
                                                        (I += " height: " + C + "px;"),
                                                        (I += " background-color: "),
                                                        (I += p.isDark(G, q) ? "#000000" : "#ffffff"),
                                                        (I += ";"),
                                                        (I += '"/>')
                                                I += "</tr>"
                                            }
                                            return (I += "</tbody>") + "</table>"
                                        }),
                                        (p.createSvgTag = function (C, O, I, G) {
                                            var q = {}
                                            typeof arguments[0] == "object" &&
                                                ((C = (q = arguments[0]).cellSize), (O = q.margin), (I = q.alt), (G = q.title)),
                                                (C = C || 2),
                                                (O = O === void 0 ? 4 * C : O),
                                                ((I = typeof I == "string" ? { text: I } : I || {}).text = I.text || null),
                                                (I.id = I.text ? I.id || "qrcode-description" : null),
                                                ((G = typeof G == "string" ? { text: G } : G || {}).text = G.text || null),
                                                (G.id = G.text ? G.id || "qrcode-title" : null)
                                            var X,
                                                lt,
                                                tt,
                                                rt,
                                                st = p.getModuleCount() * C + 2 * O,
                                                ct = ""
                                            for (
                                                rt = "l" + C + ",0 0," + C + " -" + C + ",0 0,-" + C + "z ",
                                                    ct += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                                                    ct += q.scalable ? "" : ' width="' + st + 'px" height="' + st + 'px"',
                                                    ct += ' viewBox="0 0 ' + st + " " + st + '" ',
                                                    ct += ' preserveAspectRatio="xMinYMin meet"',
                                                    ct +=
                                                        G.text || I.text
                                                            ? ' role="img" aria-labelledby="' + et([G.id, I.id].join(" ").trim()) + '"'
                                                            : "",
                                                    ct += ">",
                                                    ct += G.text ? '<title id="' + et(G.id) + '">' + et(G.text) + "</title>" : "",
                                                    ct += I.text ? '<description id="' + et(I.id) + '">' + et(I.text) + "</description>" : "",
                                                    ct += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                                                    ct += '<path d="',
                                                    lt = 0;
                                                lt < p.getModuleCount();
                                                lt += 1
                                            )
                                                for (tt = lt * C + O, X = 0; X < p.getModuleCount(); X += 1)
                                                    p.isDark(lt, X) && (ct += "M" + (X * C + O) + "," + tt + rt)
                                            return (ct += '" stroke="transparent" fill="black"/>') + "</svg>"
                                        }),
                                        (p.createDataURL = function (C, O) {
                                            ;(C = C || 2), (O = O === void 0 ? 4 * C : O)
                                            var I = p.getModuleCount() * C + 2 * O,
                                                G = O,
                                                q = I - O
                                            return a(I, I, function (X, lt) {
                                                if (G <= X && X < q && G <= lt && lt < q) {
                                                    var tt = Math.floor((X - G) / C),
                                                        rt = Math.floor((lt - G) / C)
                                                    return p.isDark(rt, tt) ? 0 : 1
                                                }
                                                return 1
                                            })
                                        }),
                                        (p.createImgTag = function (C, O, I) {
                                            ;(C = C || 2), (O = O === void 0 ? 4 * C : O)
                                            var G = p.getModuleCount() * C + 2 * O,
                                                q = ""
                                            return (
                                                (q += "<img"),
                                                (q += ' src="'),
                                                (q += p.createDataURL(C, O)),
                                                (q += '"'),
                                                (q += ' width="'),
                                                (q += G),
                                                (q += '"'),
                                                (q += ' height="'),
                                                (q += G),
                                                (q += '"'),
                                                I && ((q += ' alt="'), (q += et(I)), (q += '"')),
                                                q + "/>"
                                            )
                                        })
                                    var et = function (C) {
                                        for (var O = "", I = 0; I < C.length; I += 1) {
                                            var G = C.charAt(I)
                                            switch (G) {
                                                case "<":
                                                    O += "&lt;"
                                                    break
                                                case ">":
                                                    O += "&gt;"
                                                    break
                                                case "&":
                                                    O += "&amp;"
                                                    break
                                                case '"':
                                                    O += "&quot;"
                                                    break
                                                default:
                                                    O += G
                                            }
                                        }
                                        return O
                                    }
                                    return (
                                        (p.createASCII = function (C, O) {
                                            if ((C = C || 1) < 2)
                                                return (function (pt) {
                                                    pt = pt === void 0 ? 2 : pt
                                                    var vt,
                                                        Tt,
                                                        Et,
                                                        At,
                                                        Ft,
                                                        Ot = 1 * p.getModuleCount() + 2 * pt,
                                                        Bt = pt,
                                                        ke = Ot - pt,
                                                        Vt = { "\u2588\u2588": "\u2588", "\u2588 ": "\u2580", " \u2588": "\u2584", "  ": " " },
                                                        Mt = { "\u2588\u2588": "\u2580", "\u2588 ": "\u2580", " \u2588": " ", "  ": " " },
                                                        ge = ""
                                                    for (vt = 0; vt < Ot; vt += 2) {
                                                        for (
                                                            Et = Math.floor((vt - Bt) / 1), At = Math.floor((vt + 1 - Bt) / 1), Tt = 0;
                                                            Tt < Ot;
                                                            Tt += 1
                                                        )
                                                            (Ft = "\u2588"),
                                                                Bt <= Tt &&
                                                                    Tt < ke &&
                                                                    Bt <= vt &&
                                                                    vt < ke &&
                                                                    p.isDark(Et, Math.floor((Tt - Bt) / 1)) &&
                                                                    (Ft = " "),
                                                                Bt <= Tt &&
                                                                Tt < ke &&
                                                                Bt <= vt + 1 &&
                                                                vt + 1 < ke &&
                                                                p.isDark(At, Math.floor((Tt - Bt) / 1))
                                                                    ? (Ft += " ")
                                                                    : (Ft += "\u2588"),
                                                                (ge += pt < 1 && vt + 1 >= ke ? Mt[Ft] : Vt[Ft])
                                                        ge += `
`
                                                    }
                                                    return Ot % 2 && pt > 0
                                                        ? ge.substring(0, ge.length - Ot - 1) + Array(Ot + 1).join("\u2580")
                                                        : ge.substring(0, ge.length - 1)
                                                })(O)
                                            ;(C -= 1), (O = O === void 0 ? 2 * C : O)
                                            var I,
                                                G,
                                                q,
                                                X,
                                                lt = p.getModuleCount() * C + 2 * O,
                                                tt = O,
                                                rt = lt - O,
                                                st = Array(C + 1).join("\u2588\u2588"),
                                                ct = Array(C + 1).join("  "),
                                                ht = "",
                                                gt = ""
                                            for (I = 0; I < lt; I += 1) {
                                                for (q = Math.floor((I - tt) / C), gt = "", G = 0; G < lt; G += 1)
                                                    (X = 1),
                                                        tt <= G &&
                                                            G < rt &&
                                                            tt <= I &&
                                                            I < rt &&
                                                            p.isDark(q, Math.floor((G - tt) / C)) &&
                                                            (X = 0),
                                                        (gt += X ? st : ct)
                                                for (q = 0; q < C; q += 1)
                                                    ht +=
                                                        gt +
                                                        `
`
                                            }
                                            return ht.substring(0, ht.length - 1)
                                        }),
                                        (p.renderTo2dContext = function (C, O) {
                                            O = O || 2
                                            for (var I = p.getModuleCount(), G = 0; G < I; G++)
                                                for (var q = 0; q < I; q++)
                                                    (C.fillStyle = p.isDark(G, q) ? "black" : "white"), C.fillRect(G * O, q * O, O, O)
                                        }),
                                        p
                                    )
                                }
                                ;(E.stringToBytes = (E.stringToBytesFuncs = {
                                    default: function (c) {
                                        for (var m = [], _ = 0; _ < c.length; _ += 1) {
                                            var A = c.charCodeAt(_)
                                            m.push(255 & A)
                                        }
                                        return m
                                    },
                                }).default),
                                    (E.createStringToBytes = function (c, m) {
                                        var _ = (function () {
                                                for (
                                                    var w = x(c),
                                                        v = function () {
                                                            var B = w.read()
                                                            if (B == -1) throw "eof"
                                                            return B
                                                        },
                                                        g = 0,
                                                        u = {};
                                                    ;

                                                ) {
                                                    var p = w.read()
                                                    if (p == -1) break
                                                    var H = v(),
                                                        b = (v() << 8) | v()
                                                    ;(u[String.fromCharCode((p << 8) | H)] = b), (g += 1)
                                                }
                                                if (g != m) throw g + " != " + m
                                                return u
                                            })(),
                                            A = "?".charCodeAt(0)
                                        return function (w) {
                                            for (var v = [], g = 0; g < w.length; g += 1) {
                                                var u = w.charCodeAt(g)
                                                if (u < 128) v.push(u)
                                                else {
                                                    var p = _[w.charAt(g)]
                                                    typeof p == "number"
                                                        ? (255 & p) == p
                                                            ? v.push(p)
                                                            : (v.push(p >>> 8), v.push(255 & p))
                                                        : v.push(A)
                                                }
                                            }
                                            return v
                                        }
                                    })
                                var T,
                                    S,
                                    N,
                                    P,
                                    M,
                                    k = { L: 1, M: 0, Q: 3, H: 2 },
                                    F =
                                        ((T = [
                                            [],
                                            [6, 18],
                                            [6, 22],
                                            [6, 26],
                                            [6, 30],
                                            [6, 34],
                                            [6, 22, 38],
                                            [6, 24, 42],
                                            [6, 26, 46],
                                            [6, 28, 50],
                                            [6, 30, 54],
                                            [6, 32, 58],
                                            [6, 34, 62],
                                            [6, 26, 46, 66],
                                            [6, 26, 48, 70],
                                            [6, 26, 50, 74],
                                            [6, 30, 54, 78],
                                            [6, 30, 56, 82],
                                            [6, 30, 58, 86],
                                            [6, 34, 62, 90],
                                            [6, 28, 50, 72, 94],
                                            [6, 26, 50, 74, 98],
                                            [6, 30, 54, 78, 102],
                                            [6, 28, 54, 80, 106],
                                            [6, 32, 58, 84, 110],
                                            [6, 30, 58, 86, 114],
                                            [6, 34, 62, 90, 118],
                                            [6, 26, 50, 74, 98, 122],
                                            [6, 30, 54, 78, 102, 126],
                                            [6, 26, 52, 78, 104, 130],
                                            [6, 30, 56, 82, 108, 134],
                                            [6, 34, 60, 86, 112, 138],
                                            [6, 30, 58, 86, 114, 142],
                                            [6, 34, 62, 90, 118, 146],
                                            [6, 30, 54, 78, 102, 126, 150],
                                            [6, 24, 50, 76, 102, 128, 154],
                                            [6, 28, 54, 80, 106, 132, 158],
                                            [6, 32, 58, 84, 110, 136, 162],
                                            [6, 26, 54, 82, 110, 138, 166],
                                            [6, 30, 58, 86, 114, 142, 170],
                                        ]),
                                        (S = 1335),
                                        (N = 7973),
                                        (M = function (c) {
                                            for (var m = 0; c != 0; ) (m += 1), (c >>>= 1)
                                            return m
                                        }),
                                        ((P = {}).getBCHTypeInfo = function (c) {
                                            for (var m = c << 10; M(m) - M(S) >= 0; ) m ^= S << (M(m) - M(S))
                                            return 21522 ^ ((c << 10) | m)
                                        }),
                                        (P.getBCHTypeNumber = function (c) {
                                            for (var m = c << 12; M(m) - M(N) >= 0; ) m ^= N << (M(m) - M(N))
                                            return (c << 12) | m
                                        }),
                                        (P.getPatternPosition = function (c) {
                                            return T[c - 1]
                                        }),
                                        (P.getMaskFunction = function (c) {
                                            switch (c) {
                                                case 0:
                                                    return function (m, _) {
                                                        return (m + _) % 2 == 0
                                                    }
                                                case 1:
                                                    return function (m, _) {
                                                        return m % 2 == 0
                                                    }
                                                case 2:
                                                    return function (m, _) {
                                                        return _ % 3 == 0
                                                    }
                                                case 3:
                                                    return function (m, _) {
                                                        return (m + _) % 3 == 0
                                                    }
                                                case 4:
                                                    return function (m, _) {
                                                        return (Math.floor(m / 2) + Math.floor(_ / 3)) % 2 == 0
                                                    }
                                                case 5:
                                                    return function (m, _) {
                                                        return ((m * _) % 2) + ((m * _) % 3) == 0
                                                    }
                                                case 6:
                                                    return function (m, _) {
                                                        return (((m * _) % 2) + ((m * _) % 3)) % 2 == 0
                                                    }
                                                case 7:
                                                    return function (m, _) {
                                                        return (((m * _) % 3) + ((m + _) % 2)) % 2 == 0
                                                    }
                                                default:
                                                    throw "bad maskPattern:" + c
                                            }
                                        }),
                                        (P.getErrorCorrectPolynomial = function (c) {
                                            for (var m = R([1], 0), _ = 0; _ < c; _ += 1) m = m.multiply(R([1, $.gexp(_)], 0))
                                            return m
                                        }),
                                        (P.getLengthInBits = function (c, m) {
                                            if (1 <= m && m < 10)
                                                switch (c) {
                                                    case 1:
                                                        return 10
                                                    case 2:
                                                        return 9
                                                    case 4:
                                                    case 8:
                                                        return 8
                                                    default:
                                                        throw "mode:" + c
                                                }
                                            else if (m < 27)
                                                switch (c) {
                                                    case 1:
                                                        return 12
                                                    case 2:
                                                        return 11
                                                    case 4:
                                                        return 16
                                                    case 8:
                                                        return 10
                                                    default:
                                                        throw "mode:" + c
                                                }
                                            else {
                                                if (!(m < 41)) throw "type:" + m
                                                switch (c) {
                                                    case 1:
                                                        return 14
                                                    case 2:
                                                        return 13
                                                    case 4:
                                                        return 16
                                                    case 8:
                                                        return 12
                                                    default:
                                                        throw "mode:" + c
                                                }
                                            }
                                        }),
                                        (P.getLostPoint = function (c) {
                                            for (var m = c.getModuleCount(), _ = 0, A = 0; A < m; A += 1)
                                                for (var w = 0; w < m; w += 1) {
                                                    for (var v = 0, g = c.isDark(A, w), u = -1; u <= 1; u += 1)
                                                        if (!(A + u < 0 || m <= A + u))
                                                            for (var p = -1; p <= 1; p += 1)
                                                                w + p < 0 ||
                                                                    m <= w + p ||
                                                                    (u == 0 && p == 0) ||
                                                                    (g == c.isDark(A + u, w + p) && (v += 1))
                                                    v > 5 && (_ += 3 + v - 5)
                                                }
                                            for (A = 0; A < m - 1; A += 1)
                                                for (w = 0; w < m - 1; w += 1) {
                                                    var H = 0
                                                    c.isDark(A, w) && (H += 1),
                                                        c.isDark(A + 1, w) && (H += 1),
                                                        c.isDark(A, w + 1) && (H += 1),
                                                        c.isDark(A + 1, w + 1) && (H += 1),
                                                        (H != 0 && H != 4) || (_ += 3)
                                                }
                                            for (A = 0; A < m; A += 1)
                                                for (w = 0; w < m - 6; w += 1)
                                                    c.isDark(A, w) &&
                                                        !c.isDark(A, w + 1) &&
                                                        c.isDark(A, w + 2) &&
                                                        c.isDark(A, w + 3) &&
                                                        c.isDark(A, w + 4) &&
                                                        !c.isDark(A, w + 5) &&
                                                        c.isDark(A, w + 6) &&
                                                        (_ += 40)
                                            for (w = 0; w < m; w += 1)
                                                for (A = 0; A < m - 6; A += 1)
                                                    c.isDark(A, w) &&
                                                        !c.isDark(A + 1, w) &&
                                                        c.isDark(A + 2, w) &&
                                                        c.isDark(A + 3, w) &&
                                                        c.isDark(A + 4, w) &&
                                                        !c.isDark(A + 5, w) &&
                                                        c.isDark(A + 6, w) &&
                                                        (_ += 40)
                                            var b = 0
                                            for (w = 0; w < m; w += 1) for (A = 0; A < m; A += 1) c.isDark(A, w) && (b += 1)
                                            return _ + (Math.abs((100 * b) / m / m - 50) / 5) * 10
                                        }),
                                        P),
                                    $ = (function () {
                                        for (var c = new Array(256), m = new Array(256), _ = 0; _ < 8; _ += 1) c[_] = 1 << _
                                        for (_ = 8; _ < 256; _ += 1) c[_] = c[_ - 4] ^ c[_ - 5] ^ c[_ - 6] ^ c[_ - 8]
                                        for (_ = 0; _ < 255; _ += 1) m[c[_]] = _
                                        return {
                                            glog: function (A) {
                                                if (A < 1) throw "glog(" + A + ")"
                                                return m[A]
                                            },
                                            gexp: function (A) {
                                                for (; A < 0; ) A += 255
                                                for (; A >= 256; ) A -= 255
                                                return c[A]
                                            },
                                        }
                                    })()
                                function R(c, m) {
                                    if (c.length === void 0) throw c.length + "/" + m
                                    var _ = (function () {
                                            for (var w = 0; w < c.length && c[w] == 0; ) w += 1
                                            for (var v = new Array(c.length - w + m), g = 0; g < c.length - w; g += 1) v[g] = c[g + w]
                                            return v
                                        })(),
                                        A = {
                                            getAt: function (w) {
                                                return _[w]
                                            },
                                            getLength: function () {
                                                return _.length
                                            },
                                            multiply: function (w) {
                                                for (var v = new Array(A.getLength() + w.getLength() - 1), g = 0; g < A.getLength(); g += 1)
                                                    for (var u = 0; u < w.getLength(); u += 1)
                                                        v[g + u] ^= $.gexp($.glog(A.getAt(g)) + $.glog(w.getAt(u)))
                                                return R(v, 0)
                                            },
                                            mod: function (w) {
                                                if (A.getLength() - w.getLength() < 0) return A
                                                for (
                                                    var v = $.glog(A.getAt(0)) - $.glog(w.getAt(0)), g = new Array(A.getLength()), u = 0;
                                                    u < A.getLength();
                                                    u += 1
                                                )
                                                    g[u] = A.getAt(u)
                                                for (u = 0; u < w.getLength(); u += 1) g[u] ^= $.gexp($.glog(w.getAt(u)) + v)
                                                return R(g, 0).mod(w)
                                            },
                                        }
                                    return A
                                }
                                var W = (function () {
                                        var c = [
                                                [1, 26, 19],
                                                [1, 26, 16],
                                                [1, 26, 13],
                                                [1, 26, 9],
                                                [1, 44, 34],
                                                [1, 44, 28],
                                                [1, 44, 22],
                                                [1, 44, 16],
                                                [1, 70, 55],
                                                [1, 70, 44],
                                                [2, 35, 17],
                                                [2, 35, 13],
                                                [1, 100, 80],
                                                [2, 50, 32],
                                                [2, 50, 24],
                                                [4, 25, 9],
                                                [1, 134, 108],
                                                [2, 67, 43],
                                                [2, 33, 15, 2, 34, 16],
                                                [2, 33, 11, 2, 34, 12],
                                                [2, 86, 68],
                                                [4, 43, 27],
                                                [4, 43, 19],
                                                [4, 43, 15],
                                                [2, 98, 78],
                                                [4, 49, 31],
                                                [2, 32, 14, 4, 33, 15],
                                                [4, 39, 13, 1, 40, 14],
                                                [2, 121, 97],
                                                [2, 60, 38, 2, 61, 39],
                                                [4, 40, 18, 2, 41, 19],
                                                [4, 40, 14, 2, 41, 15],
                                                [2, 146, 116],
                                                [3, 58, 36, 2, 59, 37],
                                                [4, 36, 16, 4, 37, 17],
                                                [4, 36, 12, 4, 37, 13],
                                                [2, 86, 68, 2, 87, 69],
                                                [4, 69, 43, 1, 70, 44],
                                                [6, 43, 19, 2, 44, 20],
                                                [6, 43, 15, 2, 44, 16],
                                                [4, 101, 81],
                                                [1, 80, 50, 4, 81, 51],
                                                [4, 50, 22, 4, 51, 23],
                                                [3, 36, 12, 8, 37, 13],
                                                [2, 116, 92, 2, 117, 93],
                                                [6, 58, 36, 2, 59, 37],
                                                [4, 46, 20, 6, 47, 21],
                                                [7, 42, 14, 4, 43, 15],
                                                [4, 133, 107],
                                                [8, 59, 37, 1, 60, 38],
                                                [8, 44, 20, 4, 45, 21],
                                                [12, 33, 11, 4, 34, 12],
                                                [3, 145, 115, 1, 146, 116],
                                                [4, 64, 40, 5, 65, 41],
                                                [11, 36, 16, 5, 37, 17],
                                                [11, 36, 12, 5, 37, 13],
                                                [5, 109, 87, 1, 110, 88],
                                                [5, 65, 41, 5, 66, 42],
                                                [5, 54, 24, 7, 55, 25],
                                                [11, 36, 12, 7, 37, 13],
                                                [5, 122, 98, 1, 123, 99],
                                                [7, 73, 45, 3, 74, 46],
                                                [15, 43, 19, 2, 44, 20],
                                                [3, 45, 15, 13, 46, 16],
                                                [1, 135, 107, 5, 136, 108],
                                                [10, 74, 46, 1, 75, 47],
                                                [1, 50, 22, 15, 51, 23],
                                                [2, 42, 14, 17, 43, 15],
                                                [5, 150, 120, 1, 151, 121],
                                                [9, 69, 43, 4, 70, 44],
                                                [17, 50, 22, 1, 51, 23],
                                                [2, 42, 14, 19, 43, 15],
                                                [3, 141, 113, 4, 142, 114],
                                                [3, 70, 44, 11, 71, 45],
                                                [17, 47, 21, 4, 48, 22],
                                                [9, 39, 13, 16, 40, 14],
                                                [3, 135, 107, 5, 136, 108],
                                                [3, 67, 41, 13, 68, 42],
                                                [15, 54, 24, 5, 55, 25],
                                                [15, 43, 15, 10, 44, 16],
                                                [4, 144, 116, 4, 145, 117],
                                                [17, 68, 42],
                                                [17, 50, 22, 6, 51, 23],
                                                [19, 46, 16, 6, 47, 17],
                                                [2, 139, 111, 7, 140, 112],
                                                [17, 74, 46],
                                                [7, 54, 24, 16, 55, 25],
                                                [34, 37, 13],
                                                [4, 151, 121, 5, 152, 122],
                                                [4, 75, 47, 14, 76, 48],
                                                [11, 54, 24, 14, 55, 25],
                                                [16, 45, 15, 14, 46, 16],
                                                [6, 147, 117, 4, 148, 118],
                                                [6, 73, 45, 14, 74, 46],
                                                [11, 54, 24, 16, 55, 25],
                                                [30, 46, 16, 2, 47, 17],
                                                [8, 132, 106, 4, 133, 107],
                                                [8, 75, 47, 13, 76, 48],
                                                [7, 54, 24, 22, 55, 25],
                                                [22, 45, 15, 13, 46, 16],
                                                [10, 142, 114, 2, 143, 115],
                                                [19, 74, 46, 4, 75, 47],
                                                [28, 50, 22, 6, 51, 23],
                                                [33, 46, 16, 4, 47, 17],
                                                [8, 152, 122, 4, 153, 123],
                                                [22, 73, 45, 3, 74, 46],
                                                [8, 53, 23, 26, 54, 24],
                                                [12, 45, 15, 28, 46, 16],
                                                [3, 147, 117, 10, 148, 118],
                                                [3, 73, 45, 23, 74, 46],
                                                [4, 54, 24, 31, 55, 25],
                                                [11, 45, 15, 31, 46, 16],
                                                [7, 146, 116, 7, 147, 117],
                                                [21, 73, 45, 7, 74, 46],
                                                [1, 53, 23, 37, 54, 24],
                                                [19, 45, 15, 26, 46, 16],
                                                [5, 145, 115, 10, 146, 116],
                                                [19, 75, 47, 10, 76, 48],
                                                [15, 54, 24, 25, 55, 25],
                                                [23, 45, 15, 25, 46, 16],
                                                [13, 145, 115, 3, 146, 116],
                                                [2, 74, 46, 29, 75, 47],
                                                [42, 54, 24, 1, 55, 25],
                                                [23, 45, 15, 28, 46, 16],
                                                [17, 145, 115],
                                                [10, 74, 46, 23, 75, 47],
                                                [10, 54, 24, 35, 55, 25],
                                                [19, 45, 15, 35, 46, 16],
                                                [17, 145, 115, 1, 146, 116],
                                                [14, 74, 46, 21, 75, 47],
                                                [29, 54, 24, 19, 55, 25],
                                                [11, 45, 15, 46, 46, 16],
                                                [13, 145, 115, 6, 146, 116],
                                                [14, 74, 46, 23, 75, 47],
                                                [44, 54, 24, 7, 55, 25],
                                                [59, 46, 16, 1, 47, 17],
                                                [12, 151, 121, 7, 152, 122],
                                                [12, 75, 47, 26, 76, 48],
                                                [39, 54, 24, 14, 55, 25],
                                                [22, 45, 15, 41, 46, 16],
                                                [6, 151, 121, 14, 152, 122],
                                                [6, 75, 47, 34, 76, 48],
                                                [46, 54, 24, 10, 55, 25],
                                                [2, 45, 15, 64, 46, 16],
                                                [17, 152, 122, 4, 153, 123],
                                                [29, 74, 46, 14, 75, 47],
                                                [49, 54, 24, 10, 55, 25],
                                                [24, 45, 15, 46, 46, 16],
                                                [4, 152, 122, 18, 153, 123],
                                                [13, 74, 46, 32, 75, 47],
                                                [48, 54, 24, 14, 55, 25],
                                                [42, 45, 15, 32, 46, 16],
                                                [20, 147, 117, 4, 148, 118],
                                                [40, 75, 47, 7, 76, 48],
                                                [43, 54, 24, 22, 55, 25],
                                                [10, 45, 15, 67, 46, 16],
                                                [19, 148, 118, 6, 149, 119],
                                                [18, 75, 47, 31, 76, 48],
                                                [34, 54, 24, 34, 55, 25],
                                                [20, 45, 15, 61, 46, 16],
                                            ],
                                            m = function (A, w) {
                                                var v = {}
                                                return (v.totalCount = A), (v.dataCount = w), v
                                            },
                                            _ = {
                                                getRSBlocks: function (A, w) {
                                                    var v = (function (U, j) {
                                                        switch (j) {
                                                            case k.L:
                                                                return c[4 * (U - 1) + 0]
                                                            case k.M:
                                                                return c[4 * (U - 1) + 1]
                                                            case k.Q:
                                                                return c[4 * (U - 1) + 2]
                                                            case k.H:
                                                                return c[4 * (U - 1) + 3]
                                                            default:
                                                                return
                                                        }
                                                    })(A, w)
                                                    if (v === void 0) throw "bad rs block @ typeNumber:" + A + "/errorCorrectionLevel:" + w
                                                    for (var g = v.length / 3, u = [], p = 0; p < g; p += 1)
                                                        for (var H = v[3 * p + 0], b = v[3 * p + 1], B = v[3 * p + 2], D = 0; D < H; D += 1)
                                                            u.push(m(b, B))
                                                    return u
                                                },
                                            }
                                        return _
                                    })(),
                                    nt = function () {
                                        var c = [],
                                            m = 0,
                                            _ = {
                                                getBuffer: function () {
                                                    return c
                                                },
                                                getAt: function (A) {
                                                    var w = Math.floor(A / 8)
                                                    return ((c[w] >>> (7 - (A % 8))) & 1) == 1
                                                },
                                                put: function (A, w) {
                                                    for (var v = 0; v < w; v += 1) _.putBit(((A >>> (w - v - 1)) & 1) == 1)
                                                },
                                                getLengthInBits: function () {
                                                    return m
                                                },
                                                putBit: function (A) {
                                                    var w = Math.floor(m / 8)
                                                    c.length <= w && c.push(0), A && (c[w] |= 128 >>> m % 8), (m += 1)
                                                },
                                            }
                                        return _
                                    },
                                    J = function (c) {
                                        var m = c,
                                            _ = {
                                                getMode: function () {
                                                    return 1
                                                },
                                                getLength: function (v) {
                                                    return m.length
                                                },
                                                write: function (v) {
                                                    for (var g = m, u = 0; u + 2 < g.length; ) v.put(A(g.substring(u, u + 3)), 10), (u += 3)
                                                    u < g.length &&
                                                        (g.length - u == 1
                                                            ? v.put(A(g.substring(u, u + 1)), 4)
                                                            : g.length - u == 2 && v.put(A(g.substring(u, u + 2)), 7))
                                                },
                                            },
                                            A = function (v) {
                                                for (var g = 0, u = 0; u < v.length; u += 1) g = 10 * g + w(v.charAt(u))
                                                return g
                                            },
                                            w = function (v) {
                                                if ("0" <= v && v <= "9") return v.charCodeAt(0) - "0".charCodeAt(0)
                                                throw "illegal char :" + v
                                            }
                                        return _
                                    },
                                    Q = function (c) {
                                        var m = c,
                                            _ = {
                                                getMode: function () {
                                                    return 2
                                                },
                                                getLength: function (w) {
                                                    return m.length
                                                },
                                                write: function (w) {
                                                    for (var v = m, g = 0; g + 1 < v.length; )
                                                        w.put(45 * A(v.charAt(g)) + A(v.charAt(g + 1)), 11), (g += 2)
                                                    g < v.length && w.put(A(v.charAt(g)), 6)
                                                },
                                            },
                                            A = function (w) {
                                                if ("0" <= w && w <= "9") return w.charCodeAt(0) - "0".charCodeAt(0)
                                                if ("A" <= w && w <= "Z") return w.charCodeAt(0) - "A".charCodeAt(0) + 10
                                                switch (w) {
                                                    case " ":
                                                        return 36
                                                    case "$":
                                                        return 37
                                                    case "%":
                                                        return 38
                                                    case "*":
                                                        return 39
                                                    case "+":
                                                        return 40
                                                    case "-":
                                                        return 41
                                                    case ".":
                                                        return 42
                                                    case "/":
                                                        return 43
                                                    case ":":
                                                        return 44
                                                    default:
                                                        throw "illegal char :" + w
                                                }
                                            }
                                        return _
                                    },
                                    ot = function (c) {
                                        var m = E.stringToBytes(c)
                                        return {
                                            getMode: function () {
                                                return 4
                                            },
                                            getLength: function (_) {
                                                return m.length
                                            },
                                            write: function (_) {
                                                for (var A = 0; A < m.length; A += 1) _.put(m[A], 8)
                                            },
                                        }
                                    },
                                    it = function (c) {
                                        var m = E.stringToBytesFuncs.SJIS
                                        if (!m) throw "sjis not supported."
                                        ;(function (A, w) {
                                            var v = m("\u53CB")
                                            if (v.length != 2 || ((v[0] << 8) | v[1]) != 38726) throw "sjis not supported."
                                        })()
                                        var _ = m(c)
                                        return {
                                            getMode: function () {
                                                return 8
                                            },
                                            getLength: function (A) {
                                                return ~~(_.length / 2)
                                            },
                                            write: function (A) {
                                                for (var w = _, v = 0; v + 1 < w.length; ) {
                                                    var g = ((255 & w[v]) << 8) | (255 & w[v + 1])
                                                    if (33088 <= g && g <= 40956) g -= 33088
                                                    else {
                                                        if (!(57408 <= g && g <= 60351)) throw "illegal char at " + (v + 1) + "/" + g
                                                        g -= 49472
                                                    }
                                                    ;(g = 192 * ((g >>> 8) & 255) + (255 & g)), A.put(g, 13), (v += 2)
                                                }
                                                if (v < w.length) throw "illegal char at " + (v + 1)
                                            },
                                        }
                                    },
                                    at = function () {
                                        var c = [],
                                            m = {
                                                writeByte: function (_) {
                                                    c.push(255 & _)
                                                },
                                                writeShort: function (_) {
                                                    m.writeByte(_), m.writeByte(_ >>> 8)
                                                },
                                                writeBytes: function (_, A, w) {
                                                    ;(A = A || 0), (w = w || _.length)
                                                    for (var v = 0; v < w; v += 1) m.writeByte(_[v + A])
                                                },
                                                writeString: function (_) {
                                                    for (var A = 0; A < _.length; A += 1) m.writeByte(_.charCodeAt(A))
                                                },
                                                toByteArray: function () {
                                                    return c
                                                },
                                                toString: function () {
                                                    var _ = ""
                                                    _ += "["
                                                    for (var A = 0; A < c.length; A += 1) A > 0 && (_ += ","), (_ += c[A])
                                                    return _ + "]"
                                                },
                                            }
                                        return m
                                    },
                                    x = function (c) {
                                        var m = c,
                                            _ = 0,
                                            A = 0,
                                            w = 0,
                                            v = {
                                                read: function () {
                                                    for (; w < 8; ) {
                                                        if (_ >= m.length) {
                                                            if (w == 0) return -1
                                                            throw "unexpected end of file./" + w
                                                        }
                                                        var u = m.charAt(_)
                                                        if (((_ += 1), u == "=")) return (w = 0), -1
                                                        u.match(/^\s$/) || ((A = (A << 6) | g(u.charCodeAt(0))), (w += 6))
                                                    }
                                                    var p = (A >>> (w - 8)) & 255
                                                    return (w -= 8), p
                                                },
                                            },
                                            g = function (u) {
                                                if (65 <= u && u <= 90) return u - 65
                                                if (97 <= u && u <= 122) return u - 97 + 26
                                                if (48 <= u && u <= 57) return u - 48 + 52
                                                if (u == 43) return 62
                                                if (u == 47) return 63
                                                throw "c:" + u
                                            }
                                        return v
                                    },
                                    a = function (c, m, _) {
                                        for (
                                            var A = (function (b, B) {
                                                    var D = b,
                                                        U = B,
                                                        j = new Array(b * B),
                                                        dt = {
                                                            setPixel: function (C, O, I) {
                                                                j[O * D + C] = I
                                                            },
                                                            write: function (C) {
                                                                C.writeString("GIF87a"),
                                                                    C.writeShort(D),
                                                                    C.writeShort(U),
                                                                    C.writeByte(128),
                                                                    C.writeByte(0),
                                                                    C.writeByte(0),
                                                                    C.writeByte(0),
                                                                    C.writeByte(0),
                                                                    C.writeByte(0),
                                                                    C.writeByte(255),
                                                                    C.writeByte(255),
                                                                    C.writeByte(255),
                                                                    C.writeString(","),
                                                                    C.writeShort(0),
                                                                    C.writeShort(0),
                                                                    C.writeShort(D),
                                                                    C.writeShort(U),
                                                                    C.writeByte(0)
                                                                var O = Z(2)
                                                                C.writeByte(2)
                                                                for (var I = 0; O.length - I > 255; )
                                                                    C.writeByte(255), C.writeBytes(O, I, 255), (I += 255)
                                                                C.writeByte(O.length - I),
                                                                    C.writeBytes(O, I, O.length - I),
                                                                    C.writeByte(0),
                                                                    C.writeString(";")
                                                            },
                                                        },
                                                        Z = function (C) {
                                                            for (var O = 1 << C, I = 1 + (1 << C), G = C + 1, q = et(), X = 0; X < O; X += 1)
                                                                q.add(String.fromCharCode(X))
                                                            q.add(String.fromCharCode(O)), q.add(String.fromCharCode(I))
                                                            var lt,
                                                                tt,
                                                                rt,
                                                                st = at(),
                                                                ct =
                                                                    ((lt = st),
                                                                    (tt = 0),
                                                                    (rt = 0),
                                                                    {
                                                                        write: function (vt, Tt) {
                                                                            if (vt >>> Tt != 0) throw "length over"
                                                                            for (; tt + Tt >= 8; )
                                                                                lt.writeByte(255 & ((vt << tt) | rt)),
                                                                                    (Tt -= 8 - tt),
                                                                                    (vt >>>= 8 - tt),
                                                                                    (rt = 0),
                                                                                    (tt = 0)
                                                                            ;(rt |= vt << tt), (tt += Tt)
                                                                        },
                                                                        flush: function () {
                                                                            tt > 0 && lt.writeByte(rt)
                                                                        },
                                                                    })
                                                            ct.write(O, G)
                                                            var ht = 0,
                                                                gt = String.fromCharCode(j[ht])
                                                            for (ht += 1; ht < j.length; ) {
                                                                var pt = String.fromCharCode(j[ht])
                                                                ;(ht += 1),
                                                                    q.contains(gt + pt)
                                                                        ? (gt += pt)
                                                                        : (ct.write(q.indexOf(gt), G),
                                                                          q.size() < 4095 && (q.size() == 1 << G && (G += 1), q.add(gt + pt)),
                                                                          (gt = pt))
                                                            }
                                                            return ct.write(q.indexOf(gt), G), ct.write(I, G), ct.flush(), st.toByteArray()
                                                        },
                                                        et = function () {
                                                            var C = {},
                                                                O = 0,
                                                                I = {
                                                                    add: function (G) {
                                                                        if (I.contains(G)) throw "dup key:" + G
                                                                        ;(C[G] = O), (O += 1)
                                                                    },
                                                                    size: function () {
                                                                        return O
                                                                    },
                                                                    indexOf: function (G) {
                                                                        return C[G]
                                                                    },
                                                                    contains: function (G) {
                                                                        return C[G] !== void 0
                                                                    },
                                                                }
                                                            return I
                                                        }
                                                    return dt
                                                })(c, m),
                                                w = 0;
                                            w < m;
                                            w += 1
                                        )
                                            for (var v = 0; v < c; v += 1) A.setPixel(v, w, _(v, w))
                                        var g = at()
                                        A.write(g)
                                        for (
                                            var u = (function () {
                                                    var b = 0,
                                                        B = 0,
                                                        D = 0,
                                                        U = "",
                                                        j = {},
                                                        dt = function (et) {
                                                            U += String.fromCharCode(Z(63 & et))
                                                        },
                                                        Z = function (et) {
                                                            if (!(et < 0)) {
                                                                if (et < 26) return 65 + et
                                                                if (et < 52) return et - 26 + 97
                                                                if (et < 62) return et - 52 + 48
                                                                if (et == 62) return 43
                                                                if (et == 63) return 47
                                                            }
                                                            throw "n:" + et
                                                        }
                                                    return (
                                                        (j.writeByte = function (et) {
                                                            for (b = (b << 8) | (255 & et), B += 8, D += 1; B >= 6; ) dt(b >>> (B - 6)), (B -= 6)
                                                        }),
                                                        (j.flush = function () {
                                                            if ((B > 0 && (dt(b << (6 - B)), (b = 0), (B = 0)), D % 3 != 0))
                                                                for (var et = 3 - (D % 3), C = 0; C < et; C += 1) U += "="
                                                        }),
                                                        (j.toString = function () {
                                                            return U
                                                        }),
                                                        j
                                                    )
                                                })(),
                                                p = g.toByteArray(),
                                                H = 0;
                                            H < p.length;
                                            H += 1
                                        )
                                            u.writeByte(p[H])
                                        return u.flush(), "data:image/gif;base64," + u
                                    }
                                return E
                            })()
                        ;(y.stringToBytesFuncs["UTF-8"] = function (E) {
                            return (function (T) {
                                for (var S = [], N = 0; N < T.length; N++) {
                                    var P = T.charCodeAt(N)
                                    P < 128
                                        ? S.push(P)
                                        : P < 2048
                                        ? S.push(192 | (P >> 6), 128 | (63 & P))
                                        : P < 55296 || P >= 57344
                                        ? S.push(224 | (P >> 12), 128 | ((P >> 6) & 63), 128 | (63 & P))
                                        : (N++,
                                          (P = 65536 + (((1023 & P) << 10) | (1023 & T.charCodeAt(N)))),
                                          S.push(240 | (P >> 18), 128 | ((P >> 12) & 63), 128 | ((P >> 6) & 63), 128 | (63 & P)))
                                }
                                return S
                            })(E)
                        }),
                            (h =
                                typeof (d = function () {
                                    return y
                                }) == "function"
                                    ? d.apply(f, [])
                                    : d) === void 0 || (l.exports = h)
                    },
                    103: (l) => {
                        l.exports = r
                    },
                },
                i = {}
            function s(l) {
                var f = i[l]
                if (f !== void 0) return f.exports
                var d = (i[l] = { exports: {} })
                return n[l](d, d.exports, s), d.exports
            }
            ;(s.n = (l) => {
                var f = l && l.__esModule ? () => l.default : () => l
                return s.d(f, { a: f }), f
            }),
                (s.d = (l, f) => {
                    for (var d in f) s.o(f, d) && !s.o(l, d) && Object.defineProperty(l, d, { enumerable: !0, get: f[d] })
                }),
                (s.o = (l, f) => Object.prototype.hasOwnProperty.call(l, f))
            var o = {}
            return (
                (() => {
                    s.d(o, { default: () => A })
                    var l = s(103)
                    const f = { key: 1 }
                    var d = function () {
                            return (d =
                                Object.assign ||
                                function (w) {
                                    for (var v, g = 1, u = arguments.length; g < u; g++)
                                        for (var p in (v = arguments[g])) Object.prototype.hasOwnProperty.call(v, p) && (w[p] = v[p])
                                    return w
                                }).apply(this, arguments)
                        },
                        h = function (w, v) {
                            for (var g = 0, u = v.length, p = w.length; g < u; g++, p++) w[p] = v[g]
                            return w
                        },
                        y = function (w) {
                            return !!w && typeof w == "object" && !Array.isArray(w)
                        }
                    function E(w) {
                        for (var v = [], g = 1; g < arguments.length; g++) v[g - 1] = arguments[g]
                        if (!v.length) return w
                        var u = v.shift()
                        return u !== void 0 && y(w) && y(u)
                            ? ((w = d({}, w)),
                              Object.keys(u).forEach(function (p) {
                                  var H = w[p],
                                      b = u[p]
                                  Array.isArray(H) && Array.isArray(b)
                                      ? (w[p] = b)
                                      : y(H) && y(b)
                                      ? (w[p] = E(Object.assign({}, H), b))
                                      : (w[p] = b)
                              }),
                              E.apply(void 0, h([w], v)))
                            : w
                    }
                    const T = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 }
                    var S = function () {
                        return (S =
                            Object.assign ||
                            function (w) {
                                for (var v, g = 1, u = arguments.length; g < u; g++)
                                    for (var p in (v = arguments[g])) Object.prototype.hasOwnProperty.call(v, p) && (w[p] = v[p])
                                return w
                            }).apply(this, arguments)
                    }
                    const N = (function () {
                        function w(v) {
                            var g = v.context,
                                u = v.type
                            ;(this._context = g), (this._type = u)
                        }
                        return (
                            (w.prototype.draw = function (v, g, u, p) {
                                var H,
                                    b = this._context
                                switch (this._type) {
                                    case "dots":
                                        H = this._drawDot
                                        break
                                    case "classy":
                                        H = this._drawClassy
                                        break
                                    case "classy-rounded":
                                        H = this._drawClassyRounded
                                        break
                                    case "rounded":
                                        H = this._drawRounded
                                        break
                                    case "extra-rounded":
                                        H = this._drawExtraRounded
                                        break
                                    case "square":
                                    default:
                                        H = this._drawSquare
                                }
                                H.call(this, { x: v, y: g, size: u, context: b, getNeighbor: p })
                            }),
                            (w.prototype._rotateFigure = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation,
                                    B = v.draw,
                                    D = g + p / 2,
                                    U = u + p / 2
                                H.translate(D, U), b && H.rotate(b), B(), H.closePath(), b && H.rotate(-b), H.translate(-D, -U)
                            }),
                            (w.prototype._basicDot = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicSquare = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.rect(-g / 2, -g / 2, g, g)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicSideRounded = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, -Math.PI / 2, Math.PI / 2),
                                                u.lineTo(-g / 2, g / 2),
                                                u.lineTo(-g / 2, -g / 2),
                                                u.lineTo(0, -g / 2)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicCornerRounded = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, -Math.PI / 2, 0),
                                                u.lineTo(g / 2, g / 2),
                                                u.lineTo(-g / 2, g / 2),
                                                u.lineTo(-g / 2, -g / 2),
                                                u.lineTo(0, -g / 2)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicCornerExtraRounded = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(-g / 2, g / 2, g, -Math.PI / 2, 0), u.lineTo(-g / 2, g / 2), u.lineTo(-g / 2, -g / 2)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicCornersRounded = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, -Math.PI / 2, 0),
                                                u.lineTo(g / 2, g / 2),
                                                u.lineTo(0, g / 2),
                                                u.arc(0, 0, g / 2, Math.PI / 2, Math.PI),
                                                u.lineTo(-g / 2, -g / 2),
                                                u.lineTo(0, -g / 2)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicCornersExtraRounded = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    S(S({}, v), {
                                        draw: function () {
                                            u.arc(-g / 2, g / 2, g, -Math.PI / 2, 0), u.arc(g / 2, -g / 2, g, Math.PI / 2, Math.PI)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._drawDot = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context
                                this._basicDot({ x: g, y: u, size: p, context: H, rotation: 0 })
                            }),
                            (w.prototype._drawSquare = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context
                                this._basicSquare({ x: g, y: u, size: p, context: H, rotation: 0 })
                            }),
                            (w.prototype._drawRounded = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.getNeighbor,
                                    B = +b(-1, 0),
                                    D = +b(1, 0),
                                    U = +b(0, -1),
                                    j = +b(0, 1),
                                    dt = B + D + U + j
                                if (dt !== 0)
                                    if (dt > 2 || (B && D) || (U && j)) this._basicSquare({ x: g, y: u, size: p, context: H, rotation: 0 })
                                    else {
                                        if (dt === 2) {
                                            var Z = 0
                                            return (
                                                B && U ? (Z = Math.PI / 2) : U && D ? (Z = Math.PI) : D && j && (Z = -Math.PI / 2),
                                                void this._basicCornerRounded({ x: g, y: u, size: p, context: H, rotation: Z })
                                            )
                                        }
                                        dt === 1 &&
                                            ((Z = 0),
                                            U ? (Z = Math.PI / 2) : D ? (Z = Math.PI) : j && (Z = -Math.PI / 2),
                                            this._basicSideRounded({ x: g, y: u, size: p, context: H, rotation: Z }))
                                    }
                                else this._basicDot({ x: g, y: u, size: p, context: H, rotation: 0 })
                            }),
                            (w.prototype._drawExtraRounded = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.getNeighbor,
                                    B = +b(-1, 0),
                                    D = +b(1, 0),
                                    U = +b(0, -1),
                                    j = +b(0, 1),
                                    dt = B + D + U + j
                                if (dt !== 0)
                                    if (dt > 2 || (B && D) || (U && j)) this._basicSquare({ x: g, y: u, size: p, context: H, rotation: 0 })
                                    else {
                                        if (dt === 2) {
                                            var Z = 0
                                            return (
                                                B && U ? (Z = Math.PI / 2) : U && D ? (Z = Math.PI) : D && j && (Z = -Math.PI / 2),
                                                void this._basicCornerExtraRounded({ x: g, y: u, size: p, context: H, rotation: Z })
                                            )
                                        }
                                        dt === 1 &&
                                            ((Z = 0),
                                            U ? (Z = Math.PI / 2) : D ? (Z = Math.PI) : j && (Z = -Math.PI / 2),
                                            this._basicSideRounded({ x: g, y: u, size: p, context: H, rotation: Z }))
                                    }
                                else this._basicDot({ x: g, y: u, size: p, context: H, rotation: 0 })
                            }),
                            (w.prototype._drawClassy = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.getNeighbor,
                                    B = +b(-1, 0),
                                    D = +b(1, 0),
                                    U = +b(0, -1),
                                    j = +b(0, 1)
                                B + D + U + j !== 0
                                    ? B || U
                                        ? D || j
                                            ? this._basicSquare({ x: g, y: u, size: p, context: H, rotation: 0 })
                                            : this._basicCornerRounded({ x: g, y: u, size: p, context: H, rotation: Math.PI / 2 })
                                        : this._basicCornerRounded({ x: g, y: u, size: p, context: H, rotation: -Math.PI / 2 })
                                    : this._basicCornersRounded({ x: g, y: u, size: p, context: H, rotation: Math.PI / 2 })
                            }),
                            (w.prototype._drawClassyRounded = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.getNeighbor,
                                    B = +b(-1, 0),
                                    D = +b(1, 0),
                                    U = +b(0, -1),
                                    j = +b(0, 1)
                                B + D + U + j !== 0
                                    ? B || U
                                        ? D || j
                                            ? this._basicSquare({ x: g, y: u, size: p, context: H, rotation: 0 })
                                            : this._basicCornerExtraRounded({ x: g, y: u, size: p, context: H, rotation: Math.PI / 2 })
                                        : this._basicCornerExtraRounded({ x: g, y: u, size: p, context: H, rotation: -Math.PI / 2 })
                                    : this._basicCornersRounded({ x: g, y: u, size: p, context: H, rotation: Math.PI / 2 })
                            }),
                            w
                        )
                    })()
                    var P = function () {
                        return (P =
                            Object.assign ||
                            function (w) {
                                for (var v, g = 1, u = arguments.length; g < u; g++)
                                    for (var p in (v = arguments[g])) Object.prototype.hasOwnProperty.call(v, p) && (w[p] = v[p])
                                return w
                            }).apply(this, arguments)
                    }
                    const M = (function () {
                        function w(v) {
                            var g = v.context,
                                u = v.type
                            ;(this._context = g), (this._type = u)
                        }
                        return (
                            (w.prototype.draw = function (v, g, u, p) {
                                var H,
                                    b = this._context
                                switch (this._type) {
                                    case "square":
                                        H = this._drawSquare
                                        break
                                    case "extra-rounded":
                                        H = this._drawExtraRounded
                                        break
                                    case "dot":
                                    default:
                                        H = this._drawDot
                                }
                                H.call(this, { x: v, y: g, size: u, context: b, rotation: p })
                            }),
                            (w.prototype._rotateFigure = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation,
                                    B = v.draw,
                                    D = g + p / 2,
                                    U = u + p / 2
                                H.translate(D, U), b && H.rotate(b), B(), H.closePath(), b && H.rotate(-b), H.translate(-D, -U)
                            }),
                            (w.prototype._basicDot = function (v) {
                                var g = v.size,
                                    u = v.context,
                                    p = g / 7
                                this._rotateFigure(
                                    P(P({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, 0, 2 * Math.PI), u.arc(0, 0, g / 2 - p, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicSquare = function (v) {
                                var g = v.size,
                                    u = v.context,
                                    p = g / 7
                                this._rotateFigure(
                                    P(P({}, v), {
                                        draw: function () {
                                            u.rect(-g / 2, -g / 2, g, g), u.rect(-g / 2 + p, -g / 2 + p, g - 2 * p, g - 2 * p)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicExtraRounded = function (v) {
                                var g = v.size,
                                    u = v.context,
                                    p = g / 7
                                this._rotateFigure(
                                    P(P({}, v), {
                                        draw: function () {
                                            u.arc(-p, -p, 2.5 * p, Math.PI, -Math.PI / 2),
                                                u.lineTo(p, -3.5 * p),
                                                u.arc(p, -p, 2.5 * p, -Math.PI / 2, 0),
                                                u.lineTo(3.5 * p, -p),
                                                u.arc(p, p, 2.5 * p, 0, Math.PI / 2),
                                                u.lineTo(-p, 3.5 * p),
                                                u.arc(-p, p, 2.5 * p, Math.PI / 2, Math.PI),
                                                u.lineTo(-3.5 * p, -p),
                                                u.arc(-p, -p, 1.5 * p, Math.PI, -Math.PI / 2),
                                                u.lineTo(p, -2.5 * p),
                                                u.arc(p, -p, 1.5 * p, -Math.PI / 2, 0),
                                                u.lineTo(2.5 * p, -p),
                                                u.arc(p, p, 1.5 * p, 0, Math.PI / 2),
                                                u.lineTo(-p, 2.5 * p),
                                                u.arc(-p, p, 1.5 * p, Math.PI / 2, Math.PI),
                                                u.lineTo(-2.5 * p, -p)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._drawDot = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation
                                this._basicDot({ x: g, y: u, size: p, context: H, rotation: b })
                            }),
                            (w.prototype._drawSquare = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation
                                this._basicSquare({ x: g, y: u, size: p, context: H, rotation: b })
                            }),
                            (w.prototype._drawExtraRounded = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation
                                this._basicExtraRounded({ x: g, y: u, size: p, context: H, rotation: b })
                            }),
                            w
                        )
                    })()
                    var k = function () {
                        return (k =
                            Object.assign ||
                            function (w) {
                                for (var v, g = 1, u = arguments.length; g < u; g++)
                                    for (var p in (v = arguments[g])) Object.prototype.hasOwnProperty.call(v, p) && (w[p] = v[p])
                                return w
                            }).apply(this, arguments)
                    }
                    const F = (function () {
                        function w(v) {
                            var g = v.context,
                                u = v.type
                            ;(this._context = g), (this._type = u)
                        }
                        return (
                            (w.prototype.draw = function (v, g, u, p) {
                                var H,
                                    b = this._context
                                switch (this._type) {
                                    case "square":
                                        H = this._drawSquare
                                        break
                                    case "dot":
                                    default:
                                        H = this._drawDot
                                }
                                H.call(this, { x: v, y: g, size: u, context: b, rotation: p })
                            }),
                            (w.prototype._rotateFigure = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation,
                                    B = v.draw,
                                    D = g + p / 2,
                                    U = u + p / 2
                                H.translate(D, U), b && H.rotate(b), B(), H.closePath(), b && H.rotate(-b), H.translate(-D, -U)
                            }),
                            (w.prototype._basicDot = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    k(k({}, v), {
                                        draw: function () {
                                            u.arc(0, 0, g / 2, 0, 2 * Math.PI)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._basicSquare = function (v) {
                                var g = v.size,
                                    u = v.context
                                this._rotateFigure(
                                    k(k({}, v), {
                                        draw: function () {
                                            u.rect(-g / 2, -g / 2, g, g)
                                        },
                                    })
                                )
                            }),
                            (w.prototype._drawDot = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation
                                this._basicDot({ x: g, y: u, size: p, context: H, rotation: b })
                            }),
                            (w.prototype._drawSquare = function (v) {
                                var g = v.x,
                                    u = v.y,
                                    p = v.size,
                                    H = v.context,
                                    b = v.rotation
                                this._basicSquare({ x: g, y: u, size: p, context: H, rotation: b })
                            }),
                            w
                        )
                    })()
                    var $ = [
                            [1, 1, 1, 1, 1, 1, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 0, 0, 0, 0, 0, 1],
                            [1, 1, 1, 1, 1, 1, 1],
                        ],
                        R = [
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 1, 1, 1, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0, 0, 0],
                        ]
                    const W = (function () {
                        function w(v) {
                            ;(this._canvas = document.createElement("canvas")),
                                (this._canvas.width = v.width),
                                (this._canvas.height = v.height),
                                (this._options = v)
                        }
                        return (
                            Object.defineProperty(w.prototype, "context", {
                                get: function () {
                                    return this._canvas.getContext("2d")
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            Object.defineProperty(w.prototype, "width", {
                                get: function () {
                                    return this._canvas.width
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            Object.defineProperty(w.prototype, "height", {
                                get: function () {
                                    return this._canvas.height
                                },
                                enumerable: !1,
                                configurable: !0,
                            }),
                            (w.prototype.getCanvas = function () {
                                return this._canvas
                            }),
                            (w.prototype.clear = function () {
                                var v = this.context
                                v && v.clearRect(0, 0, this._canvas.width, this._canvas.height)
                            }),
                            (w.prototype.drawQR = function (v) {
                                return (
                                    (g = this),
                                    (u = void 0),
                                    (H = function () {
                                        var b,
                                            B,
                                            D,
                                            U,
                                            j,
                                            dt,
                                            Z,
                                            et,
                                            C,
                                            O = this
                                        return (function (I, G) {
                                            var q,
                                                X,
                                                lt,
                                                tt,
                                                rt = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & lt[0]) throw lt[1]
                                                        return lt[1]
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                }
                                            return (
                                                (tt = { next: st(0), throw: st(1), return: st(2) }),
                                                typeof Symbol == "function" &&
                                                    (tt[Symbol.iterator] = function () {
                                                        return this
                                                    }),
                                                tt
                                            )
                                            function st(ct) {
                                                return function (ht) {
                                                    return (function (gt) {
                                                        if (q) throw new TypeError("Generator is already executing.")
                                                        for (; rt; )
                                                            try {
                                                                if (
                                                                    ((q = 1),
                                                                    X &&
                                                                        (lt =
                                                                            2 & gt[0]
                                                                                ? X.return
                                                                                : gt[0]
                                                                                ? X.throw || ((lt = X.return) && lt.call(X), 0)
                                                                                : X.next) &&
                                                                        !(lt = lt.call(X, gt[1])).done)
                                                                )
                                                                    return lt
                                                                switch (((X = 0), lt && (gt = [2 & gt[0], lt.value]), gt[0])) {
                                                                    case 0:
                                                                    case 1:
                                                                        lt = gt
                                                                        break
                                                                    case 4:
                                                                        return rt.label++, { value: gt[1], done: !1 }
                                                                    case 5:
                                                                        rt.label++, (X = gt[1]), (gt = [0])
                                                                        continue
                                                                    case 7:
                                                                        ;(gt = rt.ops.pop()), rt.trys.pop()
                                                                        continue
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (lt = (lt = rt.trys).length > 0 && lt[lt.length - 1]) ||
                                                                                (gt[0] !== 6 && gt[0] !== 2)
                                                                            )
                                                                        ) {
                                                                            rt = 0
                                                                            continue
                                                                        }
                                                                        if (gt[0] === 3 && (!lt || (gt[1] > lt[0] && gt[1] < lt[3]))) {
                                                                            rt.label = gt[1]
                                                                            break
                                                                        }
                                                                        if (gt[0] === 6 && rt.label < lt[1]) {
                                                                            ;(rt.label = lt[1]), (lt = gt)
                                                                            break
                                                                        }
                                                                        if (lt && rt.label < lt[2]) {
                                                                            ;(rt.label = lt[2]), rt.ops.push(gt)
                                                                            break
                                                                        }
                                                                        lt[2] && rt.ops.pop(), rt.trys.pop()
                                                                        continue
                                                                }
                                                                gt = G.call(I, rt)
                                                            } catch (pt) {
                                                                ;(gt = [6, pt]), (X = 0)
                                                            } finally {
                                                                q = lt = 0
                                                            }
                                                        if (5 & gt[0]) throw gt[1]
                                                        return { value: gt[0] ? gt[1] : void 0, done: !0 }
                                                    })([ct, ht])
                                                }
                                            }
                                        })(this, function (I) {
                                            switch (I.label) {
                                                case 0:
                                                    return (
                                                        (b = v.getModuleCount()),
                                                        (B = Math.min(this._options.width, this._options.height) - 2 * this._options.margin),
                                                        (D = Math.floor(B / b)),
                                                        (U = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }),
                                                        (this._qr = v),
                                                        this._options.image ? [4, this.loadImage()] : [3, 2]
                                                    )
                                                case 1:
                                                    if ((I.sent(), !this._image)) return [2]
                                                    ;(j = this._options),
                                                        (dt = j.imageOptions),
                                                        (Z = j.qrOptions),
                                                        (et = dt.imageSize * T[Z.errorCorrectionLevel]),
                                                        (C = Math.floor(et * b * b)),
                                                        (U = (function (G) {
                                                            var q = G.originalHeight,
                                                                X = G.originalWidth,
                                                                lt = G.maxHiddenDots,
                                                                tt = G.maxHiddenAxisDots,
                                                                rt = G.dotSize,
                                                                st = { x: 0, y: 0 },
                                                                ct = { x: 0, y: 0 }
                                                            if (q <= 0 || X <= 0 || lt <= 0 || rt <= 0)
                                                                return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 }
                                                            var ht = q / X
                                                            return (
                                                                (st.x = Math.floor(Math.sqrt(lt / ht))),
                                                                st.x <= 0 && (st.x = 1),
                                                                tt && tt < st.x && (st.x = tt),
                                                                st.x % 2 == 0 && st.x--,
                                                                (ct.x = st.x * rt),
                                                                (st.y = 1 + 2 * Math.ceil((st.x * ht - 1) / 2)),
                                                                (ct.y = Math.round(ct.x * ht)),
                                                                (st.y * st.x > lt || (tt && tt < st.y)) &&
                                                                    (tt && tt < st.y ? ((st.y = tt), st.y % 2 == 0 && st.x--) : (st.y -= 2),
                                                                    (ct.y = st.y * rt),
                                                                    (st.x = 1 + 2 * Math.ceil((st.y / ht - 1) / 2)),
                                                                    (ct.x = Math.round(ct.y / ht))),
                                                                { height: ct.y, width: ct.x, hideYDots: st.y, hideXDots: st.x }
                                                            )
                                                        })({
                                                            originalWidth: this._image.width,
                                                            originalHeight: this._image.height,
                                                            maxHiddenDots: C,
                                                            maxHiddenAxisDots: b - 14,
                                                            dotSize: D,
                                                        })),
                                                        (I.label = 2)
                                                case 2:
                                                    return (
                                                        this.clear(),
                                                        this.drawBackground(),
                                                        this.drawDots(function (G, q) {
                                                            var X, lt, tt, rt, st, ct
                                                            return !(
                                                                (O._options.imageOptions.hideBackgroundDots &&
                                                                    G >= (b - U.hideXDots) / 2 &&
                                                                    G < (b + U.hideXDots) / 2 &&
                                                                    q >= (b - U.hideYDots) / 2 &&
                                                                    q < (b + U.hideYDots) / 2) ||
                                                                ((X = $[G]) === null || X === void 0 ? void 0 : X[q]) ||
                                                                ((lt = $[G - b + 7]) === null || lt === void 0 ? void 0 : lt[q]) ||
                                                                ((tt = $[G]) === null || tt === void 0 ? void 0 : tt[q - b + 7]) ||
                                                                ((rt = R[G]) === null || rt === void 0 ? void 0 : rt[q]) ||
                                                                ((st = R[G - b + 7]) === null || st === void 0 ? void 0 : st[q]) ||
                                                                ((ct = R[G]) === null || ct === void 0 ? void 0 : ct[q - b + 7])
                                                            )
                                                        }),
                                                        this.drawCorners(),
                                                        this._options.image &&
                                                            this.drawImage({ width: U.width, height: U.height, count: b, dotSize: D }),
                                                        [2]
                                                    )
                                            }
                                        })
                                    }),
                                    new ((p = void 0) || (p = Promise))(function (b, B) {
                                        function D(dt) {
                                            try {
                                                j(H.next(dt))
                                            } catch (Z) {
                                                B(Z)
                                            }
                                        }
                                        function U(dt) {
                                            try {
                                                j(H.throw(dt))
                                            } catch (Z) {
                                                B(Z)
                                            }
                                        }
                                        function j(dt) {
                                            var Z
                                            dt.done
                                                ? b(dt.value)
                                                : ((Z = dt.value),
                                                  Z instanceof p
                                                      ? Z
                                                      : new p(function (et) {
                                                            et(Z)
                                                        })).then(D, U)
                                        }
                                        j((H = H.apply(g, u || [])).next())
                                    })
                                )
                                var g, u, p, H
                            }),
                            (w.prototype.drawBackground = function () {
                                var v = this.context,
                                    g = this._options
                                if (v) {
                                    if (g.backgroundOptions.gradient) {
                                        var u = g.backgroundOptions.gradient,
                                            p = this._createGradient({
                                                context: v,
                                                options: u,
                                                additionalRotation: 0,
                                                x: 0,
                                                y: 0,
                                                size: this._canvas.width > this._canvas.height ? this._canvas.width : this._canvas.height,
                                            })
                                        u.colorStops.forEach(function (H) {
                                            var b = H.offset,
                                                B = H.color
                                            p.addColorStop(b, B)
                                        }),
                                            (v.fillStyle = p)
                                    } else g.backgroundOptions.color && (v.fillStyle = g.backgroundOptions.color)
                                    v.fillRect(0, 0, this._canvas.width, this._canvas.height)
                                }
                            }),
                            (w.prototype.drawDots = function (v) {
                                var g = this
                                if (!this._qr) throw "QR code is not defined"
                                var u = this.context
                                if (!u) throw "QR code is not defined"
                                var p = this._options,
                                    H = this._qr.getModuleCount()
                                if (H > p.width || H > p.height) throw "The canvas is too small."
                                var b = Math.min(p.width, p.height) - 2 * p.margin,
                                    B = Math.floor(b / H),
                                    D = Math.floor((p.width - H * B) / 2),
                                    U = Math.floor((p.height - H * B) / 2),
                                    j = new N({ context: u, type: p.dotsOptions.type })
                                u.beginPath()
                                for (
                                    var dt = function (I) {
                                            for (
                                                var G = function (X) {
                                                        return v && !v(I, X)
                                                            ? "continue"
                                                            : Z._qr.isDark(I, X)
                                                            ? void j.draw(D + I * B, U + X * B, B, function (lt, tt) {
                                                                  return (
                                                                      !(I + lt < 0 || X + tt < 0 || I + lt >= H || X + tt >= H) &&
                                                                      !(v && !v(I + lt, X + tt)) &&
                                                                      !!g._qr &&
                                                                      g._qr.isDark(I + lt, X + tt)
                                                                  )
                                                              })
                                                            : "continue"
                                                    },
                                                    q = 0;
                                                q < H;
                                                q++
                                            )
                                                G(q)
                                        },
                                        Z = this,
                                        et = 0;
                                    et < H;
                                    et++
                                )
                                    dt(et)
                                if (p.dotsOptions.gradient) {
                                    var C = p.dotsOptions.gradient,
                                        O = this._createGradient({ context: u, options: C, additionalRotation: 0, x: D, y: U, size: H * B })
                                    C.colorStops.forEach(function (I) {
                                        var G = I.offset,
                                            q = I.color
                                        O.addColorStop(G, q)
                                    }),
                                        (u.fillStyle = u.strokeStyle = O)
                                } else p.dotsOptions.color && (u.fillStyle = u.strokeStyle = p.dotsOptions.color)
                                u.fill("evenodd")
                            }),
                            (w.prototype.drawCorners = function (v) {
                                var g = this
                                if (!this._qr) throw "QR code is not defined"
                                var u = this.context
                                if (!u) throw "QR code is not defined"
                                var p = this._options,
                                    H = this._qr.getModuleCount(),
                                    b = Math.min(p.width, p.height) - 2 * p.margin,
                                    B = Math.floor(b / H),
                                    D = 7 * B,
                                    U = 3 * B,
                                    j = Math.floor((p.width - H * B) / 2),
                                    dt = Math.floor((p.height - H * B) / 2)
                                ;[
                                    [0, 0, 0],
                                    [1, 0, Math.PI / 2],
                                    [0, 1, -Math.PI / 2],
                                ].forEach(function (Z) {
                                    var et,
                                        C,
                                        O,
                                        I,
                                        G,
                                        q,
                                        X,
                                        lt,
                                        tt,
                                        rt,
                                        st = Z[0],
                                        ct = Z[1],
                                        ht = Z[2]
                                    if (!v || v(st, ct)) {
                                        var gt = j + st * B * (H - 7),
                                            pt = dt + ct * B * (H - 7)
                                        if (!((et = p.cornersSquareOptions) === null || et === void 0) && et.type) {
                                            var vt = new M({
                                                context: u,
                                                type: (C = p.cornersSquareOptions) === null || C === void 0 ? void 0 : C.type,
                                            })
                                            u.beginPath(), vt.draw(gt, pt, D, ht)
                                        } else {
                                            var Tt = new N({ context: u, type: p.dotsOptions.type })
                                            u.beginPath()
                                            for (
                                                var Et = function (Mt) {
                                                        for (
                                                            var ge = function (qt) {
                                                                    if (!(!((O = $[Mt]) === null || O === void 0) && O[qt])) return "continue"
                                                                    Tt.draw(gt + Mt * B, pt + qt * B, B, function (vr, Gt) {
                                                                        var zt
                                                                        return !!(!((zt = $[Mt + vr]) === null || zt === void 0) && zt[qt + Gt])
                                                                    })
                                                                },
                                                                Rt = 0;
                                                            Rt < $[Mt].length;
                                                            Rt++
                                                        )
                                                            ge(Rt)
                                                    },
                                                    At = 0;
                                                At < $.length;
                                                At++
                                            )
                                                Et(At)
                                        }
                                        if (!((I = p.cornersSquareOptions) === null || I === void 0) && I.gradient) {
                                            var Ft = p.cornersSquareOptions.gradient,
                                                Ot = g._createGradient({
                                                    context: u,
                                                    options: Ft,
                                                    additionalRotation: ht,
                                                    x: gt,
                                                    y: pt,
                                                    size: D,
                                                })
                                            Ft.colorStops.forEach(function (Mt) {
                                                var ge = Mt.offset,
                                                    Rt = Mt.color
                                                Ot.addColorStop(ge, Rt)
                                            }),
                                                (u.fillStyle = u.strokeStyle = Ot)
                                        } else
                                            !((G = p.cornersSquareOptions) === null || G === void 0) &&
                                                G.color &&
                                                (u.fillStyle = u.strokeStyle = p.cornersSquareOptions.color)
                                        if ((u.fill("evenodd"), (q = p.cornersDotOptions) === null || q === void 0 ? void 0 : q.type)) {
                                            var Bt = new F({
                                                context: u,
                                                type: (X = p.cornersDotOptions) === null || X === void 0 ? void 0 : X.type,
                                            })
                                            u.beginPath(), Bt.draw(gt + 2 * B, pt + 2 * B, U, ht)
                                        } else {
                                            ;(Tt = new N({ context: u, type: p.dotsOptions.type })), u.beginPath()
                                            var ke = function (Mt) {
                                                for (
                                                    var ge = function (qt) {
                                                            if (!(!((lt = R[Mt]) === null || lt === void 0) && lt[qt])) return "continue"
                                                            Tt.draw(gt + Mt * B, pt + qt * B, B, function (vr, Gt) {
                                                                var zt
                                                                return !!(!((zt = R[Mt + vr]) === null || zt === void 0) && zt[qt + Gt])
                                                            })
                                                        },
                                                        Rt = 0;
                                                    Rt < R[Mt].length;
                                                    Rt++
                                                )
                                                    ge(Rt)
                                            }
                                            for (At = 0; At < R.length; At++) ke(At)
                                        }
                                        if (!((tt = p.cornersDotOptions) === null || tt === void 0) && tt.gradient) {
                                            Ft = p.cornersDotOptions.gradient
                                            var Vt = g._createGradient({
                                                context: u,
                                                options: Ft,
                                                additionalRotation: ht,
                                                x: gt + 2 * B,
                                                y: pt + 2 * B,
                                                size: U,
                                            })
                                            Ft.colorStops.forEach(function (Mt) {
                                                var ge = Mt.offset,
                                                    Rt = Mt.color
                                                Vt.addColorStop(ge, Rt)
                                            }),
                                                (u.fillStyle = u.strokeStyle = Vt)
                                        } else
                                            !((rt = p.cornersDotOptions) === null || rt === void 0) &&
                                                rt.color &&
                                                (u.fillStyle = u.strokeStyle = p.cornersDotOptions.color)
                                        u.fill("evenodd")
                                    }
                                })
                            }),
                            (w.prototype.loadImage = function () {
                                var v = this
                                return new Promise(function (g, u) {
                                    var p = v._options,
                                        H = new Image()
                                    if (!p.image) return u("Image is not defined")
                                    typeof p.imageOptions.crossOrigin == "string" && (H.crossOrigin = p.imageOptions.crossOrigin),
                                        (v._image = H),
                                        (H.onload = function () {
                                            g()
                                        }),
                                        (H.src = p.image)
                                })
                            }),
                            (w.prototype.drawImage = function (v) {
                                var g = v.width,
                                    u = v.height,
                                    p = v.count,
                                    H = v.dotSize,
                                    b = this.context
                                if (!b) throw "canvasContext is not defined"
                                if (!this._image) throw "image is not defined"
                                var B = this._options,
                                    D = Math.floor((B.width - p * H) / 2),
                                    U = Math.floor((B.height - p * H) / 2),
                                    j = D + B.imageOptions.margin + (p * H - g) / 2,
                                    dt = U + B.imageOptions.margin + (p * H - u) / 2,
                                    Z = g - 2 * B.imageOptions.margin,
                                    et = u - 2 * B.imageOptions.margin
                                b.drawImage(this._image, j, dt, Z < 0 ? 0 : Z, et < 0 ? 0 : et)
                            }),
                            (w.prototype._createGradient = function (v) {
                                var g,
                                    u = v.context,
                                    p = v.options,
                                    H = v.additionalRotation,
                                    b = v.x,
                                    B = v.y,
                                    D = v.size
                                if (p.type === "radial") g = u.createRadialGradient(b + D / 2, B + D / 2, 0, b + D / 2, B + D / 2, D / 2)
                                else {
                                    var U = ((p.rotation || 0) + H) % (2 * Math.PI),
                                        j = (U + 2 * Math.PI) % (2 * Math.PI),
                                        dt = b + D / 2,
                                        Z = B + D / 2,
                                        et = b + D / 2,
                                        C = B + D / 2
                                    ;(j >= 0 && j <= 0.25 * Math.PI) || (j > 1.75 * Math.PI && j <= 2 * Math.PI)
                                        ? ((dt -= D / 2), (Z -= (D / 2) * Math.tan(U)), (et += D / 2), (C += (D / 2) * Math.tan(U)))
                                        : j > 0.25 * Math.PI && j <= 0.75 * Math.PI
                                        ? ((Z -= D / 2), (dt -= D / 2 / Math.tan(U)), (C += D / 2), (et += D / 2 / Math.tan(U)))
                                        : j > 0.75 * Math.PI && j <= 1.25 * Math.PI
                                        ? ((dt += D / 2), (Z += (D / 2) * Math.tan(U)), (et -= D / 2), (C -= (D / 2) * Math.tan(U)))
                                        : j > 1.25 * Math.PI &&
                                          j <= 1.75 * Math.PI &&
                                          ((Z += D / 2), (dt += D / 2 / Math.tan(U)), (C -= D / 2), (et -= D / 2 / Math.tan(U))),
                                        (g = u.createLinearGradient(Math.round(dt), Math.round(Z), Math.round(et), Math.round(C)))
                                }
                                return g
                            }),
                            w
                        )
                    })()
                    for (var nt = {}, J = 0; J <= 40; J++) nt[J] = J
                    const Q = {
                        width: 300,
                        height: 300,
                        data: "",
                        margin: 0,
                        qrOptions: { typeNumber: nt[0], mode: void 0, errorCorrectionLevel: "Q" },
                        imageOptions: { hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 },
                        dotsOptions: { type: "square", color: "#000" },
                        backgroundOptions: { color: "#fff" },
                    }
                    var ot = function () {
                        return (ot =
                            Object.assign ||
                            function (w) {
                                for (var v, g = 1, u = arguments.length; g < u; g++)
                                    for (var p in (v = arguments[g])) Object.prototype.hasOwnProperty.call(v, p) && (w[p] = v[p])
                                return w
                            }).apply(this, arguments)
                    }
                    function it(w) {
                        var v = ot({}, w)
                        if (!v.colorStops || !v.colorStops.length) throw "Field 'colorStops' is required in gradient"
                        return (
                            v.rotation ? (v.rotation = Number(v.rotation)) : (v.rotation = 0),
                            (v.colorStops = v.colorStops.map(function (g) {
                                return ot(ot({}, g), { offset: Number(g.offset) })
                            })),
                            v
                        )
                    }
                    function at(w) {
                        var v = ot({}, w)
                        return (
                            (v.width = Number(v.width)),
                            (v.height = Number(v.height)),
                            (v.margin = Number(v.margin)),
                            (v.imageOptions = ot(ot({}, v.imageOptions), {
                                hideBackgroundDots: Boolean(v.imageOptions.hideBackgroundDots),
                                imageSize: Number(v.imageOptions.imageSize),
                                margin: Number(v.imageOptions.margin),
                            })),
                            v.margin > Math.min(v.width, v.height) && (v.margin = Math.min(v.width, v.height)),
                            (v.dotsOptions = ot({}, v.dotsOptions)),
                            v.dotsOptions.gradient && (v.dotsOptions.gradient = it(v.dotsOptions.gradient)),
                            v.cornersSquareOptions &&
                                ((v.cornersSquareOptions = ot({}, v.cornersSquareOptions)),
                                v.cornersSquareOptions.gradient && (v.cornersSquareOptions.gradient = it(v.cornersSquareOptions.gradient))),
                            v.cornersDotOptions &&
                                ((v.cornersDotOptions = ot({}, v.cornersDotOptions)),
                                v.cornersDotOptions.gradient && (v.cornersDotOptions.gradient = it(v.cornersDotOptions.gradient))),
                            v.backgroundOptions &&
                                ((v.backgroundOptions = ot({}, v.backgroundOptions)),
                                v.backgroundOptions.gradient && (v.backgroundOptions.gradient = it(v.backgroundOptions.gradient))),
                            v
                        )
                    }
                    var x = s(192),
                        a = s.n(x)
                    const c = (function () {
                        function w(v) {
                            ;(this._options = v ? at(E(Q, v)) : Q), this.update()
                        }
                        return (
                            (w._clearContainer = function (v) {
                                v && (v.innerHTML = "")
                            }),
                            (w.prototype.update = function (v) {
                                w._clearContainer(this._container),
                                    (this._options = v ? at(E(this._options, v)) : this._options),
                                    this._options.data &&
                                        ((this._qr = a()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel)),
                                        this._qr.addData(
                                            this._options.data,
                                            this._options.qrOptions.mode ||
                                                (function (g) {
                                                    switch (!0) {
                                                        case /^[0-9]*$/.test(g):
                                                            return "Numeric"
                                                        case /^[0-9A-Z $%*+\-./:]*$/.test(g):
                                                            return "Alphanumeric"
                                                        default:
                                                            return "Byte"
                                                    }
                                                })(this._options.data)
                                        ),
                                        this._qr.make(),
                                        (this._canvas = new W(this._options)),
                                        (this._drawingPromise = this._canvas.drawQR(this._qr)),
                                        this.append(this._container))
                            }),
                            (w.prototype.append = function (v) {
                                if (v) {
                                    if (typeof v.appendChild != "function") throw "Container should be a single DOM node"
                                    this._canvas && v.appendChild(this._canvas.getCanvas()), (this._container = v)
                                }
                            }),
                            (w.prototype.getImageUrl = function (v) {
                                return (
                                    (g = this),
                                    (u = void 0),
                                    (H = function () {
                                        return (function (b, B) {
                                            var D,
                                                U,
                                                j,
                                                dt,
                                                Z = {
                                                    label: 0,
                                                    sent: function () {
                                                        if (1 & j[0]) throw j[1]
                                                        return j[1]
                                                    },
                                                    trys: [],
                                                    ops: [],
                                                }
                                            return (
                                                (dt = { next: et(0), throw: et(1), return: et(2) }),
                                                typeof Symbol == "function" &&
                                                    (dt[Symbol.iterator] = function () {
                                                        return this
                                                    }),
                                                dt
                                            )
                                            function et(C) {
                                                return function (O) {
                                                    return (function (I) {
                                                        if (D) throw new TypeError("Generator is already executing.")
                                                        for (; Z; )
                                                            try {
                                                                if (
                                                                    ((D = 1),
                                                                    U &&
                                                                        (j =
                                                                            2 & I[0]
                                                                                ? U.return
                                                                                : I[0]
                                                                                ? U.throw || ((j = U.return) && j.call(U), 0)
                                                                                : U.next) &&
                                                                        !(j = j.call(U, I[1])).done)
                                                                )
                                                                    return j
                                                                switch (((U = 0), j && (I = [2 & I[0], j.value]), I[0])) {
                                                                    case 0:
                                                                    case 1:
                                                                        j = I
                                                                        break
                                                                    case 4:
                                                                        return Z.label++, { value: I[1], done: !1 }
                                                                    case 5:
                                                                        Z.label++, (U = I[1]), (I = [0])
                                                                        continue
                                                                    case 7:
                                                                        ;(I = Z.ops.pop()), Z.trys.pop()
                                                                        continue
                                                                    default:
                                                                        if (
                                                                            !(
                                                                                (j = (j = Z.trys).length > 0 && j[j.length - 1]) ||
                                                                                (I[0] !== 6 && I[0] !== 2)
                                                                            )
                                                                        ) {
                                                                            Z = 0
                                                                            continue
                                                                        }
                                                                        if (I[0] === 3 && (!j || (I[1] > j[0] && I[1] < j[3]))) {
                                                                            Z.label = I[1]
                                                                            break
                                                                        }
                                                                        if (I[0] === 6 && Z.label < j[1]) {
                                                                            ;(Z.label = j[1]), (j = I)
                                                                            break
                                                                        }
                                                                        if (j && Z.label < j[2]) {
                                                                            ;(Z.label = j[2]), Z.ops.push(I)
                                                                            break
                                                                        }
                                                                        j[2] && Z.ops.pop(), Z.trys.pop()
                                                                        continue
                                                                }
                                                                I = B.call(b, Z)
                                                            } catch (G) {
                                                                ;(I = [6, G]), (U = 0)
                                                            } finally {
                                                                D = j = 0
                                                            }
                                                        if (5 & I[0]) throw I[1]
                                                        return { value: I[0] ? I[1] : void 0, done: !0 }
                                                    })([C, O])
                                                }
                                            }
                                        })(this, function (b) {
                                            switch (b.label) {
                                                case 0:
                                                    return this._drawingPromise ? [4, this._drawingPromise] : [2, ""]
                                                case 1:
                                                    return b.sent() === void 0 && this._canvas
                                                        ? [2, this._canvas.getCanvas().toDataURL("image/" + v)]
                                                        : [2, ""]
                                            }
                                        })
                                    }),
                                    new ((p = void 0) || (p = Promise))(function (b, B) {
                                        function D(dt) {
                                            try {
                                                j(H.next(dt))
                                            } catch (Z) {
                                                B(Z)
                                            }
                                        }
                                        function U(dt) {
                                            try {
                                                j(H.throw(dt))
                                            } catch (Z) {
                                                B(Z)
                                            }
                                        }
                                        function j(dt) {
                                            var Z
                                            dt.done
                                                ? b(dt.value)
                                                : ((Z = dt.value),
                                                  Z instanceof p
                                                      ? Z
                                                      : new p(function (et) {
                                                            et(Z)
                                                        })).then(D, U)
                                        }
                                        j((H = H.apply(g, u || [])).next())
                                    })
                                )
                                var g, u, p, H
                            }),
                            (w.prototype.download = function (v) {
                                var g = this
                                this._drawingPromise &&
                                    this._drawingPromise.then(function () {
                                        if (g._canvas) {
                                            var u = v,
                                                p = u.extension || "png",
                                                H = u.name || "qr"
                                            ;(function (b, B) {
                                                var D = document.createElement("a")
                                                ;(D.download = B),
                                                    (D.href = b),
                                                    document.body.appendChild(D),
                                                    D.click(),
                                                    document.body.removeChild(D)
                                            })(g._canvas.getCanvas().toDataURL("image/" + p), H + "." + p)
                                        }
                                    })
                            }),
                            w
                        )
                    })()
                    var m = function (w, v, g, u) {
                            return new (g || (g = Promise))(function (p, H) {
                                function b(U) {
                                    try {
                                        D(u.next(U))
                                    } catch (j) {
                                        H(j)
                                    }
                                }
                                function B(U) {
                                    try {
                                        D(u.throw(U))
                                    } catch (j) {
                                        H(j)
                                    }
                                }
                                function D(U) {
                                    var j
                                    U.done
                                        ? p(U.value)
                                        : ((j = U.value),
                                          j instanceof g
                                              ? j
                                              : new g(function (dt) {
                                                    dt(j)
                                                })).then(b, B)
                                }
                                D((u = u.apply(w, v || [])).next())
                            })
                        },
                        _ = function (w, v) {
                            var g,
                                u,
                                p,
                                H,
                                b = {
                                    label: 0,
                                    sent: function () {
                                        if (1 & p[0]) throw p[1]
                                        return p[1]
                                    },
                                    trys: [],
                                    ops: [],
                                }
                            return (
                                (H = { next: B(0), throw: B(1), return: B(2) }),
                                typeof Symbol == "function" &&
                                    (H[Symbol.iterator] = function () {
                                        return this
                                    }),
                                H
                            )
                            function B(D) {
                                return function (U) {
                                    return (function (j) {
                                        if (g) throw new TypeError("Generator is already executing.")
                                        for (; b; )
                                            try {
                                                if (
                                                    ((g = 1),
                                                    u &&
                                                        (p =
                                                            2 & j[0] ? u.return : j[0] ? u.throw || ((p = u.return) && p.call(u), 0) : u.next) &&
                                                        !(p = p.call(u, j[1])).done)
                                                )
                                                    return p
                                                switch (((u = 0), p && (j = [2 & j[0], p.value]), j[0])) {
                                                    case 0:
                                                    case 1:
                                                        p = j
                                                        break
                                                    case 4:
                                                        return b.label++, { value: j[1], done: !1 }
                                                    case 5:
                                                        b.label++, (u = j[1]), (j = [0])
                                                        continue
                                                    case 7:
                                                        ;(j = b.ops.pop()), b.trys.pop()
                                                        continue
                                                    default:
                                                        if (!((p = (p = b.trys).length > 0 && p[p.length - 1]) || (j[0] !== 6 && j[0] !== 2))) {
                                                            b = 0
                                                            continue
                                                        }
                                                        if (j[0] === 3 && (!p || (j[1] > p[0] && j[1] < p[3]))) {
                                                            b.label = j[1]
                                                            break
                                                        }
                                                        if (j[0] === 6 && b.label < p[1]) {
                                                            ;(b.label = p[1]), (p = j)
                                                            break
                                                        }
                                                        if (p && b.label < p[2]) {
                                                            ;(b.label = p[2]), b.ops.push(j)
                                                            break
                                                        }
                                                        p[2] && b.ops.pop(), b.trys.pop()
                                                        continue
                                                }
                                                j = v.call(w, b)
                                            } catch (dt) {
                                                ;(j = [6, dt]), (u = 0)
                                            } finally {
                                                g = p = 0
                                            }
                                        if (5 & j[0]) throw j[1]
                                        return { value: j[0] ? j[1] : void 0, done: !0 }
                                    })([D, U])
                                }
                            }
                        }
                    const A = {
                        name: "QRCodeVue3",
                        props: {
                            width: { type: Number, default: 300 },
                            imgclass: { type: String, default: "" },
                            myclass: { type: String, default: "" },
                            downloadButton: { type: String, default: "" },
                            ButtonName: { type: String, default: "Download3" },
                            height: { type: Number, default: 300 },
                            value: { type: String, required: !0 },
                            image: { type: String, default: "" },
                            qrOptions: {
                                type: Object,
                                default: function () {
                                    return { typeNumber: 0, mode: "Byte", errorCorrectionLevel: "Q" }
                                },
                            },
                            imageOptions: {
                                type: Object,
                                default: function () {
                                    return { hideBackgroundDots: !0, imageSize: 0.4, margin: 0 }
                                },
                            },
                            dotsOptions: {
                                type: Object,
                                default: function () {
                                    return {
                                        type: "dots",
                                        color: "#6a1a4c",
                                        gradient: {
                                            type: "linear",
                                            rotation: 0,
                                            colorStops: [
                                                { offset: 0, color: "#6a1a4c" },
                                                { offset: 1, color: "#6a1a4c" },
                                            ],
                                        },
                                    }
                                },
                            },
                            backgroundOptions: {
                                type: Object,
                                default: function () {
                                    return { color: "#ffffff" }
                                },
                            },
                            cornersSquareOptions: {
                                type: Object,
                                default: function () {
                                    return { type: "dot", color: "#000000" }
                                },
                            },
                            cornersDotOptions: {
                                type: Object,
                                default: function () {
                                    return { type: void 0, color: "#000000" }
                                },
                            },
                            fileExt: { type: String, default: "png" },
                            download: { type: Boolean, default: !1 },
                            downloadOptions: {
                                type: Object,
                                default: function () {
                                    return { name: "vqr", extension: "png" }
                                },
                            },
                        },
                        data: function () {
                            return {
                                imageUrl: "",
                                qrCode: new c({
                                    data: this.value,
                                    width: this.width,
                                    height: this.height,
                                    qrOptions: this.qrOptions,
                                    imageOptions: this.imageOptions,
                                    dotsOptions: this.dotsOptions,
                                    backgroundOptions: this.backgroundOptions,
                                    image: this.image,
                                    cornersSquareOptions: this.cornersSquareOptions,
                                    cornersDotOptions: this.cornersDotOptions,
                                }),
                            }
                        },
                        watch: {
                            value: function () {
                                return m(this, void 0, void 0, function () {
                                    var w
                                    return _(this, function (v) {
                                        switch (v.label) {
                                            case 0:
                                                return (
                                                    (this.qrCode = new c({
                                                        data: this.value,
                                                        width: this.width,
                                                        height: this.height,
                                                        qrOptions: this.qrOptions,
                                                        imageOptions: this.imageOptions,
                                                        dotsOptions: this.dotsOptions,
                                                        backgroundOptions: this.backgroundOptions,
                                                        image: this.image,
                                                        cornersSquareOptions: this.cornersSquareOptions,
                                                        cornersDotOptions: this.cornersDotOptions,
                                                    })),
                                                    (w = this),
                                                    [4, this.qrCode.getImageUrl(this.fileExt)]
                                                )
                                            case 1:
                                                return (w.imageUrl = v.sent()), [2]
                                        }
                                    })
                                })
                            },
                        },
                        mounted: function () {
                            return m(this, void 0, void 0, function () {
                                var w
                                return _(this, function (v) {
                                    switch (v.label) {
                                        case 0:
                                            return (w = this), [4, this.qrCode.getImageUrl(this.fileExt)]
                                        case 1:
                                            return (w.imageUrl = v.sent()), [2]
                                    }
                                })
                            })
                        },
                        render: function (w, v, g, u, p, H) {
                            return (
                                (0, l.openBlock)(),
                                (0, l.createBlock)("div", null, [
                                    p.imageUrl
                                        ? ((0, l.openBlock)(),
                                          (0, l.createBlock)(
                                              "div",
                                              { key: 0, class: g.myclass },
                                              [
                                                  (0, l.createVNode)(
                                                      "img",
                                                      { src: p.imageUrl, class: g.imgclass, crossorigin: "anonymous" },
                                                      null,
                                                      10,
                                                      ["src"]
                                                  ),
                                              ],
                                              2
                                          ))
                                        : (0, l.createCommentVNode)("v-if", !0),
                                    g.download
                                        ? ((0, l.openBlock)(),
                                          (0, l.createBlock)("div", f, [
                                              (0, l.createVNode)(
                                                  "button",
                                                  {
                                                      onClick: v[1] || (v[1] = (...b) => w.onDownloadClick && w.onDownloadClick(...b)),
                                                      class: g.downloadButton,
                                                  },
                                                  (0, l.toDisplayString)(g.ButtonName),
                                                  3
                                              ),
                                          ]))
                                        : (0, l.createCommentVNode)("v-if", !0),
                                ])
                            )
                        },
                    }
                })(),
                o.default
            )
        })()
    })
})(py)
var KI = j2(py.exports)
const GI = { style: { position: "relative" } },
    WI = ["src", "alt"],
    YI = ["src", "alt"],
    Es = bt({
        __name: "Image",
        props: { series: null, image: null, isLink: { type: Boolean }, hideQR: { type: Boolean } },
        setup(e) {
            const t = e,
                r = Ie("app"),
                n = K(() => r.series[t.series]),
                i = K(() => location.protocol + "//" + location.host + "/image/" + t.series + "/" + t.image)
            return (s, o) => {
                const l = ui("router-link")
                return (
                    Y(),
                    ft("div", null, [
                        xt("div", GI, [
                            e.isLink
                                ? (Y(),
                                  kt(
                                      l,
                                      { key: 0, to: "/image/" + t.series + "/" + t.image },
                                      {
                                          default: Ct(() => [
                                              xt(
                                                  "img",
                                                  {
                                                      style: { position: "relative" },
                                                      src:
                                                          "/img/" +
                                                          e.series.toString().padStart(3, "0") +
                                                          " " +
                                                          V(n).name +
                                                          "/" +
                                                          e.image +
                                                          ".png",
                                                      class: "d-block w-100",
                                                      alt: V(n).name + " " + e.image,
                                                  },
                                                  null,
                                                  8,
                                                  WI
                                              ),
                                          ]),
                                          _: 1,
                                      },
                                      8,
                                      ["to"]
                                  ))
                                : (Y(),
                                  ft(
                                      "img",
                                      {
                                          key: 1,
                                          style: { position: "relative" },
                                          src: "/img/" + e.series.toString().padStart(3, "0") + " " + V(n).name + "/" + e.image + ".png",
                                          class: "d-block w-100",
                                          alt: V(n).name + " " + e.image,
                                      },
                                      null,
                                      8,
                                      YI
                                  )),
                            e.hideQR
                                ? Dt("", !0)
                                : (Y(),
                                  kt(
                                      V(KI),
                                      {
                                          key: 2,
                                          class: "d-none d-md-block",
                                          style: { position: "absolute", bottom: "20px", right: "20px" },
                                          value: V(i),
                                          width: 64,
                                          height: 64,
                                          backgroundOptions: { color: "#bbb" },
                                          dotsOptions: { type: "rounded", color: "#000" },
                                      },
                                      null,
                                      8,
                                      ["value"]
                                  )),
                        ]),
                    ])
                )
            }
        },
    }),
    JI = xt("div", { class: "text-center my-5" }, [xt("h1", null, "UnRealArt")], -1),
    QI = { style: { position: "relative" }, class: "d-block d-md-none" },
    XI = { style: { position: "relative" }, class: "d-none d-md-block" },
    ZI = xt("img", { class: "w-100", style: { position: "relative" }, src: zI }, null, -1),
    tB = { class: "mt-3 mb-5 text-center" },
    eB = ve("<<"),
    rB = ve("<"),
    nB = ve(">"),
    iB = ve(">>"),
    sB = xt(
        "div",
        { class: "text-center mb-5" },
        [
            xt("h2", null, "What's this?"),
            xt(
                "p",
                null,
                " The UnrealArt exhibition showcases a wide variety of AI art created without any design or painting skills. Every few minutes a new series of artworks is shown. Explore the boundaries of creativity and the latest technology in this one-of-a-kind exhibition. "
            ),
        ],
        -1
    ),
    oB = xt("h2", { class: "text-center" }, "Series", -1),
    aB = { class: "mb-5" },
    lB = { class: "row" },
    uB = { class: "text-center mb-5" },
    fB = xt("h2", { class: "text-center" }, "Slideshow", -1),
    cB = ve("One"),
    dB = ve("Two"),
    hB = ve("Three"),
    pB = ve("Four"),
    gB = xt("footer", null, [xt("h2", { class: "text-center" }, "Add your own artworks")], -1),
    mB = bt({
        __name: "Home",
        setup(e) {
            const t = Ie("app"),
                r = Ht(1),
                n = Ht(1),
                i = () => {
                    n.value--, n.value == 0 && (r.value--, (n.value = t.series[r.value].images))
                },
                s = () => {
                    n.value++, n.value > t.series[r.value].images && (r.value++, (n.value = 1))
                },
                o = () => {
                    r.value--, (n.value = 1)
                },
                l = () => {
                    r.value++, (n.value = 1)
                }
            return (f, d) => {
                const h = ui("b-button"),
                    y = ui("router-link")
                return (
                    Y(),
                    ft("div", null, [
                        JI,
                        xt("div", QI, [Ut(Es, { series: r.value, image: n.value, isLink: "" }, null, 8, ["series", "image"])]),
                        xt("div", XI, [
                            ZI,
                            Ut(
                                Es,
                                {
                                    style: { position: "absolute", top: "17%", right: "20%", left: "20%" },
                                    series: r.value,
                                    image: n.value,
                                    isLink: "",
                                },
                                null,
                                8,
                                ["series", "image"]
                            ),
                        ]),
                        xt("div", tB, [
                            Ut(h, { onClick: o, disabled: r.value == 1 }, { default: Ct(() => [eB]), _: 1 }, 8, ["disabled"]),
                            Ut(h, { class: "ms-2", onClick: i, disabled: n.value == 1 && r.value == 1 }, { default: Ct(() => [rB]), _: 1 }, 8, [
                                "disabled",
                            ]),
                            Ut(
                                h,
                                {
                                    class: "ms-2",
                                    onClick: s,
                                    disabled: r.value == V(t).series.length - 1 && n.value == V(t).series[r.value].images,
                                },
                                { default: Ct(() => [nB]), _: 1 },
                                8,
                                ["disabled"]
                            ),
                            Ut(
                                h,
                                { class: "ms-2", onClick: l, disabled: r.value == V(t).series.length - 1 },
                                { default: Ct(() => [iB]), _: 1 },
                                8,
                                ["disabled"]
                            ),
                        ]),
                        sB,
                        oB,
                        (Y(!0),
                        ft(
                            Yt,
                            null,
                            Pe(
                                V(t).series.slice(1),
                                (E, T) => (
                                    Y(),
                                    ft("div", aB, [
                                        xt("div", lB, [
                                            Ut(
                                                Es,
                                                { class: "col", style: { width: "25%" }, series: T + 1, image: 1, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                            Ut(
                                                Es,
                                                { class: "col", style: { width: "25%" }, series: T + 1, image: 2, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                            Ut(
                                                Es,
                                                { class: "col", style: { width: "25%" }, series: T + 1, image: 3, isLink: "", hideQR: "" },
                                                null,
                                                8,
                                                ["series"]
                                            ),
                                        ]),
                                        xt("h3", null, jt(E.name) + " (" + jt(E.images) + " works)", 1),
                                    ])
                                )
                            ),
                            256
                        )),
                        xt("div", uB, [
                            fB,
                            Ut(y, { to: "/slide/1" }, { default: Ct(() => [Ut(h, null, { default: Ct(() => [cB]), _: 1 })]), _: 1 }),
                            Ut(
                                y,
                                { class: "ms-2", to: "/slide/2" },
                                { default: Ct(() => [Ut(h, null, { default: Ct(() => [dB]), _: 1 })]), _: 1 }
                            ),
                            Ut(
                                y,
                                { class: "ms-2", to: "/slide/3" },
                                { default: Ct(() => [Ut(h, null, { default: Ct(() => [hB]), _: 1 })]), _: 1 }
                            ),
                            Ut(
                                y,
                                { class: "ms-2", to: "/slide/4" },
                                { default: Ct(() => [Ut(h, null, { default: Ct(() => [pB]), _: 1 })]), _: 1 }
                            ),
                        ]),
                        gB,
                    ])
                )
            }
        },
    }),
    vB = { class: "text-center" },
    bB = { style: { position: "relative" } },
    yB = { class: "text-center" },
    _B = bt({
        __name: "ImageDetail",
        setup(e) {
            const t = Ie("app"),
                r = rv(),
                n = Ht(parseInt(r.params.series)),
                i = Ht(parseInt(r.params.image))
            return (
                Oe(
                    () => r.params,
                    (s) => {
                        ;(n.value = parseInt(s.series)), (i.value = parseInt(s.image))
                    }
                ),
                (s, o) => (
                    Y(),
                    ft("div", null, [
                        xt("div", vB, [xt("h1", null, jt(V(t).series[n.value].name) + " " + jt(i.value), 1)]),
                        xt("div", bB, [Ut(Es, { series: n.value, image: i.value }, null, 8, ["series", "image"])]),
                        xt("div", yB, [xt("h3", null, jt(V(t).series[n.value].description), 1)]),
                    ])
                )
            )
        },
    }),
    wB = bt({
        __name: "SlideShow",
        setup(e) {
            const t = Ie("app"),
                r = rv(),
                n = Ht(parseInt(r.params.screen)),
                i = Ht(Date.now()),
                s = cc(() => Math.floor((i.value / 3e4) % (t.series.length - 1)) + 1),
                o = cc(() => n.value)
            return (
                setInterval(() => {
                    i.value = Date.now()
                }),
                (l, f) => (Y(), ft("div", null, [Ut(Es, { series: V(s), image: V(o) }, null, 8, ["series", "image"])]))
            )
        },
    }),
    AB = bt({
        __name: "Manager",
        setup(e) {
            const t = Ie("app")
            return (r, n) => (Y(), ft("div", null, jt(V(t).web3.connected), 1))
        },
    }),
    Xl = [
        {
            inputs: [
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "aggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes[]", name: "returnData", type: "bytes[]" },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "blockAndAggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes32", name: "blockHash", type: "bytes32" },
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
            name: "getBlockHash",
            outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getBlockNumber",
            outputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockCoinbase",
            outputs: [{ internalType: "address", name: "coinbase", type: "address" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockDifficulty",
            outputs: [{ internalType: "uint256", name: "difficulty", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockGasLimit",
            outputs: [{ internalType: "uint256", name: "gaslimit", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getCurrentBlockTimestamp",
            outputs: [{ internalType: "uint256", name: "timestamp", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [{ internalType: "address", name: "addr", type: "address" }],
            name: "getEthBalance",
            outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [],
            name: "getLastBlockHash",
            outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
            stateMutability: "view",
            type: "function",
        },
        {
            inputs: [
                { internalType: "bool", name: "requireSuccess", type: "bool" },
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "tryAggregate",
            outputs: [
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
        {
            inputs: [
                { internalType: "bool", name: "requireSuccess", type: "bool" },
                {
                    components: [
                        { internalType: "address", name: "target", type: "address" },
                        { internalType: "bytes", name: "callData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Call[]",
                    name: "calls",
                    type: "tuple[]",
                },
            ],
            name: "tryBlockAndAggregate",
            outputs: [
                { internalType: "uint256", name: "blockNumber", type: "uint256" },
                { internalType: "bytes32", name: "blockHash", type: "bytes32" },
                {
                    components: [
                        { internalType: "bool", name: "success", type: "bool" },
                        { internalType: "bytes", name: "returnData", type: "bytes" },
                    ],
                    internalType: "struct Multicall2.Result[]",
                    name: "returnData",
                    type: "tuple[]",
                },
            ],
            stateMutability: "nonpayable",
            type: "function",
        },
    ],
    gy =
        "0x608060405234801561001057600080fd5b506110ee806100206000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806372425d9d1161007157806372425d9d146101a657806386d516e8146101c4578063a8b0574e146101e2578063bce38bd714610200578063c3077fa914610230578063ee82ac5e14610262576100b4565b80630f28c97d146100b9578063252dba42146100d757806327e86d6e14610108578063399542e91461012657806342cbb15c146101585780634d2301cc14610176575b600080fd5b6100c1610292565b6040516100ce91906106a3565b60405180910390f35b6100f160048036038101906100ec91906109d2565b61029a565b6040516100ff929190610b65565b60405180910390f35b610110610423565b60405161011d9190610bae565b60405180910390f35b610140600480360381019061013b9190610c01565b610438565b60405161014f93929190610d6b565b60405180910390f35b610160610457565b60405161016d91906106a3565b60405180910390f35b610190600480360381019061018b9190610da9565b61045f565b60405161019d91906106a3565b60405180910390f35b6101ae610480565b6040516101bb91906106a3565b60405180910390f35b6101cc610488565b6040516101d991906106a3565b60405180910390f35b6101ea610490565b6040516101f79190610de5565b60405180910390f35b61021a60048036038101906102159190610c01565b610498565b6040516102279190610e00565b60405180910390f35b61024a600480360381019061024591906109d2565b610640565b60405161025993929190610d6b565b60405180910390f35b61027c60048036038101906102779190610e4e565b610663565b6040516102899190610bae565b60405180910390f35b600042905090565b60006060439150825167ffffffffffffffff8111156102bc576102bb6106e8565b5b6040519080825280602002602001820160405280156102ef57816020015b60608152602001906001900390816102da5790505b50905060005b835181101561041d5760008085838151811061031457610313610e7b565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1686848151811061034957610348610e7b565b5b6020026020010151602001516040516103629190610ee6565b6000604051808303816000865af19150503d806000811461039f576040519150601f19603f3d011682016040523d82523d6000602084013e6103a4565b606091505b5091509150816103e9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103e090610f5a565b60405180910390fd5b808484815181106103fd576103fc610e7b565b5b60200260200101819052505050808061041590610fa9565b9150506102f5565b50915091565b60006001436104329190610ff2565b40905090565b60008060604392504340915061044e8585610498565b90509250925092565b600043905090565b60008173ffffffffffffffffffffffffffffffffffffffff16319050919050565b600044905090565b600045905090565b600041905090565b6060815167ffffffffffffffff8111156104b5576104b46106e8565b5b6040519080825280602002602001820160405280156104ee57816020015b6104db61066e565b8152602001906001900390816104d35790505b50905060005b82518110156106395760008084838151811061051357610512610e7b565b5b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1685848151811061054857610547610e7b565b5b6020026020010151602001516040516105619190610ee6565b6000604051808303816000865af19150503d806000811461059e576040519150601f19603f3d011682016040523d82523d6000602084013e6105a3565b606091505b509150915085156105ef57816105ee576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105e590611098565b60405180910390fd5b5b604051806040016040528083151581526020018281525084848151811061061957610618610e7b565b5b60200260200101819052505050808061063190610fa9565b9150506104f4565b5092915050565b6000806060610650600185610438565b8093508194508295505050509193909250565b600081409050919050565b6040518060400160405280600015158152602001606081525090565b6000819050919050565b61069d8161068a565b82525050565b60006020820190506106b86000830184610694565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b610720826106d7565b810181811067ffffffffffffffff8211171561073f5761073e6106e8565b5b80604052505050565b60006107526106be565b905061075e8282610717565b919050565b600067ffffffffffffffff82111561077e5761077d6106e8565b5b602082029050602081019050919050565b600080fd5b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006107c98261079e565b9050919050565b6107d9816107be565b81146107e457600080fd5b50565b6000813590506107f6816107d0565b92915050565b600080fd5b600067ffffffffffffffff82111561081c5761081b6106e8565b5b610825826106d7565b9050602081019050919050565b82818337600083830152505050565b600061085461084f84610801565b610748565b9050828152602081018484840111156108705761086f6107fc565b5b61087b848285610832565b509392505050565b600082601f830112610898576108976106d2565b5b81356108a8848260208601610841565b91505092915050565b6000604082840312156108c7576108c6610794565b5b6108d16040610748565b905060006108e1848285016107e7565b600083015250602082013567ffffffffffffffff81111561090557610904610799565b5b61091184828501610883565b60208301525092915050565b600061093061092b84610763565b610748565b905080838252602082019050602084028301858111156109535761095261078f565b5b835b8181101561099a57803567ffffffffffffffff811115610978576109776106d2565b5b80860161098589826108b1565b85526020850194505050602081019050610955565b5050509392505050565b600082601f8301126109b9576109b86106d2565b5b81356109c984826020860161091d565b91505092915050565b6000602082840312156109e8576109e76106c8565b5b600082013567ffffffffffffffff811115610a0657610a056106cd565b5b610a12848285016109a4565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610a81578082015181840152602081019050610a66565b83811115610a90576000848401525b50505050565b6000610aa182610a47565b610aab8185610a52565b9350610abb818560208601610a63565b610ac4816106d7565b840191505092915050565b6000610adb8383610a96565b905092915050565b6000602082019050919050565b6000610afb82610a1b565b610b058185610a26565b935083602082028501610b1785610a37565b8060005b85811015610b535784840389528151610b348582610acf565b9450610b3f83610ae3565b925060208a01995050600181019050610b1b565b50829750879550505050505092915050565b6000604082019050610b7a6000830185610694565b8181036020830152610b8c8184610af0565b90509392505050565b6000819050919050565b610ba881610b95565b82525050565b6000602082019050610bc36000830184610b9f565b92915050565b60008115159050919050565b610bde81610bc9565b8114610be957600080fd5b50565b600081359050610bfb81610bd5565b92915050565b60008060408385031215610c1857610c176106c8565b5b6000610c2685828601610bec565b925050602083013567ffffffffffffffff811115610c4757610c466106cd565b5b610c53858286016109a4565b9150509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b610c9281610bc9565b82525050565b6000604083016000830151610cb06000860182610c89565b5060208301518482036020860152610cc88282610a96565b9150508091505092915050565b6000610ce18383610c98565b905092915050565b6000602082019050919050565b6000610d0182610c5d565b610d0b8185610c68565b935083602082028501610d1d85610c79565b8060005b85811015610d595784840389528151610d3a8582610cd5565b9450610d4583610ce9565b925060208a01995050600181019050610d21565b50829750879550505050505092915050565b6000606082019050610d806000830186610694565b610d8d6020830185610b9f565b8181036040830152610d9f8184610cf6565b9050949350505050565b600060208284031215610dbf57610dbe6106c8565b5b6000610dcd848285016107e7565b91505092915050565b610ddf816107be565b82525050565b6000602082019050610dfa6000830184610dd6565b92915050565b60006020820190508181036000830152610e1a8184610cf6565b905092915050565b610e2b8161068a565b8114610e3657600080fd5b50565b600081359050610e4881610e22565b92915050565b600060208284031215610e6457610e636106c8565b5b6000610e7284828501610e39565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081905092915050565b6000610ec082610a47565b610eca8185610eaa565b9350610eda818560208601610a63565b80840191505092915050565b6000610ef28284610eb5565b915081905092915050565b600082825260208201905092915050565b7f4d756c746963616c6c206167677265676174653a2063616c6c206661696c6564600082015250565b6000610f44602083610efd565b9150610f4f82610f0e565b602082019050919050565b60006020820190508181036000830152610f7381610f37565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610fb48261068a565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610fe757610fe6610f7a565b5b600182019050919050565b6000610ffd8261068a565b91506110088361068a565b92508282101561101b5761101a610f7a565b5b828203905092915050565b7f4d756c746963616c6c32206167677265676174653a2063616c6c206661696c6560008201527f6400000000000000000000000000000000000000000000000000000000000000602082015250565b6000611082602183610efd565b915061108d82611026565b604082019050919050565b600060208201905081810360008301526110b181611075565b905091905056fea26469706673582212202ad79168f7d1dfe0e32b590efa8eefaaaf0c61e9f6257161be30bcbab1ad332264736f6c63430008090033",
    EB = (e) => e.length > 1
class gh extends k5 {
    constructor(...t) {
        var r = (...n) => {
            super(...n)
        }
        EB(t) ? r(...t) : r(Xl, gy, t[0]), (this.contractName = "Multicall2")
    }
    deploy(t) {
        return super.deploy(t || {})
    }
    getDeployTransaction(t) {
        return super.getDeployTransaction(t || {})
    }
    attach(t) {
        return super.attach(t)
    }
    connect(t) {
        return super.connect(t)
    }
    static createInterface() {
        return new Bc(Xl)
    }
    static connect(t, r) {
        return new Fc(t, Xl, r)
    }
}
gh.bytecode = gy
gh.abi = Xl
var Nt = ((e) => (
    (e[(e.NONE = 0)] = "NONE"),
    (e[(e.ETHEREUM = 1)] = "ETHEREUM"),
    (e[(e.ROPSTEN = 3)] = "ROPSTEN"),
    (e[(e.KOVAN = 42)] = "KOVAN"),
    (e[(e.RINKEBY = 4)] = "RINKEBY"),
    (e[(e.GOERLI = 5)] = "GOERLI"),
    (e[(e.OPTIMISM = 10)] = "OPTIMISM"),
    (e[(e.BINANCE = 56)] = "BINANCE"),
    (e[(e.OKEX_TEST = 65)] = "OKEX_TEST"),
    (e[(e.OKEX = 66)] = "OKEX"),
    (e[(e.BINANCE_TEST = 98)] = "BINANCE_TEST"),
    (e[(e.FUSE = 122)] = "FUSE"),
    (e[(e.POLYGON = 137)] = "POLYGON"),
    (e[(e.POLYGON_TEST = 80001)] = "POLYGON_TEST"),
    (e[(e.XDAI = 100)] = "XDAI"),
    (e[(e.HUOBI = 128)] = "HUOBI"),
    (e[(e.HUOBI_TEST = 256)] = "HUOBI_TEST"),
    (e[(e.ENERGY_WEB_CHAIN = 246)] = "ENERGY_WEB_CHAIN"),
    (e[(e.ENERGY_WEB_CHAIN_TEST = 73799)] = "ENERGY_WEB_CHAIN_TEST"),
    (e[(e.ARBITRUM = 42161)] = "ARBITRUM"),
    (e[(e.ARBITRUM_TEST = 421611)] = "ARBITRUM_TEST"),
    (e[(e.AVALANCHE = 43114)] = "AVALANCHE"),
    (e[(e.AVALANCHE_TEST = 43113)] = "AVALANCHE_TEST"),
    (e[(e.TOMO = 88)] = "TOMO"),
    (e[(e.TOMO_TEST = 89)] = "TOMO_TEST"),
    (e[(e.FANTOM = 250)] = "FANTOM"),
    (e[(e.FANTOM_TEST = 4002)] = "FANTOM_TEST"),
    (e[(e.MOONBEAM = 1284)] = "MOONBEAM"),
    (e[(e.MOONBEAM_KUSAMA = 1285)] = "MOONBEAM_KUSAMA"),
    (e[(e.MOONBEAM_TEST = 1287)] = "MOONBEAM_TEST"),
    (e[(e.HARDHAT = 31337)] = "HARDHAT"),
    (e[(e.CELO = 42220)] = "CELO"),
    (e[(e.HARMONY = 16666e5)] = "HARMONY"),
    (e[(e.HARMONY_TEST = 16667e5)] = "HARMONY_TEST"),
    (e[(e.PALM = 11297108109)] = "PALM"),
    (e[(e.TELOS = 40)] = "TELOS"),
    (e[(e.BOBA = 288)] = "BOBA"),
    (e[(e.AURORA = 1313161554)] = "AURORA"),
    (e[(e.AURORA_TEST = 1313161555)] = "AURORA_TEST"),
    (e[(e.AURORA_BETA = 1313161556)] = "AURORA_BETA"),
    (e[(e.UBIQ = 8)] = "UBIQ"),
    (e[(e.UBIQ_TEST = 9)] = "UBIQ_TEST"),
    (e[(e.CRONOS = 25)] = "CRONOS"),
    (e[(e.KLAYTN = 8217)] = "KLAYTN"),
    (e[(e.METIS = 1088)] = "METIS"),
    (e[(e.METIS_TEST = 588)] = "METIS_TEST"),
    e
))(Nt || {})
class ir {
    constructor(t) {
        ;(this.items = []), t ? (this.provider = t) : (this.provider = new oT({ url: this.rpcUrls[0] }))
    }
    static get chainId() {
        return Nt.NONE
    }
    static get chainName() {
        return "None"
    }
    static get nativeCurrency() {
        return { name: "None", symbol: "NONE", decimals: 18 }
    }
    static get rpcUrls() {
        return []
    }
    static get blockExplorerUrls() {
        return []
    }
    static get multiCallAddress() {
        return ""
    }
    static get chainParams() {
        return {
            chainId: Ld(Lt(this.chainId)),
            chainName: this.chainName,
            nativeCurrency: this.nativeCurrency,
            rpcUrls: this.rpcUrls,
            blockExplorerUrls: this.blockExplorerUrls,
        }
    }
    static get coinGeckoId() {
        return ""
    }
    get type() {
        return this.constructor
    }
    get chainId() {
        return this.type.chainId
    }
    get chainName() {
        return this.type.chainName
    }
    get nativeCurrency() {
        return this.type.nativeCurrency
    }
    get rpcUrls() {
        return this.type.rpcUrls
    }
    get blockExplorerUrls() {
        return this.type.blockExplorerUrls
    }
    get multiCallAddress() {
        return this.type.multiCallAddress
    }
    get coinGeckoId() {
        return this.type.coinGeckoId
    }
    queue(t, r, n, i) {
        this.items.push({ transactionPromise: t, contractInterface: r, callback: n, failcallback: i })
    }
    async call(t = 0) {
        const r = []
        for (; this.items.length; ) {
            const n = gh.connect(this.multiCallAddress, this.provider),
                i = this.items.splice(0, t || this.items.length)
            for (let l in i) i[l].transaction = await i[l].transactionPromise
            const s = i.map((l) => ({ target: l.transaction.to, callData: l.transaction.data })),
                o = await n.callStatic.tryAggregate(!1, s)
            i.forEach((l, f) => {
                var d
                if (o[f].success) {
                    let h = o[f].returnData
                    if (l.contractInterface)
                        try {
                            ;(h = l.contractInterface.decodeFunctionResult(
                                l.contractInterface.parseTransaction({ data: ((d = l.transaction) == null ? void 0 : d.data) || "" }).name,
                                o[f].returnData
                            )),
                                l.callback && l.callback(h.length === 1 ? h[0] : h, l.transaction)
                        } catch (y) {
                            console.log(y)
                        }
                    r.push(h.length === 1 ? h[0] : h)
                } else l.failcallback && l.failcallback(l.transaction), console.log("Fail"), r.push(new Error("Failed"))
            })
        }
        return r
    }
}
class Ws extends ir {
    static get chainId() {
        return Nt.ETHEREUM
    }
    static get chainName() {
        return "Ethereum"
    }
    static get nativeCurrency() {
        return { name: "Ethereum", symbol: "ETH", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://mainnet.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://etherscan.io/"]
    }
    static get multiCallAddress() {
        return "0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696"
    }
    static get coinGeckoId() {
        return "ethereum"
    }
}
class xB extends Ws {
    static get chainId() {
        return Nt.ROPSTEN
    }
    static get chainName() {
        return "Ropsten"
    }
    static get rpcUrls() {
        return ["https://ropsten.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://ropsten.etherscan.io/"]
    }
    static get coinGeckoId() {
        return "ethereum"
    }
}
class TB extends Ws {
    static get chainId() {
        return Nt.KOVAN
    }
    static get chainName() {
        return "Kovan"
    }
    static get rpcUrls() {
        return ["https://kovan.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://kovan.etherscan.io/"]
    }
}
class CB extends Ws {
    static get chainId() {
        return Nt.RINKEBY
    }
    static get chainName() {
        return "Rinkeby"
    }
    static get rpcUrls() {
        return ["https://rinkeby.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://rinkeby.etherscan.io/"]
    }
}
class MB extends Ws {
    static get chainId() {
        return Nt.GOERLI
    }
    static get chainName() {
        return "G\xF6rli"
    }
    static get rpcUrls() {
        return ["https://goerli.infura.io/v3/845b3e08e20a41f185f36a2b73cfa5e4"]
    }
    static get blockExplorerUrls() {
        return ["https://goerli.etherscan.io/"]
    }
}
class my extends ir {
    static get chainId() {
        return Nt.BINANCE
    }
    static get chainName() {
        return "Binance Smart Chain"
    }
    static get nativeCurrency() {
        return { name: "BNB", symbol: "BNB", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://bsc-dataseed.binance.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://bscscan.com/"]
    }
    static get multiCallAddress() {
        return "0xa9193376D09C7f31283C54e56D013fCF370Cd9D9"
    }
    static get coinGeckoId() {
        return "binance-smart-chain"
    }
}
class SB extends my {
    static get chainId() {
        return Nt.BINANCE_TEST
    }
    static get chainName() {
        return "Binance Smart Chain Testnet"
    }
    static get rpcUrls() {
        return ["https://data-seed-prebsc-1-s1.binance.org:8545/"]
    }
    static get blockExplorerUrls() {
        return ["https://testnet.bscscan.com/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class kB extends ir {
    static get chainId() {
        return Nt.FUSE
    }
    static get chainName() {
        return "Fuse"
    }
    static get nativeCurrency() {
        return { name: "Fuse", symbol: "FUSE", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.fuse.io/"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.fuse.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
    static get coinGeckoId() {
        return "fuse"
    }
}
class vy extends ir {
    static get chainId() {
        return Nt.POLYGON
    }
    static get chainName() {
        return "Polygon"
    }
    static get nativeCurrency() {
        return { name: "MATIC", symbol: "MATIC", decimals: 18 }
    }
    static get rpcUrls() {
        return [
            "https://matic-mainnet.chainstacklabs.com/",
            "https://rpc-mainnet.matic.network/",
            "https://rpc-mainnet.maticvigil.com/",
            "https://rpc-mainnet.matic.quiknode.pro/",
            "https://matic-mainnet-full-rpc.bwarelabs.com/",
            "https://matic-mainnet-archive-rpc.bwarelabs.com/",
        ]
    }
    static get blockExplorerUrls() {
        return [
            "https://polygonscan.com/",
            "https://polygon-explorer-mainnet.chainstacklabs.com/",
            "https://explorer-mainnet.maticvigil.com/",
            "https://explorer.matic.network/",
            "https://backup-explorer.matic.network/",
        ]
    }
    static get multiCallAddress() {
        return "0x02817C1e3543c2d908a590F5dB6bc97f933dB4BD"
    }
    static get coinGeckoId() {
        return "polygon-pos"
    }
}
class NB extends vy {
    static get chainId() {
        return Nt.POLYGON_TEST
    }
    static get chainName() {
        return "Mumbai (Polygon Testnet)"
    }
    static get rpcUrls() {
        return [
            "https://matic-mumbai.chainstacklabs.com/",
            "https://rpc-mumbai.matic.today/",
            "https://rpc-mumbai.maticvigil.com/",
            "https://matic-testnet-archive-rpc.bwarelabs.com/",
        ]
    }
    static get blockExplorerUrls() {
        return [
            "https://mumbai.polygonscan.com/",
            "https://polygon-explorer-mumbai.chainstacklabs.com/",
            "https://explorer-mumbai.maticvigil.com/",
            "https://mumbai-explorer.matic.today/",
            "https://backup-mumbai-explorer.matic.today/",
        ]
    }
    static get multiCallAddress() {
        return "0xc1400d49baa8e307B4462cD46E0a20109D25F50f"
    }
}
class OB extends ir {
    static get chainId() {
        return Nt.XDAI
    }
    static get chainName() {
        return "Gnosis (xDai)"
    }
    static get nativeCurrency() {
        return { name: "xDai", symbol: "xDAI", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.gnosischain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://blockscout.com/xdai/mainnet/"]
    }
    static get multiCallAddress() {
        return "0x67dA5f2FfaDDfF067AB9d5F025F8810634d84287"
    }
    static get coinGeckoId() {
        return "xdai"
    }
}
class by extends ir {
    static get chainId() {
        return Nt.HUOBI
    }
    static get chainName() {
        return "Heco"
    }
    static get nativeCurrency() {
        return { name: "HT", symbol: "HT", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://http-mainnet-node.huobichain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.hecochain.io/", "https://hecoinfo.com/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
    static get coinGeckoId() {
        return "huobi-token"
    }
}
class IB extends by {
    static get chainId() {
        return Nt.HUOBI_TEST
    }
    static get chainName() {
        return "Heco Testnet"
    }
    static get rpcUrls() {
        return ["https://http-testnet.hecochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan-testnet.hecochain.com/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class yy extends Ws {
    static get chainId() {
        return Nt.ARBITRUM
    }
    static get chainName() {
        return "Arbitrum"
    }
    static get rpcUrls() {
        return ["https://arb1.arbitrum.io/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://arbiscan.io/"]
    }
    static get multiCallAddress() {
        return "0x80C7DD17B01855a6D2347444a0FCC36136a314de"
    }
    static get coinGeckoId() {
        return "arbitrum-one"
    }
}
class BB extends yy {
    static get chainId() {
        return Nt.ARBITRUM_TEST
    }
    static get chainName() {
        return "Arbitrum Testnet"
    }
    static get rpcUrls() {
        return ["https://rinkeby.arbitrum.io/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://rinkeby-explorer.arbitrum.io/"]
    }
    static get multiCallAddress() {
        return "0xa501c031958F579dB7676fF1CE78AD305794d579"
    }
}
class _y extends ir {
    static get chainId() {
        return Nt.AVALANCHE
    }
    static get chainName() {
        return "Avalanche Mainnet C-Chain"
    }
    static get nativeCurrency() {
        return { name: "Avalanche", symbol: "AVAX", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://api.avax.network/ext/bc/C/rpc"]
    }
    static get blockExplorerUrls() {
        return ["https://cchain.explorer.avax.network/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
    static get coinGeckoId() {
        return "avalanche"
    }
}
class PB extends _y {
    static get chainId() {
        return Nt.AVALANCHE_TEST
    }
    static get chainName() {
        return "Avalanche Testnet C-Chain"
    }
    static get rpcUrls() {
        return ["https://api.avax-test.network/ext/bc/C/rpc/"]
    }
    static get blockExplorerUrls() {
        return ["https://cchain.explorer.avax-test.network/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class wy extends ir {
    static get chainId() {
        return Nt.TOMO
    }
    static get chainName() {
        return "TomoChain"
    }
    static get nativeCurrency() {
        return { name: "TOMO", symbol: "TOMO", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.tomochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan.tomochain.com/"]
    }
    static get coinGeckoId() {
        return "tomochain"
    }
}
class RB extends wy {
    static get chainId() {
        return Nt.TOMO_TEST
    }
    static get chainName() {
        return "TomoChain Testnet"
    }
    static get rpcUrls() {
        return ["https://rpc.testnet.tomochain.com/"]
    }
    static get blockExplorerUrls() {
        return ["https://scan.testnet.tomochain.com/"]
    }
}
class Ay extends ir {
    static get chainId() {
        return Nt.FANTOM
    }
    static get chainName() {
        return "Fantom Opera"
    }
    static get nativeCurrency() {
        return { name: "FTM", symbol: "FTM", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.ftm.tools/"]
    }
    static get blockExplorerUrls() {
        return ["https://ftmscan.com/"]
    }
    static get multiCallAddress() {
        return "0x22D4cF72C45F8198CfbF4B568dBdB5A85e8DC0B5"
    }
    static get coinGeckoId() {
        return "fantom"
    }
}
class LB extends Ay {
    static get chainId() {
        return Nt.FANTOM
    }
    static get chainName() {
        return "Fantom Testnet"
    }
    static get rpcUrls() {
        return ["https://rpc.testnet.fantom.network/"]
    }
    static get blockExplorerUrls() {
        return []
    }
    static get multiCallAddress() {
        return ""
    }
}
class DB extends ir {
    static get chainId() {
        return Nt.MOONBEAM
    }
    static get chainName() {
        return "Moonbeam"
    }
    static get nativeCurrency() {
        return { name: "Moonbeam", symbol: "GLMR", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://moonscan.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
}
class $B extends ir {
    static get chainId() {
        return Nt.MOONBEAM_TEST
    }
    static get chainName() {
        return "Moonbase Alpha"
    }
    static get nativeCurrency() {
        return { name: "DEV", symbol: "DEV", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonbase.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://moonbase-blockscout.testnet.moonbeam.network/"]
    }
}
class FB extends ir {
    static get chainId() {
        return Nt.MOONBEAM_KUSAMA
    }
    static get chainName() {
        return "Moonriver"
    }
    static get nativeCurrency() {
        return { name: "MOVR", symbol: "MOVR", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://rpc.api.moonriver.moonbeam.network"]
    }
    static get blockExplorerUrls() {
        return ["https://blockscout.moonriver.moonbeam.network/"]
    }
    static get multiCallAddress() {
        return "0x270f2F35bED92B7A59eA5F08F6B3fd34c8D9D9b5"
    }
    static get coinGeckoId() {
        return "moonriver"
    }
}
class VB extends Ws {
    static get chainId() {
        return Nt.HARDHAT
    }
    static get chainName() {
        return "Hardhat"
    }
    static get rpcUrls() {
        return ["http://127.0.0.1:8545/"]
    }
    static get blockExplorerUrls() {
        return ["https://localhost:2504/"]
    }
}
class UB extends ir {
    static get chainId() {
        return Nt.CELO
    }
    static get chainName() {
        return "Celo"
    }
    static get nativeCurrency() {
        return { name: "Celo", symbol: "CELO", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://forno.celo.org"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.celo.org/"]
    }
    static get multiCallAddress() {
        return "0x9aac9048fC8139667D6a2597B902865bfdc225d3"
    }
    static get coinGeckoId() {
        return "celo"
    }
}
class Ey extends ir {
    static get chainId() {
        return Nt.HARMONY
    }
    static get chainName() {
        return "Harmony"
    }
    static get nativeCurrency() {
        return { name: "Harmony", symbol: "ONE", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://api.harmony.one"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.harmony.one/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
}
class HB extends Ey {
    static get chainId() {
        return Nt.HARMONY_TEST
    }
    static get chainName() {
        return "Harmony Testnet"
    }
    static get rpcUrls() {
        return ["https://api.s0.b.hmny.io/"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.pops.one/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class xy extends ir {
    static get chainId() {
        return Nt.OKEX
    }
    static get chainName() {
        return "OKExChain"
    }
    static get nativeCurrency() {
        return { name: "OEC Token", symbol: "OKT", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://exchainrpc.okex.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.oklink.com/oec/"]
    }
    static get multiCallAddress() {
        return "0xF4d73326C13a4Fc5FD7A064217e12780e9Bd62c3"
    }
    static get coinGeckoId() {
        return "okex-chain"
    }
}
class qB extends xy {
    static get chainId() {
        return Nt.OKEX_TEST
    }
    static get chainName() {
        return "OKExChain Testnet"
    }
    static get rpcUrls() {
        return ["https://exchaintestrpc.okex.org/"]
    }
    static get blockExplorerUrls() {
        return ["https://www.oklink.com/oec-test/"]
    }
    static get multiCallAddress() {
        return ""
    }
}
class zB extends ir {
    static get chainId() {
        return Nt.PALM
    }
    static get chainName() {
        return "Palm"
    }
    static get nativeCurrency() {
        return { name: "Palm", symbol: "PALM", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://palm-mainnet.infura.io/v3/3a961d6501e54add9a41aa53f15de99b"]
    }
    static get blockExplorerUrls() {
        return ["https://explorer.palm.io/"]
    }
    static get multiCallAddress() {
        return "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F"
    }
}
class jB extends ir {
    static get chainId() {
        return Nt.TELOS
    }
    static get chainName() {
        return "Telos"
    }
    static get nativeCurrency() {
        return { name: "Telos", symbol: "TLOS", decimals: 18 }
    }
    static get rpcUrls() {
        return ["https://mainnet.telos.net/evm"]
    }
    static get blockExplorerUrls() {
        return ["https://rpc1.us.telos.net/v2/explore/"]
    }
    static get multiCallAddress() {
        return "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3"
    }
}
const fg = {
    [Nt.NONE]: ir,
    [Nt.ETHEREUM]: Ws,
    [Nt.ROPSTEN]: xB,
    [Nt.KOVAN]: TB,
    [Nt.RINKEBY]: CB,
    [Nt.GOERLI]: MB,
    [Nt.BINANCE]: my,
    [Nt.BINANCE_TEST]: SB,
    [Nt.FUSE]: kB,
    [Nt.POLYGON]: vy,
    [Nt.POLYGON_TEST]: NB,
    [Nt.XDAI]: OB,
    [Nt.HUOBI]: by,
    [Nt.HUOBI_TEST]: IB,
    [Nt.ARBITRUM]: yy,
    [Nt.ARBITRUM_TEST]: BB,
    [Nt.AVALANCHE]: _y,
    [Nt.AVALANCHE_TEST]: PB,
    [Nt.TOMO]: wy,
    [Nt.TOMO_TEST]: RB,
    [Nt.FANTOM]: Ay,
    [Nt.FANTOM_TEST]: LB,
    [Nt.MOONBEAM]: DB,
    [Nt.MOONBEAM_TEST]: $B,
    [Nt.MOONBEAM_KUSAMA]: FB,
    [Nt.HARDHAT]: VB,
    [Nt.CELO]: UB,
    [Nt.HARMONY]: Ey,
    [Nt.HARMONY_TEST]: HB,
    [Nt.OKEX]: xy,
    [Nt.OKEX_TEST]: qB,
    [Nt.PALM]: zB,
    [Nt.TELOS]: jB,
}
class KB {
    constructor() {
        ;(this.name = "Loading..."),
            (this.walletProvider = 1),
            (this.connected = !1),
            (this.chainId = Nt.NONE),
            (this.address = ""),
            (this.addresses = []),
            (this.block = 0),
            (this.queue = Ze([])),
            (this.active = K(() => this.queue.filter((t) => t.status === "Signing" || t.status === "Sending" || t.status === "Pending")))
    }
    connect() {
        this.connected && window.ethereum.request && window.ethereum.request({ method: "eth_requestAccounts" })
    }
    switch(t) {
        window.ethereum &&
            window.ethereum.request &&
            window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: Ld(Lt(t)) }] }).catch((r) => {
                console.log(r),
                    r.code == 4902 &&
                        window.ethereum &&
                        window.ethereum.request &&
                        window.ethereum.request({ method: "wallet_addEthereumChain", params: [fg[t].chainParams] })
            })
    }
    setup() {
        if (
            ((this.update = K(() => this.chainId + "|" + this.block + "|" + this.address)),
            (this.connector = K(() => (this.provider ? new fg[this.chainId](this.provider) : null))),
            window.ethereum && window.ethereum.request)
        ) {
            ;(this.provider = Oa(new hp(window.ethereum))),
                window.ethereum.isMetaMask ? (this.name = "MetaMask") : (this.name = "Other"),
                (window.ethereum.autoRefreshOnNetworkChange = !1)
            const t = (s) => {
                    this.block = s
                },
                r = (s) => {
                    var o
                    ;(this.chainId = Number(St.from(s))),
                        (this.connected = !0),
                        (o = this.provider) == null || o.off("block"),
                        (this.provider = Oa(new hp(window.ethereum))),
                        this.provider.on("block", t),
                        this.onAccountChanged && this.onAccountChanged(this.address)
                },
                n = (s) => {
                    r(s.chainId)
                },
                i = (s) => {
                    ;(this.addresses = s || []),
                        s && s.length
                            ? ((this.address = rr(s[0])), this.onAccountChanged && this.onAccountChanged(this.address))
                            : ((this.address = ""), this.onAccountChanged && this.onAccountChanged(this.address))
                }
            window.ethereum.on("accountsChanged", i),
                window.ethereum.on("chainChanged", r),
                window.ethereum.on("connect", n),
                window.ethereum.on("disconnect", (s) => {
                    ;(this.connected = !1), (this.block = 0)
                }),
                this.provider.on("block", t),
                window.ethereum
                    .request({ method: "eth_accounts" })
                    .then((s) => {
                        i(s), n({ chainId: window.ethereum.chainId })
                    })
                    .catch((s) => {
                        console.log("Error", s)
                    })
        } else this.name = "None"
    }
    async send(t, r, n) {
        const i = Ze({ status: "Signing", description: r })
        this.queue.push(i)
        try {
            ;(i.tx = await t),
                (i.status = "Pending"),
                (i.result = await i.tx.wait()),
                (i.status = "Confirmed"),
                (this.nonce = i.tx.nonce),
                n && n(i)
        } catch (s) {
            s.code == 4001 ? (i.status = "Cancelled") : (i.status = "Error"), console.log(s)
        }
    }
}
var Dl = Ze({
        title: "UnRealArt",
        name: "UnRealArt",
        web3: new KB(),
        series: [
            {},
            { name: "Inspired by my father", description: "Description", images: 11 },
            { name: "Smoking girl with goggles", description: "Description", images: 12 },
            { name: "Frogs in Space", description: "Description", images: 11 },
            { name: "Crazy Sushi", description: "Description", images: 7 },
            { name: "Wall street on fire", description: "Description", images: 6 },
        ],
    }),
    Zo = 1e9,
    GB = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
    },
    vh,
    Le = !0,
    Xr = "[DecimalError] ",
    ks = Xr + "Invalid argument: ",
    mh = Xr + "Exponent out of range: ",
    ta = Math.floor,
    ws = Math.pow,
    WB = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
    Or,
    tr = 1e7,
    Be = 7,
    Ty = 9007199254740991,
    Cu = ta(Ty / Be),
    It = {}
It.absoluteValue = It.abs = function () {
    var e = new this.constructor(this)
    return e.s && (e.s = 1), e
}
It.comparedTo = It.cmp = function (e) {
    var t,
        r,
        n,
        i,
        s = this
    if (((e = new s.constructor(e)), s.s !== e.s)) return s.s || -e.s
    if (s.e !== e.e) return (s.e > e.e) ^ (s.s < 0) ? 1 : -1
    for (n = s.d.length, i = e.d.length, t = 0, r = n < i ? n : i; t < r; ++t)
        if (s.d[t] !== e.d[t]) return (s.d[t] > e.d[t]) ^ (s.s < 0) ? 1 : -1
    return n === i ? 0 : (n > i) ^ (s.s < 0) ? 1 : -1
}
It.decimalPlaces = It.dp = function () {
    var e = this,
        t = e.d.length - 1,
        r = (t - e.e) * Be
    if (((t = e.d[t]), t)) for (; t % 10 == 0; t /= 10) r--
    return r < 0 ? 0 : r
}
It.dividedBy = It.div = function (e) {
    return ai(this, new this.constructor(e))
}
It.dividedToIntegerBy = It.idiv = function (e) {
    var t = this,
        r = t.constructor
    return Ne(ai(t, new r(e), 0, 1), r.precision)
}
It.equals = It.eq = function (e) {
    return !this.cmp(e)
}
It.exponent = function () {
    return Je(this)
}
It.greaterThan = It.gt = function (e) {
    return this.cmp(e) > 0
}
It.greaterThanOrEqualTo = It.gte = function (e) {
    return this.cmp(e) >= 0
}
It.isInteger = It.isint = function () {
    return this.e > this.d.length - 2
}
It.isNegative = It.isneg = function () {
    return this.s < 0
}
It.isPositive = It.ispos = function () {
    return this.s > 0
}
It.isZero = function () {
    return this.s === 0
}
It.lessThan = It.lt = function (e) {
    return this.cmp(e) < 0
}
It.lessThanOrEqualTo = It.lte = function (e) {
    return this.cmp(e) < 1
}
It.logarithm = It.log = function (e) {
    var t,
        r = this,
        n = r.constructor,
        i = n.precision,
        s = i + 5
    if (e === void 0) e = new n(10)
    else if (((e = new n(e)), e.s < 1 || e.eq(Or))) throw Error(Xr + "NaN")
    if (r.s < 1) throw Error(Xr + (r.s ? "NaN" : "-Infinity"))
    return r.eq(Or) ? new n(0) : ((Le = !1), (t = ai(Ka(r, s), Ka(e, s), s)), (Le = !0), Ne(t, i))
}
It.minus = It.sub = function (e) {
    var t = this
    return (e = new t.constructor(e)), t.s == e.s ? Sy(t, e) : Cy(t, ((e.s = -e.s), e))
}
It.modulo = It.mod = function (e) {
    var t,
        r = this,
        n = r.constructor,
        i = n.precision
    if (((e = new n(e)), !e.s)) throw Error(Xr + "NaN")
    return r.s ? ((Le = !1), (t = ai(r, e, 0, 1).times(e)), (Le = !0), r.minus(t)) : Ne(new n(r), i)
}
It.naturalExponential = It.exp = function () {
    return My(this)
}
It.naturalLogarithm = It.ln = function () {
    return Ka(this)
}
It.negated = It.neg = function () {
    var e = new this.constructor(this)
    return (e.s = -e.s || 0), e
}
It.plus = It.add = function (e) {
    var t = this
    return (e = new t.constructor(e)), t.s == e.s ? Cy(t, e) : Sy(t, ((e.s = -e.s), e))
}
It.precision = It.sd = function (e) {
    var t,
        r,
        n,
        i = this
    if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(ks + e)
    if (((t = Je(i) + 1), (n = i.d.length - 1), (r = n * Be + 1), (n = i.d[n]), n)) {
        for (; n % 10 == 0; n /= 10) r--
        for (n = i.d[0]; n >= 10; n /= 10) r++
    }
    return e && t > r ? t : r
}
It.squareRoot = It.sqrt = function () {
    var e,
        t,
        r,
        n,
        i,
        s,
        o,
        l = this,
        f = l.constructor
    if (l.s < 1) {
        if (!l.s) return new f(0)
        throw Error(Xr + "NaN")
    }
    for (
        e = Je(l),
            Le = !1,
            i = Math.sqrt(+l),
            i == 0 || i == 1 / 0
                ? ((t = In(l.d)),
                  (t.length + e) % 2 == 0 && (t += "0"),
                  (i = Math.sqrt(t)),
                  (e = ta((e + 1) / 2) - (e < 0 || e % 2)),
                  i == 1 / 0 ? (t = "5e" + e) : ((t = i.toExponential()), (t = t.slice(0, t.indexOf("e") + 1) + e)),
                  (n = new f(t)))
                : (n = new f(i.toString())),
            r = f.precision,
            i = o = r + 3;
        ;

    )
        if (((s = n), (n = s.plus(ai(l, s, o + 2)).times(0.5)), In(s.d).slice(0, o) === (t = In(n.d)).slice(0, o))) {
            if (((t = t.slice(o - 3, o + 1)), i == o && t == "4999")) {
                if ((Ne(s, r + 1, 0), s.times(s).eq(l))) {
                    n = s
                    break
                }
            } else if (t != "9999") break
            o += 4
        }
    return (Le = !0), Ne(n, r)
}
It.times = It.mul = function (e) {
    var t,
        r,
        n,
        i,
        s,
        o,
        l,
        f,
        d,
        h = this,
        y = h.constructor,
        E = h.d,
        T = (e = new y(e)).d
    if (!h.s || !e.s) return new y(0)
    for (
        e.s *= h.s,
            r = h.e + e.e,
            f = E.length,
            d = T.length,
            f < d && ((s = E), (E = T), (T = s), (o = f), (f = d), (d = o)),
            s = [],
            o = f + d,
            n = o;
        n--;

    )
        s.push(0)
    for (n = d; --n >= 0; ) {
        for (t = 0, i = f + n; i > n; ) (l = s[i] + T[n] * E[i - n - 1] + t), (s[i--] = l % tr | 0), (t = (l / tr) | 0)
        s[i] = (s[i] + t) % tr | 0
    }
    for (; !s[--o]; ) s.pop()
    return t ? ++r : s.shift(), (e.d = s), (e.e = r), Le ? Ne(e, y.precision) : e
}
It.toDecimalPlaces = It.todp = function (e, t) {
    var r = this,
        n = r.constructor
    return (r = new n(r)), e === void 0 ? r : (zn(e, 0, Zo), t === void 0 ? (t = n.rounding) : zn(t, 0, 8), Ne(r, e + Je(r) + 1, t))
}
It.toExponential = function (e, t) {
    var r,
        n = this,
        i = n.constructor
    return (
        e === void 0
            ? (r = $s(n, !0))
            : (zn(e, 0, Zo), t === void 0 ? (t = i.rounding) : zn(t, 0, 8), (n = Ne(new i(n), e + 1, t)), (r = $s(n, !0, e + 1))),
        r
    )
}
It.toFixed = function (e, t) {
    var r,
        n,
        i = this,
        s = i.constructor
    return e === void 0
        ? $s(i)
        : (zn(e, 0, Zo),
          t === void 0 ? (t = s.rounding) : zn(t, 0, 8),
          (n = Ne(new s(i), e + Je(i) + 1, t)),
          (r = $s(n.abs(), !1, e + Je(n) + 1)),
          i.isneg() && !i.isZero() ? "-" + r : r)
}
It.toInteger = It.toint = function () {
    var e = this,
        t = e.constructor
    return Ne(new t(e), Je(e) + 1, t.rounding)
}
It.toNumber = function () {
    return +this
}
It.toPower = It.pow = function (e) {
    var t,
        r,
        n,
        i,
        s,
        o,
        l = this,
        f = l.constructor,
        d = 12,
        h = +(e = new f(e))
    if (!e.s) return new f(Or)
    if (((l = new f(l)), !l.s)) {
        if (e.s < 1) throw Error(Xr + "Infinity")
        return l
    }
    if (l.eq(Or)) return l
    if (((n = f.precision), e.eq(Or))) return Ne(l, n)
    if (((t = e.e), (r = e.d.length - 1), (o = t >= r), (s = l.s), o)) {
        if ((r = h < 0 ? -h : h) <= Ty) {
            for (i = new f(Or), t = Math.ceil(n / Be + 4), Le = !1; r % 2 && ((i = i.times(l)), dg(i.d, t)), (r = ta(r / 2)), r !== 0; )
                (l = l.times(l)), dg(l.d, t)
            return (Le = !0), e.s < 0 ? new f(Or).div(i) : Ne(i, n)
        }
    } else if (s < 0) throw Error(Xr + "NaN")
    return (
        (s = s < 0 && e.d[Math.max(t, r)] & 1 ? -1 : 1), (l.s = 1), (Le = !1), (i = e.times(Ka(l, n + d))), (Le = !0), (i = My(i)), (i.s = s), i
    )
}
It.toPrecision = function (e, t) {
    var r,
        n,
        i = this,
        s = i.constructor
    return (
        e === void 0
            ? ((r = Je(i)), (n = $s(i, r <= s.toExpNeg || r >= s.toExpPos)))
            : (zn(e, 1, Zo),
              t === void 0 ? (t = s.rounding) : zn(t, 0, 8),
              (i = Ne(new s(i), e, t)),
              (r = Je(i)),
              (n = $s(i, e <= r || r <= s.toExpNeg, e))),
        n
    )
}
It.toSignificantDigits = It.tosd = function (e, t) {
    var r = this,
        n = r.constructor
    return (
        e === void 0 ? ((e = n.precision), (t = n.rounding)) : (zn(e, 1, Zo), t === void 0 ? (t = n.rounding) : zn(t, 0, 8)), Ne(new n(r), e, t)
    )
}
It.toString =
    It.valueOf =
    It.val =
    It.toJSON =
    It[Symbol.for("nodejs.util.inspect.custom")] =
        function () {
            var e = this,
                t = Je(e),
                r = e.constructor
            return $s(e, t <= r.toExpNeg || t >= r.toExpPos)
        }
function Cy(e, t) {
    var r,
        n,
        i,
        s,
        o,
        l,
        f,
        d,
        h = e.constructor,
        y = h.precision
    if (!e.s || !t.s) return t.s || (t = new h(e)), Le ? Ne(t, y) : t
    if (((f = e.d), (d = t.d), (o = e.e), (i = t.e), (f = f.slice()), (s = o - i), s)) {
        for (
            s < 0 ? ((n = f), (s = -s), (l = d.length)) : ((n = d), (i = o), (l = f.length)),
                o = Math.ceil(y / Be),
                l = o > l ? o + 1 : l + 1,
                s > l && ((s = l), (n.length = 1)),
                n.reverse();
            s--;

        )
            n.push(0)
        n.reverse()
    }
    for (l = f.length, s = d.length, l - s < 0 && ((s = l), (n = d), (d = f), (f = n)), r = 0; s; )
        (r = ((f[--s] = f[s] + d[s] + r) / tr) | 0), (f[s] %= tr)
    for (r && (f.unshift(r), ++i), l = f.length; f[--l] == 0; ) f.pop()
    return (t.d = f), (t.e = i), Le ? Ne(t, y) : t
}
function zn(e, t, r) {
    if (e !== ~~e || e < t || e > r) throw Error(ks + e)
}
function In(e) {
    var t,
        r,
        n,
        i = e.length - 1,
        s = "",
        o = e[0]
    if (i > 0) {
        for (s += o, t = 1; t < i; t++) (n = e[t] + ""), (r = Be - n.length), r && (s += Ii(r)), (s += n)
        ;(o = e[t]), (n = o + ""), (r = Be - n.length), r && (s += Ii(r))
    } else if (o === 0) return "0"
    for (; o % 10 === 0; ) o /= 10
    return s + o
}
var ai = (function () {
    function e(n, i) {
        var s,
            o = 0,
            l = n.length
        for (n = n.slice(); l--; ) (s = n[l] * i + o), (n[l] = s % tr | 0), (o = (s / tr) | 0)
        return o && n.unshift(o), n
    }
    function t(n, i, s, o) {
        var l, f
        if (s != o) f = s > o ? 1 : -1
        else
            for (l = f = 0; l < s; l++)
                if (n[l] != i[l]) {
                    f = n[l] > i[l] ? 1 : -1
                    break
                }
        return f
    }
    function r(n, i, s) {
        for (var o = 0; s--; ) (n[s] -= o), (o = n[s] < i[s] ? 1 : 0), (n[s] = o * tr + n[s] - i[s])
        for (; !n[0] && n.length > 1; ) n.shift()
    }
    return function (n, i, s, o) {
        var l,
            f,
            d,
            h,
            y,
            E,
            T,
            S,
            N,
            P,
            M,
            k,
            F,
            $,
            R,
            W,
            nt,
            J,
            Q = n.constructor,
            ot = n.s == i.s ? 1 : -1,
            it = n.d,
            at = i.d
        if (!n.s) return new Q(n)
        if (!i.s) throw Error(Xr + "Division by zero")
        for (f = n.e - i.e, nt = at.length, R = it.length, T = new Q(ot), S = T.d = [], d = 0; at[d] == (it[d] || 0); ) ++d
        if ((at[d] > (it[d] || 0) && --f, s == null ? (k = s = Q.precision) : o ? (k = s + (Je(n) - Je(i)) + 1) : (k = s), k < 0))
            return new Q(0)
        if (((k = (k / Be + 2) | 0), (d = 0), nt == 1))
            for (h = 0, at = at[0], k++; (d < R || h) && k--; d++) (F = h * tr + (it[d] || 0)), (S[d] = (F / at) | 0), (h = F % at | 0)
        else {
            for (
                h = (tr / (at[0] + 1)) | 0,
                    h > 1 && ((at = e(at, h)), (it = e(it, h)), (nt = at.length), (R = it.length)),
                    $ = nt,
                    N = it.slice(0, nt),
                    P = N.length;
                P < nt;

            )
                N[P++] = 0
            ;(J = at.slice()), J.unshift(0), (W = at[0]), at[1] >= tr / 2 && ++W
            do
                (h = 0),
                    (l = t(at, N, nt, P)),
                    l < 0
                        ? ((M = N[0]),
                          nt != P && (M = M * tr + (N[1] || 0)),
                          (h = (M / W) | 0),
                          h > 1
                              ? (h >= tr && (h = tr - 1),
                                (y = e(at, h)),
                                (E = y.length),
                                (P = N.length),
                                (l = t(y, N, E, P)),
                                l == 1 && (h--, r(y, nt < E ? J : at, E)))
                              : (h == 0 && (l = h = 1), (y = at.slice())),
                          (E = y.length),
                          E < P && y.unshift(0),
                          r(N, y, P),
                          l == -1 && ((P = N.length), (l = t(at, N, nt, P)), l < 1 && (h++, r(N, nt < P ? J : at, P))),
                          (P = N.length))
                        : l === 0 && (h++, (N = [0])),
                    (S[d++] = h),
                    l && N[0] ? (N[P++] = it[$] || 0) : ((N = [it[$]]), (P = 1))
            while (($++ < R || N[0] !== void 0) && k--)
        }
        return S[0] || S.shift(), (T.e = f), Ne(T, o ? s + Je(T) + 1 : s)
    }
})()
function My(e, t) {
    var r,
        n,
        i,
        s,
        o,
        l,
        f = 0,
        d = 0,
        h = e.constructor,
        y = h.precision
    if (Je(e) > 16) throw Error(mh + Je(e))
    if (!e.s) return new h(Or)
    for (t == null ? ((Le = !1), (l = y)) : (l = t), o = new h(0.03125); e.abs().gte(0.1); ) (e = e.times(o)), (d += 5)
    for (n = ((Math.log(ws(2, d)) / Math.LN10) * 2 + 5) | 0, l += n, r = i = s = new h(Or), h.precision = l; ; ) {
        if (((i = Ne(i.times(e), l)), (r = r.times(++f)), (o = s.plus(ai(i, r, l))), In(o.d).slice(0, l) === In(s.d).slice(0, l))) {
            for (; d--; ) s = Ne(s.times(s), l)
            return (h.precision = y), t == null ? ((Le = !0), Ne(s, y)) : s
        }
        s = o
    }
}
function Je(e) {
    for (var t = e.e * Be, r = e.d[0]; r >= 10; r /= 10) t++
    return t
}
function oc(e, t, r) {
    if (t > e.LN10.sd()) throw ((Le = !0), r && (e.precision = r), Error(Xr + "LN10 precision limit exceeded"))
    return Ne(new e(e.LN10), t)
}
function Ii(e) {
    for (var t = ""; e--; ) t += "0"
    return t
}
function Ka(e, t) {
    var r,
        n,
        i,
        s,
        o,
        l,
        f,
        d,
        h,
        y = 1,
        E = 10,
        T = e,
        S = T.d,
        N = T.constructor,
        P = N.precision
    if (T.s < 1) throw Error(Xr + (T.s ? "NaN" : "-Infinity"))
    if (T.eq(Or)) return new N(0)
    if ((t == null ? ((Le = !1), (d = P)) : (d = t), T.eq(10))) return t == null && (Le = !0), oc(N, d)
    if (((d += E), (N.precision = d), (r = In(S)), (n = r.charAt(0)), (s = Je(T)), Math.abs(s) < 15e14)) {
        for (; (n < 7 && n != 1) || (n == 1 && r.charAt(1) > 3); ) (T = T.times(e)), (r = In(T.d)), (n = r.charAt(0)), y++
        ;(s = Je(T)), n > 1 ? ((T = new N("0." + r)), s++) : (T = new N(n + "." + r.slice(1)))
    } else
        return (
            (f = oc(N, d + 2, P).times(s + "")),
            (T = Ka(new N(n + "." + r.slice(1)), d - E).plus(f)),
            (N.precision = P),
            t == null ? ((Le = !0), Ne(T, P)) : T
        )
    for (l = o = T = ai(T.minus(Or), T.plus(Or), d), h = Ne(T.times(T), d), i = 3; ; ) {
        if (((o = Ne(o.times(h), d)), (f = l.plus(ai(o, new N(i), d))), In(f.d).slice(0, d) === In(l.d).slice(0, d)))
            return (
                (l = l.times(2)),
                s !== 0 && (l = l.plus(oc(N, d + 2, P).times(s + ""))),
                (l = ai(l, new N(y), d)),
                (N.precision = P),
                t == null ? ((Le = !0), Ne(l, P)) : l
            )
        ;(l = f), (i += 2)
    }
}
function cg(e, t) {
    var r, n, i
    for (
        (r = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
            (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), (r += +t.slice(n + 1)), (t = t.substring(0, n))) : r < 0 && (r = t.length),
            n = 0;
        t.charCodeAt(n) === 48;

    )
        ++n
    for (i = t.length; t.charCodeAt(i - 1) === 48; ) --i
    if (((t = t.slice(n, i)), t)) {
        if (((i -= n), (r = r - n - 1), (e.e = ta(r / Be)), (e.d = []), (n = (r + 1) % Be), r < 0 && (n += Be), n < i)) {
            for (n && e.d.push(+t.slice(0, n)), i -= Be; n < i; ) e.d.push(+t.slice(n, (n += Be)))
            ;(t = t.slice(n)), (n = Be - t.length)
        } else n -= i
        for (; n--; ) t += "0"
        if ((e.d.push(+t), Le && (e.e > Cu || e.e < -Cu))) throw Error(mh + r)
    } else (e.s = 0), (e.e = 0), (e.d = [0])
    return e
}
function Ne(e, t, r) {
    var n,
        i,
        s,
        o,
        l,
        f,
        d,
        h,
        y = e.d
    for (o = 1, s = y[0]; s >= 10; s /= 10) o++
    if (((n = t - o), n < 0)) (n += Be), (i = t), (d = y[(h = 0)])
    else {
        if (((h = Math.ceil((n + 1) / Be)), (s = y.length), h >= s)) return e
        for (d = s = y[h], o = 1; s >= 10; s /= 10) o++
        ;(n %= Be), (i = n - Be + o)
    }
    if (
        (r !== void 0 &&
            ((s = ws(10, o - i - 1)),
            (l = (d / s) % 10 | 0),
            (f = t < 0 || y[h + 1] !== void 0 || d % s),
            (f =
                r < 4
                    ? (l || f) && (r == 0 || r == (e.s < 0 ? 3 : 2))
                    : l > 5 ||
                      (l == 5 &&
                          (r == 4 ||
                              f ||
                              (r == 6 && (n > 0 ? (i > 0 ? d / ws(10, o - i) : 0) : y[h - 1]) % 10 & 1) ||
                              r == (e.s < 0 ? 8 : 7))))),
        t < 1 || !y[0])
    )
        return (
            f
                ? ((s = Je(e)), (y.length = 1), (t = t - s - 1), (y[0] = ws(10, (Be - (t % Be)) % Be)), (e.e = ta(-t / Be) || 0))
                : ((y.length = 1), (y[0] = e.e = e.s = 0)),
            e
        )
    if (
        (n == 0
            ? ((y.length = h), (s = 1), h--)
            : ((y.length = h + 1), (s = ws(10, Be - n)), (y[h] = i > 0 ? ((d / ws(10, o - i)) % ws(10, i) | 0) * s : 0)),
        f)
    )
        for (;;)
            if (h == 0) {
                ;(y[0] += s) == tr && ((y[0] = 1), ++e.e)
                break
            } else {
                if (((y[h] += s), y[h] != tr)) break
                ;(y[h--] = 0), (s = 1)
            }
    for (n = y.length; y[--n] === 0; ) y.pop()
    if (Le && (e.e > Cu || e.e < -Cu)) throw Error(mh + Je(e))
    return e
}
function Sy(e, t) {
    var r,
        n,
        i,
        s,
        o,
        l,
        f,
        d,
        h,
        y,
        E = e.constructor,
        T = E.precision
    if (!e.s || !t.s) return t.s ? (t.s = -t.s) : (t = new E(e)), Le ? Ne(t, T) : t
    if (((f = e.d), (y = t.d), (n = t.e), (d = e.e), (f = f.slice()), (o = d - n), o)) {
        for (
            h = o < 0,
                h ? ((r = f), (o = -o), (l = y.length)) : ((r = y), (n = d), (l = f.length)),
                i = Math.max(Math.ceil(T / Be), l) + 2,
                o > i && ((o = i), (r.length = 1)),
                r.reverse(),
                i = o;
            i--;

        )
            r.push(0)
        r.reverse()
    } else {
        for (i = f.length, l = y.length, h = i < l, h && (l = i), i = 0; i < l; i++)
            if (f[i] != y[i]) {
                h = f[i] < y[i]
                break
            }
        o = 0
    }
    for (h && ((r = f), (f = y), (y = r), (t.s = -t.s)), l = f.length, i = y.length - l; i > 0; --i) f[l++] = 0
    for (i = y.length; i > o; ) {
        if (f[--i] < y[i]) {
            for (s = i; s && f[--s] === 0; ) f[s] = tr - 1
            --f[s], (f[i] += tr)
        }
        f[i] -= y[i]
    }
    for (; f[--l] === 0; ) f.pop()
    for (; f[0] === 0; f.shift()) --n
    return f[0] ? ((t.d = f), (t.e = n), Le ? Ne(t, T) : t) : new E(0)
}
function $s(e, t, r) {
    var n,
        i = Je(e),
        s = In(e.d),
        o = s.length
    return (
        t
            ? (r && (n = r - o) > 0 ? (s = s.charAt(0) + "." + s.slice(1) + Ii(n)) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)),
              (s = s + (i < 0 ? "e" : "e+") + i))
            : i < 0
            ? ((s = "0." + Ii(-i - 1) + s), r && (n = r - o) > 0 && (s += Ii(n)))
            : i >= o
            ? ((s += Ii(i + 1 - o)), r && (n = r - i - 1) > 0 && (s = s + "." + Ii(n)))
            : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), (s += Ii(n)))),
        e.s < 0 ? "-" + s : s
    )
}
function dg(e, t) {
    if (e.length > t) return (e.length = t), !0
}
function ky(e) {
    var t, r, n
    function i(s) {
        var o = this
        if (!(o instanceof i)) return new i(s)
        if (((o.constructor = i), s instanceof i)) {
            ;(o.s = s.s), (o.e = s.e), (o.d = (s = s.d) ? s.slice() : s)
            return
        }
        if (typeof s == "number") {
            if (s * 0 !== 0) throw Error(ks + s)
            if (s > 0) o.s = 1
            else if (s < 0) (s = -s), (o.s = -1)
            else {
                ;(o.s = 0), (o.e = 0), (o.d = [0])
                return
            }
            if (s === ~~s && s < 1e7) {
                ;(o.e = 0), (o.d = [s])
                return
            }
            return cg(o, s.toString())
        } else if (typeof s != "string") throw Error(ks + s)
        if ((s.charCodeAt(0) === 45 ? ((s = s.slice(1)), (o.s = -1)) : (o.s = 1), WB.test(s))) cg(o, s)
        else throw Error(ks + s)
    }
    if (
        ((i.prototype = It),
        (i.ROUND_UP = 0),
        (i.ROUND_DOWN = 1),
        (i.ROUND_CEIL = 2),
        (i.ROUND_FLOOR = 3),
        (i.ROUND_HALF_UP = 4),
        (i.ROUND_HALF_DOWN = 5),
        (i.ROUND_HALF_EVEN = 6),
        (i.ROUND_HALF_CEIL = 7),
        (i.ROUND_HALF_FLOOR = 8),
        (i.clone = ky),
        (i.config = i.set = YB),
        e === void 0 && (e = {}),
        e)
    )
        for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0; t < n.length; )
            e.hasOwnProperty((r = n[t++])) || (e[r] = this[r])
    return i.config(e), i
}
function YB(e) {
    if (!e || typeof e != "object") throw Error(Xr + "Object expected")
    var t,
        r,
        n,
        i = ["precision", 1, Zo, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0]
    for (t = 0; t < i.length; t += 3)
        if ((n = e[(r = i[t])]) !== void 0)
            if (ta(n) === n && n >= i[t + 1] && n <= i[t + 2]) this[r] = n
            else throw Error(ks + r + ": " + n)
    if ((n = e[(r = "LN10")]) !== void 0)
        if (n == Math.LN10) this[r] = new this(n)
        else throw Error(ks + r + ": " + n)
    return this
}
var vh = ky(GB)
Or = new vh(1)
var Fi = vh
Fi.config({ precision: 36 })
Fi.config({ toExpNeg: -1e3 })
Fi.config({ toExpPos: 1e3 })
Fi.prototype.toInt = function (e) {
    return St.from(
        this.times(new Fi("10").pow(new Fi(e.toString())))
            .todp(0)
            .toString()
    )
}
St.prototype.toDec = function (e) {
    return new Fi(this.toString()).dividedBy(new Fi(10).toPower((e || 0).toString()))
}
async function JB() {
    const e = zm(qI)
    ;(Dl.web3.onAccountChanged = (t) => {}),
        await Dl.web3.setup(),
        (window.data = Dl),
        (e.config.globalProperties.app = Ze(Dl)),
        e.provide("app", e.config.globalProperties.app),
        e.use(
            q2({
                history: s2(),
                routes: [
                    { path: "/", component: mB },
                    { path: "/image/:series/:image", component: _B },
                    { path: "/slide/:screen", component: wB },
                    { path: "/manager", component: AB },
                ],
            })
        ),
        e.use(UI),
        e.mount("#app")
}
JB()
